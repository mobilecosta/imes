#INCLUDE "TOTVS.CH"
#INCLUDE "APWIZARD.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "FWLIBVERSION.CH"
#INCLUDE "FWEVENTVIEWCONSTS.CH"
#INCLUDE "SIGACUSA.CH"

#DEFINE _CRLF CHR(13)+CHR(10)

Static __lNoErro // Variavel nao deve ser removida !!!
Static lxProxNum
Static lFProxNum
Static __lD1D2D3
Static cMoeda330C  //Moedas para calculo do custo medio - Sempre processa moeda 1
Static cProdutoLog //Produtos a serem verificados no log de diferenca de saldo -
					 //deve ser colocado "/" apos cada produto para separacao dos codigos

Static aOpcCache    := {}
Static __aPrepared  := {}
Static __lCusaVLib
Static lA330ISMOD // Utilizado para testar a existencia da funcao A330ISMOD do fonte MATA330.PRX
Static _aTamSX3

Static __lSeekMOD   := nil
Static __cQryMOD    := nil
Static __cEmpOld    := nil
Static __cFilOld    := nil
Static __oProdMOD
Static __cEmpFilOld
Static __lChkNum    := .F.
Static __RpoRelease := nil
Static __lEmpenho   := nil

/*


Ŀ
Funo     CriaSB2   Autor  Eveli Morasco          Data  16/12/92 
Ĵ
Descrio  Funcao padrao para criar registros no arquivo de saldos em 
           estoque (SB2)                                              
Ĵ
Sintaxe    CriaSB2(ExpC1,ExpC2)                                       
Ĵ
Parametros ExpC1 = Codigo do produto                                  
           ExpC2 = Codigo do almoxarifado                             
           ExpC3 = Codigo da Filial Destino (de Entrega - Compras)    
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function CriaSB2(cProduto,cLocal,cFilDes)
Static lPointCriaB2
Local nx         := 0
Local nOrdem     := SB2->(IndexOrd())
Local aCamposSB2 := {}
Local cTipo		 := ""
Local cDescricao := ""
Local cTipoSb2   := CriaVar("B2_TIPO",.T.)

lPointCriaB2:= IIF(lPointCriaB2 == NIL, ExistBlock("CRIASB2"),lPointCriaB2)

If Empty(xFilial("SB2"))
	cFilDes := xFilial("SB2")
Else
	cFilDes := IIf(Empty(cFilDes),xFilial("SB2"),cFilDes)
EndIf

	dbSelectArea("NNR")
	dbSetOrder(1)
	If(DbSeek(FWxFilial("NNR")+cLocal))
		cDescricao := NNR_DESCRI; cTipo	:= NNR_TIPO
	Endif

dbSelectArea("SB2")
dbSetOrder(1)
//Ŀ
// Cria registro quando nao existir                      
//
If !dbSeek(cFilDes+cProduto+cLocal)
	RecLock("SB2",.T.)
	Replace  B2_FILIAL With cFilDes, B2_COD With cProduto, B2_LOCAL  With cLocal, B2_TIPO with cTipoSb2
	Replace B2_LOCALIZ With cDescricao, B2_TIPO With cTipo
	If lPointCriaB2
		aCamposSB2:=ExecBlock("CRIASB2",.F.,.F.)
		If Valtype(aCamposSB2) == "A"
			For nx:=1 to Len(aCamposSB2)
				If !(Upper(Alltrim(aCamposSB2[nx,1])) $ ("B2_FILIAL,B2_COD,B2_LOCAL"+",B2_LOCALIZ,B2_TIPO"))
					SB2->(FieldPut(FieldPos(aCamposSB2[nx,1]),aCamposSB2[nx,2]))
				EndIf
			Next nx
		EndIf
	EndIf
	//Ŀ
	//Atualiza o custo unificado ON-LINE                     
	//
	Msunlock()
	B2AtuUnif(cProduto)
EndIf

dbSetOrder(nOrdem)
RETURN

/*


Ŀ
Funo     PegaCMAtu Autor  Eveli Morasco          Data  09/12/92 
Ĵ
Descrio  Devolve array com os 05 custos medios atuais               
Ĵ
Sintaxe    ExpA1 := PegaCMAtu(ExpC1,ExpC2)                            
Ĵ
Retorno    ExpA1 = Array com os 05 custos medios possiveis            
Ĵ
Parametros ExpC1 = Codigo do produto a ser pesquisado                 
           ExpC2 = Codigo do local a ser pesquisado                   
           ExpC3 = Tipo de Nota de Saida ( D = Devolucao de Compras)  
           ExpA2 = Array a ser enviado para ExpC3 = "D"               
           ExpL1 = Indica se a nota e uma devolucao de Compra         
           ExpL2 = Indica se deve retornar o custo de reposicao       
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function PegaCMAtu(cCodProd,cLocal,cTipo,aCusRec,lDevComp,lCusRep, cFilNFOri)
LOCAL nX,aCM[05],aVatu[05],aAux
LOCAL nDec		:= Set(3,8)
LOCAL cCUSZERO 	:= SuperGetMV("MV_CUSZERO")

DEFAULT lCusRep	:= .F.
DEFAULT cLocal	:=  " "
DEFAULT cFilNFOri := cFilAnt

cMoeda330C:= IIF(cMoeda330C == Nil,SuperGetMv('MV_MOEDACM',.F.,"2345"),cMoeda330C)

cTipo := IF(cTipo==NIL," ",cTipo)

//Ŀ
// Cria registro quando nao existir                      
//
dbSelectArea("SB2")
If xFilial("SB2", cFilNFOri)+cCodProd+cLocal <> SB2->B2_FILIAL+SB2->B2_COD+SB2->B2_LOCAL
	dbSetOrder(1)
	If ( !MsSeek(xFilial("SB2", cFilNFOri)+cCodProd+cLocal) )
		CriaSB2(cCodProd,cLocal)
	EndIf
EndIf
IF cTipo == "D"
	aAux := { aCusRec }
	aAux := RetCusEnt( ,aAux , , lDevComp)
	aCM  := aAux[1]
Else
	If lCusRep
		aCM[01] := B2_CMRP1
		aCM[02] := B2_CMRP2
		aCM[03] := B2_CMRP3
		aCM[04] := B2_CMRP4
		aCM[05] := B2_CMRP5
	Else
		aCM[01] := B2_CM1
		aCM[02] := B2_CM2
		aCM[03] := B2_CM3
		aCM[04] := B2_CM4
		aCM[05] := B2_CM5
		If !IsProdMod(cCodProd)
			aVatu[01] := B2_VATU1
			aVatu[02] := B2_VATU2
			aVatu[03] := B2_VATU3
			aVatu[04] := B2_VATU4
			aVatu[05] := B2_VATU5
			For nX := 1 to 5
			    // Verifica se moeda devera ser considerada
				If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
					aCM[nX] := 0
					Loop
				EndIf

				If B2_QATU > 0 .And. aVatu[nX] > 0
					aCM[nX] := CusRound(aVatu[nX] / B2_QATU,nX)
				Else
					If cCUSZERO == "S"
						aCM[nX] := 0
					EndIf
				EndIf
			Next nX
		EndIf
	EndIf
EndIf
Set(3,nDec)
Return aCM

/*


Ŀ
Funo     PegaCMFim Autor  Eveli Morasco          Data  09/12/92 
Ĵ
Descrio  Devolve array com os 05 custos medios finais               
Ĵ
Sintaxe    ExpA1 := PegaCMFim(ExpC1,ExpC2)                            
Ĵ
Parametros ExpC1 = Codigo do Produto                                  
           ExpC2 = Local do Produto                                   
           ExpC3 = Tipo de saida para calculo do custo de saida       
           ExpA4 = Array com os 05 custos medios possiveis            
           ExpC5 = Alias                                              
           ExpC6 = Rotina Chamada                                     
           ExpL7 = Processa devolucao de compras                      
           ExpL8 = Processa custo FIFO                                
           ExpL9 = Processa custo em Partes                           
           ExpN10= Numero de regras para o custo em partes            
           ExpA11= Array com as regras do custo em partes             
           ExpL10= Indica se deve retornar o custo de reposicao  	  
 		  ExpL11= Indica se a nota e uma devolucao de Compra com a	  
 		 	       quantidade igual a zero		 			          
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function PegaCMFim(cCodProd,cLocal,cTipo,aCusRec,cAlias,cProg,lDevCompra,lCusFifo,lCstPart,nRegras,aRegraCP,lCusRep,lDevQtd0,lTrans)
LOCAL cSerie 	:= ""
LOCAL cItem  	:= ""
LOCAL nQuant 	:= 0
LOCAL nQtdDev	:= 0
LOCAL nI		:= 0
LOCAL aSD8      := {}
LOCAL aRetPartes:= {}
LOCAL aCM       := {0,0,0,0,0}
LOCAL aCusto    := {0,0,0,0,0}
LOCAL aCMFF     := {0,0,0,0,0}
LOCAL aCustox   := {0,0,0,0,0}
LOCAL aCustoFF  := {0,0,0,0,0}
LOCAL aCMRep    := {0,0,0,0,0}
LOCAL cOldAlias := Alias()
LOCAL nSB2Recno := SB2->(Recno())
LOCAL nDec      := Set(3,8)
LOCAL lCredDeb  := .F.
LOCAL lGrvDevOP := .F.

LOCAL nX,aVFim[05],aAux,nQtdSBD,aSBDFim[02]
LOCAL cTipoCF,aVFimFF[05],aRet[04]
LOCAL cCUSZERO := SuperGetMV("MV_CUSZERO",.F.,"N")

//Ŀ
// MV_ADEVCOM - Utilizado para verificar se nas devolucoes |
//| de compras o custo de devolucao da nota de saida sera   |
//| ajustado quando o saldo final for menor que o valor do  |
//| custo de origem.                                        |
//
LOCAL lAjuDevCom := SuperGetMV("MV_ADEVCOM",.F.,.T.)
LOCAL lRound	:= EstGetMV("MV_CMROUND",.F.,.F.)

DEFAULT lCstPart := .F.
DEFAULT lCusRep  := .F.
DEFAULT lDevQtd0 := .F.
DEFAULT ltrans	 := .F.

cTipo 	 := IIF(cTipo    == NIL," ",cTipo)
cAlias   := IIF(cAlias   == NIL,"SD3",cAlias)
cProg    := IIF(cProg    == NIL,Space(03),cProg)
lCusFIFO := IIF(lCusFifo == NIL,.F.,lCusFifo)
cTipoCF  := IIF(cAlias   == "SD3",Substr(SD3->D3_CF,1,2),Space(02))
cMoeda330C:= IIF(cMoeda330C == Nil,SuperGetMv('MV_MOEDACM',.F.,"2345"),cMoeda330C)

//Ŀ
// Cria registro quando nao existir                      
//

SB2->(dbSetOrder(1))
If !SB2->(MsSeek(xFilial("SB2")+cCodProd+cLocal))
	CriaSB2(cCodProd,cLocal)
EndIf
//Ŀ
// Tratamento especial para Notas de Credito/Debito      
//| Somente utilizado para paises localizados com custo   |
//| FIFO habilitado.                                      |
//
If lCusFifo .And. cPaisLoc <> "BRA" .And. cTipo == "D"
	If cAlias == "SD1"
		If AllTrim((cAlias)->D1_ESPECIE) $ "NCC|NDE"
			cTipo := "N"
		EndIf
	ElseIf cAlias == "SD2"
		If AllTrim((cAlias)->D2_ESPECIE) $ "NDI|NCP"
			cTipo    := "N"
			lCredDeb := .T.
		EndIf
	EndIf
EndIf
//Ŀ
// Verifica tipo de saida para calculo do custo de saida 
//
If cTipo == "D"
	aAux:={ aCusRec }
	aAux := RetCusEnt( , aAux , , lDevCompra,lDevQtd0)
	aCM  := aAux[1]
	If cProg == "330"
		For nX := 1 to 5
			// Verifica se moeda devera ser considerada
			If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
	           	aCm[nx] := 0
			EndIf
		Next nX
	EndIf
	If lCusFIFO
		aCMFF	:=	RetCusSBD()
	ElseIf cProg == "330" .And. lDevCompra .And. cAlias == "SD2" .And. SB2->B2_VFIM1 < aCM[01] .And. lAjuDevCom
		Afill(aVFim,0)
		aVFim[01] := SB2->B2_VFIM1
		aVFim[02] := If("2" $ cMoeda330C,SB2->B2_VFIM2,0)
		aVFim[03] := If("3" $ cMoeda330C,SB2->B2_VFIM3,0)
		aVFim[04] := If("4" $ cMoeda330C,SB2->B2_VFIM4,0)
		aVFim[05] := If("5" $ cMoeda330C,SB2->B2_VFIM5,0)
		For nX := 1 to 5
			// Verifica se moeda devera ser considerada
			If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
               	aCm[nx] := 0
               	Loop
			EndIf
			If SB2->B2_QFIM > 0 .And. aVFim[nX] > 0
				aCM[nX] := aVFim[nX]/SB2->B2_QFIM
				aCm[nx] := aCm[nx]*SD2->D2_QUANT
			Else
				If cCUSZERO == "S"
					aCM[nX] := 0
				EndIf
			EndIf
		Next nX
	EndIf
Else
	If lCusFIFO
		If cAlias == "SD1"
			//Ŀ
			// Retorna o Custo Fifo/Lifo quando for devolucao de vendas 
			//
			aCMFF:=PegaCusSBD(cCodProd,cLocal,cAlias)
		Else
			//Ŀ
			// Processa Custo FIFO menos Mao de Obra                 
			//
			If !IsProdMod(cCodProd)
				If cTipoCF != "DE"
					//Ŀ
					// Atualiza o saldo final FIFO com os dados do SD3       
					//
					aSBDFim := BaixaSBD(cAlias,.F.)
					aVFimFF := aSBDFim[01]
					nQtdSBD := aSBDFim[02]
					For nX := 1 to 5
						// Verifica se moeda devera ser considerada
						If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
		                	aCMFF[nX] := 0
		                	Loop
						EndIf
						If lCredDeb
							aCMFF[nX] := aVFimFF[nX]
						Else
							If nQtdSBD > 0 .And. aVFimFF[nX] > 0
								aCMFF[nX] := aVFimFF[nX]/nQtdSBD
							EndIf
						EndIf
					Next nX
				Else
					//Ŀ
					// Processa Custo FIFO para Devolucao                    
					//
					If cAlias == "SD3"
						If !Empty(SD3->D3_OP)
							//Ŀ
							// Posiciona no ultimo registro para fazer a devolucao   
							//
							dbSelectArea("SD8")
							dbSetOrder(2)
							dbSeek(xFilial("SD8")+SD3->D3_OP+SD3->D3_COD+SD3->D3_LOCAL+"999999",.T.)
							dbSkip(-1)
							nQtdDev:=SD3->D3_QUANT
							While !Bof() .And. xFilial("SD8")+SD3->D3_OP+SD3->D3_COD+SD3->D3_LOCAL==;
									D8_FILIAL+D8_OP+D8_PRODUTO+D8_LOCAL .And. nQtdDev > 0
								If Substr(D8_CF,1,2) != "RE"
									dbSkip(-1)
									Loop
								EndIf
								If nQtdDev >= (SD8->D8_QUANT - SD8->D8_QTDDEV)
									nQuant  := (SD8->D8_QUANT - SD8->D8_QTDDEV)
									nQtdDev -= (SD8->D8_QUANT - SD8->D8_QTDDEV)
									nProp   := 1
								Else
									nQuant  := nQtdDev
									nQtddev := 0
									nProp   := (nQuant / SD8->D8_QUANT)
								EndIf
								RecLock("SD8",.F.)
								Replace SD8->D8_QTDDEV With SD8->D8_QTDDEV + nQuant
								MsUnlock()
								aCusto[01]  := Round(NoRound(D8_CUSTO1 * nProp,3),2)
								aCusto[02]  := If("2" $ cMoeda330C,Round(NoRound(D8_CUSTO2 * nProp,3),2),0)
								aCusto[03]  := If("3" $ cMoeda330C,Round(NoRound(D8_CUSTO3 * nProp,3),2),0)
								aCusto[04]  := If("4" $ cMoeda330C,Round(NoRound(D8_CUSTO4 * nProp,3),2),0)
								aCusto[05]  := If("5" $ cMoeda330C,Round(NoRound(D8_CUSTO5 * nProp,3),2),0)
								aCustox[01] += aCusto[01]
								aCustox[02] += aCusto[02]
								aCustox[03] += aCusto[03]
								aCustox[04] += aCusto[04]
								aCustox[05] += aCusto[05]
								AAdd(aSD8,{D8_SEQ,nQuant,aCusto[1],aCusto[2],aCusto[3],aCusto[4],aCusto[5]})
								dbSkip(-1)
							End
							For ni:=1 to Len(aSD8)
								GravaSD8(SD3->D3_CF,"",SD3->D3_DOC,SD3->D3_OP,aSD8[ni][2],aSD8[ni][3],aSD8[ni][4],aSD8[ni][5],aSD8[ni][6],aSD8[ni][7],aSD8[ni][1],SD3->D3_EMISSAO,SD3->D3_TM,cSerie,cItem)
								dbSelectArea("SBD")
								dbSetOrder(2)
								If dbSeek(xFilial("SBD")+SD8->D8_SEQ)
									Reclock("SBD",.F.)
									Replace SBD->BD_QFIM    With SBD->BD_QFIM + aSD8[ni][2]
									Replace SBD->BD_CUSFIM1 With SBD->BD_CUSFIM1 + aSD8[ni][3]
									Replace SBD->BD_CUSFIM2 With SBD->BD_CUSFIM2 + If("2" $ cMoeda330C,aSD8[ni][4],0)
									Replace SBD->BD_CUSFIM3 With SBD->BD_CUSFIM3 + If("3" $ cMoeda330C,aSD8[ni][5],0)
									Replace SBD->BD_CUSFIM4 With SBD->BD_CUSFIM4 + If("4" $ cMoeda330C,aSD8[ni][6],0)
									Replace SBD->BD_CUSFIM5 With SBD->BD_CUSFIM5 + If("5" $ cMoeda330C,aSD8[ni][7],0)
									Replace SBD->BD_STATUS  With " "
									MsUnlock()
								EndIf
							Next
							For nX := 1 to 5
								If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
									aCMFF[nX] := 0
									Loop
								EndIf
								If SD3->D3_QUANT > 0 .And. aCustox[nX] > 0
									aCMFF[nX] := aCustox[nX]/SD3->D3_QUANT
								EndIf
							Next nX
							lGrvDevOP := .T.
						Endif
						If nQtdDev > 0 .Or. !lGrvDevOP
							aCMFF  := PegaCusSBD(SD3->D3_COD,SD3->D3_LOCAL)
							For nX := 1 to 5
								If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
									aCustoFF[nX] := 0
									Loop
								EndIf
								aCustoFF[nX] := aCMFF[nX] * IIF(nQtdDev > 0, nQtdDev, SD3->D3_QUANT)
							Next nX
							//Ŀ
							// Atualiza o SBD FIFO com os dados do SD3               
							//
							If !lTrans
								If nQtdDev > 0
									GravaSBD("SD3",aCustoFF,"",nQtdDev)
								Else
									GravaSBD("SD3",aCustoFF)
								Endif
							EndIf
						EndIf
					EndIf
				EndIf
			Else
				//Ŀ
				// Processa Custo FIFO da Mao de Obra		              
				//
				If cAlias == "SD3"
					If cTipoCF == "DE"
						aCMFF  := PegaCusSBD(SD3->D3_COD,SD3->D3_LOCAL)
						For nX := 1 to 5
							// Verifica se moeda devera ser considerada
							If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
			                	aCustoFF[nx] := 0
			                	Loop
							EndIf
							aCustoFF[nX] := aCMFF[nX] * SD3->D3_QUANT
						Next nX
						//Ŀ
						// Atualiza o SBD FIFO com os dados do SD3               
						//
						GravaSBD("SD3",aCustoFF)
					Else
						aSBDFim := BaixaSBD(cAlias,.F.)
						aVFimFF := aSBDFim[01]
						nQtdSBD := aSBDFim[02]
						For nX := 1 to 5
							// Verifica se moeda devera ser considerada
							If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
			                	aCMFF[nX] := 0
			                	Loop
							EndIf
							If nQtdSBD > 0 .And. aVFimFF[nX] > 0
								aCMFF[nX] := aVFimFF[nX]/nQtdSBD
							EndIf
						Next nX
					EndIf
				EndIf
			EndIf
		EndIf

	Else
		aCM[01] := SB2->B2_CMFIM1
		aCM[02] := SB2->B2_CMFIM2
		aCM[03] := SB2->B2_CMFIM3
		aCM[04] := SB2->B2_CMFIM4
		aCM[05] := SB2->B2_CMFIM5
    	If lCusRep
			aCMRep[01] := SB2->B2_CMRP1
			aCMRep[02] := SB2->B2_CMRP2
			aCMRep[03] := SB2->B2_CMRP3
			aCMRep[04] := SB2->B2_CMRP4
			aCMRep[05] := SB2->B2_CMRP5
    	EndIf
		If !IsProdMod(cCodProd)
			aVFim[01] := SB2->B2_VFIM1
			aVFim[02] := If("2" $ cMoeda330C,SB2->B2_VFIM2,0)
			aVFim[03] := If("3" $ cMoeda330C,SB2->B2_VFIM3,0)
			aVFim[04] := If("4" $ cMoeda330C,SB2->B2_VFIM4,0)
			aVFim[05] := If("5" $ cMoeda330C,SB2->B2_VFIM5,0)
			For nX := 1 to 5
				// Verifica se moeda devera ser considerada
				If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
                	aCM[nX]:=0
                	Loop
				EndIf
				If SB2->B2_QFIM > 0 .And. aVFim[nX] > 0
					If lRound
						aCM[nX] := Val(Str(aVFim[nX] / SB2->B2_QFIM,TamSX3("B2_CM1")[1], TamSX3("B2_CM1")[2]))
					Else
						aCM[nX] := aVFim[nX] / SB2->B2_QFIM
					EndIf
				Else
					If cCUSZERO == "S"
						aCM[nX] := 0
					EndIf
				EndIf
			Next nX
			DbSelectarea('SB2')
			aRetPartes:=PegaCMPFim("B2_CPF",lCstPart,nRegras,SB2->B2_QFIM,ACLONE(aCm),aRegraCP)
		EndIf
	EndIf
EndIf

//-- Retorna Integridade do Sistema
dbSelectArea(cOldAlias)
SB2->(dbGoto(nSB2Recno))

Set(3,nDec)
If cProg == "330"
	aRet[01] := aCM
	aRet[02] := aCMFF
	aRet[03] := aRetPartes
	aRet[04] := aCMRep
	Return aRet
Else
	Return aCM
EndIf

/*


Ŀ
Funo     PegaCMD1  Autor  Eveli Morasco          Data  10/01/97 
Ĵ
Descrio  Devolve os 05 custos da movimentacao                       
Ĵ
Sintaxe    ExpA1 := PegaCMD1()                                        
Ĵ
Parametros ExpL1 = Processa Custo FIFO                                
Parametros ExpL2 = Processa Custo Reposicao                           
Ĵ
Retorno    ExpA1 = Array devolvido pela funcao com os 05 custos da    
                   movimentacao                                       
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function PegaCMD1(lFifo,lCusRep)
Local aCusto := {0,0,0,0,0}
Local nCnt01 := 0
Local nDec   :=Set(3,8)

DEFAULT lFifo    := .F.
DEFAULT lCusRep  := .F.

If lCusRep
	aCusto[01] := SD1->D1_CUSRP1
	aCusto[02] := SD1->D1_CUSRP2
	aCusto[03] := SD1->D1_CUSRP3
	aCusto[04] := SD1->D1_CUSRP4
	aCusto[05] := SD1->D1_CUSRP5
Else
	If lFifo
		aCusto[01] := SD1->D1_CUSFF1
		aCusto[02] := SD1->D1_CUSFF2
		aCusto[03] := SD1->D1_CUSFF3
		aCusto[04] := SD1->D1_CUSFF4
		aCusto[05] := SD1->D1_CUSFF5
	Else
		aCusto[01] := SD1->D1_CUSTO
		aCusto[02] := SD1->D1_CUSTO2
		aCusto[03] := SD1->D1_CUSTO3
		aCusto[04] := SD1->D1_CUSTO4
		aCusto[05] := SD1->D1_CUSTO5
	EndIf
EndIf
If (SD1->D1_QUANT > 0)
	For nCnt01 := 1 To 5
		aCusto[ nCnt01 ] /= SD1->D1_QUANT
	Next
EndIf
Set(3,nDec)
Return aCusto

/*


Ŀ
Funo     PegaCMD3  Autor   Marcos Simidu         Data  13/01/97 
Ĵ
Descrio  Devolve os 05 custos da movimentacao                       
Ĵ
Sintaxe    ExpA1 := PegaCMD3()                                        
Ĵ
Parametros ExpA1 = Array devolvido pela funcao com os 05 custos da    
                   movimentacao                                       
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function PegaCMD3(lCusRep)
Local aCusto[05],nCnt01
Local nDec:=Set(3,8)

Default lCusRep := .F.

If lCusRep
	aCusto[01] := SD3->D3_CUSRP1
	aCusto[02] := SD3->D3_CUSRP2
	aCusto[03] := SD3->D3_CUSRP3
	aCusto[04] := SD3->D3_CUSRP4
	aCusto[05] := SD3->D3_CUSRP5
Else
	aCusto[01] := SD3->D3_CUSTO1
	aCusto[02] := SD3->D3_CUSTO2
	aCusto[03] := SD3->D3_CUSTO3
	aCusto[04] := SD3->D3_CUSTO4
	aCusto[05] := SD3->D3_CUSTO5
EndIf

If (SD3->D3_QUANT > 0)
	For nCnt01 := 1 To 5
		aCusto[ nCnt01 ] /= SD3->D3_QUANT
	Next
EndIf
Set(3,nDec)
Return aCusto

/*


Ŀ
Funo    GravaCusD1 Autor  Eveli Morasco          Data  08/02/93 
Ĵ
Descrio  Grava o custo da nota fiscal de devolucao                  
Ĵ
Parametros ExpA1 = Array com os 05 custos medios do produto           
           ExpC1 = Tipo da Nota Fiscal                                
           ExpA2 = Array com os 05 custos FIFO do produto             
           ExpC2 = Programa que chamou a funcao                       
           ExpL1 = Variavel logica indicando se utiliza custo em parte
           ExpA3 = Array com as regras do custo em partes             
           ExpA4 = Array com os custos de todas as partes             
           ExpN1 = Quantidade para divisao do custo em partes         
           ExpL2 = Descontinuado/Integrao com o modulo TMS          
           ExpL3 = Indica se atualiza os campo custo de reposicao     
           ExpA5 = Array com os custos de reposicao                   
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function GravaCusD1(aCM,cTipo,aCMFF,cProg,lCstPart,aRegraCP,aRetPartes,nQuantParte,lIntCusTMS,lCusRep,aCMRep)
LOCAL nDec      :=Set(3,8)
LOCAL aCustoRep := {0,0,0,0,0}
LOCAL nX        := 0
LOCAL aCustoFF[05]
LOCAL aCusto[05]
LOCAL aRet[04]


cProg    := IIF(cProg == NIL  ,Space(03),cProg)
lCusFIFO := IIF(cProg == "330",EstGetMV("MV_CUSFIFO",.F.),.F.)
lCusLIFO := IIF(cProg == "330",EstGetMV("MV_CUSLIFO",.F.,.F.),.F.)
cTipo    := IIF(cTipo == NIL, " ", cTipo)
aCMRep   := IIF(aCMRep== NIL, {0,0,0,0,0}, aCMRep)
cMoeda330C:= IIF(cMoeda330C == Nil,EstGetMv('MV_MOEDACM',.F.,"2345"),cMoeda330C)

DEFAULT nQuantParte := SD1->D1_QUANT
DEFAULT lCusRep     := .F.

dbSelectArea("SD1")

If cTipo == "D"		// Devolucao de Vendas
	If aCM != NIL
		aCusto := aCM
	ElseIf (lCusFIFO .Or. lCusLIFO) .And. aCMFF != NIL
		aCustoFF := aCMFF
	Endif
Else
	For nX := 1 To 05
		// Verifica se moeda devera ser considerada
		If cProg == "330" .And. nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
	        If aCM != NIL
				aCusto[nX]    := 0
			ElseIf (lCusFIFO .Or. lCusLIFO) .And. aCMFF != NIL
				aCustoFF[nX]:= 0
			EndIf
           	Loop
		EndIf
		If aCM != NIL
			aCusto[nX] := D1_QUANT*aCM[nX]
		ElseIf (lCusFIFO .Or. lCusLIFO) .And. aCMFF != NIL
			//Ŀ
			// Tratamento para Fifo caso NF seja complementar (IPI/ICM/Despesa/Preco)
			//
			If cTipo $ "CIP"
				aCustoFF := aCMFF
				Exit
			Else
				aCustoFF[nX] := D1_QUANT*aCMFF[nX]
			EndIf
		EndIf
	Next nX
EndIf

RecLock("SD1",.F.)
If aCM != NIL
	Replace D1_CUSTO  With aCusto[01]
	If cProg # "330" .Or. (cProg == "330" .And. "2" $ cMoeda330C)
		Replace D1_CUSTO2 With aCusto[02]
	EndIf
	If cProg # "330" .Or. (cProg == "330" .And. "3" $ cMoeda330C)
		Replace D1_CUSTO3 With aCusto[03]
	EndIf
	If cProg # "330" .Or. (cProg == "330" .And. "4" $ cMoeda330C)
		Replace D1_CUSTO4 With aCusto[04]
	EndIf
	If cProg # "330" .Or. (cProg == "330" .And. "5" $ cMoeda330C)
		Replace D1_CUSTO5 With aCusto[05]
	EndIf
	aCusto[01] := D1_CUSTO
	aCusto[02] := D1_CUSTO2
	aCusto[03] := D1_CUSTO3
	aCusto[04] := D1_CUSTO4
	aCusto[05] := D1_CUSTO5
ElseIf (lCusFIFO .Or. lCusLIFO) .And. aCMFF != NIL
	Replace D1_CUSFF1 With aCustoFF[01]
	If cProg # "330" .Or. (cProg == "330" .And. "2" $ cMoeda330C)
		Replace D1_CUSFF2 With aCustoFF[02]
	EndIf
	If cProg # "330" .Or. (cProg == "330" .And. "3" $ cMoeda330C)
		Replace D1_CUSFF3 With aCustoFF[03]
	EndIf
	If cProg # "330" .Or. (cProg == "330" .And. "4" $ cMoeda330C)
		Replace D1_CUSFF4 With aCustoFF[04]
	EndIf
	If cProg # "330" .Or. (cProg == "330" .And. "5" $ cMoeda330C)
		Replace D1_CUSFF5 With aCustoFF[05]
	EndIf
EndIf
If lCusRep
	Replace D1_CUSRP1 With aCMRep[1]
	If cProg # "330" .Or. (cProg == "330" .And. "2" $ cMoeda330C)
		Replace D1_CUSRP2 With aCMRep[2]
	EndIf
	If cProg # "330" .Or. (cProg == "330" .And. "3" $ cMoeda330C)
		Replace D1_CUSRP3 With aCMRep[3]
	EndIf
	If cProg # "330" .Or. (cProg == "330" .And. "4" $ cMoeda330C)
		Replace D1_CUSRP4 With aCMRep[4]
	EndIf
	If cProg # "330" .Or. (cProg == "330" .And. "5" $ cMoeda330C)
		Replace D1_CUSRP5 With aCMRep[5]
	EndIf
	aCustoRep[1] := D1_CUSRP1
	aCustoRep[2] := D1_CUSRP2
	aCustoRep[3] := D1_CUSRP3
	aCustoRep[4] := D1_CUSRP4
	aCustoRep[5] := D1_CUSRP5
EndIf
MsUnlock()

//Ŀ
// Grava o custo em partes no arquivo de movimento              
//
aRetPartes:=GravaCusCP(lCstPart,aRegraCP,aCusto,"SD1",SD1->D1_COD,aRetPartes,nQuantParte,NIL,ACLONE(aCusto))

Set(3,nDec)
If cProg == "330"
	aRet[01] := aCusto
	aRet[02] := aCustoFF
	aRet[03] := aRetPartes
	aRet[04] := aCustoRep
	Return aRet
Else
	Return aCusto
Endif

/*


Ŀ
Funo    GravaCusD2 Autor  Eveli Morasco          Data  28/12/92 
Ĵ
Descrio  Grava os 05 custos da nota fiscal de venda                 
Ĵ
Parametros ExpA1 = Array com os 05 custos medios do produto           
           ExpC1 = Tipo da Nota Fiscal                                
           ExpA2 = Array com os 05 custos FIFO do produto             
           ExpC2 = Programa que chamou a funcao                       
           ExpL1 = Variavel logica indicando se utiliza custo em parte
           ExpA3 = Array com as regras do custo em partes             
           ExpA4 = Array com os custos de todas as partes             
           ExpL2 = Descontinuado/Integrao com o mdulo TMS          
           ExpL3 = Indica se permite manter o custo quanto quantidade 
                   do item for igual a zero.(F4_QTDZERO)              
           ExpL4 = Indica se grava o custo de reposicao               
           ExpA5 = Array com os custos de reposicao                   
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function GravaCusD2(aCM,cTipo,aCMFF,cProg,lCstPart,aRegraCP,aRetPartes,lIntCusTMS,lF4QtdZero,lCusRep,aCMRep)
LOCAL aCusto[05],nX,aCustoFF[05],aRet[04]
LOCAL aCustoRep := {0,0,0,0,0}
LOCAL nDec:=Set(3,8)

DEFAULT lF4QtdZero := .F.
DEFAULT lCusRep    := .F.
DEFAULt aCMRep     := {0,0,0,0,0}

cTipo     := IF(cTipo == NIL, " ", cTipo)
cProg     := IIF(cProg == NIL  ,Space(03),cProg)
lCusFIFO  := IIF(cProg == "330",SuperGetMV("MV_CUSFIFO",.F.),.F.)
lCusLIFO  := IIF(cProg == "330",SuperGetMV("MV_CUSLIFO",.F.,.F.),.F.)
cMoeda330C:= IIF(cMoeda330C == Nil,SuperGetMv('MV_MOEDACM',.F.,"2345"),cMoeda330C)

dbSelectArea("SD2")
If cTipo == "D" // Devolucao de Compras
	If aCM != NIL
		aCusto := aCM
		If lCusRep
			aCustoRep := aCMRep
		EndIf
	ElseIf (lCusFIFO .Or. lCusLIFO) .And. aCMFF != NIL
		aCustoFF := aCMFF
	Endif
Else
	For nX := 1 To 05
		// Verifica se moeda devera ser considerada
		If cProg == "330" .And. nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
	        If aCM != NIL
				aCusto[nX]:= 0
			ElseIf (lCusFIFO .Or. lCusLIFO) .And. aCMFF != NIL
				aCustoFF[nX]:= 0
			EndIf
			If lCusRep
				If aCMRep != NIL
					aCustoRep[nX] := 0
				EndIf
			EndIf
           	Loop
		EndIf
		If aCM != NIL
			aCusto[nX] := D2_QUANT*aCM[nX]
		ElseIf (lCusFIFO .Or. lCusLIFO) .And. aCMFF != NIL
			aCustoFF[nX] := D2_QUANT*aCMFF[nX]
		Endif
		If lCusRep
			aCustoRep[nX] := D2_QUANT*aCMRep[nX]
		EndIf
	Next nX
EndIf

RecLock("SD2",.F.)
If aCM != NIL
	If !(lF4QtdZero .And. D2_QUANT == 0)
		Replace D2_CUSTO1 With aCusto[01]
		If cProg # "330" .Or. (cProg == "330" .And. "2" $ cMoeda330C)
			Replace D2_CUSTO2 With aCusto[02]
		EndIf
		If cProg # "330" .Or. (cProg == "330" .And. "3" $ cMoeda330C)
			Replace D2_CUSTO3 With aCusto[03]
		EndIf
		If cProg # "330" .Or. (cProg == "330" .And. "4" $ cMoeda330C)
			Replace D2_CUSTO4 With aCusto[04]
		EndIf
		If cProg # "330" .Or. (cProg == "330" .And. "5" $ cMoeda330C)
			Replace D2_CUSTO5 With aCusto[05]
		EndIf
	EndIf
	aCusto[01] := D2_CUSTO1
	aCusto[02] := D2_CUSTO2
	aCusto[03] := D2_CUSTO3
	aCusto[04] := D2_CUSTO4
	aCusto[05] := D2_CUSTO5
ElseIf (lCusFIFO .Or. lCusLIFO) .And. aCMFF != NIL
	If !(lF4QtdZero .And. D2_QUANT == 0)
		Replace D2_CUSFF1 With aCustoFF[01]
		If cProg # "330" .Or. (cProg == "330" .And. "2" $ cMoeda330C)
			Replace D2_CUSFF2 With aCustoFF[02]
		EndIf
		If cProg # "330" .Or. (cProg == "330" .And. "3" $ cMoeda330C)
			Replace D2_CUSFF3 With aCustoFF[03]
		EndIf
		If cProg # "330" .Or. (cProg == "330" .And. "4" $ cMoeda330C)
			Replace D2_CUSFF4 With aCustoFF[04]
		EndIf
		If cProg # "330" .Or. (cProg == "330" .And. "5" $ cMoeda330C)
			Replace D2_CUSFF5 With aCustoFF[05]
		EndIf
	EndIf
EndIf
If lCusRep
	Replace D2_CUSRP1 With aCustoRep[01]
	If cProg # "330" .Or. (cProg == "330" .And. "2" $ cMoeda330C)
		Replace D2_CUSRP2 With aCustoRep[02]
	EndIf
	If cProg # "330" .Or. (cProg == "330" .And. "3" $ cMoeda330C)
		Replace D2_CUSRP3 With aCustoRep[03]
	EndIf
	If cProg # "330" .Or. (cProg == "330" .And. "4" $ cMoeda330C)
		Replace D2_CUSRP4 With aCustoRep[04]
	EndIf
	If cProg # "330" .Or. (cProg == "330" .And. "5" $ cMoeda330C)
		Replace D2_CUSRP5 With aCustoRep[05]
	EndIf
	aCustoRep[01] := D2_CUSRP1
	aCustoRep[02] := D2_CUSRP2
	aCustoRep[03] := D2_CUSRP3
	aCustoRep[04] := D2_CUSRP4
	aCustoRep[05] := D2_CUSRP5
EndIf
MsUnlock()

//Ŀ
// Grava o custo em partes no arquivo de movimento              
//
aRetPartes:=SB1->(GravaCusCP(lCstPart,aRegraCP,aCusto,"SD2",SD2->D2_COD,aRetPartes,SD2->D2_QUANT,NIL,ACLONE(aCusto)))

Set(3,nDec)
If cProg == "330"
	aRet[01] := aCusto
	aRet[02] := aCustoFF
	aRet[03] := aRetPartes
	aRet[04] := aCustoRep
	Return aRet
Else
	Return aCusto
EndIf

/*


Ŀ
Funo    GravaCusD3 Autor  Eveli Morasco          Data  09/12/92 
Ĵ
Descrio  Grava os 05 custos da movimentacao                         
Ĵ
Parametros ExpA1 = Array com os 05 custos medios do produto           
           ExpL1 = Flag que indica se retorna custo total             
           ExpA2 = Array com os 05 custos FIFO do produto             
           ExpC1 = Programa que chamou a funcao                       
           ExpL2 = Flag que indica se aceita qtd zerada               
           ExpL3 = Variavel logica indicando se utiliza custo em parte
           ExpA3 = Array com as regras do custo em partes             
           ExpA4 = Array com os custos de todas as partes             
           ExpL2 = Descontinuado/Integrao com o mdulo TMS          
           ExpN1 = Quantidade para divisao do custo em partes         
           ExpL4 = Indica se atualiza os campos do custo de reposicao 
           ExpA5 = Array com os custos de reposicao                   
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function GravaCusD3(aCM,lTotal,aCMFF,cProg,lQtdZero,lCstPart,aRegraCP,aRetPartes,lIntCusTMS,nQuantParte,lCusRep,aCMRep,lTotalCP)

LOCAL nDec :=Set(3,8)
LOCAL nX   := 0
LOCAL aCustoRep[05]
LOCAL aCustoFF[05]
LOCAL aCusto[05]
LOCAL aRet[04]
Local cIntMntAt

Static __aDefDec

DEFAULT lCusRep    := .F.
DEFAULT lTotalCP   := .F.
DEFAULT nQuantParte:= SD3->D3_QUANT

If __aDefDec == NIL
	__aDefDec := array(3)
	__aDefDec[1] := {}
	aAdd(__aDefDec[1],TamSX3("D3_CUSTO1")[2])
	aAdd(__aDefDec[1],TamSX3("D3_CUSTO2")[2])
	aAdd(__aDefDec[1],TamSX3("D3_CUSTO3")[2])
	aAdd(__aDefDec[1],TamSX3("D3_CUSTO4")[2])
	aAdd(__aDefDec[1],TamSX3("D3_CUSTO5")[2])

	__aDefDec[2] :={}
	aAdd(__aDefDec[2],TamSX3("D3_CUSRP1")[2])
	aAdd(__aDefDec[2],TamSX3("D3_CUSRP2")[2])
	aAdd(__aDefDec[2],TamSX3("D3_CUSRP3")[2])
	aAdd(__aDefDec[2],TamSX3("D3_CUSRP4")[2])
	aAdd(__aDefDec[2],TamSX3("D3_CUSRP5")[2])

	__aDefDec[3] :={}
	aAdd(__aDefDec[3],TamSX3("D3_CUSFF1")[2])
	aAdd(__aDefDec[3],TamSX3("D3_CUSFF2")[2])
	aAdd(__aDefDec[3],TamSX3("D3_CUSFF3")[2])
	aAdd(__aDefDec[3],TamSX3("D3_CUSFF4")[2])
	aAdd(__aDefDec[3],TamSX3("D3_CUSFF5")[2])
EndIf

cProg    := IIF(cProg == NIL  ,Space(03),cProg)
lQtdZero := IIF(Valtype(lQtdZero) == "L",lQtdZero,.F.)
lCusFIFO := IIF(cProg == "330",EstGetMV("MV_CUSFIFO",.F.,.F.),.F.)
lCusLIFO := IIF(cProg == "330",EstGetMV("MV_CUSLIFO",.F.,.F.),.F.)
aCMRep   := IIF(aCMRep== NIL, {0,0,0,0,0}, aCMRep)
cMoeda330C:= IIF(cMoeda330C == Nil,EstGetMv('MV_MOEDACM',.F.,"2345"),cMoeda330C)
cIntMntAt := IIF(cIntMntAt  == Nil,EstGetMv('MV_NGMNTES',.F.,"N"),cIntMntAt)

dbSelectArea("SD3")
lTotal := IF(lTotal == Nil,.f.,lTotal)
IF !lTotal
	For nX := 1 To 05
		// Verifica se moeda devera ser considerada
		If cProg == "330" .And. nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
	        If aCM != NIL
				aCusto[nX]:= 0
			ElseIf (lCusFIFO .Or. lCusLIFO) .And. aCMFF != NIL
				aCustoFF[nX]:= 0
			EndIf
			If lCusRep
		        If aCMRep != NIL
					aCustoRep[nX]:= 0
				EndIf
    		EndIf
           	Loop
		EndIf
		If aCM != NIL
            If !lQtdZero .And. cProg == "261" .And. SD3->D3_CF == "DE4"
                SD3->(dbGoto(aRegSD3[len(aRegSd3) -1]))
				Do Case
					Case nX == 1
						aCusto[nX] := SD3->D3_CUSTO1
					Case nX == 2
						aCusto[nX] := SD3->D3_CUSTO2
					Case nX == 3
						aCusto[nX] := SD3->D3_CUSTO3
					Case nX == 4
						aCusto[nX] := SD3->D3_CUSTO4
					Case nX == 5
						aCusto[nX] := SD3->D3_CUSTO5
				End Case
                SD3->(dbGoto(aRegSD3[len(aRegSd3)]))
            Else
				aCusto[nX] := If(lQtdZero,1,D3_QUANT)*aCM[nX]
			EndIf
		EndIf
		If lCusRep
			aCustoRep[nX] := If(lQtdZero,1,D3_QUANT)*aCMRep[nX]
		EndIf
		If (lCusFIFO .Or. lCusLIFO) .And. aCMFF != NIL
			aCustoFF[nX] := If(lQtdZero,1,D3_QUANT)*aCMFF[nX]
		EndIf
	Next nX
Else
	If aCM != NIL
		aCusto := aClone(aCm)
	EndIf
	If lCusRep
		aCustoRep := aClone(aCMRep)
	EndIf
	If (lCusFIFO .Or. lCusLIFO) .And. aCMFF != NIL
		aCustoFF := aClone(aCMFF)
	EndIf
Endif
RecLock("SD3",.F.)

If aCM != NIL
	SD3->D3_CUSTO1 := Round(aCusto[01],__aDefDec[1,01])
	If cProg # "330" .Or. (cProg == "330" .And. "2" $ cMoeda330C) .and. D3_CUSTO2 != aCusto[02]
		SD3->D3_CUSTO2 := Round(aCusto[02],__aDefDec[1,02])
	EndIf
	If cProg # "330" .Or. (cProg == "330" .And. "3" $ cMoeda330C) .and. D3_CUSTO3 != aCusto[03]
		SD3->D3_CUSTO3 := Round(aCusto[03],__aDefDec[1,03])
	EndIf
	If cProg # "330" .Or. (cProg == "330" .And. "4" $ cMoeda330C) .and. D3_CUSTO4 != aCusto[04]
		SD3->D3_CUSTO4 := Round(aCusto[04],__aDefDec[1,04])
	EndIf
	If cProg # "330" .Or. (cProg == "330" .And. "5" $ cMoeda330C) .and. D3_CUSTO5 != aCusto[05]
		SD3->D3_CUSTO5 := Round(aCusto[05],__aDefDec[1,05])
	EndIf

	aCusto[01] := D3_CUSTO1
	aCusto[02] := D3_CUSTO2
	aCusto[03] := D3_CUSTO3
	aCusto[04] := D3_CUSTO4
	aCusto[05] := D3_CUSTO5
    //Ŀ
    // Integracao com o Modulo de Manutencao de Ativos              
    //
    If cIntMntAt == "S"
       NGCUSSTLMED(SD3->D3_NUMSEQ,SD3->D3_CUSTO1)
    EndIf
Endif
If lCusRep
	SD3->D3_CUSRP1 := Round(aCustoRep[01],__aDefDec[2,01])
	If cProg # "330" .Or. (cProg == "330" .And. "2" $ cMoeda330C) .and. D3_CUSRP2 != aCustoRep[02]
		SD3->D3_CUSRP2 := Round(aCustoRep[02],__aDefDec[2,02])
	EndIf
	If cProg # "330" .Or. (cProg == "330" .And. "3" $ cMoeda330C) .and. D3_CUSRP3 != aCustoRep[03]
		SD3->D3_CUSRP3 := Round(aCustoRep[03],__aDefDec[2,03])
	EndIf
	If cProg # "330" .Or. (cProg == "330" .And. "4" $ cMoeda330C) .and. D3_CUSRP4 != aCustoRep[04]
		SD3->D3_CUSRP4 := Round(aCustoRep[04],__aDefDec[2,04])
	EndIf
	If cProg # "330" .Or. (cProg == "330" .And. "5" $ cMoeda330C) .and. D3_CUSRP5 != aCustoRep[05]
		SD3->D3_CUSRP5 := Round(aCustoRep[05],__aDefDec[2,05])
	EndIf
	aCustoRep[01] := D3_CUSRP1
	aCustoRep[02] := D3_CUSRP2
	aCustoRep[03] := D3_CUSRP3
	aCustoRep[04] := D3_CUSRP4
	aCustoRep[05] := D3_CUSRP5
EndIf
If (lCusFIFO .Or. lCusLIFO) .And. aCMFF != NIL
	SD3->D3_CUSFF1 := Round(aCustoFF[01],__aDefDec[3,01])
	If cProg # "330" .Or. (cProg == "330" .And. "2" $ cMoeda330C) .and. D3_CUSFF2 != aCustoFF[02]
		SD3->D3_CUSFF2 := Round(aCustoFF[02],__aDefDec[3,02])
	EndIf
	If cProg # "330" .Or. (cProg == "330" .And. "3" $ cMoeda330C) .and. D3_CUSFF3 != aCustoFF[03]
		SD3->D3_CUSFF3 := Round(aCustoFF[03],__aDefDec[3,03])
	EndIf
	If cProg # "330" .Or. (cProg == "330" .And. "4" $ cMoeda330C) .and. D3_CUSFF4 != aCustoFF[04]
		SD3->D3_CUSFF4 := Round(aCustoFF[04],__aDefDec[3,04])
	EndIf
	If cProg # "330" .Or. (cProg == "330" .And. "5" $ cMoeda330C) .and. D3_CUSFF5 != aCustoFF[05]
		SD3->D3_CUSFF5 := Round(aCustoFF[05],__aDefDec[3,05])
	EndIf
	aCustoFF[01] := D3_CUSFF1
	aCustoFF[02] := D3_CUSFF2
	aCustoFF[03] := D3_CUSFF3
	aCustoFF[04] := D3_CUSFF4
	aCustoFF[05] := D3_CUSFF5
EndIf
SD3->(MsUnLock())
//Ŀ
// Grava o custo em partes no arquivo de movimento              
//
aRetPartes:=GravaCusCP(lCstPart,aRegraCP,aCusto,"SD3",SD3->D3_COD,aRetPartes,nQuantParte,NIL,ACLONE(aCusto),lTotalCP)

Set(3,nDec)
If cProg == "330"
	aRet[01] := aCusto
	aRet[02] := aCustoFF
	aRet[03] := aRetPartes
	aRet[04] := aCustoRep
	Return aRet
Else
	Return aCusto
EndIf

/*


Ŀ
Funo    PegaCusD3  Autor  Eveli Morasco          Data  09/12/92 
Ĵ
Descrio  Devolve os 05 custos da movimentacao                       
Ĵ
Sintaxe    ExpA1 := PegaCusD3()                                       
Ĵ
Parametros ExpA1 = Array devolvido pela funcao com os 05 custos da    
                   movimentacao                                       
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function PegaCusD3
LOCAL aCusto[05]

dbSelectArea("SD3")
aCusto[01] := D3_CUSTO1
aCusto[02] := D3_CUSTO2
aCusto[03] := D3_CUSTO3
aCusto[04] := D3_CUSTO4
aCusto[05] := D3_CUSTO5
Return aCusto

/*


Ŀ
Funo    B2FimComD1 Autor  Eveli Morasco          Data  19/10/92 
Ĵ
Descrio  Atualiza o saldo final do SB2 (VFIM) baseado no SD1        
Ĵ
Sintaxe    B2FimComD1(ExpA1)                                          
Ĵ
Parametros ExpA1 = Array com os custos gravados no SD1                
           ExpA2 = Array com os custos FIFO gravados no SD1           
           ExpL1 = Processa Custo FIFO                                
           ExpL2 = Processa Custo em Partes                           
           ExpA3 = Array com custos em partes                         
           ExpL3 = Indica se atualiza o custo de reposicao            
Ĵ
 Uso       Generico                                                   
ٱ


*/
FUNCTION B2FimComD1(aCusto,aCustoFF,lCusFIFO,lCstPart,aRetPartes,lCusRep)
LOCAL nV,nX,aVFim[5],aCM[5],nMultiplic := 1
LOCAL aVFimFF[5],aCMFF[5],aCMHist[5]
LOCAL bBloco := { |nV,nX| Trim(nV)+Str(nX,1) }
LOCAL nDec:=Set(3,8)
Local lIsMod

DEFAULT lCusFIFO   := .F.
DEFAULT lCstPart   := .F.
DEFAULT lCusRep    := .F.

cMoeda330C:= IIF(cMoeda330C == Nil,SuperGetMv('MV_MOEDACM',.F.,"2345"),cMoeda330C)

If SD1->D1_TES > "500"
	nMultiplic := -1
EndIf

//Ŀ
// Posiciona no local a ser atualizado                   
//
dbSelectArea("SB2")
dbSetOrder(1)
MsSeek(FWxFilial("SB2")+SD1->D1_COD+SD1->D1_LOCAL)
//Ŀ
// Se nao existir , ele cria                             
//
If EOF()
	CriaSB2(SD1->D1_COD,SD1->D1_LOCAL)
EndIf
RecLock("SB2",.F.)

//Ŀ
// Pega o custo do campo e soma o custo da entrada       
//
If lCusFifo .And. aCustoFF == NIL
	aVFimFF[01] := B2_VFIMFF1 + SD1->D1_CUSTO  * nMultiplic
	aVFimFF[02] := B2_VFIMFF2 + If("2" $ cMoeda330C,SD1->D1_CUSTO2 * nMultiplic,0)
	aVFimFF[03] := B2_VFIMFF3 + If("3" $ cMoeda330C,SD1->D1_CUSTO3 * nMultiplic,0)
	aVFimFF[04] := B2_VFIMFF4 + If("4" $ cMoeda330C,SD1->D1_CUSTO4 * nMultiplic,0)
	aVFimFF[05] := B2_VFIMFF5 + If("5" $ cMoeda330C,SD1->D1_CUSTO5 * nMultiplic,0)
ElseIf !lCusFifo .And. aCusto == NIL
	aVFim[01] := B2_VFIM1 + SD1->D1_CUSTO  * nMultiplic
	aVFim[02] := B2_VFIM2 + If("2" $ cMoeda330C,SD1->D1_CUSTO2 * nMultiplic,0)
	aVFim[03] := B2_VFIM3 + If("3" $ cMoeda330C,SD1->D1_CUSTO3 * nMultiplic,0)
	aVFim[04] := B2_VFIM4 + If("4" $ cMoeda330C,SD1->D1_CUSTO4 * nMultiplic,0)
	aVFim[05] := B2_VFIM5 + If("5" $ cMoeda330C,SD1->D1_CUSTO5 * nMultiplic,0)
Else
	//Ŀ
	// Pega o custo do campo e soma o custo da entrada       
	//
	For nX := 1 to 5
		// Verifica se moeda devera ser considerada
		If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
			If lCusFIFO
				aVFimFF[nX] := 0
			Else
				aVfim[nX] := 0
			EndIf
           	Loop
		EndIf
		If lCusFIFO
			aVFimFF[nX] := &(Eval(bBloco,"SB2->B2_VFIMFF",nX)) + aCustoFF[nX]
		Else
			aVfim[nX] := &(Eval(bBloco,"SB2->B2_VFIM",nX)) + aCusto[nX]
		EndIf
	Next nX
EndIf

If lCusFIFO
	Replace B2_QFIMFF  With B2_QFIMFF + (SD1->D1_QUANT * nMultiplic)
	Replace B2_VFIMFF1 With aVFimFF[01]
	If "2" $ cMoeda330C
		Replace B2_VFIMFF2 With aVFimFF[02]
	EndIf
	If "3" $ cMoeda330C
		Replace B2_VFIMFF3 With aVFimFF[03]
  	EndIf
	If "4" $ cMoeda330C
		Replace B2_VFIMFF4 With aVFimFF[04]
	EndIf
	If "5" $ cMoeda330C
		Replace B2_VFIMFF5 With aVFimFF[05]
	EndIf
Else
	Replace B2_QFIM  With B2_QFIM  + (SD1->D1_QUANT * nMultiplic)
	Replace B2_QFIM2 With B2_QFIM2 + (SD1->D1_QTSEGUM * nMultiplic)
	Replace B2_VFIM1 With aVFim[01]
	If "2" $ cMoeda330C
		Replace B2_VFIM2 With aVFim[02]
	EndIf
	If "3" $ cMoeda330C
		Replace B2_VFIM3 With aVFim[03]
	EndIf
	If "4" $ cMoeda330C
		Replace B2_VFIM4 With aVFim[04]
	EndIf
	If "5" $ cMoeda330C
		Replace B2_VFIM5 With aVFim[05]
	EndIf
EndIf

If lCusRep
	If SD1->D1_QUANT > 0
		Replace B2_CMRP1 With SD1->D1_CUSRP1 / SD1->D1_QUANT
		If "2" $ cMoeda330C
			Replace B2_CMRP2 With SD1->D1_CUSRP2 / SD1->D1_QUANT
		EndIf
		If "3" $ cMoeda330C
			Replace B2_CMRP3 With SD1->D1_CUSRP3 / SD1->D1_QUANT
		EndIf
		If "4" $ cMoeda330C
			Replace B2_CMRP4 With SD1->D1_CUSRP4 / SD1->D1_QUANT
		EndIf
		If "5" $ cMoeda330C
			Replace B2_CMRP5 With SD1->D1_CUSRP5 / SD1->D1_QUANT
		EndIf

		Replace B2_VFRP1 With B2_VFRP1 + (SD1->D1_CUSRP1 * nMultiplic)
		If "2" $ cMoeda330C
			Replace B2_VFRP2 With B2_VFRP2 + SD1->D1_CUSRP2 * nMultiplic
		EndIf
		If "3" $ cMoeda330C
			Replace B2_VFRP3 With B2_VFRP3 + SD1->D1_CUSRP3 * nMultiplic
		EndIf
		If "4" $ cMoeda330C
			Replace B2_VFRP4 With B2_VFRP4 + SD1->D1_CUSRP4 * nMultiplic
		EndIf
		If "5" $ cMoeda330C
			Replace B2_VFRP5 With B2_VFRP5 + SD1->D1_CUSRP5 * nMultiplic
		EndIf

	ElseIf B2_QFIM > 0 .And. SD1->D1_QUANT == 0 .And. SD1->D1_CUSRP1 > 0 .And. !Empty(SD1->D1_NFORI) // Agrega custos das Notas de Gastos

		Replace B2_VFRP1 With B2_VFRP1 + (SD1->D1_CUSRP1 * nMultiplic)
		If "2" $ cMoeda330C
			Replace B2_VFRP2 With B2_VFRP2 + If("2" $ cMoeda330C,SD1->D1_CUSRP2 * nMultiplic,0)
		EndIf
		If "3" $ cMoeda330C
			Replace B2_VFRP3 With B2_VFRP3 + If("3" $ cMoeda330C,SD1->D1_CUSRP3 * nMultiplic,0)
		EndIf
		If "4" $ cMoeda330C
			Replace B2_VFRP4 With B2_VFRP4 + If("4" $ cMoeda330C,SD1->D1_CUSRP4 * nMultiplic,0)
		EndIf
		If "5" $ cMoeda330C
			Replace B2_VFRP5 With B2_VFRP5 + If("5" $ cMoeda330C,SD1->D1_CUSRP5 * nMultiplic,0)
		EndIf

		Replace B2_CMRP1 With B2_VFRP1 / B2_QFIM
		If "2" $ cMoeda330C
			Replace B2_CMRP2 With B2_VFRP2 / B2_QFIM
		EndIf
		If "3" $ cMoeda330C
			Replace B2_CMRP3 With B2_VFRP3 / B2_QFIM
		EndIf
		If "4" $ cMoeda330C
			Replace B2_CMRP4 With B2_VFRP4 / B2_QFIM
		EndIf
		If "5" $ cMoeda330C
			Replace B2_CMRP5 With B2_VFRP5 / B2_QFIM
		EndIf
	EndIf
EndIf

// Verifica as divergencias entre a quantidade da primeira e da segunda UM
MatQtdZero(.F.,.T.,.T.)

If lCusFIFO
	aCMFF[01] := B2_CMFF1
	aCMFF[02] := B2_CMFF2
	aCMFF[03] := B2_CMFF3
	aCMFF[04] := B2_CMFF4
	aCMFF[05] := B2_CMFF5
Else
	aCM[01] := B2_CMFIM1
	aCM[02] := B2_CMFIM2
	aCM[03] := B2_CMFIM3
	aCM[04] := B2_CMFIM4
	aCM[05] := B2_CMFIM5
	If cPaisLoc == "BRA" .And. SF4->F4_BONIF == 'S' .and. QTDCOMP(SD1->D1_CUSTO,.t.)  = QTDCOMP(0) 
		If QTDCOMP(B2_VFIM1,.t.) = qtdcomp(0)
			aCM[01] := 0
		EndIf
		If QTDCOMP(B2_VFIM2,.t.) = qtdcomp(0)
			aCM[02] := 0
		EndIf
		If QTDCOMP(B2_VFIM3,.t.) = qtdcomp(0)
			aCM[03] := 0
		EndIf
		If QTDCOMP(B2_VFIM4,.t.) = qtdcomp(0)
			aCM[04] := 0
		EndIf
		If QTDCOMP(B2_VFIM5,.t.) = qtdcomp(0)
			aCM[05] := 0
		EndIf		
	EndIf
	aCMHist := aClone(aCM)
EndIf

For nX := 1 to 5
	// Verifica se moeda devera ser considerada
	If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
		If lCusFIFO
			aCMFF[nX] := 0
		Else
			aCM[nX] := 0
		EndIf
       	Loop
	EndIf
	If lCusFIFO
		If B2_QFIMFF > 0 .And. aVFIMFF[nX] > 0
			aCMFF[nX] := aVFIMFF[nX]/B2_QFIMFF
		EndIf
	Else
		If B2_QFIM > 0 .And. aVFim[nX] > 0
			aCM[nX] := CusRound(aVFIM[nX]/B2_QFIM,nX)
		EndIf
	EndIf
Next nX

If lA330ISMOD == NIL
	lA330ISMOD := FindFunction("A330ISMOD")
EndIf

If lA330ISMOD
	lIsMod := A330ISMOD(B2_COD)
else
	lIsMod := ISPRODMOD(B2_COD)
ENDIF

If !lIsMod
	If lCusFIFO
		Replace B2_CMFF1 With aCMFF[01]
		If "2" $ cMoeda330C
			Replace B2_CMFF2 With aCMFF[02]
		EndIf
		If "3" $ cMoeda330C
			Replace B2_CMFF3 With aCMFF[03]
		EndIf
		If "4" $ cMoeda330C
			Replace B2_CMFF4 With aCMFF[04]
		EndIf
		If "5" $ cMoeda330C
			Replace B2_CMFF5 With aCMFF[05]
		EndIf
	Else
		Replace B2_CMFIM1 With aCM[01]
		If "2" $ cMoeda330C
			Replace B2_CMFIM2 With aCM[02]
		EndIf
		If "3" $ cMoeda330C
			Replace B2_CMFIM3 With aCM[03]
		EndIf
		If "4" $ cMoeda330C
			Replace B2_CMFIM4 With aCM[04]
		EndIf
		If "5" $ cMoeda330C
			Replace B2_CMFIM5 With aCM[05]
		EndIf
	EndIf
EndIf

//Ŀ
// Atualiza o custo em partes                            
//
AtuCPSB2(lCstPart,aRetPartes,nMultiplic,Nil,aClone(aCMHist))
MsUnlock()

Set(3,nDec)
Return

/*


Ŀ
Funo    B2FimComD2 Autor  Eveli Morasco          Data  28/12/92 
Ĵ
Descrio  Atualiza o saldo final (VFIM) com os dados do SD2          
Ĵ
Sintaxe    B2FimComD2(ExpA1)                                          
Ĵ
Parametros ExpA1 = Array com os custos gravados no SD2                
           ExpA2 = Array com os custos FIFO gravados no SD2           
           ExpL1 = Processa Custo FIFO                                
           ExpL2 = Processa Custo em Partes                           
           ExpA3 = Array com custos em partes                         
           ExpL3 = Indica se atualiza o custo de reposicao            
           ExpA4 = Array com custos de reposicao                      
Ĵ
 Uso       Generico                                                   
ٱ


*/
FUNCTION B2FimComD2(aCusto,aCustoFF,lCusFIFO,lCstPart,aRetPartes,lCusRep,aCustoRep)
LOCAL nX,aVFim[05],aCM[05],nMultiplic := 1
LOCAL aVFimFF[05],aCMFF[05],aCMHist[5]
LOCAL nDec:=Set(3,8)
Local lIsMod

DEFAULT lCusFIFO := .F.
DEFAULT lCstPart := .F.
DEFAULT lCusRep  := .F.
DEFAULT aCustoRep:= {0,0,0,0,0}
DEFAULT aCusto 	 := {}

cMoeda330C:= IIF(cMoeda330C == Nil,SuperGetMv('MV_MOEDACM',.F.,"2345"),cMoeda330C)

If SD2->D2_TES > "500"
	nMultiplic := -1
EndIf

//Ŀ
// Posiciona no local a ser atualizado                   
//
dbSelectArea("SB2")
dbSetOrder(1)
MsSeek(FWxFilial("SB2")+SD2->D2_COD+SD2->D2_LOCAL)
//Ŀ
// Se nao existir , ele cria                             
//
If EOF()
	CriaSB2(SD2->D2_COD,SD2->D2_LOCAL)
EndIf

//Ŀ
// Aqui e' acertado o Saldo do Custo do Produto, quando  
// a movimentacao do SD2 zerar o Saldo em Estoque do Prd.
// Dev. de Compra nao tratada pois o custo Origem = Dev. 
//
If len(aCusto) > 0 .And. SD2->D2_TIPO <> "D" .And. QtdComp(SB2->B2_QFIM+(SD2->D2_QUANT * nMultiplic)) == QtdComp(0) .and. Abs(aCusto[1]-SB2->B2_VFIM1) <= 0.01
	aCusto[1] := Abs(SB2->B2_VFIM1)
	aCusto[2] := Abs(SB2->B2_VFIM2)
	aCusto[3] := Abs(SB2->B2_VFIM3)
	aCusto[4] := Abs(SB2->B2_VFIM4)
	aCusto[5] := Abs(SB2->B2_VFIM5)
	RecLock("SD2")
	SD2->D2_CUSTO1 := aCusto[1]
	SD2->D2_CUSTO2 := aCusto[2]
	SD2->D2_CUSTO3 := aCusto[3]
	SD2->D2_CUSTO4 := aCusto[4]
	SD2->D2_CUSTO5 := aCusto[5]
	MsUnLock()
EndIf

If lA330ISMOD == NIL
	lA330ISMOD := FindFunction("A330ISMOD")
EndIf

If lA330ISMOD
	lIsMod := A330ISMOD(SB2->B2_COD)
else
	lIsMod := ISPRODMOD(SB2->B2_COD)
ENDIF

RecLock("SB2",.F.)

If lCusFIFO
	aVFimFF[01] := B2_VFIMFF1 + aCustoFF[01] * nMultiplic
	aVFimFF[02] := B2_VFIMFF2 + If("2" $ cMoeda330C,aCustoFF[02] * nMultiplic,0)
	aVFimFF[03] := B2_VFIMFF3 + If("3" $ cMoeda330C,aCustoFF[03] * nMultiplic,0)
	aVFimFF[04] := B2_VFIMFF4 + If("4" $ cMoeda330C,aCustoFF[04] * nMultiplic,0)
	aVFimFF[05] := B2_VFIMFF5 + If("5" $ cMoeda330C,aCustoFF[05] * nMultiplic,0)
Else
	aVFim[01] := B2_VFIM1 + aCusto[01] * nMultiplic
	aVFim[02] := B2_VFIM2 + If("2" $ cMoeda330C,aCusto[02] * nMultiplic,0)
	aVFim[03] := B2_VFIM3 + If("3" $ cMoeda330C,aCusto[03] * nMultiplic,0)
	aVFim[04] := B2_VFIM4 + If("4" $ cMoeda330C,aCusto[04] * nMultiplic,0)
	aVFim[05] := B2_VFIM5 + If("5" $ cMoeda330C,aCusto[05] * nMultiplic,0)
EndIf

If lCusFIFO
	Replace B2_QFIMFF  With B2_QFIMFF + (SD2->D2_QUANT * nMultiplic)
	Replace B2_VFIMFF1 With aVFimFF[01]
	If "2" $ cMoeda330C
		Replace B2_VFIMFF2 With aVFimFF[02]
	EndIf
	If "3" $ cMoeda330C
		Replace B2_VFIMFF3 With aVFimFF[03]
	EndIf
	If "4" $ cMoeda330C
		Replace B2_VFIMFF4 With aVFimFF[04]
	EndIf
	If "5" $ cMoeda330C
		Replace B2_VFIMFF5 With aVFimFF[05]
	EndIf
Else
	Replace B2_QFIM  With B2_QFIM  + (SD2->D2_QUANT   * nMultiplic)
	Replace B2_QFIM2 With B2_QFIM2 + (SD2->D2_QTSEGUM * nMultiplic)
	Replace B2_VFIM1 With aVFim[01]
	If "2" $ cMoeda330C
		Replace B2_VFIM2 With aVFim[02]
	EndIf
	If "3" $ cMoeda330C
		Replace B2_VFIM3 With aVFim[03]
	EndIf
	If "4" $ cMoeda330C
		Replace B2_VFIM4 With aVFim[04]
	EndIf
	If "5" $ cMoeda330C
		Replace B2_VFIM5 With aVFim[05]
	EndIf
EndIf

If lCusRep
	Replace B2_VFRP1 With B2_VFRP1 + (aCustoRep[1] * nMultiplic)
	If "2" $ cMoeda330C
		Replace B2_VFRP2 With B2_VFRP2 + (aCustoRep[2] * nMultiplic)
	EndIf
	If "3" $ cMoeda330C
		Replace B2_VFRP3 With B2_VFRP3 + (aCustoRep[3] * nMultiplic)
	EndIf
	If "4" $ cMoeda330C
		Replace B2_VFRP4 With B2_VFRP4 + (aCustoRep[4] * nMultiplic)
	EndIf
	If "5" $ cMoeda330C
		Replace B2_VFRP5 With B2_VFRP5 + (aCustoRep[5] * nMultiplic)
	EndIf
EndIf

// Verifica as divergencias entre a quantidade da primeira e da segunda UM
MatQtdZero(.F.,.T.,.T.)

If lCusFIFO
	aCMFF[01] := B2_CMFF1
	aCMFF[02] := B2_CMFF2
	aCMFF[03] := B2_CMFF3
	aCMFF[04] := B2_CMFF4
	aCMFF[05] := B2_CMFF5
Else
	aCM[01] := B2_CMFIM1
	aCM[02] := B2_CMFIM2
	aCM[03] := B2_CMFIM3
	aCM[04] := B2_CMFIM4
	aCM[05] := B2_CMFIM5
	aCMHist := aClone(aCM)
EndIf

For nX := 1 to 5
	// Verifica se moeda devera ser considerada
	If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
		If lCusFIFO
			aCMFF[nX] := 0
		Else
			aCM[nX] := 0
		EndIf
       	Loop
	EndIf
	If lCusFIFO
		If B2_QFIMFF > 0 .And. aVFIMFF[nX] > 0
			aCMFF[nX] := aVFIMFF[nX]/B2_QFIMFF
		EndIf
	Else
		If B2_QFIM > 0 .And. aVFim[nX] > 0
			aCM[nX] := CusRound(aVFIM[nX]/B2_QFIM,nX)
		Endif
	EndIf
Next nX

If !lIsMod
	If lCusFIFO
		Replace B2_CMFF1 With aCMFF[01]
		If "2" $ cMoeda330C
			Replace B2_CMFF2 With aCMFF[02]
		EndIf
		If "3" $ cMoeda330C
			Replace B2_CMFF3 With aCMFF[03]
		EndIf
		If "4" $ cMoeda330C
			Replace B2_CMFF4 With aCMFF[04]
		EndIf
		If "5" $ cMoeda330C
			Replace B2_CMFF5 With aCMFF[05]
		EndIf
	Else
		Replace B2_CMFIM1     With aCM[01]
		If "2" $ cMoeda330C
			Replace B2_CMFIM2 With aCM[02]
		EndIf
		If "3" $ cMoeda330C
			Replace B2_CMFIM3 With aCM[03]
		EndIf
		If "4" $ cMoeda330C
			Replace B2_CMFIM4 With aCM[04]
		EndIf
		If "5" $ cMoeda330C
			Replace B2_CMFIM5 With aCM[05]
		EndIf
	Endif
EndIf

//Ŀ
// Atualiza o custo em partes                            
//
AtuCPSB2(lCstPart,aRetPartes,nMultiplic,Nil,aClone(aCMHist))
MsUnlock()

Set(3,nDec)
Return

/*


Ŀ
Funo    B2FimComD3 Autor  Eveli Morasco          Data  19/10/92 
Ĵ
Descrio  Atualiza o SB2 baseado no SD3                              
Ĵ
Sintaxe    B2FimComD3(ExpA1,ExpC1)                                    
Ĵ
Parametros ExpA1 = Array com os custos gravados no SD3                
           ExpC1 = Codigo do local padrao do processo , quando este   
                   parametro nao for passado significa que ele deve   
                   atualizar o local corrente.                        
           ExpA2 = Array com os custos FIFO gravados no SD2           
           ExpL1 = Processa Custo FIFO                                
           ExpL2 = Processa Custo Unificado por filial                
           ExpL3 = Processa Custo em Partes                           
           ExpA3 = Array com custos em partes                         
Ĵ
 Uso       Generico                                                   
ٱ


*/
FUNCTION B2FimComD3(aCusto,cLocProc,aCustoFF,lCusFIFO,lCusUnif,lCstPart,aRetPartes,lCusRep,aCustoRep,lUpdateSB2)
LOCAL nX,aVFim[05],aCM[05],nMultiplic := 1,cLocal
LOCAL aVFimFF[05],aCMFF[05],aCMHist[5],aVFimRep[5]
LOCAL aCMRep := {0,0,0,0,0}
LOCAL nDec     := Set(3,8)
LOCAL nRecSB2 := 0
LOCAL cOriglan := ""
//Ŀ
// MV_TMPRV - parametro utilizado na integtracao do template
// DCL_EST com Estoque, contem a TM de movimentacao interna.
//
LOCAL cTmDCL   := EstGetMv('MV_TMPRV',.F.,'')

Local lIsMod

DEFAULT lCusFIFO := .F.
DEFAULT lCstPart := .F.
DEFAULT lCusUnif := .F.
DEFAULT lCusRep  := .F.
DEFAULT aCustoRep:= {0,0,0,0,0}
DEFAULT lUpdateSB2 := .T.

cMoeda330C:= IIF(cMoeda330C == Nil,EstGetMv('MV_MOEDACM',.F.,"2345"),cMoeda330C)

If (SD3->D3_TM > "500" .And. cLocProc == NIL) .Or. (SD3->D3_TM <= "500" .And. cLocProc != NIL)
	nMultiplic := -1
EndIf

//Ŀ
// Se for movimento de material indireto ele deve atualizar 
// o local padrao do processo passado como parametro        
//
If cLocProc == NIL
	cLocal := SD3->D3_LOCAL
Else
	cLocal := cLocProc
EndIf

//Ŀ
// Posiciona SD7 para identificar a origem do lancto        
// A ser tratado pelo acerto de saldo do custo do produto   
// qdo a movimentao do SD3 zerar o saldo e Baixa de CQ    
//

If SD3->D3_CF == 'RE6'
	dbSelectArea('SD7')
	dbSetOrder(1)
	If SD7->(MsSeek(FWxFilial('SD7')+alltrim(SD3->D3_DOC)+SD3->D3_COD+cLocal+'001'))
		cOriglan := D7_ORIGLAN
	EndIf
EndIf

//Ŀ
// Posiciona no local a ser atualizado                   
//
dbSelectArea("SB2")
dbSetOrder(1)
MsSeek(FWxFilial("SB2")+SD3->D3_COD+cLocal)
//Ŀ
// Se nao existir , ele cria                             
//
If EOF()
	CriaSB2(SD3->D3_COD,cLocal)
EndIf

If lA330ISMOD == NIL
	lA330ISMOD := FindFunction("A330ISMOD")
EndIf

If lA330ISMOD
	lIsMod := A330ISMOD(SB2->B2_COD)
else
	lIsMod := ISPRODMOD(SB2->B2_COD)
ENDIF

If lUpdateSB2
	RecLock("SB2",.F.)
Else
	dbSelectArea('SB2')
EndIf
nRecSB2 := SB2->(Recno()) //-- Guarda o registro no SB2 que foi travado

//Ŀ
// Aqui e' acertado o Saldo do Custo do Produto, quando  
// a movimentacao do SD3 zerar o Saldo em Estoque do Prd.
//
If (B2_QFIM+((SD3->D3_QUANT+SD3->D3_PERDA) * nMultiplic) == 0 ) .And. ;
	AllTrim(cTmDCL)#AllTrim(SD3->D3_TM) .And. ;
   (!(SD3->D3_CF$"DE4|DE5|RE5|DE6|RE6|DE7|RE8|DE8|PR0|PR1|ER0|ER1") .Or. (cOriglan == 'CP|TR' .and. SD3->D3_CF == 'RE6')) .And. !lCusFifo .And. !lCusUnif
	If SD3->D3_TM <= "500"
		aCusto[1] := Abs(B2_VFIM1)
		aCusto[2] := If("2" $ cMoeda330C,Abs(B2_VFIM2),0)
		aCusto[3] := If("3" $ cMoeda330C,Abs(B2_VFIM3),0)
		aCusto[4] := If("4" $ cMoeda330C,Abs(B2_VFIM4),0)
		aCusto[5] := If("5" $ cMoeda330C,Abs(B2_VFIM5),0)
	Else
		aCusto[1] := B2_VFIM1
		aCusto[2] := If("2" $ cMoeda330C,B2_VFIM2,0)
		aCusto[3] := If("3" $ cMoeda330C,B2_VFIM3,0)
		aCusto[4] := If("4" $ cMoeda330C,B2_VFIM4,0)
		aCusto[5] := If("5" $ cMoeda330C,B2_VFIM5,0)
	EndIf
	dbSelectArea("SD3")
	RecLock("SD3",.F.)
	SD3->D3_CUSTO1 := aCusto[1]
	SD3->D3_CUSTO2 := If("2" $ cMoeda330C,aCusto[2],0)
	SD3->D3_CUSTO3 := If("3" $ cMoeda330C,aCusto[3],0)
	SD3->D3_CUSTO4 := If("4" $ cMoeda330C,aCusto[4],0)
	SD3->D3_CUSTO5 := If("5" $ cMoeda330C,aCusto[5],0)
	MsUnLock()
	dbSelectArea("SB2")
EndIf

If lCusFIFO
	aVFimFF[01] := B2_VFIMFF1 + IF(aCustoFF[01]= NIL,0,aCustoFF[01]) * nMultiplic
	aVFimFF[02] := B2_VFIMFF2 + If("2" $ cMoeda330C,aCustoFF[02] * nMultiplic,0)
	aVFimFF[03] := B2_VFIMFF3 + If("3" $ cMoeda330C,aCustoFF[03] * nMultiplic,0)
	aVFimFF[04] := B2_VFIMFF4 + If("4" $ cMoeda330C,aCustoFF[04] * nMultiplic,0)
	aVFimFF[05] := B2_VFIMFF5 + If("5" $ cMoeda330C,aCustoFF[05] * nMultiplic,0)
Else
	aVFim[01] := B2_VFIM1 + aCusto[01] * nMultiplic
	aVFim[02] := B2_VFIM2 + If("2" $ cMoeda330C,aCusto[02] * nMultiplic,0)
	aVFim[03] := B2_VFIM3 + If("3" $ cMoeda330C,aCusto[03] * nMultiplic,0)
	aVFim[04] := B2_VFIM4 + If("4" $ cMoeda330C,aCusto[04] * nMultiplic,0)
	aVFim[05] := B2_VFIM5 + If("5" $ cMoeda330C,aCusto[05] * nMultiplic,0)
EndIf
If lCusRep
	aVFimRep[01] := B2_VFRP1 + aCustoRep[01] * nMultiplic
	aVFimRep[02] := B2_VFRP2 + If("2" $ cMoeda330C,aCustoRep[02] * nMultiplic,0)
	aVFimRep[03] := B2_VFRP3 + If("3" $ cMoeda330C,aCustoRep[03] * nMultiplic,0)
	aVFimRep[04] := B2_VFRP4 + If("4" $ cMoeda330C,aCustoRep[04] * nMultiplic,0)
	aVFimRep[05] := B2_VFRP5 + If("5" $ cMoeda330C,aCustoRep[05] * nMultiplic,0)
EndIf
If lUpdateSB2
	If lCusFIFO
		Replace B2_QFIMFF  With B2_QFIMFF + (SD3->D3_QUANT * nMultiplic)
		Replace B2_VFIMFF1 With aVFimFF[01]
		Replace B2_VFIMFF2 With If("2" $ cMoeda330C,aVFimFF[02],0)
		Replace B2_VFIMFF3 With If("3" $ cMoeda330C,aVFimFF[03],0)
		Replace B2_VFIMFF4 With If("4" $ cMoeda330C,aVFimFF[04],0)
		Replace B2_VFIMFF5 With If("5" $ cMoeda330C,aVFimFF[05],0)
	Else
		Replace B2_QFIM  With B2_QFIM  + (SD3->D3_QUANT * nMultiplic)
		Replace B2_QFIM2 With B2_QFIM2 + (SD3->D3_QTSEGUM * nMultiplic)
		Replace B2_VFIM1 With aVFim[01]
		Replace B2_VFIM2 With If("2" $ cMoeda330C,aVFim[02],0)
		Replace B2_VFIM3 With If("3" $ cMoeda330C,aVFim[03],0)
		Replace B2_VFIM4 With If("4" $ cMoeda330C,aVFim[04],0)
		Replace B2_VFIM5 With If("5" $ cMoeda330C,aVFim[05],0)
	EndIf
	
	If lCusRep
		Replace B2_VFRP1 With aVFimRep[01]
		Replace B2_VFRP2 With If("2" $ cMoeda330C,aVFimRep[02],0)
		Replace B2_VFRP3 With If("3" $ cMoeda330C,aVFimRep[03],0)
		Replace B2_VFRP4 With If("4" $ cMoeda330C,aVFimRep[04],0)
		Replace B2_VFRP5 With If("5" $ cMoeda330C,aVFimRep[05],0)
	EndIf
	
	// Verifica as divergencias entre a quantidade da primeira e da segunda UM
	MatQtdZero(.F.,.T.,.T.)
	
	If nMultiplic == -1
		Replace SB2->B2_USAI With SD3->D3_EMISSAO
	EndIf

EndIf

If lCusFIFO
	aCMFF[01] := B2_CMFF1
	aCMFF[02] := If("2" $ cMoeda330C,B2_CMFF2,0)
	aCMFF[03] := If("3" $ cMoeda330C,B2_CMFF3,0)
	aCMFF[04] := If("4" $ cMoeda330C,B2_CMFF4,0)
	aCMFF[05] := If("5" $ cMoeda330C,B2_CMFF5,0)
Else
	aCM[01] := B2_CMFIM1
	aCM[02] := If("2" $ cMoeda330C,B2_CMFIM2,0)
	aCM[03] := If("3" $ cMoeda330C,B2_CMFIM3,0)
	aCM[04] := If("4" $ cMoeda330C,B2_CMFIM4,0)
	aCM[05] := If("5" $ cMoeda330C,B2_CMFIM5,0)
	aCMHist	:= aClone(aCM)
	If lCusRep
		If SD3->D3_CF$"PR0|PR1"
			aCMRep[1] := aCustoRep[01] / IIf(SD3->D3_QUANT==0,1,SD3->D3_QUANT)
			aCMRep[2] := If("2" $ cMoeda330C,aCustoRep[02] / IIf(SD3->D3_QUANT==0,1,SD3->D3_QUANT),0)
			aCMRep[3] := If("3" $ cMoeda330C,aCustoRep[03] / IIf(SD3->D3_QUANT==0,1,SD3->D3_QUANT),0)
			aCMRep[4] := If("4" $ cMoeda330C,aCustoRep[04] / IIf(SD3->D3_QUANT==0,1,SD3->D3_QUANT),0)
			aCMRep[5] := If("5" $ cMoeda330C,aCustoRep[05] / IIf(SD3->D3_QUANT==0,1,SD3->D3_QUANT),0)
		ElseIf SD3->D3_CF$"DE6|RE6" .And. cPaisLoc == "ARG"
			aCMRep[1] := IIf(SD3->D3_CUSRP1 > 0,SD3->D3_CMRP,B2_CMRP1)
			aCMRep[2] := If("2" $ cMoeda330C,IIf(SD3->D3_CUSRP2 > 0,SD3->D3_CMRP,B2_CMRP2),0)
			aCMRep[3] := If("3" $ cMoeda330C,IIf(SD3->D3_CUSRP3 > 0,SD3->D3_CMRP,B2_CMRP3),0)
			aCMRep[4] := If("4" $ cMoeda330C,IIf(SD3->D3_CUSRP4 > 0,SD3->D3_CMRP,B2_CMRP4),0)
			aCMRep[5] := If("5" $ cMoeda330C,IIf(SD3->D3_CUSRP5 > 0,SD3->D3_CMRP,B2_CMRP5),0)
		Else
			aCMRep[1] := B2_CMRP1
			aCMRep[2] := If("2" $ cMoeda330C,B2_CMRP2,0)
			aCMRep[3] := If("3" $ cMoeda330C,B2_CMRP3,0)
			aCMRep[4] := If("4" $ cMoeda330C,B2_CMRP4,0)
			aCMRep[5] := If("5" $ cMoeda330C,B2_CMRP5,0)
		EndIf
	EndIf
EndIf

For nX := 1 to 5
	// Verifica se moeda devera ser considerada
	If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
		If lCusFIFO
			aCMFF[nX] := 0
		Else
			aCM[nX] := 0
		EndIf
       	Loop
	EndIf
	If lCusFIFO
		If B2_QFIMFF > 0 .And. aVFIMFF[nX] > 0
			aCMFF[nX] := aVFIMFF[nX]/B2_QFIMFF
		EndIf
	Else
		If B2_QFIM > 0 .And. aVFim[nX] > 0
			aCM[nX] := CusRound(aVFIM[nX]/B2_QFIM,nX)
		Endif
	EndIf
Next nX

If lUpdateSB2
	If !lIsMod
		If lCusFIFO
			Replace B2_CMFF1 With aCMFF[01]
			If "2" $ cMoeda330C
				Replace B2_CMFF2 With aCMFF[02]
			EndIf
			If "3" $ cMoeda330C
				Replace B2_CMFF3 With aCMFF[03]
			EndIf
			If "4" $ cMoeda330C
				Replace B2_CMFF4 With aCMFF[04]
			EndIf
			If "5" $ cMoeda330C
				Replace B2_CMFF5 With aCMFF[05]
			EndIf
		Else
			Replace B2_CMFIM1 With aCM[01]
			If "2" $ cMoeda330C
				Replace B2_CMFIM2 With aCM[02]
			EndIf
			If "3" $ cMoeda330C
				Replace B2_CMFIM3 With aCM[03]
			EndIf
			If "4" $ cMoeda330C
				Replace B2_CMFIM4 With aCM[04]
			EndIf
			If "5" $ cMoeda330C
				Replace B2_CMFIM5 With aCM[05]
			EndIf
			If lCusRep
				Replace B2_CMRP1 With aCMRep[01]
				If "2" $ cMoeda330C
					Replace B2_CMRP2 With aCMRep[02]
				EndIf
				If "3" $ cMoeda330C
					Replace B2_CMRP3 With aCMRep[03]
				EndIf
				If "4" $ cMoeda330C
					Replace B2_CMRP4 With aCMRep[04]
				EndIf
				If "5" $ cMoeda330C
					Replace B2_CMRP5 With aCMRep[05]
				EndIf
			EndIf
		Endif
	EndIf
	//Ŀ
	// Atualiza o custo em partes                            
	//
	AtuCPSB2(lCstPart,aRetPartes,nMultiplic,Nil,aClone(aCMHist))
EndIf

dbSelectArea('SB2')
If nRecSB2 > 0
	SB2->(MsGoto(nRecSB2)) //-- Posiciona no registro que foi travado
EndIf
If lUpdateSB2
	SB2->(MsUnlock())
EndIf

//Ŀ
// Se ele atualizou o local do processo , ele deve voltar 
// ao local original da movimentacao                      
//
If cLocProc != NIL
	MsSeek(FWxFilial("SB2")+SD3->D3_COD+SD3->D3_LOCAL)
EndIf
Set(3,nDec)
Return

/*


Ŀ
Funo    B2AtuComD1 Autor  Eveli Morasco          Data  19/01/93 
Ĵ
Descrio  Atualiza o saldo atual do SB2 (VATU) baseado no SD1        
Ĵ
Sintaxe    B2AtuComD1(ExpN1)                                          
Ĵ
Parametros ExpN1 = Expressao numerica indicando se movimentacao soma  
                   ou subtrai                                         
           ExpC1 = Numero do Skip-Lote                                
           ExpC2 = Alias do SD1 (i.e.: quando usa QUERY)              
           ExpL1 = Inverte o Tipo de Entrada/Saida                    
Ĵ
 Uso       Generico                                                   
ٱ


*/
FUNCTION B2AtuComD1(nMultiplic, cSkipLote,  cAliasSD1, lInverte, lAgregaOri)
Static lMTAB2D1
Static lMTAB2D1R
Static lMTAATUD1
Static nDecCM1
Local nDec       := Set(3,8)
Local nX         := 0
Local aVAtu      := Array(5)
Local aCM        := Array(5)
Local cHelp      := ""
Local cValue     := ""
Local cChave     := SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD
Local cD1VTES    := ''
Local lSeekSB1   := .F.
Local nSALDOSB2  := 0
Local cLocCQ	 := GetMvNNR('MV_CQ','98')
Local cLocaliz	 := Nil
Local cNumSerie	 := Nil
Local aSldAnt    := {}
Local aLogMov    := {}
Local dDtFabric  := dDataBase
Local cEventID   := 0    // Variavel usada para armazenar o ID do EventViewer
Local cMensagem  := " " // Variavel para armazenar a mensagem utilizada no eventviewer
Local lIntegPPI  := PCPIntgPPI()

//Ŀ
// Variavel usada para identificar se usuario permite que o 
// estoque fique negativo. Se permitir, a variavel vale .T. 
//
Local lEstNeg	:= IF(SuperGetMV("MV_ESTNEG",.F.,"N")=="S",.T.,.F.)
Local oFactory	:= Nil
Local oAdapter	:= Nil

Default cAliasSD1  := 'SD1'
Default lInverte   := .F.
Private aPPIDelete := {}

cD1VTES := If(lInverte,"999",(cAliasSD1)->D1_TES)
lMTAB2D1  := IIF(lMTAB2D1  == Nil,ExistBlock('MTAB2D1'),lMTAB2D1)
lMTAB2D1R := IIF(lMTAB2D1R == Nil,ExistBlock('MTAB2D1R'),lMTAB2D1R)
lMTAATUD1 := IIF(lMTAATUD1 == Nil,ExistBlock('MTAATUD1'),lMTAATUD1)
nDecCM1   := IIF(nDecCM1   == Nil,TamSx3('B2_CM1') [2],nDecCM1)

If cD1VTES > "500"
	nMultiplic := -1
Else
	nMultiplic := IF(nMultiplic==NIL, 1, nMultiplic)
EndIf

//Ŀ
//Verifica a existencia do campo D1_DFABRIC              
//
If cPaisLoc == "BRA"
	dDtFabric := SD1->D1_DFABRIC
EndIf
//Ŀ
// Posiciona no produto a ser atualizado                 
//
dbSelectArea("SB1")
dbSetOrder(1)
lSeekSB1:=MsSeek(xFilial("SB1")+SD1->D1_COD+SD1->D1_LOCAL)

//Ŀ
// Ponto de Entrada Executado ANTES da atualizacao do SB2
//
If lMTAB2D1
	ExecBlock("MTAB2D1",.F.,.F.,{SD1->D1_COD, SD1->D1_LOCAL, nMultiplic})
EndIf

//Ŀ
// Chamada da LogMov para verificar o saldo antes da     |
//| atualizacao das tabelas SB2/SBF/SB8                   |
//
If Rastro(SD1->D1_COD) .Or. Localiza(SD1->D1_COD)
	LogMov('SD1',,,,,,lInverte,cAliasSD1,,.T.,@aSldAnt)
EndIf

//Ŀ
// Posiciona no local a ser atualizado                   
//
dbSelectArea("SB2")
dbSetOrder(1)
If !MsSeek(xFilial("SB2")+SD1->D1_COD+SD1->D1_LOCAL, .F.)
	//Ŀ
	// Se nao existir , ele cria                             
	//
	CriaSB2(SD1->D1_COD,SD1->D1_LOCAL)
	RecLock("SB2",.F.)
Else
	RecLock("SB2",.F.)
EndIf

//Ŀ
// Pega o custo do campo e soma o custo da entrada       
//
aVAtu[01] := B2_VATU1 + SD1->D1_CUSTO  * nMultiplic
aVAtu[02] := B2_VATU2 + SD1->D1_CUSTO2 * nMultiplic
aVAtu[03] := B2_VATU3 + SD1->D1_CUSTO3 * nMultiplic
aVAtu[04] := B2_VATU4 + SD1->D1_CUSTO4 * nMultiplic
aVAtu[05] := B2_VATU5 + SD1->D1_CUSTO5 * nMultiplic

If (B2_QATU+(SD1->D1_QUANT * nMultiplic)) < 0
	If !lEstNeg
		cValue:=Transform((B2_QATU+(SD1->D1_QUANT * nMultiplic)),PesqPictQt("B2_QATU",14))
		cHelp:=AllTrim(B2_COD)+"/"+B2_LOCAL+STR0001+ALLTRIM(cValue)+")."	//", Saldo: "
		If ( Type("l103Auto") == "U" .Or. !l103Auto )
			Help ( " ", 1, "MVESTNEG",,cHelp,3,1)
		EndIf
	EndIf
	//Ŀ
	// Envia e-mail ref. a SALDO NEGATIVO NO ESTOQUE - 002
	//
	If lSeekSB1
		//Ŀ
		// Messenger						  
		//
		MEnviaMail("002",{SB1->B1_COD,SB1->B1_DESC,SB2->B2_LOCAL,(SB2->B2_QATU + (SD1->D1_QUANT * nMultiplic)),lEstNeg})

		//Ŀ
		// EventViewer						  
		//
		cEventID  := "002"
		cMensagem := STR0261+SB1->B1_COD+" - "+SB1->B1_DESC //"O produto "###""
		cMensagem += STR0262+cValToChar(SB2->B2_QATU + (SD1->D1_QUANT * nMultiplic)) //" atingiu o saldo negativo de "###""
		cMensagem += STR0263+SB2->B2_LOCAL //" no almoxarifado "###""
		EventInsert( FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID, FW_EV_LEVEL_INFO, "", STR0265, cMensagem, .T. )
	EndIf
EndIf

//Ŀ
// Verifica se envia e-mail ref. PONTO DE PEDIDO - 001
//
If lSeekSB1 .And. !(SB2->B2_LOCAL == cLocCQ) .And. !Empty(RetFldProd(SB1->B1_COD,"B1_EMIN"))
	nSALDOSB2 := (SALDOSB2(.T.,,dDataBase))+SB2->B2_SALPEDI+SB2->B2_QACLASS

	//Ŀ
	// Ponto de Entrada para validar saldo em TODOS os armazens
	//
	If lMTAATUD1
		nSALDOSB2 := ExecBlock('MTAATUD1',.F.,.F.)
		nSALDOSB2 := IIf(Valtype(nSALDOSB2) <> "N", 0, nSALDOSB2)
	EndIf

		If (nSALDOSB2 + (SD1->D1_QUANT * nMultiplic)) <= RetFldProd(SB1->B1_COD,"B1_EMIN")
			dbSelectarea("SXI")
			dbsetorder(2)
			cEventID  := "001" //Ponto de pedido
		If msSeek('002' + '001' + cEventID)
			cMensagem:=STR0022+SB1->B1_COD+" - "+SB1->B1_DESC+STR0224	//"O produto "###" atingiu a quantidade de "
			cMensagem+= Str(nSALDOSB2 + (SD1->D1_QUANT * nMultiplic))+' '+STR0005+SB2->B2_LOCAL+STR0225+ Str(RetFldProd(SB1->B1_COD,"B1_EMIN"))	//" (armazm "###"), abaixo do Ponto de Pedido de "
			EventInsert(FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID,FW_EV_LEVEL_INFO,""/*cCargo*/,STR0226,cMensagem,.T./*lPublic*/)
		Else
			MEnviaMail("001",{SB1->B1_COD,SB1->B1_DESC,SB2->B2_LOCAL,(nSALDOSB2 + (SD1->D1_QUANT * nMultiplic)),RetFldProd(SB1->B1_COD,"B1_EMIN")})
		EndIf
	EndIf
EndIf

//Ŀ
// Verifica se envia e-mail ref. ESTOQUE MAXIMO  - 029
//
If lSeekSB1 .And. !Empty(RetFldProd(SB1->B1_COD,"B1_EMAX"))
	If (SB2->B2_QATU + (SD1->D1_QUANT * nMultiplic)) >= RetFldProd(SB1->B1_COD,"B1_EMAX")
		//Ŀ
		// EventViewer						  
		//
		cEventID	:= "029"
		cMensagem	:= OemToAnsi(STR0022) + SB1->B1_COD +" - "+ SB1->B1_DESC + OemToAnsi(STR0224) + CRLF //"O produto "###" atingiu a quantidade de "
		cMensagem	+= STR(SB2->B2_QATU + (SD1->D1_QUANT * nMultiplic)) + ' - ' + OemToAnsi(STR0005) + SB2->B2_LOCAL + OemToAnsi(STR0264) + STR(RetFldProd(SB1->B1_COD,"B1_EMAX")) //"Armazem  : ##, sendo que o produto tem como Estoque Maximo (B1_EMAX) de: "
		EventInsert(FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID,FW_EV_LEVEL_INFO,""/*cCargo*/,OemToAnsi(STR0266),cMensagem,.T./*lPublic*/)
		//Ŀ
		// Messenger						  
		//
		MEnviaMail("029",{SB1->B1_COD,SB1->B1_DESC,SB2->B2_LOCAL,(SB2->B2_QATU + (SD1->D1_QUANT * nMultiplic)),RetFldProd(SB1->B1_COD,"B1_EMAX")})
	EndIf
EndIf

//Ŀ
// Verifica se envia e-mail ref. LOTE MINIMO/QTDE EMBALAGEM  - 045
//
SG1->(DbSetOrder(1))
If SG1->(DbSeek(xFilial('SG1')+SB1->B1_COD))
	If lSeekSB1 .And. !Empty(RetFldProd(SB1->B1_COD,"B1_LM"))
		If (SB2->B2_QATU + (SD1->D1_QUANT * nMultiplic)) <= RetFldProd(SB1->B1_COD,"B1_LM")
			MEnviaMail("045",{SB1->B1_COD,SB1->B1_DESC,SB2->B2_LOCAL,(SB2->B2_QATU + (SD1->D1_QUANT * nMultiplic)),RetFldProd(SB1->B1_COD,"B1_LM")})
			cEventID  := "045"
			cMensagem := STR0261+SB1->B1_COD+" - "+SB1->B1_DESC //"O produto "###""
			cMensagem += STR0269+cValToChar(SB2->B2_QATU + (SD1->D1_QUANT * nMultiplic)) //" Abaixo da Quantidade por Embalagem do Produto "###""
			cMensagem += STR0263+SB2->B2_LOCAL //" no almoxarifado "###""
			EventInsert( FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID, FW_EV_LEVEL_INFO, "", STR0269, cMensagem, .T. )
		EndIf
	EndIf
Else
	If lSeekSB1 .And. !Empty(RetFldProd(SB1->B1_COD,"B1_QE"))
		If (SB2->B2_QATU + (SD1->D1_QUANT * nMultiplic)) <= RetFldProd(SB1->B1_COD,"B1_QE")
			MEnviaMail("045",{SB1->B1_COD,SB1->B1_DESC,SB2->B2_LOCAL,(SB2->B2_QATU + (SD1->D1_QUANT * nMultiplic)),RetFldProd(SB1->B1_COD,"B1_QE")})
			cEventID  := "045"
			cMensagem := STR0261+SB1->B1_COD+" - "+SB1->B1_DESC //"O produto "###""
			cMensagem += STR0270+cValToChar(SB2->B2_QATU + (SD1->D1_QUANT * nMultiplic)) //" Abaixo da Quantidade por Embalagem do Produto "###""
			cMensagem += STR0263+SB2->B2_LOCAL //" no almoxarifado "###""
			EventInsert( FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID, FW_EV_LEVEL_INFO, "", STR0269, cMensagem, .T. )
		EndIf
	Endif
EndIf

REPLACE	SB2->B2_QATU WITH SB2->B2_QATU + (SD1->D1_QUANT * nMultiplic)

//Ŀ
// Movimenta Lotes/Sub-Lotes/Localizacao Fisica
//
If Rastro(SD1->D1_COD) .Or. Localiza(SD1->D1_COD)

	//Ŀ
	//Busca detalhes da localizacao e do numero de serie quando
	//trata-se de uma devolucao                                
	//
	If IsInCallStack("LOJA720")
		RetLocaliz(@cLocaliz,@cNumSerie)
	EndIf

	//Ŀ
	// Tratamento da gravacao do SD1 na Integridade Referencial            
	//
	SD1->(FkCommit())
	MovLote("SD1",;				//1
			SD1->D1_COD,;		//2
			SD1->D1_LOCAL,;		//3
			If((cPaisLoc<>"BRA"),SD1->D1_LOCALIZ,cLocaliz ),;	//4
			If((cPaisLoc<>"BRA"),SD1->D1_NUMSERI,cNumSerie),;	//5
			SD1->D1_LOTECTL,;	//6
			SD1->D1_NUMLOTE,;	//7
			SD1->D1_NUMSEQ,;	//8
			cD1VTES,;         	//9
			SD1->D1_FORNECE,;	//10
			SD1->D1_LOJA,;		//11
			SD1->D1_LOTEFOR,;	//12
			"NF",;				//13
			cChave,;			//14
			SD1->D1_DOC,;		//15
			SD1->D1_SERIE,;		//16
			SD1->D1_OP,;		//17
			NIL,;				//18
			NIL,;				//19
			NIL,;				//20
			NIL,;				//21
			SD1->D1_QUANT,;		//22
			SD1->D1_QTSEGUM,;	//23
			SD1->D1_DTDIGIT,;	//24
			SD1->D1_DTVALID,;	//25
			NIL,;				//26
			NIL,;				//27
			cD1VTES>"500",;   	//28
			.T.,;				//29
			cD1VTES<="500",; 	//30
			NIL,;				//31
			NIL,;				//32
			NIL,;				//33
			NIL,;				//34
			NIL,;				//35
			NIL,;				//36
			NIL,;				//37
			NIL,;				//38
			NIL,;				//39
			NIL,;				//40
			NIL,;				//41
			NIL,;				//42
			NIL,;				//43
			NIL,;				//44
			NIL,;				//45
			NIL,;				//46
			NIL,;				//47
			NIL,;				//48
			NIL,;				//49
			SD1->D1_POTENCI,; 	//50
			NIL,;				//51
			NIL,;				//52
			NIL,;				//53
			NIL,;				//54
			NIL,;				//55
			@aLogMov,;         	//56
			dDtFabric,;			//57
			NIL,;				//58
			NIL,;				//59
			NIL,;				//60
			NIL,;				//61
			NIL,;				//62
			lAgregaOri)			//63
	LogMov('SD1',,,,,,lInverte,cAliasSD1,,,aClone(aSldAnt),aClone(aLogMov),,0,SD1->D1_QUANT)

	// Tratamento para notas de entradas de devoluo de terceiros com lote ou sublote retornados para o armazem diferente do envio
	// onde  criado o lote no armazem destino e devido a qtde origem da SB8 no era ajustado o saldo.

	If !Empty(SD1->D1_IDENTB6) .and. IsInCallStack ('MATA103')
        SD2->(DBSETORDER(4))
		If SD2->(Dbseek(xFilial('SD2')+SD1->D1_IDENTB6))
			If SD2->D2_LOCAL <> SD1->D1_LOCAL .and. SD1->D1_QUANT <> SD2->D2_QUANT
				dbSelectArea("SB8")
				dbSetOrder(3)
				If Rastro(SD1->D1_COD,"S")
					If Dbseek(xFilial("SB8")+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_LOTECTL+SD1->D1_NUMLOTE)
					   	If B8_QTDORI <> SD2->D2_QUANT
					   		Reclock("SB8",.F.)
							Replace B8_QTDORI 	With SD2->D2_QUANT
							Replace B8_QTDORI2	With SD2->D2_QTSEGUM
							MsUnlock()
					   	Endif
					EndIf
				ElseIf Rastro(SD1->D1_COD,"L")
					If Dbseek(xFilial("SB8")+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_LOTECTL)
					   	If B8_QTDORI <> SD2->D2_QUANT
					   		Reclock("SB8",.F.)
							Replace B8_QTDORI 	With SD2->D2_QUANT
							Replace B8_QTDORI2	With SD2->D2_QTSEGUM
							MsUnlock()
					   	Endif
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
EndIf

//Ŀ
//Grava campo referente a 2a. Unidade de Medida          
//
RecLock("SB2",.F.)
If Empty(SB1->B1_CONV) .And. !Empty(SD1->D1_QTSEGUM)
	REPLACE	B2_QTSEGUM WITH B2_QTSEGUM + SD1->D1_QTSEGUM * nMultiplic
ElseIf !Empty(SB1->B1_CONV)
	REPLACE B2_QTSEGUM WITH B2_QTSEGUM + SB1->(ConvUm(SB1->B1_COD,SD1->D1_QUANT,SD1->D1_QTSEGUM,2)* nMultiplic)
EndIf

// Verifica as divergencias entre a quantidade da primeira e da segunda UM
MatQtdZero(.T.,.F.,.T.)

REPLACE	B2_VATU1 WITH aVAtu[01]
REPLACE	B2_VATU2 WITH aVAtu[02]
REPLACE	B2_VATU3 WITH aVAtu[03]
REPLACE	B2_VATU4 WITH aVAtu[04]
REPLACE	B2_VATU5 WITH aVAtu[05]

aCM[01] := B2_CM1
aCM[02] := B2_CM2
aCM[03] := B2_CM3
aCM[04] := B2_CM4
aCM[05] := B2_CM5

If cPaisLoc == "BRA" .And. SF4->F4_BONIF == 'S' .and. QTDCOMP(SD1->D1_CUSTO,.t.)  = QTDCOMP(0) .and. nMultiplic = 1
	For nX := 1 to 5
		If QTDCOMP(aVAtu[nX],.t.) = qtdcomp(0)
			aCM[nX] := 0
		EndIf
	Next nX
EndIf  

For nX := 1 to 5
	If B2_QATU > 0 .And. aVAtu[nX] > 0
		aCM[nX] := CusRound(aVatu[nX]/B2_QATU,nX)
	EndIf
Next nX

REPLACE	B2_CM1 WITH aCM[01]
REPLACE	B2_CM2 WITH aCM[02]
REPLACE	B2_CM3 WITH aCM[03]
REPLACE	B2_CM4 WITH aCM[04]
REPLACE	B2_CM5 WITH aCM[05]

If SB2->(ColumnPos("B2_DMOV")) > 0
	REPLACE	B2_DMOV WITH dDataBase
EndIf

If SB2->(ColumnPos("B2_HMOV")) > 0
	REPLACE	B2_HMOV WITH Time()
EndIf

Set(3,nDec)

//Ŀ
//Atualiza o custo unificado ON-LINE                     
//
B2AtuUnif(SB2->B2_COD)

//Ŀ
//Atualiza o custo FIFO ON-LINE                          
//
B2AtuFIFO("SD1",nMultiplic)


//Ŀ
//Se houver integrao com outros softwares (Framework do SIGALOJA).
//
If  SuperGetMv("MV_LJGRINT",.F., .F.) == .T.
	oFactory := LJCAdapXmlEnvFactory():New( )	// Cria a fabrica de Adaptadores de envio
	oAdapter := oFactory:Create( "SB2" )

    oAdapter:Inserir( "SB2", xFilial( "SB2" ) + SB2->B2_COD + SB2->B2_LOCAL, "1", "4" )
    oAdapter:Gerar()
	oAdapter:Finalizar()
EndIf

//Ŀ
// MTAB2DIR - Ponto de entrada APOS execucao da funcao.  
//
If lMTAB2D1R
	ExecBlock("MTAB2D1R",.F.,.F.,{SD1->D1_COD, SD1->D1_LOCAL, nMultiplic})
EndIf

If lIntegPPI
	dbSelectArea("SOE")
	SOE->(dbSetOrder(1))
	If SOE->(dbSeek(xFilial("SOE")+"SB2")) .AND. Alltrim(SOE->OE_VAR1) == '1'
		MATA225PPI(SB2->B2_COD,;
					SB2->B2_LOCAL,;
		 			cLocaliz,;
		 			cNumSerie,;
		 			SD1->D1_LOTECTL,;
		 			SD1->D1_NUMLOTE,;
		 			IF(Empty(SD1->D1_DTVALID),SD1->D1_DTDIGIT + SB1->B1_PRVALID,SD1->D1_DTVALID),;
		 			SD1->D1_QUANT, ;
		 			if(nMultiplic<0,'2','1'),;
		 			SD1->D1_NUMSEQ,;
		 			SD1->D1_DOC, ;
		 			aPPIDelete)
	Endif
EndIf

Return

/*


Ŀ
Funo    B2AtuComD2 Autor  Eveli Morasco          Data  28/12/92 
Ĵ
Descrio  Atualiza o saldo final (VATU) com os dados do SD2          
Ĵ
Sintaxe    B2AtuComD2(ExpA1,ExpN1,ExpA2)                              
Ĵ
Parametros ExpA1 = Array com os custos gravados no SD2                
           ExpN1 = Expressao numerica indicando se movimentacao soma  
                   ou subtrai                                         
           ExpA2 = Array para atualizar SDC a partir do SC9           
                   Array aArraySC9                                    
                   1 Pedido                                           
                   2 Item do Pedido                                   
                   3 Seq. Liberacao                                   
                   4 Quantidade                                       
           ExpL1 = Expressao que indica se baixa empenho/reserva      
           ExpN2 = Forca a acao para tomar quando se apaga uma saida  
                   com localizacao fisica (Sobrepoe o parametro       
                   MV_PDEVLOC)                                        
           ExpC1 = Alias utilizado na baixa do empenho (MovLote)      
           ExpL2 = Inverte o Tipo de Entrada/Saida                    
           ExpL3 = Indica se a rotina e' chamada pelo modulo SIGALOJA 
           ExpC2 = Numero do pedido - reserva                         
           ExpC3 = Numero do item                                     
           ExpC4 = Numero da sequqencia                               
Ĵ
 Uso       Generico                                                   
ٱ


*/
FUNCTION B2AtuComD2(aCusto	, nMultiplic , aArraySC9, lBaixaEmp	,;
					nPdevLoc, cAliasBaixa, lInverte , lLoja		,;
					cParmPed, cParmItem	 , cParmSeq,lDtFabric, lRmOrdSep )

Static lMTAB2D2
Static lMTAB2D2R
Static lMTAATUD2
Static nDecCM1

Local nDec      := Set(3,8)
Local cChave    := SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD
Local lSeekSB1  := .F.
Local nSALDOSB2 := 0
Local nQtdeSC9  := 0
Local nX,aVAtu[05],aCM[05]
Local cD2VTes
Local cLocCQ	:= GetMvNNR('MV_CQ','98')
Local cPedido	:= ""					//Numero do pedido gerado pelo SIGALOJA (cdigo da reserva)
Local cItem		:= ""					//Codigo do item
Local cSeq		:= ""					//Codigo da sequencia
Local aSldAnt   := {}
Local aLogMov   := {}
Local lUsaD2DIG    :=  UsaD2DTDIG()
Local cEventID   := 0    // Variavel usada para armazenar o ID do EventViewer
Local cMensagem  := " " // Variavel para armazenar a mensagem utilizada no eventviewer
Local lIntegPPI  := PCPIntgPPI()
Local dB2_USAI	:= NIL

//Ŀ
// Variavel usada para identificar se usuario permite que o 
// estoque fique negativo. Se permitir, a variavel vale .T. 
//
Local lEstNeg   := IF(SuperGetMV("MV_ESTNEG",.F.,"N")=="S",.T.,.F.)
Local oFactory	:= Nil
Local oAdapter	:= Nil

Private aPPIDelete := {}

DEFAULT lInverte    := .F.
DEFAULT cAliasBaixa := "SC6"
DEFAULT lLoja		:= .F.
DEFAULT lDtFabric	:= .F.
DEFAULT cParmPed	:= ""
DEFAULT cParmItem	:= ""
DEFAULT cParmSeq	:= ""
DEFAULT lRmOrdSep	:= .F.


lMTAB2D2  := IIF(lMTAB2D2  == Nil,ExistBlock('MTAB2D2'),lMTAB2D2)
lMTAB2D2R := IIF(lMTAB2D2R  == Nil,ExistBlock('MTAB2D2R'),lMTAB2D2R)
lMTAATUD2 := IIF(lMTAATUD2  == Nil,ExistBlock('MTAATUD2'),lMTAATUD2)
nDecCM1   := IIF(nDecCM1  == Nil,TamSx3('B2_CM1') [2],nDecCM1)

cD2VTes := IIF(lInverte,"1"+Subs(SD2->D2_TES,2), SD2->D2_TES)

lBaixaEmp:=If(ValType(lBaixaEmp) == "L",lBaixaEmp,.T.)

If cD2VTes > "500"
	nMultiplic := IF(nMultiplic==NIL, -1, nMultiplic)
Else
	nMultiplic := 1
EndIf

//Ŀ
// Posiciona no produto a ser atualizado                 
// e atualiza a data de consumo inicial                  
//
dbSelectArea("SB1")
dbSetOrder(1)
lSeekSB1:=MsSeek(xFilial("SB1")+SD2->D2_COD+SD2->D2_LOCAL)
If lSeekSB1
	B2AtuConIn(nMultiplic,SD2->D2_EMISSAO)
EndIf

//Ŀ
// Ponto de Entrada Executado ANTES da atualizacao do SB2
//
If lMTAB2D2
	ExecBlock("MTAB2D2",.F.,.F.,{SD2->D2_COD, SD2->D2_LOCAL, nMultiplic})
EndIf

//Ŀ
// Chamada da LogMov para verificar o saldo antes da     |
//| atualizacao das tabelas SB2/SBF/SB8                   |
//
If Rastro(SD2->D2_COD) .Or. Localiza(SD2->D2_COD,.T.)
	LogMov('SD2',,,,,,lInverte,,,.T.,@aSldAnt)
EndIf

//Ŀ
// Posiciona no local a ser atualizado                   
//
dbSelectArea("SB2")
If xFilial("SB2")+SD2->D2_COD+SD2->D2_LOCAL <> SB2->B2_FILIAL+SB2->B2_COD+SB2->B2_LOCAL
	dbSetOrder(1)
	If !MsSeek(xFilial("SB2")+SD2->D2_COD+SD2->D2_LOCAL)
		//Ŀ
		// Se nao existir , ele cria                             
		//
		CriaSB2(SD2->D2_COD,SD2->D2_LOCAL)
	EndIf
EndIf
//Ŀ
// Aqui e' acertado o Saldo do Custo do Produto, quando  
// a movimentacao do SD2 zerar o Saldo em Estoque do Prd.
// Dev. de Compra nao tratada pois o custo Origem = Dev. 
//
If SD2->D2_TIPO <> "D" .And. QtdComp(SB2->B2_QATU+(SD2->D2_QUANT * nMultiplic)) == QtdComp(0) .AND.  Abs(aCusto[1]-SB2->B2_VATU1) <= 0.01
	aCusto[1] := Abs(SB2->B2_VATU1)
	aCusto[2] := Abs(SB2->B2_VATU2)
	aCusto[3] := Abs(SB2->B2_VATU3)
	aCusto[4] := Abs(SB2->B2_VATU4)
	aCusto[5] := Abs(SB2->B2_VATU5)
	RecLock("SD2")
	SD2->D2_CUSTO1 := aCusto[1]
	SD2->D2_CUSTO2 := aCusto[2]
	SD2->D2_CUSTO3 := aCusto[3]
	SD2->D2_CUSTO4 := aCusto[4]
	SD2->D2_CUSTO5 := aCusto[5]
	MsUnLock()
	dbSelectArea("SB2")
EndIf
RecLock("SB2",.F.)
aVAtu[01] := SB2->B2_VATU1 + aCusto[01] * nMultiplic
aVAtu[02] := SB2->B2_VATU2 + aCusto[02] * nMultiplic
aVAtu[03] := SB2->B2_VATU3 + aCusto[03] * nMultiplic
aVAtu[04] := SB2->B2_VATU4 + aCusto[04] * nMultiplic
aVAtu[05] := SB2->B2_VATU5 + aCusto[05] * nMultiplic

If (SB2->B2_QATU+(SD2->D2_QUANT * nMultiplic)) < 0
	//Ŀ
	// Envia e-mail ref. a SALDO NEGATIVO NO ESTOQUE - 002
	//
	If lSeekSB1
		//Ŀ
		// Messenger						  
		//
		MEnviaMail("002",{SB1->B1_COD,SB1->B1_DESC,SB2->B2_LOCAL,(B2_QATU + (SD2->D2_QUANT * nMultiplic)),lEstNeg})

		//Ŀ
		// EventViewer						  
		//
		cEventID  := "002"
		cMensagem := STR0261+SB1->B1_COD+" - "+SB1->B1_DESC //"O produto "###""
		cMensagem += STR0262+cValToChar(SB2->B2_QATU + (SD2->D2_QUANT * nMultiplic)) //" atingiu o saldo negativo de "###""
		cMensagem += STR0263+SB2->B2_LOCAL //" no almoxarifado "###""
		EventInsert( FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID, FW_EV_LEVEL_INFO, "", STR0265, cMensagem, .T. )
	EndIf
EndIf

//Ŀ
// Verifica se envia e-mail ref. PONTO DE PEDIDO - 001
//
If lSeekSB1 .And. !(SB2->B2_LOCAL == cLocCQ) .And. !Empty(RetFldProd(SB1->B1_COD,"B1_EMIN"))
	nSALDOSB2 := (SALDOSB2(,!lBaixaEmp,dDataBase))+SB2->B2_SALPEDI

	//Ŀ
	// Ponto de Entrada para validar saldo em TODOS os armazens
	//
	If lMTAATUD2
		nSALDOSB2 := ExecBlock('MTAATUD2',.F.,.F.)
		nSALDOSB2 := IIf(Valtype(nSALDOSB2) <> "N", 0, nSALDOSB2)
	EndIf

		If nSALDOSB2 <= RetFldProd(SB1->B1_COD,"B1_EMIN")
			dbSelectarea("SXI")
			dbsetorder(2)
			cEventID  := "001" //Ponto de pedido
		If msSeek('002' + '001' + cEventID)
			cMensagem:=STR0022+SB1->B1_COD+" - "+SB1->B1_DESC+STR0224	//"O produto "###" atingiu a quantidade de "
			cMensagem+= Str(nSALDOSB2)+' '+STR0005+SB2->B2_LOCAL+STR0225+ Str(RetFldProd(SB1->B1_COD,"B1_EMIN"))	//" (armazm "###"), abaixo do Ponto de Pedido de "
			EventInsert(FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID,FW_EV_LEVEL_INFO,""/*cCargo*/,STR0226,cMensagem,.T./*lPublic*/)
		Else
			MEnviaMail("001",{SB1->B1_COD,SB1->B1_DESC,SB2->B2_LOCAL,nSALDOSB2,RetFldProd(SB1->B1_COD,"B1_EMIN")})
		EndIf
	EndIf
EndIf

//Ŀ
// Verifica se envia e-mail ref. ESTOQUE MAXIMO  - 029
//
If lSeekSB1 .And. !Empty(RetFldProd(SB1->B1_COD,"B1_EMAX"))
	If (SB2->B2_QATU + (SD2->D2_QUANT * nMultiplic)) >= RetFldProd(SB1->B1_COD,"B1_EMAX")
		//Ŀ
		// EventViewer						  
		//
		cEventID	:= "029"
		cMensagem	:= OemToAnsi(STR0022) + SB1->B1_COD +" - "+ SB1->B1_DESC + OemToAnsi(STR0224) + CRLF //"O produto "###" atingiu a quantidade de "
		cMensagem	+= STR(SB2->B2_QATU + (SD2->D2_QUANT * nMultiplic)) + ' - ' + OemToAnsi(STR0005) + SB2->B2_LOCAL + OemToAnsi(STR0264) + STR(RetFldProd(SB1->B1_COD,"B1_EMAX")) //"Armazem  : ##, sendo que o produto tem como Estoque Maximo (B1_EMAX) de: "
		EventInsert(FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID,FW_EV_LEVEL_INFO,""/*cCargo*/,OemToAnsi(STR0010),cMensagem,.T./*lPublic*/)
		//Ŀ
		// Messenger						  
		//
		MEnviaMail("029",{SB1->B1_COD,SB1->B1_DESC,SB2->B2_LOCAL,(SB2->B2_QATU + (SD2->D2_QUANT * nMultiplic)),RetFldProd(SB1->B1_COD,"B1_EMAX")})
	EndIf
EndIf

//Ŀ
// Verifica se envia e-mail ref. LOTE MINIMO/QTDE EMBALAGEM  - 045
//
SG1->(DbSetOrder(1))
If SG1->(MsSeek(xFilial('SG1')+SB1->B1_COD))
	If lSeekSB1 .And. !Empty(RetFldProd(SB1->B1_COD,"B1_LM"))
		If (SB2->B2_QATU + (SD2->D2_QUANT * nMultiplic)) <= RetFldProd(SB1->B1_COD,"B1_LM")
			MEnviaMail("045",{SB1->B1_COD,SB1->B1_DESC,SB2->B2_LOCAL,(SB2->B2_QATU + (SD2->D2_QUANT * nMultiplic)),RetFldProd(SB1->B1_COD,"B1_LM")})
			cEventID  := "045"
			cMensagem := STR0261+SB1->B1_COD+" - "+SB1->B1_DESC //"O produto "###""
			cMensagem += STR0269+cValToChar(SB2->B2_QATU + (SD2->D2_QUANT * nMultiplic)) //" Abaixo da Quantidade por Embalagem do Produto "###""
			cMensagem += STR0263+SB2->B2_LOCAL //" no almoxarifado "###""
			EventInsert( FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID, FW_EV_LEVEL_INFO, "", STR0269, cMensagem, .T. )
		EndIf
	EndIf
Else
	If lSeekSB1 .And. !Empty(RetFldProd(SB1->B1_COD,"B1_QE"))
		If (SB2->B2_QATU + (SD2->D2_QUANT * nMultiplic)) <= RetFldProd(SB1->B1_COD,"B1_QE")
			MEnviaMail("045",{SB1->B1_COD,SB1->B1_DESC,SB2->B2_LOCAL,(SB2->B2_QATU + (SD2->D2_QUANT * nMultiplic)),RetFldProd(SB1->B1_COD,"B1_QE")})
			cEventID  := "045"
			cMensagem := STR0261+SB1->B1_COD+" - "+SB1->B1_DESC //"O produto "###""
			cMensagem += STR0270+cValToChar(SB2->B2_QATU + (SD2->D2_QUANT * nMultiplic)) //" Abaixo da Quantidade por Embalagem do Produto "###""
			cMensagem += STR0263+SB2->B2_LOCAL //" no almoxarifado "###""
			EventInsert( FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID, FW_EV_LEVEL_INFO, "", STR0270, cMensagem, .T. )
		EndIf
	Endif
EndIf

Replace SB2->B2_QATU With SB2->B2_QATU + (SD2->D2_QUANT * nMultiplic)

dB2_USAI := MaxSD2Emis(SD2->D2_COD, SD2->D2_LOCAL, SD2->D2_NUMSEQ, SD2->D2_EMISSAO, nMultiplic > 0 )

If ((nMultiplic <0) .AND. dB2_USAI > SB2->B2_USAI) .OR. (nMultiplic >0 .AND. dB2_USAI <> SB2->B2_USAI)
	Replace SB2->B2_USAI With dB2_USAI
EndIf

//Ŀ
// Movimenta Lotes/Sub-Lotes/Localizacao Fisica
//
If Rastro(SD2->D2_COD) .Or. Localiza(SD2->D2_COD, RetFldProd(SD2->D2_COD,"B5_CTRWMS") == "1")
	//Ŀ
	// Tratamento da gravacao do SD1 na Integridade Referencial            
	//
	If ValType(aArraySC9) == "A"
		nQtdeSC9 := 0
		For nx:=1 to Len(aArraySC9)
			MovLote("SD2",;					//1
					SD2->D2_COD,;			//2
					SD2->D2_LOCAL,;			//3
					NIL,;					//4
					NIL,;					//5
					SD2->D2_LOTECTL,;		//6
					SD2->D2_NUMLOTE,;		//7
					SD2->D2_NUMSEQ,;		//8
					If(lInverte,"499",cD2VTes),;	//9
					SD2->D2_CLIENTE,;		//10
					SD2->D2_LOJA,;			//11
					NIL,;					//12
					"NF",;					//13
					cChave,;				//14
					SD2->D2_DOC,;			//15
					SD2->D2_SERIE,;			//16
					NIL,;					//17
					NIL,;					//18
					aArraySC9[nx,1],;		//19
					aArraySC9[nx,2],;		//20
					aArraySC9[nx,3],;		//21
					aArraySC9[nx,4],;		//22
					ConvUm(SD2->D2_COD,aArraySC9[nx,4],aArraySC9[nx,5],2),;	//23
					IIf(lUsaD2DIG, SD2->D2_DTDIGIT, SD2->D2_EMISSAO),;		//24
					SD2->D2_DTVALID,;		//25
					lBaixaEmp,;				//26
					NIL,;					//27
					cD2VTes<="500",;		//28
					NIL,;					//29
					NIL,;					//30
					cAliasBaixa,;			//31
					.T.,;					//32
					NIL,;					//33
					NIL,;					//34
					NIL,;					//35
					NIL,;					//36
					NIL,;					//37
					NIL,;					//38
					NIL,;					//39
					NIL,;					//40
					NIL,;					//41
					NIL,;					//42
					NIL,;					//43
					NIL,;					//44
					NIL,;					//45
					NIL,;					//46
					NIL,;					//47
					NIL,;					//48
					NIL,;					//49
					NIL,;					//50
					nPDevLoc,;				//51
					NIL,;					//52
					NIL,;					//53
					NIL,;					//54
					NIL,;					//55
					aLogMov,;				//56
					NIL,;					//57
					NIl,;					//58
					NIL,;					//59
					NIL,;					//60
					NIL,;					//61
					lDtFabric,;				//62
					NIL,;					//63
					@lRmOrdSep )			//64

					nQtdeSC9 += aArraySC9[nx,4]
		Next nx
		LogMov('SD2',,,,,,lInverte,,,,aClone(aSldAnt),aClone(aLogMov),.T.,nQtdeSC9,SD2->D2_QUANT)
	Else

		If lLoja
			cPedido := cParmPed
			cItem	:= cParmItem
			cSeq	:= cParmSeq
		Else
			cPedido := NIL
			cItem	:= NIL
			cSeq	:= NIL
		endif

		MovLote("SD2",;					//1
				SD2->D2_COD,;			//2
				SD2->D2_LOCAL,;			//3
				If(cPaisloc<>"BRA" ,SD2->D2_LOCALIZ,If(!Empty(SD2->D2_LOCALIZ),SD2->D2_LOCALIZ,NIL)),;	//4
				If(cPaisloc<>"BRA" ,SD2->D2_NUMSERI,If(!Empty(SD2->D2_NUMSERI),SD2->D2_NUMSERI,NIL)),;	//5
				SD2->D2_LOTECTL,;		//6
				SD2->D2_NUMLOTE,;		//7
				SD2->D2_NUMSEQ,;		//8
				If(lInverte,"499",cD2VTes),;	//9
				SD2->D2_CLIENTE,;		//10
				SD2->D2_LOJA,;			//11
				NIL,;					//12
				"NF",;					//13
				cChave,;				//14
				SD2->D2_DOC,;			//15
				SD2->D2_SERIE,;			//16
				NIL,;					//17
				NIL,;					//18
				cPedido,;				//19
				cItem,;					//20
				cSeq,;					//21
				SD2->D2_QUANT,;			//22
				SD2->D2_QTSEGUM,;		//23
				IIf(lUsaD2DIG, SD2->D2_DTDIGIT, SD2->D2_EMISSAO),;		//24
				SD2->D2_DTVALID,;		//25
				lBaixaEmp,;				//26
				NIL,;					//27
				cD2VTes<="500",;		//28
				NIL,;					//29
				NIL,;					//30
				cAliasBaixa,;			//31
				.T.,;					//32
				NIL,;					//33
				NIL,;					//34
				NIL,;					//35
				NIL,;					//36
				NIL,;					//37
				NIL,;					//38
				NIL,;					//39
				NIL,;					//40
				NIL,;					//41
				NIL,;					//42
				NIL,;					//43
				NIL,;					//44
				NIL,;					//45
				NIL,;					//46
				NIL,;					//47
				NIL,;					//48
				NIL,;					//49
				NIL,;					//50
				nPDevLoc,;				//51
				NIL,;					//52
				NIL,;					//53
				NIL,;					//54
				NIL,;					//55
				aLogMov,;				//56
				NIL,;					//57
				NIl,;					//58
				NIL,;					//59
				NIL,;					//60
				NIL,;					//61
				lDtFabric,;				//62
				NIL,;					//63
				@lRmOrdSep )			//64

		LogMov('SD2',,,,,,lInverte,,,,aClone(aSldAnt),aClone(aLogMov),,0,SD2->D2_QUANT)
	EndIf
	//Ŀ
	// Baixa reserva                               
	//
Else
	If nMultiplic == -1 .And. lBaixaEmp
		GravaB2Emp("-",Min(SB2->B2_RESERVA,SD2->D2_QUANT),,.T., If( Empty( SD2->D2_QTSEGUM ),NIL,Min(SB2->B2_RESERV2,SD2->D2_QTSEGUM ) ) )
	EndIf
EndIf

RecLock("SB2",.F.)
If Empty(SB1->B1_CONV) .And. !Empty(SD2->D2_QTSEGUM)
	Replace	B2_QTSEGUM With B2_QTSEGUM + SD2->D2_QTSEGUM * nMultiplic
ElseIf !Empty(SB1->B1_CONV)
	Replace  B2_QTSEGUM With B2_QTSEGUM + (ConvUm(SB1->B1_COD,SD2->D2_QUANT,SD2->D2_QTSEGUM,2)* nMultiplic)
EndIf

// Verifica as divergencias entre a quantidade da primeira e da segunda UM
MatQtdZero(.T.,.F.,.T.)

Replace B2_VATU1   With aVAtu[01],B2_VATU2 With aVAtu[02],;
		B2_VATU3   With aVAtu[03],B2_VATU4 With aVAtu[04],;
		B2_VATU5   With aVAtu[05]

aCM[01] := B2_CM1
aCM[02] := B2_CM2
aCM[03] := B2_CM3
aCM[04] := B2_CM4
aCM[05] := B2_CM5

For nX := 1 to 5
	If B2_QATU > 0 .And. aVAtu[nX] > 0
		aCM[nX] := 	CusRound(aVatu[nX]/SB2->B2_QATU,nX)
	EndIf
Next nX

Replace	B2_CM1 With aCM[01],B2_CM2 With aCM[02],B2_CM3 With aCM[03],;
	B2_CM4 With aCM[04],B2_CM5 With aCM[05]

If SB2->(ColumnPos("B2_DMOV")) > 0
	REPLACE	B2_DMOV WITH dDataBase
EndIf

If SB2->(ColumnPos("B2_HMOV")) > 0
	REPLACE	B2_HMOV WITH Time()
EndIf

Set(3,nDec)

//Ŀ
//Atualiza o custo unificado ON-LINE                     
//
B2AtuUnif(SB2->B2_COD)

//Ŀ
//Atualiza o custo FIFO ON-LINE                          
//
B2AtuFIFO("SD2",nMultiplic)

//Ŀ
//Se houver integrao com outros softwares (Framework do SIGALOJA).
//
If  SuperGetMv("MV_LJGRINT",.F., .F.) == .T.
	oFactory := LJCAdapXmlEnvFactory():New( )	// Cria a fabrica de Adaptadores de envio
	oAdapter := oFactory:Create( "SB2" )

    oAdapter:Inserir( "SB2", xFilial( "SB2" ) + SB2->B2_COD + SB2->B2_LOCAL, "1", "4" )
    oAdapter:Gerar()
	oAdapter:Finalizar()
EndIf

//Ŀ
// MTAB2D2R - Ponto de entrada APOS execucao da funcao.  
//
If lMTAB2D2R
	ExecBlock("MTAB2D2R",.F.,.F.,{SD2->D2_COD, SD2->D2_LOCAL, nMultiplic})
EndIf
If lIntegPPI
	dbSelectArea("SOE")
	SOE->(dbSetOrder(1))
	If SOE->(dbSeek(xFilial("SOE")+"SB2")) .AND. Alltrim(SOE->OE_VAR2) == '1'
		MATA225PPI(SB2->B2_COD,;
					SB2->B2_LOCAL,;
					SD2->D2_LOCALIZ,;
					SD2->D2_NUMSERI,;
					SD2->D2_LOTECTL,;
					SD2->D2_NUMLOTE,;
					IF(Empty(SD2->D2_DTVALID),If(lUsaD2DIG, SD2->D2_DTDIGIT, SD2->D2_EMISSAO) + SB1->B1_PRVALID,SD2->D2_DTVALID),;
					SD2->D2_QUANT,;
					if(nMultiplic<0,'2','1'),;
					SD2->D2_NUMSEQ,;
					SD2->D2_DOC,;
					aPPIDelete)
	Endif
EndIf
Return

/*


Ŀ
Funo    B2AtuComD3 Autor  Eveli Morasco          Data  19/10/92 
Ĵ
Descrio  Atualiza o SB2 baseado no SD3                              
Ĵ
Sintaxe    B2AtuComD3(ExpA1,ExpC1,ExpL1,ExpL2)                        
Ĵ
Parametros ExpA1 = Array com os custos gravados no sd3                
           ExpC1 = Codigo do local padrao do processo , quando este   
                   parametro nao for passado significa que ele deve   
                   atualizar o local corrente.                        
           ExpL1 = Flag que indica se deve ser mostrado help ou nao   
           ExpL2 = Flag que indica se baixa empenho ou nao            
           ExpL3 = Flag que indica se gera devolucao ou nao           
           ExpL4 = Flag que indica se considera lotes vencidos        
           ExpC2 = cEstFis    - Estrutura Fisica          (APDL)      
           ExpC3 = cServico   - Servico                   (APDL)      
           ExpC4 = cTarefa    - Tarefa                    (APDL)      
           ExpC5 = cAtividade - Atividade                 (APDL)      
           ExpC6 = cAnomalia  - Houve Anomalia? (S/N)     (APDL)      
           ExpC7 = cEstDest   - Estrututa Fisica Destino  (APDL)      
           ExpC8 = cEndDest   - Endereco Destino          (APDL)      
           ExpC9 = cHrInicio  - Hora Inicio               (APDL)      
           ExpC10= cAtuEst    - Atualiza Estoque? (S/N)   (APDL)      
           ExpL5 = lPosSB8 - Restaura a Posicao do SB8 na chamada da  
                   da funcao MovLote()                                
           ExpC11= cCarga     - Numero da Carga           (APDL)      
           ExpC12= cUnitiza   - Numero do Unitizador      (APDL)      
           ExpC13= cOrdTar    - Ordem da Tarefa           (APDL)      
           ExpC14= cOrdAti    - Ordem da Atividade        (APDL)      
           ExpC15= cRHumano   - Recurso Humano            (APDL)      
           ExpC16= cRFisico   - Recurso Fisico            (APDL)      
           ExpL6 = Indica se confere saldo em estoque novamente       
           ExpC17= cLotePrd   - Lote do Produto                       
           ExpC18= cSubLotePrd- Sublote do Produto                    
           ExpC20= cLoteFor- Lote do Fornecedor                   (29)
           ExpC32= lConsSB2- Verifica esta consultando a Funcao    	  
           ExpC36= lQtdZero- Verifica se utiliza quantidade zerada    
Ĵ
 Uso       Generico                                                   
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.             
Ĵ
Programador  Data    BOPS   Motivo da Alteracao                     
Ĵ
Marcelo Pim.29/12/9701966AAjuste na validacao,qdo produto == "MOD"  
ٱ


*/
FUNCTION B2AtuComD3(aCusto,cLocProc,lShowHelp,lBaixaEmp,lGeraDev,lConsVenc,lBxEmpB8,cEstFis,cServico,cTarefa,cAtividade,cAnomalia,cEstDest,cEndDest,cHrInicio,cAtuEst,lPosSB8,cCarga,cUnitiza,cOrdTar,cOrdAti,cRHumano,cRFisico,lConfEst,cLotePrd,cSubLotePrd,cPerdaOP,aCustoFF,cLoteFor,cNumDesp,cOriLanc,lConsSB2,lDespCQ,dVencLote,lUsaB8Emp,lQtdZero,lLtVcCQ,lAtuLog)

Static lMTAB2D3
Static lMTAB2D3R
Static lMTAATUD3
Static nDecCM1

Local nX,aVatu[05],aCm[05],cLocal
Local cIndNeg 	:= SuperGetMv("MV_INDNEG",.F.,'E')
Local nDec		:= Set(3,8)
Local cHelp		:=""
Local cValue    :=""
Local lApropri  :=.F.
Local lSeekSB1	:=.F.
Local lCriaNew  :=.T.
Local lDistribui:=.T.
Local lRastro	:=.F.
Local lLocaliz	:=.F.
Local lProdMod	:=.F.
Local aTravas	:={}
Local aRet      :={}
Local aAreaSDA  :={}
Local aAreaSF5  :={}
Local nSaldo    :=0
Local Z 		:=0
Local nSALDOSB2 :=0
Local nMultiplic:=1
Local cLocCQ    := GetMvNNR('MV_CQ','98')
Local lMVPerdInf:=If(Type('lPerdInf')#"L",SuperGetMV('MV_PERDINF',.F.,.F.),lPerdInf)
Local cEventID   := 0    // Variavel usada para armazenar o ID do EventViewer
Local cMensagem  := " " // Variavel para armazenar a mensagem utilizada no eventviewer
Local aAreaSB2
Local lTpSaldo	:= SuperGetMV("MV_TPSALDO",.F.,"Q")  == "C"

//Ŀ
// Variavel usada para identificar se usuario permite que o 
// estoque fique negativo. Se permitir, a variavel vale .T. 
//
Local lEstNeg:=IF(SuperGetMV("MV_ESTNEG",.F.,"N")=="S",.T.,.F.)

//Ŀ
// Variavel utilizada quando nao mostra o HELP e gera Log	 
//
Local lLog		:=.F.
Local aSavSD4	:= {SD4->(IndexOrd()), SD4->(RecNo())}
Local nBxSD4  	:= 0
Local nBxSD42UM := 0
Local aSldAnt   :={}
Local aLogMov   :={}
Local cSeek		:= ""
Local oFactory	:= Nil
Local oAdapter	:= Nil
Local nRecSB2   := 0
Local lCusUNIF2	:= AllTrim(SuperGetMv("MV_CUSMED",.F.,"M"))=="O" .AND. (AllTrim(SuperGetMv('MV_CUSFIL',.F.,"A")) == "E" .or. AllTrim(SuperGetMv('MV_CUSFIL',.F.,"A")) == "F")
//Ŀ
// MV_TMPRV - parametro utilizado na integtracao do template
// DCL_EST com Estoque, contem a TM de movimentacao interna.
//
Local cTmDCL	:= SuperGetMv('MV_TMPRV',.F.,'')
Local oSaldoADis	:= Nil
Local lWmsNew		:= SuperGetMv("MV_WMSNEW",.F.,.F.)
Local lWmsSD3		:= If(!(Type('lExecWms')=='U'), lExecWms, .F.)
Local lIntegPPI  := PCPIntgPPI()
Local lParcial	:= .F.
Local cDtEst	:= ''
Local cSeqSBD	:= ''
Local nSldPP    := 0
Local nSldPre   := 0
Local aRetSA    := {}
Static nDecCM1 := Nil

Default lConfEst   := .T.
Default cLoteFor   := ""
Default cLotePrd   := ""
Default cSubLotePrd:= ""
Default aCustoFF   := {0,0,0,0,0}
Default cNumDesp   := ""
Default cOriLanc   := ""
Default lConsSB2   := .T.
Default lDespCQ    := .F.
Default lUsaB8Emp  := .F.
Default lQtdZero   := .F.
Private aPPIDelete := {}

Default lLtVcCQ    := NIL
Default lAtuLog    := .T.

//Ŀ
// Preenche parametros nao recebidos pela funcao         
//
lShowHelp	:=If(lShowHelp==NIL,.T.,lShowHelp)
lBaixaEmp	:=If(lBaixaEmp==NIL,.F.,lBaixaEmp)
lBxEmpB8 	:=If(lBxEmpB8== NIL,lBaixaEmp,lBxEmpB8)
lGeraDev 	:=If(lGeraDev==NIL,.F.,lGeraDev)
lConsVenc	:=If(lConsVenc== NIL,SUPERGETMV("MV_LOTVENC",.T.,"N") == "S",lConsVenc)
cEstFis   	:=If(cEstFis==Nil,'',cEstFis)
cServico  	:=If(cServico==Nil,'',cServico)
cTarefa   	:=If(cTarefa==Nil,'',cTarefa)
cAtividade	:=If(cAtividade==Nil,'',cAtividade)
cAnomalia 	:=If(cAnomalia==Nil,'',cAnomalia)
cEstDest  	:=If(cEstDest==Nil,'',cEstDest)
cEndDest  	:=If(cEndDest==Nil,'',cEndDest)
cHrInicio 	:=If(cHrInicio==Nil,'',cHrInicio)
cAtuEst   	:=If(cAtuEst==Nil,'',cAtuEst)
lPosSB8   	:=If(Valtype(lPosSB8)=="L",lPosSB8,.T.)
cCarga    	:=If(cCarga==Nil,'',cCarga)
cUnitiza  	:=If(cUnitiza==Nil,'',cUnitiza)
cOrdTar   	:=If(cOrdTar==Nil,'',cOrdTar)
cOrdAti   	:=If(cOrdAti==Nil,'',cOrdAti)
cRHumano  	:=If(cRHumano==Nil,'',cRHumano)
cRFisico  	:=If(cRFisico==Nil,'',cRFisico)
l185        :=If(Type("l185") == "L",l185,.F.)
lMTAB2D3	:= IIF(lMTAB2D3  == Nil,ExistBlock('MTAB2D3'),lMTAB2D3)
lMTAB2D3R	:= IIF(lMTAB2D3R == Nil,ExistBlock('MTAB2D3R'),lMTAB2D3R)
lMTAATUD3	:= IIF(lMTAATUD3 == Nil,ExistBlock('MTAATUD3'),lMTAATUD3)
nDecCM1  	:= IIF(nDecCM1   == Nil,TamSx3('B2_CM1') [2],nDecCM1)

lRastro    := Rastro(SD3->D3_COD)
lLocaliz   := Localiza(SD3->D3_COD)
lProdMod   := IsProdMod(SD3->D3_COD)

If (SD3->D3_TM > "500" .And. cLocProc == NIL) .Or. (SD3->D3_TM <= "500" .And. cLocProc != NIL)
	nMultiplic := -1
EndIf

//Ŀ
// Se for movimento de material indireto ele deve atualizar 
// o local padrao do processo passado como parametro        
//
If cLocProc == NIL
	cLocal := SD3->D3_LOCAL
Else
	cLocal := cLocProc
	lApropri:=.T.
EndIf

//Ŀ
// Ponto de Entrada Executado ANTES da atualizacao do SB2
//
If lMTAB2D3
	ExecBlock("MTAB2D3",.F.,.F.,{SD3->D3_COD, cLocal, nMultiplic})
EndIf

//Ŀ
// Chamada da LogMov para verificar o saldo antes da     |
//| atualizacao das tabelas SB2/SBF/SB8                   |
//
If lRastro .Or. lLocaliz
	LogMov('SD3',,,,,,,,,.T.,@aSldAnt)
EndIf

//Ŀ
// Posiciona no local a ser atualizado                   
//
dbSelectArea("SB2")
dbSetOrder(1)
If ( !MsSeek(xFilial("SB2")+SD3->D3_COD+cLocal) )
	CriaSB2(SD3->D3_COD,cLocal)
EndIf
lLog:=!(RecLock("SB2",.F.))

//Ŀ
// Valida saldo qdo movimento for de requisicao             
//
If !lQtdZero .And. !lWmsSD3 .And.!lLog .And. lConfEst .And. nMultiplic == -1 .And. !(SD3->D3_CF $ "RE1/ER0") .And. ;
	((lRastro .And. !Empty(SD3->D3_LOTECTL+SD3->D3_NUMLOTE))     .Or.  ;
	 (lLocaliz .And. !Empty(SD3->D3_LOCALIZ+SD3->D3_NUMSERI))     .Or.  ;
	 (!lEstNeg .And. !lProdMod))

	//Ŀ
	// Obtem saldo por lote e /ou localizacao                
	//
	If (lRastro .And. !Empty(SD3->D3_LOTECTL+SD3->D3_NUMLOTE)) .Or. (lLocaliz .And. !Empty(SD3->D3_LOCALIZ+SD3->D3_NUMSERI))
		nSaldo:=0
		//Ŀ
		// Pesquisa saldo a distribuir pendente                  
		//
		If Localiza(SD3->D3_COD,.T.)
			If !(lWmsNew .And. IntDl(SD3->D3_COD))
				aAreaSDA:=SDA->(GetArea())
				SDA->(dbSetOrder(1))
				If SDA->(dbSeek(xFilial("SDA")+SD3->D3_COD+cLocal+SD3->D3_NUMSEQ+SD3->D3_DOC))
					nSaldo+=SDA->DA_SALDO
				EndIf
				Restarea(aAreaSDA)
			Else
				oSaldoADis := WMSDTCSaldoADistribuir():New()
				nSaldo := oSaldoADis:WmsVldEst(cLocal,SD3->D3_COD,SD3->D3_DOC,SD3->D3_NUMSERI,Nil,Nil,SD3->D3_NUMSEQ)
			EndIf
		EndIf
		If Type("lRunPPI")=="L" .And. lRunPPI
			aRet :=SldPorLote(SD3->D3_COD,cLocal,SD3->D3_QUANT,SD3->D3_QTSEGUM,SD3->D3_LOTECTL,SD3->D3_NUMLOTE,SD3->D3_LOCALIZ,SD3->D3_NUMSERI,@aTravas,lBxEmpb8,NIL,lConsVenc,NIL,NIL,If(SD3->D3_ESTORNO == "S", Nil,SD3->D3_EMISSAO),,IIf(lMVPerdInf,cPerdaOP,Nil),.T.)
		Else
			aRet :=SldPorLote(SD3->D3_COD,cLocal,SD3->D3_QUANT,SD3->D3_QTSEGUM,SD3->D3_LOTECTL,SD3->D3_NUMLOTE,SD3->D3_LOCALIZ,SD3->D3_NUMSERI,@aTravas,lBxEmpb8,NIL,lConsVenc,NIL,NIL,If(SD3->D3_ESTORNO == "S", Nil,SD3->D3_EMISSAO),,IIf(lMVPerdInf,cPerdaOP,Nil),lLtVcCQ)
		EndIf

		For nx:=1 to Len(aRet)
			If lRastro
				If Len(aRet[nx,10]) > 0
					For z:=1 to Len(aRet[nx,10])
						nSaldo+=aRet[nx,10,z,2]
					Next z
				Else
					Exit
				EndIf
			Else
				nSaldo+=aRet[nx,5]
			EndIf
		Next i
		//Ŀ
		// Obtem saldo em estoque                                
		//
	Else
		//Ŀ
		// Posiciona no local a ser pesquisado                   
		//
		dbSelectArea("SB2")
		dbSetOrder(1)
		If (!MsSeek(xFilial("SB2")+SD3->D3_COD+cLocal))
			CriaSB2(SD3->D3_COD,cLocal)
		EndIf

		//Ŀ
		// Tratamento para considerar o saldo do movimento j includo quanto utilizada funo CalcEst para clculo do saldo em estoque
		//
	   	If lTpSaldo
			nSaldo := CalcEst(SD3->D3_COD,SD3->D3_LOCAL,SD3->D3_EMISSAO+1)[1]
			nSaldo += IIf(SD3->D3_TM > "499",SD3->D3_QUANT,( - SD3->D3_QUANT * nMultiplic) )
	  	Else
			nSaldo := SB2->B2_QATU
	  	EndIf
	EndIf

	SB1->(dbSeek(xFilial("SB1")+SB2->B2_COD))
	//Ŀ
	// Verifica se devera validar qtde. disponivel em Estoque  
	//
	If QtdComp(nSaldo,.T.)  < QtdComp(SD3->D3_QUANT,.T.) .And.((cIndNeg == "N" .And. SB1->B1_APROPRI == "I").Or. (cIndNeg == "E" .And. !lEstNeg .And. SB1->B1_APROPRI == "I") .Or. ((!lEstNeg .or. lRastro .or. lLocaliz).And. SB1->B1_APROPRI != "I"))
		If lRastro
			Help(" ",1,"A240LOTENE")
			Return .T.
		ElseIf lLocaliz
			Help(" ",1,"SALDOLOCLZ")
			Return .T.
		ElseIf lShowHelp
			cValue:=Transform((SB2->B2_QATU+(SD3->D3_QUANT * nMultiplic)),PesqPictQt("B2_QATU",14))
			cHelp:=AllTrim(SB2->B2_COD)+"/"+SB2->B2_LOCAL+STR0001+ALLTRIM(cValue)+")."	//", Saldo: "
			If ( Type("l103Auto") == "U" .Or. !l103Auto )
	  			Help ( " ", 1, "MVESTNEG",,cHelp,3,1)
			EndIf
		EndIf
		//Ŀ
		// Remove travas dos registros utilizados                  
		//
		MaDesTrava(aTravas)
		//Ŀ
		// Apaga registro no SD3 para invalidar movimento          
		//
		Reclock("SD3",.F.)
		dbDelete()
		MsUnlock()
		lLog:=.T.
		dbSelectArea("SB2")
		MsUnlock()
	EndIf
ElseIf lLog
	//Ŀ
	// Apaga registro no SD3 para invalidar movimento          
	//
	Reclock("SD3",.F.)
	dbDelete()
	MsUnlock()
EndIf

//Ŀ
// Valida se tem saldo disponivel                        
//
If !lLog
	//Ŀ
	// Posiciona no produto a ser atualizado                 
	// e atualiza a data de consumo inicial                  
	//
	dbSelectArea("SB1")
	dbSetOrder(1)
	lSeekSB1:=dbSeek(xFilial("SB1")+SD3->D3_COD+cLocal)
	If lSeekSB1 .And. !(SD3->D3_ESTORNO == "S")
		B2AtuConIn(nMultiplic,SD3->D3_EMISSAO)
	EndIf
	dbSelectArea("SB2")
	if lCusUNIF2		// Custo unificado no dever tratar seo abaixo qdo zerar o saldo de um deposito apenas.
		nRecSB2 := SB2->(Recno())
		nQtdeAtu := 0
		dbSeek(xFilial("SB2")+SD3->D3_COD)
		while !SB2->(EOF()) .And. SB2->B2_COD == SD3->D3_COD
		  nQtdeAtu += SB2->B2_QATU
		  SB2->(dbSkip())
		EndDO
		lZeraSLD := Iif(nQtdeAtu = 0,.T.,.F.)
		SB2->(Dbgoto(nRecSB2))
	Else
		lZeraSLD := QtdComp(B2_QATU+(SD3->D3_QUANT * nMultiplic),.t.) == QtdComp(0)
		lParcial := Iif (lProdMod,QtdComp(B2_QATU  * nMultiplic,.t.) < QtdComp(SD3->D3_QUANT * nMultiplic,.t.) .And. QtdComp(B2_VATU1,.t.) == QtdComp(0),.F.)
	EndIf

	//Ŀ
	// Aqui e' acertado o Saldo do Custo do Produto, quando  
	// a movimentacao do SD3 zerar o Saldo em Estoque do Prd.
	//
	If AllTrim(cTmDCL)#AllTrim(SD3->D3_TM) .And. ;
	   QtdComp(SD3->D3_QUANT,.t.) > QtdComp(0) .And. (lZeraSLD .oR. lParcial) .And. (SD3->D3_ESTORNO <> "S" .And. SD3->D3_CF <> 'DE0') .And. ;
	   ( !(SD3->D3_CF$"DE4|DE5|RE5|DE6|RE6|DE7|RE8|DE8|PR0|PR1|ER0|ER1") .Or. (cOriLanc $ 'CP|TR' .and. SD3->D3_CF $ 'RE6' .and. !lDespCQ)) .And.;
	   cLocal # cLocCQ
		aCusto[1] := Abs(B2_VATU1)
		aCusto[2] := Abs(B2_VATU2)
		aCusto[3] := Abs(B2_VATU3)
		aCusto[4] := Abs(B2_VATU4)
		aCusto[5] := Abs(B2_VATU5)
		RecLock("SD3")
		SD3->D3_CUSTO1 := aCusto[1]
		SD3->D3_CUSTO2 := aCusto[2]
		SD3->D3_CUSTO3 := aCusto[3]
		SD3->D3_CUSTO4 := aCusto[4]
		SD3->D3_CUSTO5 := aCusto[5]
		MsUnLock()
		dbSelectArea("SB2")
	EndIf

	aVAtu[01] := B2_VATU1 + aCusto[01] * nMultiplic
	aVAtu[02] := B2_VATU2 + aCusto[02] * nMultiplic
	aVAtu[03] := B2_VATU3 + aCusto[03] * nMultiplic
	aVAtu[04] := B2_VATU4 + aCusto[04] * nMultiplic
	aVAtu[05] := B2_VATU5 + aCusto[05] * nMultiplic

	//Ŀ
	// Tratamento para considerar o saldo do movimento j includo quanto utilizada funo CalcEst para clculo do saldo em estoque
	//
   	If lTpSaldo
		nSaldo := CalcEst(SD3->D3_COD,SD3->D3_LOCAL,SD3->D3_EMISSAO+1)[1]
		nSaldo += IIf(SD3->D3_TM > "499",SD3->D3_QUANT,( - SD3->D3_QUANT * nMultiplic) )
  	Else
		nSaldo := SB2->B2_QATU
  	EndIf

	If (nSaldo+(SD3->D3_QUANT * nMultiplic)) < 0

		If lAtuLog //DMANSMARTSQUAD1-26905
			If (!lEstNeg .And. SB1->B1_APROPRI !="I" .And. !lProdMod).Or. ((cIndNeg == "N" .And. SB1->B1_APROPRI == "I") .Or. (cIndNeg == "E" .And. SB1->B1_APROPRI == "I" .And. !lEstNeg .AND. !lProdMod))
				If lShowHelp
					cValue:=Transform((B2_QATU+(SD3->D3_QUANT * nMultiplic)),PesqPictQt("B2_QATU",14))
					cHelp:=AllTrim(B2_COD)+"/"+B2_LOCAL+STR0001+ALLTRIM(cValue)+")."	//", Saldo: "
					If ( Type("l103Auto") == "U" .Or. !l103Auto )
						Help ( " ", 1, "MVESTNEG",,cHelp,3,1)
					EndIf
				EndIf
				lLog:=.T.
			EndIf
		EndIf
		
		//Ŀ
		// Envia e-mail ref. a SALDO NEGATIVO NO ESTOQUE - 002
		//
		If lSeekSB1
			//Ŀ
			// Messenger						  
			//
			MEnviaMail("002",{SB1->B1_COD,SB1->B1_DESC,SB2->B2_LOCAL,(B2_QATU + (SD3->D3_QUANT * nMultiplic)),lEstNeg})

			//Ŀ
			// EventViewer						  
			//
			cEventID  := "002"
			cMensagem := STR0261+SB1->B1_COD+" - "+SB1->B1_DESC //"O produto "###""
			cMensagem += STR0262+cValToChar(SB2->B2_QATU + (SD3->D3_QUANT * nMultiplic)) //" atingiu o saldo negativo de "###""
			cMensagem += STR0263+SB2->B2_LOCAL //" no almoxarifado "###""
			EventInsert( FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID, FW_EV_LEVEL_INFO, "", STR0265, cMensagem, .T. )
		EndIf
	EndIf

	//Ŀ
	// Verifica se envia e-mail ref. PONTO DE PEDIDO - 001
	//
	If lSeekSB1 .And. !(SB2->B2_LOCAL == cLocCQ) .And. !Empty(RetFldProd(SB1->B1_COD,"B1_EMIN"))
		nSALDOSB2 := (SALDOSB2(.T.,!lBaixaEmp,dDataBase))+SB2->B2_SALPEDI+SB2->B2_QACLASS

		//Ŀ
		// Ponto de Entrada para validar saldo em TODOS os armazens
		//
		If lMTAATUD3
			nSALDOSB2 := ExecBlock('MTAATUD3',.F.,.F.)
			nSALDOSB2 := IIf(Valtype(nSALDOSB2) <> "N", 0, nSALDOSB2)
		EndIf

		If !l185
			nSldPP := (nSALDOSB2 + (SD3->D3_QUANT * nMultiplic))
		Elseif l240
			If nMultiplic < 0
				DbSelectArea("SCQ")
				aRetSA := ca100RetCQ(SCP->CP_NUM,SCP->CP_ITEM)
				nSldPre:= aRetSA[2] - SD3->D3_QUANT
			EndIf
			nSldPP := (nSALDOSB2 + IIf(nMultiplic < 0,IIf(nSldPre < 0, nSldPre, 0),0))
		Else
			nSldPP := (nSALDOSB2 + IIf(nMultiplic < 0,IIf(SD3->D3_QUANT < SCP->CP_QUANT, SD3->D3_QUANT, SCP->CP_QUANT) * nMultiplic,0))
		EndIf

		If nSldPP <= RetFldProd(SB1->B1_COD,"B1_EMIN")
			dbSelectarea("SXI")
			dbsetorder(2)
			cEventID  := "001" //Ponto de pedido
			If msSeek('002' + '001' + cEventID)
				cMensagem:=STR0022+SB1->B1_COD+" - "+SB1->B1_DESC+STR0224	//"O produto "###" atingiu a quantidade de "
				cMensagem+= Str(nSldPP)+' '+STR0005+SB2->B2_LOCAL+STR0225+ Str(RetFldProd(SB1->B1_COD,"B1_EMIN"))	//" (armazm "###"), abaixo do Ponto de Pedido de "
				EventInsert(FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID,FW_EV_LEVEL_INFO,""/*cCargo*/,STR0226,cMensagem,.T./*lPublic*/)
			Else
				MEnviaMail("001",{SB1->B1_COD,SB1->B1_DESC,SB2->B2_LOCAL,nSldPP,RetFldProd(SB1->B1_COD,"B1_EMIN")})
			EndIf
		EndIf
	EndIf

	//Ŀ
	// Verifica se envia e-mail ref. ESTOQUE MAXIMO  - 029
	//
	If lSeekSB1 .And. !Empty(RetFldProd(SB1->B1_COD,"B1_EMAX"))
		If (SB2->B2_QATU + (SD3->D3_QUANT * nMultiplic)) >= RetFldProd(SB1->B1_COD,"B1_EMAX")
			//Ŀ
			// EventViewer						  
			//
			cEventID	:= "029"
			cMensagem	:= OemToAnsi(STR0022) + SB1->B1_COD +" - "+ SB1->B1_DESC + OemToAnsi(STR0224) + CRLF //"O produto "###" atingiu a quantidade de "
			cMensagem	+= STR(SB2->B2_QATU + (SD3->D3_QUANT * nMultiplic)) + ' - ' + OemToAnsi(STR0005) + SB2->B2_LOCAL + OemToAnsi(STR0264) + STR(RetFldProd(SB1->B1_COD,"B1_EMAX")) //"Armazem  : ##, sendo que o produto tem como Estoque Maximo (B1_EMAX) de: "
			EventInsert(FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID,FW_EV_LEVEL_INFO,""/*cCargo*/,OemToAnsi(STR0010),cMensagem,.T./*lPublic*/)
			//Ŀ
			// Messenger						  
			//
			MEnviaMail("029",{SB1->B1_COD,SB1->B1_DESC,SB2->B2_LOCAL,(SB2->B2_QATU + (SD3->D3_QUANT * nMultiplic)),RetFldProd(SB1->B1_COD,"B1_EMAX")})
		EndIf
	EndIf

	//Ŀ
	// Verifica se envia e-mail ref. LOTE MINIMO/QTDE EMBALAGEM  - 045
	//
	SG1->(DbSetOrder(1))
	If SG1->(DbSeek(xFilial('SG1')+SB1->B1_COD))
		If lSeekSB1 .And. !Empty(RetFldProd(SB1->B1_COD,"B1_LM"))
			If (SB2->B2_QATU + (SD3->D3_QUANT * nMultiplic)) <= RetFldProd(SB1->B1_COD,"B1_LM")
				MEnviaMail("045",{SB1->B1_COD,SB1->B1_DESC,SB2->B2_LOCAL,(SB2->B2_QATU + (SD3->D3_QUANT * nMultiplic)),RetFldProd(SB1->B1_COD,"B1_LM")})
				cEventID  := "045"
				cMensagem := STR0261+SB1->B1_COD+" - "+SB1->B1_DESC //"O produto "###""
				cMensagem += STR0269+cValToChar(SB2->B2_QATU + (SD3->D3_QUANT * nMultiplic)) //" Abaixo do Lote Minimo do Produto "###""
				cMensagem += STR0263+SB2->B2_LOCAL //" no almoxarifado "###""
				EventInsert( FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID, FW_EV_LEVEL_INFO, "", STR0270, cMensagem, .T. )
			EndIf
		EndIf
	Else
		If lSeekSB1 .And. !Empty(RetFldProd(SB1->B1_COD,"B1_QE"))
			If (SB2->B2_QATU + (SD3->D3_QUANT * nMultiplic)) <= RetFldProd(SB1->B1_COD,"B1_QE")
				MEnviaMail("045",{SB1->B1_COD,SB1->B1_DESC,SB2->B2_LOCAL,(SB2->B2_QATU + (SD3->D3_QUANT * nMultiplic)),RetFldProd(SB1->B1_COD,"B1_QE")})
				cEventID  := "045"
				cMensagem := STR0261+SB1->B1_COD+" - "+SB1->B1_DESC //"O produto "###""
				cMensagem += STR0270+cValToChar(SB2->B2_QATU + (SD3->D3_QUANT * nMultiplic)) //" Abaixo da Quantidade por Embalagem do Produto "###""
				cMensagem += STR0263+SB2->B2_LOCAL //" no almoxarifado "###""
				EventInsert( FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID, FW_EV_LEVEL_INFO, "", STR0270, cMensagem, .T. )
			EndIf
		Endif
	EndIf

	Replace  SB2->B2_QATU    With SB2->B2_QATU    + (SD3->D3_QUANT   * nMultiplic)

	//Ŀ
	// Movimenta Lotes/Sub-Lotes/Localizacao Fisica
	//
	If lRastro .Or. lLocaliz
		//Ŀ
		// Tratamento da gravacao do SD1 na Integridade Referencial            
		//
		SD3->(FkCommit())
		lCriaNew:=lGeraDev .Or. nMultiplic == 1
		lDistribui:=Substr(SD3->D3_CF,1,1) $ "DP"
		aAreaSF5:=SF5->(GetArea())
		SF5->(dbSetOrder(1))
		If SF5->(dbSeek(xFilial("SF5")+SD3->D3_TM))
			lCriaNew:=lGeraDev .Or. nMultiplic == 1
			If nMultiplic == 1 .And. SF5->F5_TIPO == "P" .And. SD3->D3_CF=="PR1"
				lDistribui:=.F.
			EndIf
		EndIf
		SF5->(Restarea(aAreaSF5))

		cOpOrig := nil
		If lUsaB8Emp
			cOpOrig := SD4->D4_OPORIG
		EndIf

		MovLote("SD3",;				//1
				SD3->D3_COD,;		//2
				cLocal,;			//3
				If(SD3->D3_CF == "DE3" .And. SD3->D3_ESTORNO # "S" .And. lConsSB2,"",SD3->D3_LOCALIZ),;	//4
				If(SD3->D3_CF == "DE3" .And. SD3->D3_ESTORNO # "S","",SD3->D3_NUMSERI),;	//5
				SD3->D3_LOTECTL,;	//6
				SD3->D3_NUMLOTE,;	//7
				SD3->D3_NUMSEQ,;	//8
				SD3->D3_TM,;		//9
				NIL,;				//10
				NIL,;				//11
				cLoteFor,;			//12
				"MI",;				//13
				NIL,;				//14
				SD3->D3_DOC,;		//15
				NIL,;				//16
				SD3->D3_OP,;		//17
				If(IsInCallStack('MATA250') .OR. lBaixaEmp, If(!Empty(SD3->D3_TRT),SD3->D3_TRT,If(SD3->D3_COD == SD4->D4_COD, SD4->D4_TRT,SD3->D3_TRT)),NIL),;//18
				NIL,;				//19
				NIL,;				//20
				NIL,;				//21
				SD3->D3_QUANT,;		//22
				SD3->D3_QTSEGUM,;	//23
				SD3->D3_EMISSAO,;	//24
				SD3->D3_DTVALID,;	//25
				lBaixaEmp,;			//26
				lApropri,;			//27
				SD3->D3_ESTORNO == "S",;//28
				lCriaNew,;			//29
				lDistribui,;      	//30
				NIL,;				//31
				lConsVenc,;			//32
				lBxEmpB8,;			//33
				cEstFis,;			//34
				cServico,;			//35
				cTarefa,;			//36
				cAtividade,;		//37
				cAnomalia,;			//38
				cEstDest,;			//39
				cEndDest,;			//40
				cHrInicio,;			//41
				cAtuEst,; 			//42
				lPosSB8,;			//43
				cCarga,;			//44
				cUnitiza,;			//45
				cOrdTar,;			//46
				cOrdAti,;			//47
				cRHumano,;			//48
				cRFisico,;			//49
				SD3->D3_POTENCI,;	//50
				Nil,;				//51
				lGeraDev,; 			//52
				cLotePrd,; 			//53
				cSubLotePrd,; 		//54
				cPerdaOP,;			//55
				aLogMov,;           //56
				Iif(!Empty(DTOS(SB8->B8_DFABRIC)) .and. SD3->D3_CF # "PR0", SB8->B8_DFABRIC, Nil),; //57
				cNumDesp,; 			//58
				NIL,;				//59
				dVencLote,; //60
				lUsaB8Emp,; //61
				nil,; //62
				nil,; //63
				nil,; //64
				cOpOrig) //65

		LogMov('SD3',,,,,,,,,,aClone(aSldAnt),aClone(aLogMov),,0,SD3->D3_QUANT)
	Else
		If lBaixaEmp
			If !(Substr(SD3->D3_CF,3,1) $ "129" )
				SD4->(dbSetOrder(1))  // D4_FILIAL+D4_COD+D4_OP+D4_TRT+D4_LOTECTL+D4_NUMLOTE
				SD4->(dbSeek(cSeek := xFilial("SD4") + SD3->D3_COD + SD3->D3_OP + SD3->D3_TRT + SD3->D3_LOTECTL + SD3->D3_NUMLOTE))
				While ! SD4->(Eof()) .And. cSeek == SD4->(D4_FILIAL+D4_COD+D4_OP+D4_TRT+D4_LOTECTL+D4_NUMLOTE)
					If lGeraDev
						nBxSD4 += If(nMultiplic == 1, ABS(SD4->D4_QUANT) , ABS(SD4->D4_QTDEORI - SD4->D4_QUANT))
					Else
						nBxSD4 += If(nMultiplic == 1, SD4->D4_QTDEORI - SD4->D4_QUANT, SD4->D4_QUANT)
					EndIf
					SD4->(dbSkip())
				Enddo
				nBxSD4 := Min(SD3->D3_QUANT,If(nBxSD4<0,0,nBxSD4))
				nBxSD42UM := Min(SD3->D3_QTSEGUM, If(nBxSD42UM<0,0,ConvUM(SD3->D3_COD,nBxSD4,SD3->D3_QTSEGUM,2)))
				SD4->(dbSetOrder(aSavSD4[1]))
				SD4->(dbGoto(aSavSD4[2]))
			Else
				nBxSD4    := SD3->D3_QUANT
				nBxSD42UM := SD3->D3_QTSEGUM
			EndIf
			If !Empty(nBxSD4)
				If SD3->D3_QTMAIOR > 0
					nBxSD4 := Max(nBxSD4 - SD3->D3_QTMAIOR,0)
				EndIf
				If lGeraDev
					If nMultiplic == -1
						GravaB2Pre("+",nBxSD4,"F",,nBxSD42UM)
					ElseIf nMultiplic == 1 .And. SB2->B2_SALPEDI > 0
						GravaB2Pre("-",Min(SB2->B2_SALPEDI,nBxSD4),"F",,Min(SB2->B2_QEMP2,nBxSD42UM))
					EndIf
				Else
					If nMultiplic == -1  .And. SB2->B2_QEMP > 0
						GravaB2Emp("-",Min(SB2->B2_QEMP,nBxSD4),"F",,Min(SB2->B2_QEMP2,nBxSD42UM))
					ElseIf nMultiplic == 1
						GravaB2Emp("+",nBxSD4,"F",,nBxSD42UM)
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf

	RecLock("SB2",.F.)
	//Ŀ
	//Grava campo referente a 2a. Unidade de Medida          
	//
	If Empty(SB1->B1_CONV) .And. !Empty(SD3->D3_QTSEGUM)
		Replace	B2_QTSEGUM With B2_QTSEGUM + SD3->D3_QTSEGUM * nMultiplic
	ElseIf !Empty(SB1->B1_CONV)
		Replace  B2_QTSEGUM With B2_QTSEGUM + (ConvUm(SB1->B1_COD,SD3->D3_QUANT,SD3->D3_QTSEGUM,2)* nMultiplic)
	EndIf

	// Verifica as divergencias entre a quantidade da primeira e da segunda UM
	MatQtdZero(.T.,.F.,.T.)

	Replace	B2_VATU1   With aVatu[01],B2_VATU2 With aVatu[02],;
			B2_VATU3   With aVatu[03],B2_VATU4 With aVatu[04],;
			B2_VATU5   With aVatu[05]

	If nMultiplic == -1
		Replace B2_USAI With SD3->D3_EMISSAO
	EndIf

	aCM[01] := B2_CM1
	aCM[02] := B2_CM2
	aCM[03] := B2_CM3
	aCM[04] := B2_CM4
	aCM[05] := B2_CM5

	For nX := 1 to 5
		If B2_QATU > 0 .And. aVatu[nX] > 0
			aCM[nX] := CusRound(aVatu[nX]/SB2->B2_QATU,nX)
		EndIf
	Next nX

	//-- Realiza a Distribuicao Automatica atravez do parametro MV_DISTAUT para apropriacao indireta
	If SD3->D3_ESTORNO # "S" .And. cLocProc != NIL .And. nMultiplic == 1 .And. lLocaliz .And. !Empty(SuperGetMv("MV_DISTAUT",.F.," "))
		A100Distri(SD3->D3_COD, cLocProc, SD3->D3_NUMSEQ, SD3->D3_DOC, Nil, Nil, Nil, Nil, Nil, SD3->D3_QUANT, SD3->D3_LOTECTL, SD3->D3_NUMLOTE, Nil, Nil, Nil, Nil, SD3->D3_QUANT)
	EndIf

	If !IsProdMod(B2_COD)
		Replace	B2_CM1 With aCM[01],B2_CM2 With aCM[02],B2_CM3 With aCM[03],;
			B2_CM4 With aCM[04],B2_CM5 With aCM[05]
	EndIf

	//Flag mensagem de saldo em estoque
	If SB2->(ColumnPos("B2_DMOV")) > 0
		Replace	B2_DMOV With dDataBase
	EndIf

	If SB2->(ColumnPos("B2_HMOV")) > 0
		Replace	B2_HMOV With Time()
	EndIf

	//Ŀ
	// Se ele atualizou o local do processo , ele deve voltar 
	// ao local original da movimentacao                      
	//
	If cLocProc != NIL
		dbSelectArea("SB2")
		dbSeek(xFilial("SB2")+SD3->D3_COD+SD3->D3_LOCAL)
	EndIf
EndIf
Set(3,nDec)

//Ŀ
//Atualiza o custo unificado ON-LINE                     
//
B2AtuUnif(SB2->B2_COD)

//Ŀ
//Atualiza o custo FIFO ON-LINE                          
//
B2AtuFIFO("SD3",nMultiplic,@aCustoFF)

//-------------------------------------------------------------------
// Busca as requisies feitas para a devoluo estornada com base na SD8 tambem estornada
// refaz a requiso da SD8 e atualiza o saldo do lote fifo SBD na data da SD8 recuperada caso exista SBD
// usando o novo SEQ da SBD.
//-------------------------------------------------------------------
If IsFifoOnLine () .and. SF5->F5_CODIGO < '500' .and. SF5->F5_TIPO == 'D' .and. SD3->D3_ESTORNO == 'S'
    cDtEst:= SD3->D3_EMISSAO
	SD8->(dbSetOrder(5))
	If SD8->(dbSeek(xFilial("SD8")+SD3->(D3_COD+D3_LOCAL+D3_NUMSEQ))) // FILIAL+CODIGO+LOCAL+NUMSEQ
		SBD->(dbSetOrder(1))
		SBD->(Dbgotop())
		IF SBD->(dbSeek(xFilial("SBD")+SD8->D8_PRODUTO+SD8->D8_LOCAL+'Z'+SD8->D8_SEQ)) // FILIAL+CODIGO+LOCAL+SEQ
			If SBD->BD_QUANT <> SBD->BD_QFIM //verifica se houve consumo no saldo SBD
				cSeqSBD:=SBD->BD_SEQ
				dbSelectArea("SBD")
				dbSetOrder(1)
				IF dbSeek(xFilial("SBD")+SD3->(D3_COD+D3_LOCAL+" ")) // FILIAL+CODIGO+LOCAL+STATUS 	-- //status ativo #Z
					If BD_DATA = cDtEst //se existir um saldo fifo na mesma data da devoluo
						cSeq:= BD_SEQ
						SD8->(dbSetOrder(1))
						SD8->(dbSeek(xFilial("SD8")+SD3->(D3_COD+D3_LOCAL+cSeqSBD))) // FILIAL+CODIGO+LOCAL+SEQ
						Do While SD8->(!EOF()) .and. SD8->(D8_FILIAL+D8_PRODUTO+D8_LOCAL+D8_SEQ) == xFilial("SD8")+SD3->(D3_COD+D3_LOCAL)+cSeqSBD
							If SubStr(SD8->D8_CF,1,2) == 'RE' .and. SD8->D8_TM <> '999' .and. SD8->D8_NUMSEQ <> cSeq
								SD3->(Dbsetorder(3))
								If SD3->(dbSeek(xFilial("SD3")+SD8->(D8_PRODUTO+D3_LOCAL+D8_NUMSEQ+D8_CF))) // FILIAL+COD+LOCAL+NUMSEQ+CF
									RecLock('SBD',.F.)
									Replace BD_QFIM    With BD_QFIM 	- SD3->D3_QUANT
									Replace BD_QFIM2UM With BD_QFIM2UM 	- SD3->D3_QTSEGUM
									MsUnlock()

									RecLock("SD8",.T.)
									Replace D8_FILIAL  With xFilial("SD8")
									Replace D8_PRODUTO With SD3->D3_COD
									Replace D8_LOCAL   With SD3->D3_LOCAL
									Replace D8_QUANT   With SD3->D3_QUANT
									Replace D8_QT2UM   With SD3->D3_QTSEGUM
									Replace D8_DATA    With SD3->D3_EMISSAO
									Replace D8_CUSTO1  With aCm[1]
									Replace D8_CUSTO2  With aCm[2]
									Replace D8_CUSTO3  With aCm[3]
									Replace D8_CUSTO4  With aCm[4]
									Replace D8_CUSTO5  With aCm[5]
									Replace D8_SEQ     With cSeq
									Replace D8_CF      With SD3->D3_CF
									Replace D8_TIPONF  With 'N'
									Replace D8_DOC     With SD3->D3_DOC
									Replace D8_OP      With SD3->D3_OP
									Replace D8_TM      With SD3->D3_TM
									Replace D8_NUMSEQ  With SD3->D3_NUMSEQ
									Replace D8_DTPROC  With SD3->D3_EMISSAO
									Replace D8_DTCALC  With SD3->D3_EMISSAO
									MsUnlock()
								EndIf
							EndIf
							SD8->(DbSkip())
						EndDo
					EndIf
				EndIF
			EndIf
		EndIf
	EndIf
EndIf

//Ŀ
//Se houver integrao com outros softwares (Framework do SIGALOJA).
//
If SuperGetMv("MV_LJGRINT",.F., .F.) == .T.
	aAreaSB2 := GetArea()
	oFactory := LJCAdapXmlEnvFactory():New( )	// Cria a fabrica de Adaptadores de envio
	oAdapter := oFactory:Create( "SB2" )

    oAdapter:Inserir( "SB2", xFilial( "SB2" ) + SB2->B2_COD + SB2->B2_LOCAL, "1", "4" )
    oAdapter:Gerar()
	oAdapter:Finalizar()
	RestArea(aAreaSB2)
EndIf

//Ŀ
// MTAB2D2R - Ponto de entrada APOS execucao da funcao.  
//
If lMTAB2D3R
	ExecBlock("MTAB2D3R",.F.,.F.,{SD3->D3_COD, SD3->D3_LOCAL, nMultiplic})
EndIf

If lIntegPPI
	If SD3->(FieldPos('D3_OBSERVA')) == 0 .OR. (SD3->(FieldPos('D3_OBSERVA')) > 0 .AND. Alltrim(SD3->D3_OBSERVA) != 'TOTVSMES')
		dbSelectArea("SOE")
		SOE->(dbSetOrder(1))
		If SOE->(dbSeek(xFilial("SOE")+"SB2")) .AND. ALLTRIM(SOE->OE_PARINTG) == '1'
			MATA225PPI(SB2->B2_COD,;
						SB2->B2_LOCAL,;
						SD3->D3_LOCALIZ,;
						SD3->D3_NUMSERI,;
						SD3->D3_LOTECTL,;
						SD3->D3_NUMLOTE,;
						IF(Empty(SD3->D3_DTVALID),SD3->D3_EMISSAO + SB1->B1_PRVALID,SD3->D3_DTVALID),;
						SD3->D3_QUANT,;
						if(nMultiplic<0,'2','1'),;
						SD3->D3_NUMSEQ,;
						SD3->D3_DOC,;
						aPPIDelete)
		Endif
	Endif
EndIf

Return lLog

/*


Ŀ
Funo    C2FimComD3 Autor  Eveli Morasco          Data  10/12/92 
Ĵ
Descrio  Atualiza arquivo de OP's com dasdos da movimentacao        
Ĵ
Sintaxe    C2FimComD3(ExpA1)                                          
Ĵ
Parametros ExpA1 = Array com os custos gravados no SD3                
           ExpA2 = Array com os custos FIFO gravados no SD3           
           ExpL1 = Processa Custo FIFO                                
           ExpL2 = Processa Custo em Partes                           
           ExpA3 = Array com custos em partes                         
Ĵ
 Uso       Generico                                                   
ٱ


*/
FUNCTION C2FimComD3(aCusto,aCustoFF,lCusFIFO,lCstPart,aRetPartes,lCusRep,aCMRep)
LOCAL nMultiplic := 1
LOCAL aVFimFF    := {0,0,0,0,0}
LOCAL aVFim      := {0,0,0,0,0}
LOCAL aVFimRep   := {0,0,0,0,0}
LOCAL nDec       :=Set(3,8)

lCusFIFO := IIF(lCusFIFO == NIL,.F.,lCusFIFO)
cMoeda330C:= IIF(cMoeda330C == Nil,SuperGetMv('MV_MOEDACM',.F.,"2345"),cMoeda330C)
DEFAULT lCstPart := .F.
DEFAULT lCusRep  := .F.
DEFAULT aCMRep   := {0,0,0,0,0}

dbSelectArea("SC2")
MsSeek(FWxFilial("SC2")+SD3->D3_OP)

If SD3->D3_TM <= "500"
	nMultiplic := -1
EndIf

If lCusFIFO
	aVFimFF[01] := C2_VFIMFF1 + (aCustoFF[01] * nMultiplic)
	aVFimFF[02] := If("2" $ cMoeda330C,C2_VFIMFF2 + (aCustoFF[02] * nMultiplic),0)
	aVFimFF[03] := If("3" $ cMoeda330C,C2_VFIMFF3 + (aCustoFF[03] * nMultiplic),0)
	aVFimFF[04] := If("4" $ cMoeda330C,C2_VFIMFF4 + (aCustoFF[04] * nMultiplic),0)
	aVFimFF[05] := If("5" $ cMoeda330C,C2_VFIMFF5 + (aCustoFF[05] * nMultiplic),0)
Else
	aVFim[01] := C2_VFIM1 + (aCusto[01] * nMultiplic)
	aVFim[02] := If("2" $ cMoeda330C,C2_VFIM2 + (aCusto[02] * nMultiplic),0)
	aVFim[03] := If("3" $ cMoeda330C,C2_VFIM3 + (aCusto[03] * nMultiplic),0)
	aVFim[04] := If("4" $ cMoeda330C,C2_VFIM4 + (aCusto[04] * nMultiplic),0)
	aVFim[05] := If("5" $ cMoeda330C,C2_VFIM5 + (aCusto[05] * nMultiplic),0)
	If lCusRep
		aVFimRep[01] := C2_VFIMRP1 + (aCMRep[01] * nMultiplic)
		aVFimRep[02] := If("2" $ cMoeda330C,C2_VFIMRP2 + (aCMRep[02] * nMultiplic),0)
		aVFimRep[03] := If("3" $ cMoeda330C,C2_VFIMRP3 + (aCMRep[03] * nMultiplic),0)
		aVFimRep[04] := If("4" $ cMoeda330C,C2_VFIMRP4 + (aCMRep[04] * nMultiplic),0)
		aVFimRep[05] := If("5" $ cMoeda330C,C2_VFIMRP5 + (aCMRep[05] * nMultiplic),0)
	EndIf
EndIf

RecLock("SC2",.F.)
If lCusFifo
	Replace C2_VFIMFF1 With aVFimFF[01]
	Replace C2_VFIMFF2 With aVFimFF[02]
	Replace C2_VFIMFF3 With aVFimFF[03]
	Replace C2_VFIMFF4 With aVFimFF[04]
	Replace C2_VFIMFF5 With aVFimFF[05]
Else
	Replace C2_VFIM1 With aVFim[01]
	Replace C2_VFIM2 With aVFim[02]
	Replace C2_VFIM3 With aVFim[03]
	Replace C2_VFIM4 With aVFim[04]
	Replace C2_VFIM5 With aVFim[05]
	If lCusRep
		Replace C2_VFIMRP1 With aVFimRep[01]
		Replace C2_VFIMRP2 With aVFimRep[02]
		Replace C2_VFIMRP3 With aVFimRep[03]
		Replace C2_VFIMRP4 With aVFimRep[04]
		Replace C2_VFIMRP5 With aVFimRep[05]
	EndIf
EndIf

//Ŀ
// Atualiza o custo em partes                            
//
If lCstPart
	ATUCPSC2(lCstPart,aRetPartes,nMultiplic)
EndIf
MsUnlock()
Set(3,nDec)
Return

/*


Ŀ
Funo    C2AtuComD3 Autor  Eveli Morasco          Data  10/12/92 
Ĵ
Descrio  Atualiza arquivo de OP's com dasdos da movimentacao        
Ĵ
Sintaxe    C2AtuComD3(ExpA1)                                          
Ĵ
Parametros ExpA1 = Array com os custos gravados no SD3                
Ĵ
 Uso       Generico                                                   
ٱ


*/
FUNCTION C2AtuComD3(aCusto)
LOCAL aVatu[05],nMultiplic := 1
LOCAL nDec:=Set(3,8)

dbSelectArea("SC2")
dbSetOrder(1)
If MsSeek(xFilial('SC2')+SD3->D3_OP, .F.)

	If SD3->D3_TM <= "500"
		nMultiplic := -1
	EndIf

	aVatu[01] := C2_VATU1 + (aCusto[01] * nMultiplic)
	aVatu[02] := C2_VATU2 + (aCusto[02] * nMultiplic)
	aVatu[03] := C2_VATU3 + (aCusto[03] * nMultiplic)
	aVatu[04] := C2_VATU4 + (aCusto[04] * nMultiplic)
	aVatu[05] := C2_VATU5 + (aCusto[05] * nMultiplic)

	RecLock("SC2",.F.)
	Replace C2_VATU1 With aVatu[01]
	Replace C2_VATU2 With aVatu[02]
	Replace C2_VATU3 With aVatu[03]
	Replace C2_VATU4 With aVatu[04]
	Replace C2_VATU5 With aVatu[05]
	MsUnlock()
EndIf
Set(3,nDec)
Return

/*


Ŀ
Funo    PegaC2Atu  Autor  Eveli Morasco          Data  16/12/92 
Ĵ
Descrio  Pega os custos atuais de uma OP                            
Ĵ
 Uso       Generico                                                   
ٱ


*/
FUNCTION PegaC2Atu(lFifo)
LOCAL aVatu[05]
DEFAULT lFifo := .F.
dbSelectArea("SC2")
If lFifo
	aVatu[01] := C2_VFIMFF1
	aVatu[02] := C2_VFIMFF2
	aVatu[03] := C2_VFIMFF3
	aVatu[04] := C2_VFIMFF4
	aVatu[05] := C2_VFIMFF5
Else
	aVatu[01] := C2_VATU1
	aVatu[02] := C2_VATU2
	aVatu[03] := C2_VATU3
	aVatu[04] := C2_VATU4
	aVatu[05] := C2_VATU5
EndIf
Return aVatu

/*


Ŀ
Funo    PegaC2Fim  Autor  Eveli Morasco          Data  28/12/92 
Ĵ
Descrio  Pega os custos finais de uma OP                            
Ĵ
Parametros ExpC1 = Rotina Chamada                                     
           ExpL1 = Processa Custo FIFO                                
           ExpL2 = Processa Custo em Partes                           
           ExpN1 = Numero de Regras para o custo em partes            
           ExpL3 = Indica se utiliza o custo de reposicao             
Ĵ
 Uso       Generico                                                   
ٱ


*/
FUNCTION PegaC2Fim(cProg,lCusFifo,lCstPart,nRegras,lCusRep)
LOCAL aVFim[05],aVFimFF[05],aVFimRep[05],aRet[04]
LOCAL aRetPartes:={}

DEFAULT lCstPart := .F.
DEFAULT lCusRep  := .F.

cProg    := IIF(cProg == NIL  ,Space(03),cProg)

dbSelectArea("SC2")
aVFim[01] := C2_VFIM1
aVFim[02] := C2_VFIM2
aVFim[03] := C2_VFIM3
aVFim[04] := C2_VFIM4
aVFim[05] := C2_VFIM5
If lCusFIFO
	aVFimFF[01] := C2_VFIMFF1
	aVFimFF[02] := C2_VFIMFF2
	aVFimFF[03] := C2_VFIMFF3
	aVFimFF[04] := C2_VFIMFF4
	aVFimFF[05] := C2_VFIMFF5
EndIf

If lCusRep
	aVFimRep[01] := C2_VFIMRP1
	aVFimRep[02] := C2_VFIMRP2
	aVFimRep[03] := C2_VFIMRP3
	aVFimRep[04] := C2_VFIMRP4
	aVFimRep[05] := C2_VFIMRP5
EndIf

aRetPartes:=PegaCMPFim("C2_CPF",lCstPart,nRegras,NIL)

If cProg == "330"
	aRet[01] := aVFim
	aRet[02] := aVFimFF
	aRet[03] := aRetPartes
	aRet[04] := aVFimRep
	Return aRet
Else
	Return aVFim
Endif

/*


Ŀ
Funo     RetCusEnt Autor  Claudinei M. Benzi     Data  07/06/93 
Ĵ
Descrio  Calcular o Custo de Entrada para moeda 1,2,3,4 e 5         
Ĵ
Sintaxe    Void RetCusEnt(ExpA1,ExpA2,ExpC1,ExpL1                     
Ĵ
Parametros ExpA1 = Array contendo vencimentos dos titulos             
           ExpA2 = Array a ser gravado os custos                      
           ExpC1 = Define o Tipo da Nota                              
           ExpL1 = Indica se a nota e uma devolucao de Compra         
 		  ExpL2 = Indica se a nota e uma devolucao de Compra com a	  
 		 	       quantidade igual a zero		 			          
Ĵ
Observacao Quando for devolucao de compra o tipo da nota deve ser     
           Nil e o ExpL1 deve ser .T.                                 
Ĵ
 Uso       MatA100                                                    
ٱ


*/
Function RetCusEnt(aDupl,aCusto,cTipo,lDevCompra,lDevQtd0,aNFCompra,lCstPart,nRegras,cProg,aRetPartes,lTxNeg)

Static lMTARETDC

Local aArea     := GetArea()
Local aAreaSD1  := SD1->(GetArea("SD1"))
Local aDVenc    := {}
Local aValor    := {}
Local dAux
Local i         := 0
Local j         := 0
Local nTotDupl  := 0
Local nValTot   := 0
Local nValIpi   := 0
Local nValIcm   := 0
Local nIpiAtc   := 0
Local nValIcmRet:= 0
Local nValEstIcm:= 0
Local nValCOF   := 0
Local nValImp   := 0
Local nIVCred	:= 0
Local nValPisPas:= 0
Local nTaxaOri	:= 0
Local nTaxaDest := 0
Local nC		:= 0
Local nValSN    := 0
Local nValFEEF  := 0
Local nValAnti	:= 0
Local lCredCOF  := .F.
Local lCredPIS  := .F.
Local lDevSimb	:= (cPaisLoc <> "BRA" .And. cTipo == "B" .And. SF1->F1_TIPODOC == '63')
Local nTaxaEIC  := .F.
Local lCredSN   := .F.
Local aCustoEnt := Array(Len(aCusto), 5)
Local cParamCus := Upper(AllTrim(SuperGetMv("MV_CUSENT",.F.,"DIARIO")))
Local lRemito	:= SuperGetMv("MV_REMINT",.F.,.F.)
Local lICMRCus  := SuperGetMv('MV_ICMRCUS',.F.,.F.)
Local cCalcImpV := SuperGetMV("MV_GERIMPV",,"N")
Local dData     := SF1->F1_DTDIGIT
Local nTamData 	:= IIF(__SetCentury(),10,8)
Local nTamDocStr:= 0
Local nTamDoc   := 0
Local nDifTam   := 0
Local aMoedDecs := {0,0,0,0,0}
Local cMoedaCm	:= SuperGetMv('MV_MOEDACM',.F.,"2345")
Local lAmazonas	:= SuperGetMv('MV_ESTADO',.F.,"") == "AM"
Local lSuframa	:= SuperGetMv('MV_SUFRAMA',.F., .F.)
Local lEntrFutur:= .F. // controle para tratamento de entrega futura no recebimento
Local lCredCOFEF:= .F.
Local lCredPISEF:= .F.
Local aCusEF	:= {}
Local lDespCol  := cPaisLoc == "COL" .and. FunName() == "MATA143" .and.  FindFunction('lxDspVlCol') 
Local lAltDec	:= .F.
Local nDecAdi	:= 0

//Ŀ
// Ponto de Entrada para Informar quantas casa decimais serao utulizadas
//
If lMTARETDC
	aMoedDecs := ExecBlock('MTARETDC',.F.,.F.)
	If Valtype(aMoedDecs) <> "A"
		aMoedDecs := {0,0,0,0,0}
	EndIf
EndIf

DEFAULT lDevQtd0 	:= .F.
DEFAULT aNFCompra	:= {}
DEFAULT lCstPart 	:= .F.
DEFAULT nRegras  	:= 0
DEFAULT cProg 	 	:= ' '
DEFAULT aRetPartes	:= {}
DEFAULT lTXNeg		:= .F.

lMTARETDC := IIF(lMTARETDC == Nil,ExistBlock('MTARETDC'),lMTARETDC)
//Ŀ
// Variaveis de localizacoes para a entrada de Nota em varias |
//| moeda e comtaxa variavel. Bruno 13/07/2000                 |
//
nTaxa		:=	SF1->F1_TXMOEDA
nMoedaNF    :=	Iif(Type("nMoedaNF")=="U",1,nMoedaNF)

aDupl := If(aDupl == Nil,{},aDupl)
cTipo := If(cTipo == Nil," ",cTipo)
lDevCompra 	:= If(lDevCompra==Nil,.F.,lDevCompra)
lAltDec	:= (cPaisLoc $ "COL" .And. FunName() == "MATA101N" .And. nMoedaNf<>1)
nDecAdi := If(lAltDec, 1, nDecAdi)

//Ŀ
// Calcula o tamanho da nota conforme string passada no aDupl |
//| e a diferena para notas de 6 posies                     |
//
nTamDocStr:= IIf(ValType(aDupl) == "A" .And. !Empty(aDupl),Len(SubStr(aDupl[1],5,At("/",aDupl[1])-12)),0)
nTamDoc   := IIf(nTamDocStr > 0,nTamDocStr,TamSX3("D1_DOC")[1])
nDifTam   := IIf(nTamDoc > 6, nTamDoc - 6, 0)

If lDevCompra
	cTipo := "D"
	SD1->(dbSetOrder(1))
	If !SD1->(MsSeek(FWxFilial("SD1")+SD2->D2_NFORI+SD2->D2_SERIORI+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEMORI))
		cTipo := " "
	EndIf
	dData := SD2->D2_EMISSAO
	nTaxa	:=	SF2->F2_TXMOEDA
EndIf

nTaxaOri := IIf(nTaxa==0,RecMoeda(dData , nMoedaNF),nTaxa)

//Ŀ
// Utilizacao dos elementos definidos como LOCAL na funcao 
//
// aDVenc-> Array bidimensional, dimensao 1 data de vencimento do titulo
// aDVenc->                      dimensao 2 proporcao da data em relacao ao total
// aValor-> Array unidimensional, para valor de cada vencimento
// nTotDupl-> Somatoria dos desdobramentos dos titulos.
// aCustoEnt-> Custo de Entrada para as 5 moedas.
//Ŀ
// Avalia duplicatas digitadas p/ separar valores e venctos
//
If !Empty(aDupl)
	For i:=1 To Len(aDupl)
		AADD(aDVenc, {DataValida(Ctod(Subs(aDupl[i], 16 + nDifTam, nTamData))), 0})
		AADD(aValor, DesTrans(Subs(aDupl[i], 27 + nDifTam, 18)))
		nTotDupl += DesTrans(Subs(aDupl[i], 27 + nDifTam, 18))
	Next i
	//Ŀ
	// Calcula proporcionalidade dos vencimentos            
	//
	For i:=1 To Len(aDVenc)
		aDVenc[i][2] := (aValor[i] / nTotDupl)
	Next i
Else
	dAux := IF(cTipo == "D",SD2->D2_EMISSAO,If(lDevCompra,SD2->D2_EMISSAO,SD1->D1_DTDIGIT))
	AADD(aDVenc, { dAux, 1 } )
EndIf

For i:=1 To Len(aCusto)
	For j:=1 To 5
		aCustoEnt[i][j] := 0.00
	Next j
Next i

// Se trata de entrega futura, se foi enviado o custo do documento Simples Faturamento e a TES est configurado para recebimento
If AliasInDic("DHQ") .And. SF4->(ColumnPos("F4_EFUTUR") > 0) .and. SF4->F4_EFUTUR == '2'

	If Empty(aNFCompra)
		aCusEF := CustEF()
	Else
		aCusEF := CustEF({aNFCompra[1] ,aNFCompra[2] ,aNFCompra[6] ,aNFCompra[7] ,aNFCompra[3]})
	EndIf

	lEntrFutur := len(aCusEF) > 0

EndIf

If cCalcImpV == "S" .And. (Len(aCusto)>0 .And. ValType(aCusto[1][2])=="A")
	//Ŀ
	// Tratamento para Multi-Moedas, converter o custo com base na    
	// do pedido de compra qdo moeda do Pedido diferente de 1.        
	//Lucas
	SC7->(DbSetOrder(1))
	SC7->(DbSeek(FWxFilial("SC7")+SD1->D1_PEDIDO+SD1->D1_ITEMPC))
	If SC7->(Found()) .and. SC7->C7_MOEDA <> 1
		dData := SC7->C7_EMISSAO
	EndIf

	//Ŀ
	// Calculo do Custo considerando os Impostos Variaveis, Clientes  
	// Internacionais...                                              
	//Lucas
	For i:=1 To Len(aCusto)

		If cTipo != "D" .And. ValType(aCusto[i][2])=="A" .And. !lDevSimb
			For j:=1 To 5
				//se a moeda no estiver configurada no MV_MOEDACM pula para a prxima
				If j > 1 .And. !(Str(j,1,0) $ cMoedaCm)
					Loop
				EndIf
				nValimp	:=	0
				nTaxaDest:=	IIf(nMoedaNF==j ,nTaxaOri, RecMoeda(dData , j))
				nTaxaCus	:=	nTaxaDest/nTaxaOri
				If j > 1
					//Ŀ
					// Cuando NF de Importacao para Localizacoes, considerar as Taxas 
					// de SW6, SW9 e SWD para as moedas 2 e 3 somente...              
					//Lucas
					If (cPaisLoc != "BRA" .Or. cParamCus $ "TXINFORMADA")
						If (!SF1->F1_TIPO_NF $ "9AB" .And. !Empty(SF1->F1_HAWB))
							DbSelectArea("SW9")
							DbSetOrder(3)
							If MsSeek(xFilial("SW9")+SF1->F1_HAWB)
								If j == SimbToMoeda(SW9->W9_MOE_FOB) .and. SW9->W9_FORN == SF1->F1_FORNECE
									nTaxaDest := SW9->W9_TX_FOB
									nTaxaCus  := nTaxaDest/nTaxaOri
								EndIf
							EndIf
						EndIf
					EndIf

					If !(cParamCus $ "DIARIO" .Or. cParamCus $ "TXINFORMADA").And. Len(aDupl) > 0
						nValTot := CSoma(  aDVenc, aCusto[i][1], j )
						For nC := 1 To Len(aCusto[i][2])
							If 	Subs(aCusto[i][2][nC][5],3,1 ) == "1" //Quando incide no custo
								nValImp += CImposVar(aCusto[i][2][nC][4],j,aCusto[i][2][nC][1],dData)
							ElseIf Subs(aCusto[i][2][nC][5],3,1 ) == "2" //Quando nao incide no custo
								nValImp -= CImposVar(aCusto[i][2][nC][4],j,aCusto[i][2][nC][1],dData)
							EndIf
						Next nC
					Else
						If lDespCol .and. nMoedaNf <> 1 
							nValTot:= lxDspVlCol(aCusto[i][1],nMoedaNF,j,dData,aMoedDecs,nTaxaOri,nTaxaDest)
						Else
							nValTot := aCusto[i][1]
						EndIf
						For nC := 1 To Len(aCusto[i][2])
							If 	Subs(aCusto[i][2][nC][5],3,1 ) == "1" //Quando incide no custo
								nValImp += (aCusto[i][2][nC][4] / nTaxaCus)
							ElseIf Subs(aCusto[i][2][nC][5],3,1 ) == "2" //Quando nao incide no custo
								nValImp -= (aCusto[i][2][nC][4] / nTaxaCus)
							EndIf
						Next nC
					EndIf
				Else
					nValTot := aCusto[i][1]
					For nC := 1 To Len(aCusto[i][2])
						If 	Subs(aCusto[i][2][nC][5],3,1 ) == "1" //Quando incide no custo
							nValImp += aCusto[i][2][nC][4]
						ElseIf Subs(aCusto[i][2][nC][5],3,1 ) == "2" //Quando nao incide no custo
							nValImp -= aCusto[i][2][nC][4]
						EndIf
					Next nC

				EndIf
				//Ŀ
				// Calcula o Custo de Entrada                           
				//
				aCustoEnt[i][j] := nValTot + nValimp
			Next j
		Else
			//Ŀ
			//Na devolucao de Venda,busca o custo da Nf Origem      
			//aCusto[i][6] -> Numero da nf Origem                   
			//aCusto[i][7] -> Serie da nf Origem                    
			//aCusto[i][8] -> Produto                               
			//aCusto[i][9] -> Local (almoxarifado)                  
			//aCusto[i][10] -> Quantidade devolvida                 
			//aCusto[i][22] -> Item da NF de Origem                 
			//
			aCustoDev := PegaCmDev(.T.,aCusto[i][6],aCusto[i][7],aCusto[i][8],aCusto[i][9],aCusto[i][10],cProg=='330',cProg,lDevCompra,,,lCstPart,nRegras,If(len(aCusto[i])>=22,aCusto[i][22],""))
			If lCstPart .And. cProg=="330" .And. Len(acustodev) >= 3
				aRetPartes := aCustoDev[3]
			EndIf

			For j := 1 to 5
				//se a moeda no estiver configurada no MV_MOEDACM pula para a prxima
				If j > 1 .And. !(Str(j,1,0) $ cMoedaCm)
					Loop
				EndIf
				aCustoEnt[i][j] := Iif(cProg=='330',aCustoDev[i,j],aCustoDev[j])
			Next
		EndIf
	Next i
Else
	//Ŀ
	// Clculo do Custo Normal considerando IPI, ICMS, PIS, COFINS e impostos variaveis.
	//
	For i:=1 To Len(aCusto)

		lCredPIS := .F.
		lCredCOF := .F.
        lCredSN	 := .F.
		nValimpV :=	0

		If lRemito .And. !(cParamCus $ "DIARIO" .Or. cParamCus $ "TXINFORMADA") .And. Len(aDupl) > 0 .And. nMoedaNF <> 1
			aCusto[i][1] := xMOEDA(aCusto[i][1],nMoedaNF,1,dData,MsDecimais(2))
		Endif

		If cTipo != "D"  .And. !lDevSimb

			//Ŀ
			// Verifica se efetua o credito do PIS / Pasep                    
			//
			If Len( aCusto[i] ) > 16
				lCredPIS := .F.
				If aCusto[i,15] $ "13"
					lCredPIS := IIf(lDevQtd0,aCusto[i,16] $ "1|2",aCusto[i,16] $ "1")
				ElseIf aCusto[i,15] $ "4" .and. !lDevQtd0
					lCredPIS := aCusto[i,16] $ "1"
				EndIf
				lCredPISEF := IIf(lDevQtd0,aCusto[i,16] $ "1|2",aCusto[i,16] $ "1")
			EndIf

			//Ŀ
			// Verifica se efetua o credito do COFINS                         
			//
			If Len( aCusto[i] ) > 17
				lCredCOF := .F.
				If aCusto[i,15] $ "23"
					lCredCOF := IIf(lDevQtd0,aCusto[i,16] $ "1|2",aCusto[i,16] $ "1")
				ElseIf aCusto[i,15] $ "4" .and. !lDevQtd0
					lCredCOF := aCusto[i,16] $ "1"
				EndIf
				lCredCOFEF := IIf(lDevQtd0,aCusto[i,16] $ "1|2",aCusto[i,16] $ "1")
			EndIf

			//Ŀ
			// Verifica se efetua o credito presumido do simples nacional     
			//
			If Len( aCusto[i] ) > 19 .And. aCusto[i,20] <> Nil .And. aCusto[i,20] > 0
				lCredSN := .T.
			EndIf

			For j := 1 To 5
				//se a moeda no estiver configurada no MV_MOEDACM pula para a prxima
				If j > 1 .And. !(Str(j,1,0) $ cMoedaCm)
					Loop
				EndIf
				nTaxaEIC := .F.
				nTaxaDest:=	IIf(nMoedaNF==j ,nTaxaOri, RecMoeda(dData , j))
				//Ŀ
				// Para as Notas fiscais de importacao deve-se considerar a taxa  
				// informada no SW9.                                              
				//
				If cParamCus $ "TXINFORMADA"
					If (!SF1->F1_TIPO_NF $ "9AB" .And. !Empty(SF1->F1_HAWB))
						DbSelectArea("SW9")
						DbSetOrder(3)
						If MsSeek(xFilial("SW9")+SF1->F1_HAWB)
							If j == SimbToMoeda(SW9->W9_MOE_FOB) .And. SW9->W9_FORN == SF1->F1_FORNECE
								nTaxaDest := SW9->W9_TX_FOB
								nTaxaEIC  := .T.
							EndIf
						EndIf
					EndIf
				EndIf
				nTaxaCus := nTaxaDest/nTaxaOri
				If j > 1 .Or. nMoedaNF <> 1
					If !(cParamCus $ "DIARIO" .Or. cParamCus $ "TXINFORMADA") .And. Len(aDupl) > 0 .And. nMoedaNF <> 1
						If cTipo # "P"
							nValTot    := CSoma(  aDVenc, aCusto[i][1]+aCusto[i][2]/nTaxaCus, j )
						Else
							nValTot    := CSoma(  aDVenc, aCusto[i][1]/nTaxaCus, j )
						EndIf
						nValIpi := CImpos( aCusto[i][2]/nTaxaCus, j, "P",dData )
						nValIcm := CImpos( aCusto[i][3]/nTaxaCus, j, "I",dData )
						If Len(aCusto[i]) > 12 .And. aCusto[i][13]!=NIL
							nValIcmRet := CImpos( aCusto[i][13]/nTaxaCus,j, "I",dData )
						Else
							nvalIcmRet := 0
						EndIf
						If Len(aCusto[i]) > 10
							nIpiAtc := Cimpos(aCusto[i][11]/nTaxaCus,j,"P",dData )
						Else
							nIpiAtc :=0
						EndIf
						//Ŀ
						//A posicao 14 do array aCusto, contem um array com os impostos variaveis que interferem no custo.    
						//Aqui esta sendo acumulado este valor, considerando os impostos que devem ser somados ou subtraidos, 
						//em um unico montante (nIVCred) que sera retirado do valor do custo, pois se refere ao total de      
						//que sera creditado                                                                                  
						//
						If Len(aCusto[i]) > 13 .And. !Empty(aCusto[i][14]) .And. ValType(aCusto[i][14]) == "A"
							nIVCred := 0
							Aeval(aCusto[i][14], { |x| nIVCred += CSoma(  aDVenc, x[2]/nTaxaCus, j )} )
						EndIf

						//Ŀ
						// Apura o valor do PIS / Pasep                                   
						//
						If lCredPIS
							nValPisPas := Cimpos(aCusto[i,17],j,"S",dData )
						Else
							nValPisPas := 0
						EndIf

						//Ŀ
						// Apura o valor do COFINS                                        
						//
						If lCredCOF
							nValCOF := Cimpos(aCusto[i,18],j,"S",dData )
						Else
							nValCOF := 0
						EndIf

						//Ŀ
						// Apura o valor do Credito Presumido Simples Nacional            
						//
						If lCredSN
							nValSN := aCusto[i,20]
						Else
							nValSN := 0
						EndIf

					Else
						If cTipo # "P"
							nValTot := xMoeda((aCusto[i][1]+aCusto[i][2]),nMoedaNF,j,dData,If(aMoedDecs[j]==0,MsDecimais(j)+nDecAdi,aMoedDecs[j]),nTaxaOri,Iif(lTxNeg,nTaxaOri,nTaxaDest))
							If lAltDec
								nValTot := Round(nValTot,MsDecimais(j))
							EndIf
						Else
							nValTot    := xMoeda(aCusto[i][1],nMoedaNf,j,dData,If(aMoedDecs[j]==0,MsDecimais(j),aMoedDecs[j]),nTaxaOri,nTaxaDest)
						EndIf
						nValIpi := xMoeda(aCusto[i][2],nMoedaNf,j,dData,If(aMoedDecs[j]==0,MsDecimais(j),aMoedDecs[j]),nTaxaOri,nTaxaDest)
						nValIcm := xMoeda(aCusto[i][3],nMoedaNf,j,dData,If(aMoedDecs[j]==0,MsDecimais(j),aMoedDecs[j]),nTaxaOri,nTaxaDest)
						If Len(aCusto[i]) > 12 .And. aCusto[i][13]!=NIL
							nValIcmRet := xMoeda(aCusto[i][13],nMoedaNf,j,dData,If(aMoedDecs[j]==0,MsDecimais(j),aMoedDecs[j]),nTaxaOri,nTaxaDest)
						Else
							nValIcmRet := 0
						EndIf
						If Len(aCusto[i]) > 10 .And. aCusto[i][11]!=NIL
							nIpiAtc := xMoeda(aCusto[i][11],nMoedaNf,j,dData,If(aMoedDecs[j]==0,MsDecimais(j),aMoedDecs[j]),nTaxaOri,nTaxaDest)
						Else
							nIpiAtc :=0
						EndIf
						//Ŀ
						//A posicao 14 do array aCusto, contem um array com os impostos variaveis que interferem no custo.    
						//Aqui esta sendo acumulado este valor, considerando os impostos que devem ser somados ou subtraidos, 
						//em um unico montante (nIVCred) que sera retirado do valor do custo, pois se refere ao total de      
						//que sera creditado                                                                                  
						//
						If Len(aCusto[i]) > 13 .And. !Empty(aCusto[i][14]) .And. ValType(aCusto[i][14]) == "A"
							nIVCred := 0
							Aeval(aCusto[i][14], { |x| nIVCred += x[2]} )
							nIVCred	:= xMoeda(nIVCred,nMoedaNf,j,dData,If(aMoedDecs[j]==0,MsDecimais(j),aMoedDecs[j]),nTaxaOri,nTaxaDest)
						EndIf

						//Ŀ
						// Apura o valor do PIS / Pasep                                   
						//
						If lCredPIS
							nValPisPas := aCusto[i,17] / IIf( j > 1 .And. nTaxaEIC,nTaxaDest,RecMoeda(dData ,j))
						Else
							nValPisPas := 0
						EndIf

						//Ŀ
						// Apura o valor do COFINS                                        
						//
						If lCredCOF
							nValCOF := aCusto[i,18] / IIf( j > 1 .And. nTaxaEIC,nTaxaDest,RecMoeda(dData ,j))
						Else
							nValCOF := 0
						EndIf

						//Ŀ
						// Apura o valor do Credito Pressumido Simples Nacional           
						//
						If lCredSN
							nValSN := aCusto[i,20]  / IIf( j > 1 .And. nTaxaEIC,nTaxaDest,RecMoeda(dData ,j))
						Else
							nValSN := 0
						EndIf

					EndIf

					If Len(aCusto[i]) > 22 // Issue DMANMAT01-21311 - Apropriao do imposto FEEF ao custo de entrada
						nValFEEF := xMoeda(aCusto[i][23],nMoedaNf,j,dData,If(aMoedDecs[j]==0,MsDecimais(j),aMoedDecs[j]),nTaxaOri,nTaxaDest)
					EndIf

				Else
					nValTot := aCusto[i][1]
					nValIpi := aCusto[i][2]
					nValIcm := aCusto[i][3]
					
					If Len(aCusto[i]) > 18 .And. aCusto[i][19]!=NIL
						nValEstIcm := aCusto[i][19]
					EndIf
					If Len(aCusto[i]) > 12 .And. aCusto[i][13]!=NIL
						nValIcmRet := aCusto[i][13]
					Else
						nValIcmRet := 0
					EndIf
					If Len(aCusto[i]) > 10 .And. aCusto[i][11]!=NIL
						nIpiAtc := aCusto[i][11]
					Else
						nIpiAtc :=0
					EndIf
					//Ŀ
					//A posicao 14 do array aCusto, contem um array com os impostos variaveis que interferem no custo.    
					//Aqui esta sendo acumulado este valor, considerando os impostos que devem ser somados ou subtraidos, 
					//em um unico montante (nIVCred) que sera retirado do valor do custo, pois se refere ao total de      
					//que sera creditado                                                                                  
					//
					If Len(aCusto[i]) > 13  .And. !Empty(aCusto[i][14]) .And. ValType(aCusto[i][14]) == "A"
						nIVCred := 0
						Aeval(aCusto[i][14], { |x| nIVCred += x[2] } )
					EndIf

					//Ŀ
					// Apura o valor do PIS / Pasep                                   
					//
					If lCredPIS
						nValPisPas := aCusto[i,17]
					Else
						nValPisPas := 0
					EndIf

					//Ŀ
					// Apura o valor do COFINS                                        
					//
					If lCredCOF
						nValCOF := aCusto[i,18]
					Else
						nValCOF := 0
					EndIf

					//Ŀ
					// Apura o valor do Credito Pressumido Simples Nacional           
					//
					If lCredSN
						nValSN := aCusto[i,20]
					Else
						nValSN := 0
					EndIf

					//Ŀ
					// Apura o valor da Atencipacao de ICMS					       
					//
					If Len(aCusto[i])>20
						nValAnti:= aCusto[i,21]
					EndIf

					If Len(aCusto[i]) > 22 // Issue DMANMAT01-21311 - Apropriao do imposto FEEF ao custo de entrada
						nValFEEF := aCusto[i][23]
					EndIf

				EndIf

				//Ŀ
				//           Calcula o Custo de Entrada                 
				//
				If  aCusto[i][5] == "N"			// Credito de ICMS?
					If cTipo != "I"
						If aCusto[i][4] == "N"		// Credito de IPI?
							If j > 1
								aCustoEnt[i][j] := nValTot   // Ja somei p/ moeda > 1
							Else
								If cTipo == "P"
									aCustoEnt[i][j] := nValTot
								Else
									aCustoEnt[i][j] := nValTot + nValIpi
									// ENTREGA FUTURA - Considera o IPI da nota de Simples Faturamento
									If lEntrFutur
										aCustoEnt[i][j] += (nValTot / aCusEF[1,9]) * aCusEF[1,16] //VALIPI
									EndIf
								EndIf
							EndIf
						Else
							If cTipo != "P"
								aCustoEnt[i][j] := nValTot - nIpiAtc
								If aCusto[i][4] == "S" .and. j > 1
									aCustoEnt[i][j] := nValTot - nValIpi - nIpiAtc
								EndIf
							Else
								aCustoEnt[i][j] := 0
							EndIf
						EndIf
					Else
						//Ŀ
						//Caso o usuario tenha informado valores manualmente na aba "Impostos" os
						//mesmos deverao ser adicionados ao custo da nota.                       
						//
						aCustoEnt[i][j] := Max(0, nValTot)
					EndIf
				Else
					If cTipo != "I"
						If nValTot != 0
							aCustoEnt[i][j] := nValTot - ( IIf(lCredSN,0,nValIcm) - nValEstIcm )
							If aCusto[i][4] == "N"
								If j = 1 .And. cTipo # "P"
									aCustoEnt[i][j] += nValIpi // ja' somei para outras
									// ENTREGA FUTURA - Considera o IPI da nota de Simples Faturamento
									If lEntrFutur
										aCustoEnt[i][j] += (nValTot / aCusEF[1,9]) * aCusEF[1,16] //VALIPI
									EndIf

								EndIf
							Else
								If cTipo != "P"
									aCustoEnt[i][j] -=  nIpiAtc
									If aCusto[i][4] == "S" .And. j > 1
										aCustoEnt[i][j] -= nValIpi
									EndIf
								Else
									aCustoEnt[i][j] := 0
								EndIf
							EndIf
						Else
							aCustoEnt[i][j] := (IIf(lCredSN,0,nValIcm) - nValEstIcm) * -1
						EndIf
					Else
						aCustoEnt[i][j] := (IIf(lCredSN,0,nValIcm) - nValEstIcm) * -1
					EndIf
				EndIf
				//Ŀ
				//Incrementar ou subtrair do custo o valor dos impostos variaveis  
				//
				If aCustoEnt[i][j] > 0
					aCustoEnt[i][j] += nIVCred
				EndIf
				//Ŀ
				//           Efetua o credito do ICMS Retido            
				//
				If Len(aCusto[i]) > 11 .And. aCusto[i][12]!=NIL .And. cPaisLoc == "BRA"
					If !(aCusto[i,12] $ '1|4') .Or. (aCusto[i,12] == "4" .And. SF4->F4_ANTICMS <> '1')
						aCustoEnt[i][j] += nValIcmRet
						//Ŀ
						// Soma o valor do ICMS quando existe Solidario na entrada  Alteracao feita para
						// Nilton CHG
						//If SF4->F4_AGREG == 'S'  .and. !lCredSN .And. nValIcmRet > 0 .And.;
						//   !(aCusto[i][5]=="N") .And. cTipo != "I"
						//	aCustoEnt[i][j] += nValIcm
						//EndIf
					EndIf
					//Ŀ
					// Soma o ICMS Retido ao Custo quando a empresa e a  
					// substituta na cadeia e nao tem direito ao credito 
					//
					If lICMRCus .And. aCusto[i,12] == '4' .And. SF4->F4_ANTICMS == '1'
						aCustoEnt[i][j] += nValIcmRet
					EndIf
				EndIf

				//Ŀ
				//           Efetua o credito do PIS / Pasep            
				//
				If lCredPIS
					aCustoEnt[i][j] -= nValPisPas
				EndIf
				// ENTREGA FUTURA - Considera o PIS da nota de Simples Faturamento
				If lEntrFutur .AND. lCredPISEF
					aCustoEnt[i][j] -= (nValTot / aCusEF[1,9]) * aCusEF[1,14] //VALIMP5
				EndIf

				//Ŀ
				//           Efetua o credito do COFINS                 
				//
				If lCredCOF
					aCustoEnt[i][j] -= nValCOF
				EndIf
				// ENTREGA FUTURA - Considera o COFINS da nota de Simples Faturamento
				If lEntrFutur .AND. lCredCOFEF
					aCustoEnt[i][j] -= (nValTot / aCusEF[1,9]) * aCusEF[1,15] //VALIMP6
				EndIf

				//Ŀ
				// Efetua o Credito Presumido Simples Nacional          
				//
				If lCredSN
					aCustoEnt[i][j] -= nValSN
				EndIf

				//Ŀ
				// Efetua o Credito Presumido do ICMS para estado do Amazonas 
				//
				//SF4->F4_CREDICM = 'S'
				If aCusto[i][5] == "S" .And. lAmazonas .And. lSuframa .And. SF4->F4_AGREG == 'D'
					aCustoEnt[i][j] -= nValIcm
				EndIf

				If  Len(aCusto[i]) > 11 .And. aCusto[i][12]!=NIL
					If !(aCusto[i,12] $ '1|4') .And. Len(aCusto[i]) > 20
						aCustoEnt[i][j] += nValAnti
					EndIf
				EndIf

				// Issue DMANMAT01-21311 - Apropriao do imposto FEEF ao custo de entrada
				aCustoEnt[i][j] += nValFEEF

			Next j
		Else
			//Ŀ
			//Na devolucao de Venda,busca o custo da Nf Origem      
			//aCusto[i][6] -> Numero da nf Origem                   
			//aCusto[i][7] -> Serie da nf Origem                    
			//aCusto[i][8] -> Produto                               
			//aCusto[i][9] -> Local (almoxarifado)                  
			//aCusto[i][10] -> Quantidade devolvida                 
			//aCusto[i][22] -> Item da NF de Origem                 
			//
			aCustoDev := PegaCmDev (.T.,aCusto[i][6],aCusto[i][7],aCusto[i][8],aCusto[i][9],aCusto[i][10],cProg=='330',cProg,lDevCompra,,,lCstPart,nRegras,If(len(aCusto[i])>=22,aCusto[i][22],""))
			If lCstPart .And. cProg=="330" .And. Len(acustodev) >= 3
				aRetPartes := aCustoDev[3]
			EndIf
			For j := 1 to 5
				//se a moeda no estiver configurada no MV_MOEDACM pula para a prxima
				If j > 1 .And. !(Str(j,1,0) $ cMoedaCm)
					Loop
				EndIf
				aCustoEnt[i][j] := Iif(cProg=='330',aCustoDev[i,j],aCustoDev[j])
			Next
		EndIf
	Next i
EndIf
RestArea(aAreaSD1)
RestArea(aArea)
Return aCustoEnt

/*


Ŀ
Funo     CSoma     Autor  Claudinei M. Benzi     Data  07/06/93 
Ĵ
Descrio  Calcula Somatoria de valores por vencimentos p/ moeda forte
Ĵ
Sintaxe    Void CSoma(ExpA1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpA1 = Array contendo vencimentos dos titulos.            
           ExpN1 = Valor a ser calculado.                             
           ExpN2 = Numero da moeda a ser calculado.                   
Ĵ
 Uso       MatA100                                                    
ٱ


*/
Static Function CSoma(aDVenc,nValor,nMoeda)
LOCAL i, nRet:=0
For i:=1 To Len(aDVenc)
	nRet += ( (nValor*aDVenc[i][2]) / RecMoeda( aDVenc[i][1], nMoeda ) )
Next i
Return nRet

/*


Ŀ
Funo     CImpos    Autor  Claudinei M. Benzi     Data  07/06/93 
Ĵ
Descrio  Calcula data de vencimento de impostos(IPI/ICMS/PIS/COFINS)
Ĵ
Sintaxe    Void CImpos(ExpD1,ExpC2)                                   
Ĵ
Parametros ExpN1 = Valor a ser calculado.                             
           ExpN2 = Numero da moeda a ser calculado.                   
           ExpC1 = Se  calculo de <I>cms, i<P>i                      
           ExpD1 = Data do Documento (Nota Fiscal)                    
Ĵ
 Uso       MatA100                                                    
ٱ


*/
FUNCTION CImpos( nValor, nMoeda, cCalc, dDataDoc )
LOCAL cDay, cMonth, cYear, nRet := 0, cPeriodo

//Ŀ
// Verifica se o calculo deve ser feito para i<P>i ou <I>cms ou <P>is ou <C>ofins 
//
dDataDoc := If(Empty(dDataDoc),dDataBase,dDataDoc)
IF cCalc == "I"
	cDay   := GetMV("MV_ICMVENC")
Elseif cCalc == "P"
	cDay   := GetMV("MV_IPIVENC")
Elseif cCalc == "S"
	cDay   := GetNewPar("MV_PISVENC", "01,1")
Elseif cCalc == "C"
	cDay   := GetNewPar("MV_COFVENC", "01,1")
Endif
cPeriodo:=Substr(cDay,4,1)
cDay	:=Substr(cDay,1,2)
cPeriodo:=IF(Empty(cPeriodo),"1",cPeriodo)

If Val(cDay) < 1 .or. Val(cDay) > 28  // Acerta caso o parametro esteja errado
	cDay:= "01"
Else
	cDay:=Strzero(Val(cDay),2)
Endif


cMonth := StrZero(Month( dDataDoc ),2)
cYear  := Subs(Str(Year( dDataDoc ),4),3,2)
dDataVenc := CTOD(cDay+"/"+cMonth+"/"+cYear)

Do Case
Case cPeriodo=="1"
	IF Day( dDataDoc ) < 11
		dDataVenc += 10
	ElseIf Day( dDataDoc ) < 21
		dDataVenc += 20
	Else
		dDataVenc := Lastday( dDataDoc,0)+Val(cDay)
	Endif
Case cPeriodo=="2"
	IF Day( dDataDoc ) < 15
		dDataVenc += 15
	Else
		dDataVenc := Lastday( dDataDoc,0)+Val(cDay)
	Endif
Otherwise
	dDataVenc := Lastday( dDataDoc,0)+Val(cDay)
EndCase

nRet := ( nValor / RecMoeda( dDataVenc, nMoeda ) )
Return nRet

/*


Ŀ
Funo     CImposVar Autor  Jos Lucas             Data  29/06/98 
Ĵ
Descrio  Calcula data de vencimento dos impostos variveis e retorna
           o valor do imposto convertido na data calculada.           
Ĵ
Sintaxe    ExpN1 := CImpos(ExpN2,ExpN3,ExpC1,ExpD1)                   
Ĵ
Parametros ExpN2 = Valor a ser calculado.                             
           ExpN3 = Numero da moeda a ser calculado.                   
           ExpC1 = Sigla ou Nome do imposto.                          
           ExpD1 = Data do Documento (Nota Fiscal).                   
Retorno    ExpN1 = Valor calculado.                                   
Ĵ
 Uso       MatA100                                                    
ٱ


*/
FUNCTION CImposVar( nValor, nMoeda, cImposto, dDataDoc )
LOCAL cDay, cMonth, cYear, cPeriodo, nValorCalc := 0

//Ŀ
// Pesquisar o imposto e obter o dia de vencimento.             
//
SFB->( dbSetOrder(1) )
SFB->( dbSeek( xFilial("SFB")+Alltrim(cImposto)) )

cDay     := SFB->FB_DIAVENC
cPeriodo := SFB->FB_PERIODO

cPeriodo := If(Empty(cPeriodo),"1",cPeriodo)

If Val(cDay) < 1 .or. Val(cDay) > 28  // Acerta caso o campos esteja errado
	cDay:= "01"
Else
	cDay:=Strzero(Val(cDay),2)
Endif

cMonth    := StrZero(Month( dDataDoc ),2)
cYear     := Subs(Str(Year( dDataDoc ),4),3,2)
dDataVenc := CTOD(cDay+"/"+cMonth+"/"+cYear)

Do Case
Case cPeriodo=="1"
	IF Day( dDataDoc ) < 11
		dDataVenc += 10
	ElseIf Day( dDataDoc ) < 21
		dDataVenc += 20
	Else
		dDataVenc := Lastday( dDataDoc,0)+Val(cDay)
	Endif
Case cPeriodo=="2"
	IF Day( dDataDoc ) < 15
		dDataVenc += 15
	Else
		dDataVenc := Lastday( dDataDoc,0)+Val(cDay)
	Endif
Otherwise
	dDataVenc := Lastday( dDataDoc,0)+Val(cDay)
EndCase
nValorCalc := ( nValor / RecMoeda( dDataVenc, nMoeda ) )
Return( nValorCalc )

/*


Ŀ
Funo     PegaCusD2 Autor  Claudinei M. Benzi     Data  09/12/92 
Ĵ
Descrio  Devolve os 05 custos da movimentacao                       
Ĵ
Sintaxe    ExpA1 := PegaCusD2()                                       
Ĵ
Parametros ExpA1 = Array devolvido pela funcao com os 05 custos da    
                   movimentacao                                       
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function PegaCusD2
LOCAL aCusto[05]

dbSelectArea("SD2")
aCusto[01] := SD2->D2_CUSTO1
aCusto[02] := SD2->D2_CUSTO2
aCusto[03] := SD2->D2_CUSTO3
aCusto[04] := SD2->D2_CUSTO4
aCusto[05] := SD2->D2_CUSTO5
Return aCusto

/*


Ŀ
Funo     xFilEnt   Autor  Jose Lucas             Data  24.11.93 
Ĵ
Descrio  Retorna a filial de entrega utilizada pelos arquivos SC7 e 
           SC8.                                                       
Ĵ
Sintaxe    xFilEnt()                                                  
Ĵ
 Uso       SIGACUS                                                    
ٱ


*/
Function xFilEnt(cFilialEnt,cAlias)
//Selecione a area antes da funcao da xFilEnt() ou passe como parametro.
Default cAlias:= Alias()
Return(IF(FWModeAccess(cAlias)=="E",cFilialEnt,FWxFilial(cAlias)))

/*


Ŀ
Funo     PegaCmDev Autor  Marcos Bregantim       Data  18.02.94 
Ĵ
Descrio  Retorna o Custo de devolucao de venda, se nao houver a nota
           original,devolve o custo atual                             
Ĵ
Sintaxe    PegaCmDev(EXPl1,ExpC2,ExpC3,ExpC4,ExpC5,ExpN6)             
Ĵ
Parametros Expl1 = Especifica se Custo Atual ou Final                 
           ExpC2 = Nota Fiscal Origem                                 
           ExpC3 = Serie da Nota Fiscal Origem                        
           ExpC4 = Produto da Nf de Devolucao                         
           ExpC5 = Local (Almoxarifado)                               
           ExpN6 = Quantdidade Devolvida                              
           ExpL7 = Recalculo do custo Medio                           
           ExpC8 = Rotina de chamada                                  
           ExpL9 = Expressao logica indicando se devoulao de compras  
           ExpL10= Expressao logica indicando se usa Custo FIFO       
           ExpL11= Expressao logica indicando se usa Custo Unificado  
           ExpL12= Expressao logica indicando se usa custo em partes  
           ExpN13= Numero de regras para custo em partes              
           ExpC14= Item Original                                      
           ExpL13= Indica se deve calcular o custo de reposicao       
Ĵ
 Uso       SIGACUS                                                    
ٱ


*/
Function PegaCmDev(lAtual,cNfOri,cSeriOri,cProduto,cLocal,nQuantD1,l330,cProg,lDevCompra,lCusFifo,lCusUnif,lCstPart,nRegras,cItemOri,lCusRep,lDevNCC)
Static lPointCDV
Static lPointCDVP

Local lSeekNFOri := .F.
Local lCustoSBD	 := .F.
Local aCustoBlock:={}
Local aRetPartes :={}
Local cAlias     := Alias()
Local lCusDevAtu := (EstGetMv('MV_CUSTDEV', .F., .F.) .And. l330) //-- No recalculo do custo medio forca a utilizacao do custo atual para devolucoes de saida
Local aCustoFF   := {0,0,0,0,0}
Local aCustoRep  := {0,0,0,0,0}
Local cSeek		 := ""
Local cNewNfOri  := ""
Local cNewSeriOri:= ""
Local ni         := 0
Local nTotDev	 := 0
Local nProp		 := 0
Local nQtdDev	 := 0
Local cIndex,nRec,aRet[04]
Local aCusto[05]
Local nPosFil	:= 0
Local cFilOri	:= ""
Local cFilSD2	 := FWxFilial("SD2") //Filial do SD2
Local cFilSD8	:=  FWxFilial("SD8")
Local cFilNfOri	:= cFilAnt
Local lProcLoja	:= .F. //Processamento do Controle de Lojas

DEFAULT lCstPart := .F.
DEFAULT lCusRep  := .F.
DEFAULT lDevNCC  := .F.

lPointCDV  := IIF(lPointCDV == NIL, ExistBlock("MTCNFDV"),lPointCDV)
lPointCDVP := IIF(lPointCDVP== NIL, ExistBlock("MTCNFDVP"),lPointCDVP)
l330       := IIF(l330  == Nil,.f.,l330)
cProg      := IIF(cProg == NIL,Space(03),cProg)
lCusFIFO   := IIF(lCusFifo == NIL,.F.,lCusFifo)
lDevCompra := If(lDevCompra==Nil,.F.,lDevCompra)
lCusUnif   := If(lCusUnif==Nil,.F.,lCusUnif)
cItemOri   := IIf(cItemOri==Nil,"",AllTrim(cItemOri))

//-- Ajuste no tratamento para devoluo em filial diferente da origem da nota
If Type("aAutoItens") == "A" .And. !Empty(aAutoItens) .And. !Empty(aAutoItens[1]) .And.;
			(nPosFil := aScan(aAutoItens[1], {|x| AllTrim(x[1]) == "D1_FILORI"})) > 0
	cFilOri := aAutoItens[1,nPosFil,2]
	lProcLoja := IsInCallStack("LOJA720")
ElseIf SD1->D1_ORIGLAN == "LO" .And. !Empty(SD1->D1_FILORI) //Tratamento multi-filiais (SIGALOJA-LOJA720)
	cFilOri := SD1->D1_FILORI
	lProcLoja := IsInCallStack("LOJA720")
EndIf

IF l330 .and. SD1->D1_ORIGLAN == "CT" .Or. lDevCompra
	If lCusFIFO
		aCustoFF[01] := SD1->D1_CUSFF1
		aCustoFF[02] := SD1->D1_CUSFF2
		aCustoFF[03] := SD1->D1_CUSFF3
		aCustoFF[04] := SD1->D1_CUSFF4
		aCustoFF[05] := SD1->D1_CUSFF5
	Else
		aCusto[01] := SD1->D1_CUSTO
		aCusto[02] := SD1->D1_CUSTO2
		aCusto[03] := SD1->D1_CUSTO3
		aCusto[04] := SD1->D1_CUSTO4
		aCusto[05] := SD1->D1_CUSTO5
		If lCusRep
			aCustoRep[01] := SD1->D1_CUSRP1
			aCustoRep[02] := SD1->D1_CUSRP2
			aCustoRep[03] := SD1->D1_CUSRP3
			aCustoRep[04] := SD1->D1_CUSRP4
			aCustoRep[05] := SD1->D1_CUSRP5
		EndIf
		dbSelectArea("SD1")
		aRetPartes:=PegaCMPFim("D1_CP",lCstPart,nRegras,SD1->D1_QUANT)
	Endif
	nQuantD1 :=IF(nQuantD1 == NIL,SD2->D2_QUANT,nQuantD1)
	For ni:=1 to If(lCusFifo,Len(aCustoFF),Len(aCusto))
		If lCusFIFO
			aCustoFF[ni]:= aCustoFF[ni] * (nQuantD1 / SD1->D1_QUANT)
		Else
			aCusto[ni]:= aCusto[ni] * (nQuantD1 / SD1->D1_QUANT)
			If lCusRep
				aCustoRep[ni]:= aCustoRep[ni] * (nQuantD1 / SD1->D1_QUANT)
			EndIf
		EndIf
	Next ni
ElseIf cNfOri != NIL .And. cProduto != NIL .And. cLocal != NIL .And. !lCusDevAtu //-- Procura pelo Custo da NF de Saida Original
	dbSelectArea("SD2")
	cIndex:=IndexOrd()
	nRec:=RecNo()
	dbSetOrder(3)

	If !Empty(cFilOri)
		cFilSD2 := cFilOri
		If lProcLoja
			If cFilSD2 <> FWxFilial("SD2")
				//Mudou a Filial e  Sd2 Esta exclusiva
				If FWFilExist(,cFilSD2)
					cFilNfOri := cFilSD2
					cFilSD8 := FWxFilial("SD8", cFilNfOri)
				EndIf
			EndIf
		EndIf
	EndIf


	lSeekNFOri:=dbSeek(cFilSD2 +cNfOri+cSeriOri)

	If lDevNCC .And. lSeekNFOri .And. cPaisLoc <> "BRA"
		If !Empty(SD2->D2_REMITO)
			cNewNfOri    := SD2->D2_REMITO
			cNewSeriOri  := SD2->D2_SERIREM
			lSeekNFOri:=dbSeek(cFilSD2+cNewNfOri+cNewSeriOri)
			If lSeekNfOri
				cNfOri    := cNewNfOri
				cSeriOri  := cNewSeriOri
			EndIf
		EndIf
	EndIf
	While (cFilSD2+cNfOri+cSeriOri)==(D2_FILIAL+D2_DOC+D2_SERIE) .and. !Eof()
		IF cProduto != D2_COD .OR. D2_TIPO != "N" .Or. IIf(!Empty(cItemOri),cItemOri != D2_ITEM,.F.)
			dbSkip()
		Else
			lSeekNFOri:=.T.
			Exit
		Endif
	EndDo
	If cNfOri == SD2->D2_DOC .and. cSeriOri == SD2->D2_SERIE .and. IIf(lCusFifo .And. !Empty(cItemOri),cItemOri == SD2->D2_ITEM,.T.) .and. cProduto == SD2->D2_COD .and. SD2->D2_TIPO == "N" .and. !eof()
		If lCusFIFO
			//Ŀ
			// Recupera o Custo de origem Fifo atraves do lotes gerados no SD8 |
			//
			aAreaAnt := GetArea()
			nTotDev	 := SD1->D1_QUANT
			dbSelectArea("SD8")
			dbSetOrder(3)  //D8_FILIAL+D8_DOC+D8_SERIE+D8_ITEM
			dbSeek(cSeek:=cFilSD8+SD1->(D1_NFORI+D1_SERIORI+D1_ITEMORI))
			Do While !Eof() .And. cSeek == cFilSD8+SD1->(D1_NFORI+D1_SERIORI+D1_ITEMORI)
				If SD8->D8_TM <= "500" .Or. Empty(D8_ITEM) .Or.SD8->D8_QUANT <= SD8->D8_SD1DEV
					dbSkip()
					Loop
				EndIf
				//Ŀ
				// Recupera o custo de origem dos lotes fifo de acordo com os lotes |
				//| de entrada para respeitar o custo de cada lote Fifo/Lifo		 
				//
				If QtdComp(nTotDev) > QtdComp(0)
					If QtdComp(nTotDev) > QtdComp(SD8->D8_QUANT-SD8->D8_SD1DEV)
						nQtdDev := (SD8->D8_QUANT-SD8->D8_SD1DEV)
						nProp	:= nQtdDev/SD8->D8_QUANT
					Else
						nQtdDev := nTotDev
						nProp	:= nQtdDev/SD8->D8_QUANT
					EndIf
					//Ŀ
					// aCustoDev - Array contendo as quebras e seus respectivos custos |
					//
					aCustoFF[01] += SD8->D8_CUSTO1 * nProp
					aCustoFF[02] += SD8->D8_CUSTO2 * nProp
					aCustoFF[03] += SD8->D8_CUSTO3 * nProp
					aCustoFF[04] += SD8->D8_CUSTO4 * nProp
					aCustoFF[05] += SD8->D8_CUSTO5 * nProp
					nTotDev	  := nTotDev - (SD8->D8_QUANT-SD8->D8_SD1DEV)
					lCustoSBD := .T.
				Else
					Exit
				EndIf
	        	SD8->(dbSkip())
	        EndDo
			RestArea(aAreaAnt)
		Else
			aCusto[01] := SD2->D2_CUSTO1
			aCusto[02] := SD2->D2_CUSTO2
			aCusto[03] := SD2->D2_CUSTO3
			aCusto[04] := SD2->D2_CUSTO4
			aCusto[05] := SD2->D2_CUSTO5
			If lCusRep
				aCustoRep[01] := SD2->D2_CUSRP1
				aCustoRep[02] := SD2->D2_CUSRP2
				aCustoRep[03] := SD2->D2_CUSRP3
				aCustoRep[04] := SD2->D2_CUSRP4
				aCustoRep[05] := SD2->D2_CUSRP5
			EndIf
			aRetPartes:=PegaCMPFim("D2_CP",lCstPart,nRegras,SD2->D2_QUANT)
		EndIf
		//Ŀ
		//| Previne custo FIFO zerado ou negativo					 |
		//
		If lCusFIFO .And. aCustoFF[1] <= 0

			// Pega o ultimo custo do lote Fifo em aberto
			aCustoFF:=PegaCusSBD(cProduto,cLocal,cAlias, cFilNfOri)

			If SD2->D2_CUSTO1 > 0 .And. aCustoFF[1] <= 0
				aCustoFF[01] := SD2->D2_CUSTO1
				aCustoFF[02] := SD2->D2_CUSTO2
				aCustoFF[03] := SD2->D2_CUSTO3
				aCustoFF[04] := SD2->D2_CUSTO4
				aCustoFF[05] := SD2->D2_CUSTO5
			Else
				lCustoSBD := .T.
			EndIf
		EndIf

		If !lCustoSBD
			For ni:=1 to If(lCusFifo,Len(aCustoFF),Len(aCusto))
				If lCusFIFO
					aCustoFF[ni]:= aCustoFF[ni] * (nQuantD1 / SD2->D2_QUANT)
				Else
					aCusto[ni]:= aCusto[ni] * (nQuantD1 / SD2->D2_QUANT)
					If lCusRep
						aCustoRep[ni]:= aCustoRep[ni] * (nQuantD1 / SD2->D2_QUANT)
					EndIf
				Endif
			Next ni
		EndIF
	Else
		If lAtual
			aCusto   := PegaCmAtu(cProduto,cLocal, /*cTipo*/,/*aCusRec*/,/*lDevComp*/,/*lCusRep*/, cFilNFOri)
		Else
			If lCusUnif
				aRet := A330TTFim(cProduto,cLocal, , ,cAlias,cProg,,lCusFifo,lCstPart,nRegras)
			Else
				aRet := PegaCmFim(cProduto,cLocal, , ,cAlias,cProg,,lCusFifo,,,,lCusRep)
			EndIf
			aCusto   	:= aRet[1]
			aCustoFF 	:= aRet[2]
			aRetPartes	:= aRet[3]
			aCustoRep	:= aRet[4]
		Endif
		For ni:=1 to If(lCusFifo,Len(aCustoFF),Len(aCusto))
			If lCusFIFO
				aCustoFF[ni]:= aCustoFF[ni] * (nQuantD1)
			Else
				aCusto[ni]:= aCusto[ni] * (nQuantD1)
			EndIf
		Next ni
	Endif
	dbSelectArea("SD2")
	dbSetOrder(cIndex)
	dbGoto(nRec)
	//Ŀ
	//Processa ponto de entrada qdo nao encontra NF original 
	//
	If lPointCDV .And. !lSeekNfOri
		aCustoBlock:=ExecBlock("MTCNFDV",.F.,.F.,{lCusFifo,If(lCusFIFO,aCustoFF,aCusto),cNfOri+cSeriOri})
		If Valtype(aCustoBlock) == "A" .And. Len(aCustoBlock) == Len(aCusto)
			For ni:=1 to Len(aCustoBlock)
				If Valtype(aCustoBlock[ni]) # "N"
					lPointCDV:=.F.
					Exit
				EndIf
			Next ni
			If lPointCDV
				If lCusFIFO
					aCustoFF:=ACLONE(aCustoBlock)
				Else
					aCusto:=ACLONE(aCustoBlock)
				EndIf
			EndIf
		EndIf
	EndIf
	If lPointCDVP .And. !lSeekNfOri
		aCustoBlock:=ExecBlock("MTCNFDVP",.F.,.F.,{aRetPartes,cNfOri+cSeriOri})
		If Valtype(aCustoBlock) == "A" .And. Len(aCustoBlock) == Len(aRetPartes)
			For ni:=1 to Len(aCustoBlock)
				If Valtype(aCustoBlock[ni]) # "N"
					lPointCDVP:=.F.
					Exit
				EndIf
			Next ni
			If lPointCDVP
				aRetPartes:=ACLONE(aCustoBlock)
			EndIf
		EndIf
	EndIf
Else  //-- Procura pelo Custo Atual
	If lAtual .And. !(lCusDevAtu) //-- lCusDevAtu = Quando o parametro estiver ativado o custo deve ser obtido com base no B2_VFIM? ("ELSE" abaixo)
		aCusto   := PegaCmAtu(cProduto,cLocal)
	Else
		If lCusUnif
			aRet := A330TTFim(cProduto,cLocal, , ,cAlias,cProg,,lCusFifo,lCstPart,nRegras)
		Else
			aRet := PegaCmFim(cProduto,cLocal, , ,cAlias,cProg,,lCusFifo)
		EndIf
		aCusto   	:= aRet[1]
		aCustoFF 	:= aRet[2]
		aRetPartes	:= aRet[3]
	Endif
	For ni:=1 to If(lCusFifo,Len(aCustoFF),Len(aCusto))
		If lCusFIFO
			aCustoFF[ni]:= aCustoFF[ni] * (nQuantD1)
		Else
			aCusto[ni]:= aCusto[ni] * (nQuantD1)
		EndIf
	Next ni
Endif

dbSelectArea(cAlias)

If cProg == "330"
	aRet[01] := aCusto
	aRet[02] := aCustoFF
	aRet[03] := aRetPartes
	aRet[04] := aCustoRep
	Return aRet
Else
	Return aCusto
EndIf

/*


Ŀ
Funo     ExistFecha Autor  Jose Lucas            Data  13.04.94 
Ĵ
Descrio  Nao permitir a movimentacao do produto com data de emissao 
           anterior a data de fechamento.                             
Ĵ
Sintaxe    ExpL1 := ExistFecha(ExpD1)                                 
Ĵ
Parametros ExpL1 = retorno da funcao .T. ou .F.                       
           ExpD1 = Data da geracao do movimento SD1, SD2 e SD3.       
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function ExistFecha(dData)
LOCAL cSavAlias := Alias()
LOCAL dDataFec := MVUlmes()
LOCAL lRet := .T.

//Ŀ
// Verificar data do ultimo fechamento em SX6.                  
//
If dDataFec >= dData
	Help ( " ", 1, "FECHTO" )
	lRet := .F.
EndIf
dbSelectArea(cSavAlias)
Return( lRet )

/*


Ŀ
Funo     TransAut  Autor  Jose Lucas             Data  15.04.94 
Ĵ
Descrio  Transferencia de materiais de um almoxarifado para outro   
           almoxarifado indisponivel CQ.                              
Ĵ
Sintaxe    TransAut(ExpC1,ExpC2,ExpC3,ExpC4,ExpC5,ExpC6,ExpN1,ExpC7 ,;
           ExpC8, ExpC9).                                             
Ĵ
Parametros ExpC1 = Codigo Produto Original                            
           ExpC2 = Unidade Original                                   
           ExpC3 = Local Original                                     
           ExpC4 = Codigo Produto Destino                             
           ExpC5 = Unidade de Destino                                 
           ExpC6 = Local de Destino                                   
           ExpN7 = Quantidade                                         
           ExpC8 = Numero do Lote                                     
           ExpC9 = Numero do controle do Lote                         
           ExpC10= Expressao chave do SD1                             
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function TransAut(cCodOrig,cUmOrig,cLocOrig,cCodDest,cUmDest,cLocDest,nQuant,cNumLote,cLoteCtl,cChaveD1)

//Ŀ
// Define Variaveis                                             
//
LOCAL cSaveArea := Alias(), nRegistro := RecNo()
LOCAL cCusMed
LOCAL cNumSeq
LOCAL lDigita,lAglutina
LOCAL nQtSegUm := 0.00
LOCAL cArq
LOCAL lRet := .T.
LOCAL aCtbDia := {}
//Ŀ
// Verifica se dados de origem sao iguais aos dados destino.    
//
If cCodOrig+cUmOrig+cLocOrig == cCodDest+cUmDest+cLocDest
	//Ŀ
	// Restaura a integridade dos Dados.                            
	//
	dbSelectArea(cSaveArea)
	dbGoTo(nRegistro)
	lRet := .F.
EndIf

If lRet
	//Ŀ
	// Verifica se dados de origem sao iguais aos dados destino.    
	//
	dbSelectArea("SB1")
	dbSetOrder(1)
	dbSeek(xFilial("SB1")+cCodOrig )
	nQtSegUm := ConvUm(B1_COD,nQuant,0,2)

	//Ŀ
	// Pega a variavel que identifica se o calculo do custo e' :    
	//               O = On-Line                                    
	//               M = Mensal                                     
	//
	cCusMed := SuperGetMv("MV_CUSMED",.F.,"M")

	//Ŀ
	// Verifica se o custo medio e' calculado On-Line               
	//
	If cCusMed == "O"

		PRIVATE nHdlPrv // Endereco do arquivo de contra prova dos lanctos cont.

		PRIVATE lCriaHeader := .T. // Para criar o header do arquivo Contra Prova

		PRIVATE cLoteEst 	// Numero do lote para lancamentos do estoque
		//Ŀ
		// Posiciona numero do Lote para Lancamentos do Faturamento     
		//
		dbSelectArea("SX5")
		dbSeek(xFilial("SX5")+"09EST")
		cLoteEst:=IF(Found(),Trim(X5Descri()),"EST ")

		PRIVATE nTotal := 0 	// Total dos lancamentos contabeis

		PRIVATE cArquivo	// Nome do arquivo contra prova

		//Ŀ
		// Carregar arquivo de perguntas.                                 
		//
		Pergunte("MTA260",.F.)

	EndIf
	//Ŀ
	// Verifica se o custo medio e' calculado On-Line               
	//
	If cCusMed == "O"
		//Ŀ
		// Se necessario cria o cabecalho do arquivo de prova           
		//
		If lCriaHeader
			lCriaHeader := .F.
			nHdlPrv := HeadProva(cLoteEst,"MATA260",Subs(cUsuario,7,6),@cArquivo)
			If nHdlPrv <= 0
				//Ŀ
				// Restaura a integridade dos Dados.                            
				//
				dbSelectArea(cSaveArea)
				dbGoTo(nRegistro)
				lRet := .F.
			EndIf
		EndIf
	EndIf

	If lRet
		//Ŀ
		// Atualiza arquivo de saldos em estoque      
		//
		dbSelectArea("SB1")
		dbSeek(xFilial("SB1")+cCodOrig)
		dbSelectArea("SB2")
		dbSetOrder(1)
		If (!MsSeek(xFilial("SB2")+cCodOrig+cLocOrig ))
			CriaSB2(cCodOrig,cLocOrig)
		EndIf
		RecLock("SB2",.F.)

		//Ŀ
		// Pega o proximo numero sequencial de movimento      
		//
		cNumSeq := ProxNum()

		//Ŀ
		// Verifica se o custo medio e' calculado On-Line               
		//
		If cCusMed == "O"
			//Ŀ
			// Gera o lancamento no arquivo de prova           
			//
			nTotal+=DetProva(nHdlPrv,"670","MATA260",cLoteEst)
		EndIf
		dbSelectArea("SB2")
		dbSetOrder(1)
		If !MsSeek(xFilial("SB2")+cCodDest+cLocDest)
			CriaSB2(cCodDest,cLocDest)
		EndIf
		RecLock("SB2",.F.)

		//Ŀ
		// Verifica se o custo medio e' calculado On-Line               
		//
		If cCusMed == "O"
			//Ŀ
			// Gera o lancamento no arquivo de prova           
			//
			nTotal+=DetProva(nHdlPrv,"672","MATA260",cLoteEst)
		EndIf

		//-- Inclui o Produto no CQ
		If !Empty(cChaveD1)
			cArq := 'SD1'
			fGeraCQ0(cArq, cCodOrig, 'CP')
		EndIf

		If cCusMed == "O"
			If !lCriaHeader
				lDigita   := IF(mv_par01 == 1,.T.,.F.)
				lAglutina := IF(mv_par02 == 1,.T.,.F.)

				//Ŀ
				// Se ele criou o arquivo de prova ele deve gravar o rodape'    
				//
				RodaProva(nHdlPrv,nTotal)
				If (  UsaSeqCor() )
					aCtbDia := {{"SD3",SD3->(RECNO()),SD3->D3_DIACTB,"D3_NODIA","D3_DIACTB"}}
				Else
	    			aCtbDia := {}
				EndIF
				cA100Incl(cArquivo,nHdlPrv,3,cLoteEst,lDigita,lAglutina,,,,,,aCtbDia)
				lCriaHeader := .T.
			EndIf
		EndIf
	EndIf
EndIf
//Ŀ
// Restaura a integridade dos Dados.                            
//
dbSelectArea(cSaveArea)
dbGoTo(nRegistro)

Return lRet

/*

Ŀ
Funo     CriaLote  Autor  Ary Medeiros           Data  02.07.93 
Ĵ
Descrio  Cria lote para um produto                                  
Ĵ
Parametros ExpC1 = Alias de origem (de onde a funcao e' chamada)      
           ExpC2 = Produto                                            
           ExpC3 = Local                                              
           ExpC4 = Lote                                               
           ExpC5 = SubLote                                            
           ExpC6 = Lote do Fornecedor                                 
           ExpC7 = Cliente                                            
           ExpC8 = Loja                                               
           ExpC9 = Tipo do Movimento                                  
           ExpC10= Origem do Lancamento                               
           ExpC11= Chave do SB8                                       
           ExpC12= Numero Sequencial                                  
           ExpC13= Documento                                          
           ExpC14= Serie do Documento                                 
           ExpC15= Ordem de Producao                                  
           ExpN1 = Quantidade                                         
           ExpN2 = Quantidade 2a. UM                                  
           ExpD1 = Data de Criacao do Lote                            
           ExpD2 = Data de Validade do Lote                           
           ExpL1 = Indica se cria lote para implantacao de saldos     
           ExpN3 = Potencia do Lote a ser criado                      
           ExpC16= Lote produzido                                     
           ExpC17= Sub-Lote produzido                                 
Ĵ
 Uso       Generico                                                   
Ĵ
Revisao    Rodrigo de A. Sartorio                    Data   23/02/99
ٱ


*/
Function CriaLote(cAlias,cProduto,cLocal,cLoteCtl,cNumLote,cLoteFor,cCliFor,cLoja,cTm,cOrigLan,cChave,cNumSeq,cDoc,cSerie,cOp,nQuant,nQuant2UM,dData,dDtValid,lCrialote,nPotencia,cLotePrd,cSubLotePrd,dDataFabric,cNumDesp,lAgregaOri)

Static lFiCrialo:= Nil
Static lMTGRVLOT := NIL

Local nRegOrig	:= 0
Local nRegSeek	:= 0
Local aArea		:= GetArea()
Local aAreaSB1	:= {}
Local lGeraAuto := Empty(cLoteCtl) //identifica gerao de numerao automtica

DEFAULT cLotePrd   := ""
DEFAULT cSubLotePrd:= ""
DEFAULT dDataFabric:= dDataBase
DEFAULT cNumDesp   := ""

lMTGRVLOT := iif(lMTGRVLOT==NIL, ExistBlock("MTGRVLOT"), lMTGRVLOT)

//Ŀ
// MV_LOTEUNI = TRUE  -> Utiliza o conceito de LOTE UNICO para produtos com rastreabilidade do tipo LOTE 
//                       Neste caso o SUB-LOTE nunca serah preenchido.                                   
//                       ATENCAO! Para ativacao deste parametro deve-se executar antes a rotina UPDEST08 
//              FALSE -> Cada inclusao saldos no SB8 irah criar um novo SUB-LOTE                         
//
If SuperGetMV('MV_LOTEUNI', .F., .F.)
	CriaLote2(cAlias, ;
		cProduto, ;
		cLocal, ;
		@cLoteCtl, ;
		@cNumLote, ;
		cLoteFor, ;
		cCliFor, ;
		cLoja, ;
		cTm, ;
		cOrigLan, ;
		cChave, ;
		cNumSeq, ;
		cDoc, ;
		cSerie, ;
		cOp, ;
		nQuant, ;
		nQuant2UM, ;
		dData, ;
		@dDtValid, ;
		lCrialote, ;
		@nPotencia, ;
		cLotePrd, ;
		cSubLotePrd,;
		dDataFabric,;
		cNumDesp,;
		lAgregaOri)
	Return Nil
EndIf

If lFiCrialo == Nil
	lFiCrialo := ExistBlock('FICRIALO') //-- A verificacao sera executada somente uma vez
EndIf

//Ŀ
// Preenche parametros nao recebidos pela funcao         
//
dData     := IF(dData == NIL .Or. !(ValType(dData) == "D") .Or. Empty(dData),dDataBase,dData)
cChave    := IF(cChave == NIL,"",cChave)
cLoteFor  := IF(cLoteFor == NIL,"",cLoteFor)
nQuant2UM := If(nQuant2UM == NIL, ConvUM(cProduto, nQuant, 0, 2),ConvUM(cProduto, nQuant, nQuant2UM,2))
lCriaLote := If(ValType(lCriaLote) # "L",.F.,lCrialote)
nPotencia := If(nPotencia == NIL, 0,nPotencia)

dbSelectArea("SB1")
aAreaSB1:=GetArea()
dbSetOrder(1)
dbSeek(xFilial("SB1")+cProduto)
// Descobre a data de validade
If !(ValType(dDtValid) == "D") .Or. Empty(dDtValid)
	If SB1->B1_FILIAL+SB1->B1_COD == xFilial("SB1")+cProduto
		dDtValid:=dData+SB1->B1_PRVALID
	Else
		dDtValid:=dData
	EndIf
EndIf
// Descobre a POTENCIA do lote
If nPotencia == 0 .And. (SB1->B1_FILIAL+SB1->B1_COD == xFilial("SB1")+cProduto)
	nPotencia:=SB1->B1_POTENCI
EndIf
RestArea(aAreaSB1)

// Descobre o sub-lote
cNumLote := If(cNumLote == Nil,NextLote(cProduto,"S"),IF(Empty(cNumLote),NextLote(cProduto,"S"),cNumLote))
// Descobre o lote
cLoteCtl := If(Empty(cLoteCtl),NextLote(cProduto,"L",cNumLote),cLoteCtl)
cLoteCtl := If(Empty(cLoteCtl),"AUTO"+cNumLote,cLoteCtl)

Reclock(cAlias,.F.)
Replace &(Substr(cAlias,2,2)+"_LOTECTL") With cLoteCtl
If Rastro(cProduto,"S") .Or. cAlias == "SD5"
	Replace &(Substr(cAlias,2,2)+"_NUMLOTE") With cNumLote
EndIf
MsUnlock()
//Atualizacao do lote na etiqueta do produto - SIGAACD
If lGeraAuto .And. cAlias == "SD1" .And. UsaCB0("01")
	CBAtuLote(cLoteCtl,cNumLote,dDtValid)
EndIf

dbSelectArea("SB8")
RecLock("SB8",.T.)
Replace	B8_FILIAL  with xFilial("SB8"),;
	B8_NUMLOTE with cNumLote,;
	B8_PRODUTO with cProduto,;
	B8_LOCAL   with cLocal,;
	B8_DATA    with dData,;
	B8_DTVALID with dDtValid,;
	B8_SALDO   with nQuant,;
	B8_SALDO2  with nQuant2UM,;
	B8_ORIGLAN with cOrigLan,;
	B8_LOTEFOR with cLoteFor,;
	B8_DOC     with cDoc,;
	B8_SERIE   with cSerie,;
	B8_CLIFOR  with cCliFor,;
	B8_LOJA    with cLoja,;
	B8_QTDORI  with nQuant,;
	B8_QTDORI2 with nQuant2UM,;
	B8_LOTECTL with cLoteCtl,;
	B8_POTENCI with nPotencia,;
	B8_DFABRIC with	dDataFabric


If cAlias=='SD1' .And. (cPaisLoc <> "BRA")
	Replace B8_NUMDESP With (cAlias)->D1_NUMDESP
	Replace B8_ORIGEM  With (cAlias)->D1_ORIGEM
	Replace B8_ITEM	With (cAlias)->D1_ITEM
ElseIf cAlias=='SD3' .And. (cPaisLoc <> "BRA")
	Replace B8_NUMDESP With cNumDesp
EndIf

MsUnlock()

If cAlias == "SD3" .And. Type("aLotPrdAut") == "A"
	aAdd(aLotPrdAut,{	cOp,;
								cProduto,;
								cLocal,;
								cNumLote,;
								cLoteCtl})
EndIf

If lMTGRVLOT
	ExecBlock("MTGRVLOT",.F.,.F.)
EndIf
// Verifica se a data de validade pode ser utilizada
nRegOrig:=Recno()
If dbSeek(xFilial("SB8")+cProduto+cLocal+cLoteCtl+IF(Rastro(cProduto,"S"),cNumLote,""))
	nRegSeek	:= Recno()
	If	dDtValid # SB8->B8_DTVALID
		HelpAutoma(" ",1,"A240DTVALI")
		dDtValid:=SB8->B8_DTVALID
		// Grava no registro o Lote e a Data de Validade
		dbGoto(nRegOrig)
		RecLock("SB8",.F.)
		Replace	B8_DTVALID with dDtValid
		MsUnlock()
	EndIf
	dbGoto(nRegSeek) //-- Retorna ao registro encontrado no dbSeek
	If nPotencia # SB8->B8_POTENCI
		Help(" ",1,"POTENCORI")
		nPotencia:=SB8->B8_POTENCI
		// Grava no registro o Lote e a POTENCIA
		dbGoto(nRegOrig)
		RecLock("SB8",.F.)
		Replace	B8_POTENCI with nPotencia
		MsUnlock()
	EndIf
EndIf
dbGoto(nRegOrig)

If (cAlias != "SD5" .And. !lCrialote)
	GravaSD5(cAlias,cProduto,cLocal,cLoteCtl,cNumLote,cNumSeq,cDoc,cSerie,cOp,cTm,cCliFor,cLoja,cLoteFor,nQuant,nQuant2UM,dData,dDtValid,nPotencia,cLotePrd,cSubLotePrd)
EndIf
If aArea[1] # "SB8"
	RestArea(aArea)
EndIf
//Ŀ
// Ponto de entrada no final da CriaLote 
//
If lFiCrialo
	ExecBlock('FICRIALO', .F., .F.)
Endif
Return NIL

/*

Ŀ
Funo     NextLote  Autor  Ary Medeiros           Data  02.07.93 
Ĵ
Descrio  Retorna proximo numero de lote                             
Ĵ
Sintaxe    ExpC1 := NextLote(ExpC2,ExpC3)                             
Ĵ
Parametros ExpC1 - Retorno do proximo Lote (caracter)                 
           ExpC2 - Codigo do Produto a ter o proximo lote gerado      
           ExpC3 - Tipo do Lote a ser gerado (S Sub-Lote L Lote)      
Ĵ
 Uso       Generico                                                   
Ĵ
Revisao    Rodrigo de A. Sartorio / Sergio Silveira  Data   22/10/97
ٱ


*/
Function NextLote(cCod,cTipo,cSubLote)
Local cAlias := Alias(),nRecno:=0,nOrder:=0,cRet:=""
Local cNumLote:=""
LOCAL lxProxLot := ExistBlock("XPROXLOT")
cCod:=IF(cCod==NIL,"",cCod)
cTipo:=IF(cTipo==NIL,"S",cTipo)
cSubLote:=IF(cSubLote==NIL,"",cSubLote)
// Proximo numero qdo usa lote+sublote
If cTipo == "S"
	If lxProxLot
		cNumLote:=Soma1(GetMV('MV_PRXLOTE'))
		// Execblock para manipular o numero do sub-lote
		cRet:=ExecBlock("XPROXLOT",.F.,.F.,{cNumLote})
		If ValType(cRet) == "C"
			cNumLote:=cRet
			Return cNumLote
		Else
			cNumLote:=""
		EndIf
	EndIf
	If GetMV('MV_PRXLOTE', .T.)
		cNumLote := Right(Alltrim(GetMV('MV_PRXLOTE')),6)
		PutMV('MV_PRXLOTE', Soma1(cNumLote))
	EndIf
	dbSelectArea(cAlias)
	// Proximo numero qdo usa lote
ElseIf cTipo == "L"
	If cAlias # "SB1"
		dbSelectArea("SB1")
	Else
		nRecno:=Recno()
		nOrder:=IndexOrd()
	EndIf
	dbSetOrder(1)
	If MsSeek(xFilial("SB1")+cCod)
		If !Empty(B1_FORMLOT)
			cNumLote:=Formula(B1_FORMLOT)
		Else
			cNumLote:=Formula(GetMV("MV_FORMLOT"))
		EndIf
	EndIf
	If cNumLote == NIL
		cNumLote:=""
	EndIf
	If Empty(cNumLote)
		If GetMV('MV_PRXLOTC', .T.)
			cNumLote := Right(Alltrim(GetMV('MV_PRXLOTC')),10)
			If !Empty(cNumLote)
				PutMV('MV_PRXLOTC', Soma1(cNumLote))
			EndIf
			dbSelectArea(cAlias)
		EndIf
		If Empty(cNumLote)
			If Empty(cSubLote)
				cSubLote:=NextLote(cCod,"S")
			EndIf
			cNumLote:="AUTO"+cSubLote
		EndIf
	EndIf
	If cAlias == "SB1"
		dbSetOrder(nOrder)
		dbGoto(nRecno)
	Else
		dbSelectArea(cAlias)
	EndIf
EndIf
Return cNumLote

/*

Ŀ
Funo    MovLote    Autor  Rodrigo de A. Sartorio Data  23.02.99 
Ĵ
Descrio  Faz movimentacao referente a Lotes/Sub-Lotes/Localizacao   
Ĵ
Parametros                                                            
        01 ExpC1 = Alias Oigem da Movimentacao                        
        02 ExpC2 = Produto                                            
        03 ExpC3 = Almoxarifado                                       
        04 ExpC4 = Localizacao                                        
        05 ExpC5 = Numero de Serie                                    
        06 ExpC6 = Lote                                               
        07 ExpC7 = Sub-Lote                                           
        08 ExpC8 = Numero Sequencial                                  
        09 ExpC9 = Tipo do Movimento                                  
        10 ExpC10= Cliente                                            
        11 ExpC11= Loja                                               
        12 ExpC12= Lote do Fornecedor                                 
        13 ExpC13= Origem do Lancamento                               
        14 ExpC14= Chave de Gravacao do SD5                           
        15 ExpC15= Documento                                          
        16 ExpC16= Serie do Documento                                 
        17 ExpC17= Ordem de Producao                                  
        18 ExpC18= Sequencia Empenho                                  
        19 ExpC19= Pedido de Venda                                    
        20 ExpC20= Item do Pedido de Venda                            
        21 ExpC21= Sequencia de Liberacao                             
        22 ExpN1 = Quantidade                                         
        23 ExpN2 = Quantidade na 2a. UM                               
        24 ExpD1 = Data de Movimentacao                               
        25 ExpD2 = Data de Validade                                   
        26 ExpL1 = Flag que indica se baixa empenho (Producao)        
        27 ExpL2 = Flag que indica se material aprop. indireta        
        28 ExpL3 = Flag que indica que Movimento  um estorno         
        29 ExpL4 = Flag que indica se Gera Novo Sub-Lote              
        30 ExpL5 = Flag que indica se manda produto para Distribuicao 
                   e se grava empenho no Lote Recem Criado            
        31 ExpC22= Origem do movimento (usado p/ atualizar SDC)       
        32 ExpL6 = Flag que indica se considera produtos vencidos     
        33 ExpL7 = Flag que indica se baixa empenho nos arqs SB8/SBF  
        34 ExpC23= cEstFis    - Estrutura Fisica          (APDL)      
        35 ExpC24= cServico   - Servico                   (APDL)      
        36 ExpC25= cTarefa    - Tarefa                    (APDL)      
        37 ExpC26= cAtividade - Atividade                 (APDL)      
        38 ExpC27= cAnomalia  - Houve Anomalia? (S/N)     (APDL)      
        39 ExpC28= cEstDest   - Estrututa Fisica Destino  (APDL)      
        40 ExpC29= cEndDest   - Endereco Destino          (APDL)      
        41 ExpC30= cHrInicio  - Hora Inicio               (APDL)      
        42 ExpC31= cAtuEst    - Atualiza Estoque? (S/N)   (APDL)      
        43 ExpL08= Indica se reposiciona SB8 (.T. ou .F.)             
        44 ExpC32= cCarga     - Numero da Carga           (APDL)      
        45 ExpC33= cUnitiza   - Numero do Unitizador      (APDL)      
        46 ExpC34= cOrdTar    - Ordem da Tarefa           (APDL)      
        47 ExpC35= cOrdAti    - Ordem da Atividade        (APDL)      
        48 ExpC36= cRHumano   - Recurso Humano            (APDL)      
        49 ExpC37= cRFisico   - Recurso Fisico            (APDL)      
        50 ExpN3 = Potencia do Lote a ser criado                      
        51 ExpN4 = Forca a acao para tomar quando se apaga uma saida  
                   com localizacao fisica (Sobrepoe o parametro       
                   MV_PDEVLOC)                                        
        52 ExpL8 = Indica se gera devolucao                           
        53 ExpC38= Lote produzido                                     
        54 ExpC39= Sub-Lote produzido                                 
        55 ExpC40= Numero da OP referente a Perda                     
        56 ExpA01= Array com o Log de execucao da MOVLOTE             
        57 ExpD03= Data de Fabricao					              
Ĵ
 Uso       Generico                                                   
Ĵ
Revisao    Rodrigo de A. Sartorio (Sub. Baixalote)   Data   23/02/99
ٱ


*/
Function MovLote(cAlias,cProduto,cLocal,cLocaliz,cNumSerie,cLoteCtl,cNumLote,cNumSeq,cTm,cCliFor,cLoja,cLoteFor,cOrigLan,cChave,cDoc,cSerie,cOp,cTrt,cPedido,cItem,cSeqLib,nQuant,nQuant2UM,dData,dDtValid,lBaixaEmp,lApropri,lEstorno,lCriaNew,lDistribui,cOrigem,lConsVenc,lBxEmpB8,cEstFis,cServico,cTarefa,cAtividade,cAnomalia,cEstDest,cEndDest,cHrInicio,cAtuEst,lPosSB8,cCarga,cUnitiza,cOrdTar,cOrdAti,cRHumano,cRFisico,nPotencia,nPDevLoc,lGeraDev,cLotePrd,cSubLotePrd,cPerdaOP,aLogMov,dDataFabric,cNumDesp,lAtuSB2,dVencLote,lUsaB8Emp,lDtFabric,lAgregaOri, lRmOrdSep, cOpOrig )
Local aArea   := GetArea()
Local aAreaSB1:= SB1->(GetArea())
Local aAreaSB2:= SB2->(GetArea())
Local aAreaSB8:= SB8->(GetArea())
Local aAreaSBF:= SBF->(GetArea())
Local aAreaSD4:= SD4->(GetArea())
Local aAreaSD5:= SD5->(GetArea())
Local aAreaSDA:= SDA->(GetArea())
Local aAreaSDB:= SDB->(GetArea())

Local aArray      :={}
Local aTravas     :={}
Local aRegistros  :={}
Local aCampos     :={}
Local aStruSDC    :={}

Local i           :=0
Local z           :=0
Local nBaixa      :=0
Local nSaldo      :=0
Local nBaixa2     :=0
Local nQuant2Baixa:=0
Local nQuantPMax  :=0
Local nQuantLoc2  :=0
Local nQuantLc22  :=0
Local nz          :=0
Local nX          :=0
Local nQtdSD5     :=0
Local nQtdSDB     :=0
Local nQtd2SD5    :=0
Local nQtd2SDB    :=0
Local nRecnoSDB   :=0
Local nDifSD5     :=0
Local nDifSDB     :=0
Local nDif2SD5    :=0
Local nDif2SDB    :=0
Local nQtdLog     :=0
Local nRecnoSB8   :=0
Local nQtMaior	  :=0
Local nQuantBaixa :=nQuant
Local nQuantEstSD5:=nQuant

Local lCriaSDA    :=.F.
Local lTemSDC     :=.F.
Local lNumSerDev  :=.F.
Local lRet		  :=.T.
Local lSeek       :=.F.
Local lPotencLote :=.F.

Local cSeek       :=""
Local cCompara    :=""
Local cSeekDC     :=""
Local cComparaDC  :=""
Local cArquivo    :=""
Local cTipoNf     :=""
Local cQuery      :=""
Local cIdDCF	  :=""
Local cIdMovto    :=""
Local cAliasSDC   :="SDC"

Local lLocaliz    := .F.
Local lRastro     := .F.
Local cLocCQ      := GetMvNNR('MV_CQ','98')
Local cEndPR1     := SuperGetMV('MV_ENDPR1',.F.,'ENDPR1')
Local nMultiplic  := If(cTm > "500",-1,1)
Local lPENSerDv   := ExistBlock("SD3NSDV")
Local lEmpPrev    := If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)
Local cTipoLote   := "N"
Local lMVPerdInf  := If(Type('lPerdInf')#"L",SuperGetMV('MV_PERDINF',.F.,.F.),lPerdInf)
Local cCF         := IIf(cAlias=='SD3',SD3->D3_CF,'')
Local lAchoPR1    := .F.
Local nTamLocaliz := TamSX3("BE_LOCALIZ")[1]
Local lWmsNew     := SuperGetMV("MV_WMSNEW",.F.,.F.)
Local lDevLj720	  := .F.
Local aInsert 	  := {}
Local nLen 		  := 0
Local nPosPrepared:= 0
Local cMD5 		  := ""

Default lRmOrdSep := .F.

__lCusaVLib := If(__lCusaVLib == NIL,FWLibVersion() >= "20211116",__lCusaVLib)

If Type("lAbreop") == "U"
	Private lAbreop := .T.
EndIf

SB1->(DbSetOrder(1))
SB1->(DbSeek(xFilial("SB1") + cProduto))

lLocaliz    := Localiza(cProduto, .T.)
lRastro     := Rastro(cProduto)
cTipoLote   := If(Rastro(cProduto),If(Rastro(cProduto,"S"),"S","L"),"N")

//Ŀ
// No Movimenta Lote para Notas de Frete ou Importao  
// ou quando a quantidade do movimento e igual a zero    
//
If (Type('lConFrete') == 'L' .And. !lConFrete) .Or. ;
   (Type('lConImp')   == 'L' .And. !lConImp) .Or. QtdComp(nQuant,.t.) == QtdComp(0)
	lRet := .F.
EndIf

If Type('aParam150')=='A'
	cIdDCF   := Iif(Len(aParam150)>=32,aParam150[32],' ')
	cIdMovto := Iif(Len(aParam150)>=34,aParam150[34],' ')
EndIf

If lRet
	//Ŀ
	// Salva status atual das areas que serao atualizadas    
	//
	dbSelectArea("SB2")
	If xFilial("SB2")+cProduto+cLocal <> SB2->B2_FILIAL+SB2->B2_COD+SB2->B2_LOCAL
		dbSetOrder(1)
		If !MsSeek(xFilial("SB2")+cProduto+cLocal)
			//Ŀ
			// Cria registro quando nao existir                      
			//
			CriaSB2(cProduto,cLocal)
		EndIf
	EndIf
	//Ŀ
	// Preenche parametros nao recebidos pela funcao         
	//
	cOp       := IF(cOp       == NIL,"",cOp)
	cDoc      := IF(cDoc      == NIL,Criavar("D5_DOC",.F.),cDoc)
	cItem     := IF(cItem     == NIL,"",cItem)
	cLoja     := IF(cLoja     == NIL,Criavar("D5_LOJA",.F.),cLoja)
	cSerie    := IF(cSerie    == NIL,Criavar("D5_SERIE",.F.),cSerie)
	cChave    := IF(cChave    == NIL,"",cChave)
	cCliFor   := IF(cCliFor   == NIL,Criavar("D5_CLIFOR",.F.),cCliFor)
	cOrigem   := IF(cOrigem   == NIL,cAlias,cOrigem)
	cPedido   := IF(cPedido   == NIL,"",cPedido)
	cSeqLib   := IF(cSeqLib   == NIL,"",cSeqLib)
	cLoteFor  := IF(cLoteFor  == NIL,"",cLoteFor)
	cLocaliz  := IF(cLocaliz  == NIL,"",cLocaliz)
	cNumLote  := IF(cNumLote  == NIL,CriaVar("B8_NUMLOTE", If(SuperGetMV('MV_LOTEUNI', .F., .F.), .F., Nil)),cNumLote)
	cLoteCtl  := IF(cLoteCtl  == NIL,CriaVar("B8_LOTECTL"),cLoteCtl)
	cNumSerie := IF(cNumSerie == NIL,"",cNumSerie)
	lApropri  := If(lApropri  == NIL,.F.,lApropri)
	lEstorno  := If(lEstorno  == NIL,.F.,lEstorno)
	lBaixaEmp := If(lBaixaEmp == NIL,.F.,lBaixaEmp)
	lBxEmpB8  := lBaixaEmp .And. If(lBxEmpB8  == NIL,lBaixaEmp,lBxEmpB8)
	lCriaNew  := If(lCriaNew  == NIL,.T.,lCriaNew)
	lDistribui:= If(lDistribui== NIL,.T.,lDistribui)
	nQuant2UM := If(nQuant2UM == NIL,ConvUm(cProduto,nQuant,0,2),nQuant2UM)
	lConsVenc := If(lConsVenc == NIL,SuperGetMV("MV_LOTVENC") == "S",lConsVenc)
	cEstFis   := If(cEstFis   == Nil,'',cEstFis)
	cServico  := If(cServico  == Nil,'',cServico)
	cTarefa   := If(cTarefa   == Nil,'',cTarefa)
	cAtividade:= If(cAtividade== Nil,'',cAtividade)
	cAnomalia := If(cAnomalia == Nil,'',cAnomalia)
	cEstDest  := If(cEstDest  == Nil,'',cEstDest)
	cEndDest  := If(cEndDest  == Nil,'',cEndDest)
	cHrInicio := If(cHrInicio == Nil,'',cHrInicio)
	cAtuEst   := If(cAtuEst   == Nil,'',cAtuEst)
	lPosSB8   := If(Valtype(lPosSB8) == "L",lPosSB8,.T.)
	cCarga    := If(cCarga    == Nil,'',cCarga)
	cUnitiza  := If(cUnitiza  == Nil,'',cUnitiza)
	cOrdTar   := If(cOrdTar   == Nil,'',cOrdTar)
	cOrdAti   := If(cOrdAti   == Nil,'',cOrdAti)
	cRHumano  := If(cRHumano  == Nil,'',cRHumano)
	cRFisico  := If(cRFisico  == Nil,'',cRFisico)
	nPotencia := If(nPotencia == NIL, 0,nPotencia)
	lGeraDev  := If(lGeraDev  == NIL,.F.,lGeraDev)
	cLotePrd  := If(cLotePrd == NIL,"",cLotePrd)
	cSubLotePrd:=If(cSubLotePrd == NIL,"",cSubLotePrd)
	aLogMov    :=If(aLogMov == NIL,{},aLogMov)
	lAtuSB2    :=If(lAtuSB2 == NIL,.T.,lAtuSB2)
	dDataFabric:=If(dDataFabric == NIL .or. dDataFabric == CTOD("  /  /  "),dDataBase,dDataFabric)
	cNumDesp   :=If(cNumDesp == NIL,"",cNumDesp)
	lUsaB8Emp  := If(lUsaB8Emp== Nil,.F.,lUsaB8Emp)
	lDtFabric  := If(lDtFabric== Nil,.F.,lDtFabric)
	cOpOrig    := If(cOpOrig== Nil,' ',cOpOrig)
	If lUsaB8Emp
		lEmpPrev := .F.
	EndIF
	nQuant2Baixa:=nQuant2UM
	//-- Verifica se possui integracao com WMS
	lIntDL     := IntDL()

	dbSelectArea("SDB")
	lExistOP := If (SDB->(ColumnPos("DB_OP")) >  0, .T., .F.)

	//Ŀ
	// Quando Material de Apropr. Indireta ou for um estorno,inverte movimento
	//
	If lApropri
		nMultiplic := IF(cTm > "500",1,-1)
		cTm        := StrZero(Val(cTm)+If(cTm>'500', -500, +500), Len(cTm))
		//Ŀ
		// Ponto de Entrada utilizado no MATA240.PRX para 		
		//| devolucao de material com apropriacao indireta.     |
		//
		If lPENSerDv
			lNumSerDev := ExecBlock("SD3NSDV",.f.,.f.) .And. cTm > '500'
		EndIf
	EndIf

	//Ŀ
	//Verifica se o estoque pode ser alterado                                 
	//
	If IIf(lAtuSB2,RecLock("SB2"),.T.)
		//Ŀ
		//Caso seja estorno de producao deve-se verificar se houve atualizacao de 
		//|empenho no momento da geracao do movimento interno (D3_EMPOP='N')       |
		//
		If lEstorno .And. cAlias=="SD3" .And. !Empty(SD3->D3_OP)
			If SD3->D3_EMPOP == 'N'
				lBaixaEmp := .F.
				lBxEmpB8  := .F.
			EndIf
		EndIf
		// Carrega Log de execucao da MOVLOTE
		TLogMov(@aLogMov,'100',,nQuant,cLoteCtl,cNumlote,nQuant,cLocaliz,cNumSerie,cAlias,cProduto,cLocal,cTm,cNumSeq,cOp,cDoc,cSerie,cItem,cCliFor,cLoja,cTipoLote,lEstorno,lBaixaEmp,lBxEmpB8,cPedido,cSeqLib,lLocaliz,lDistribui,cCF)
		//Ŀ
		// Cria movimento para Lote/Sub-Lote/Localizacao         
		//
		If !lEstorno .And. !IsProdMod(cProduto)
			//Ŀ
			// Verifica se utiliza rastreabilidade                   
			//
			If cTipoLote # "N"
				dbSelectArea("SB8")
				dbSetOrder(3)
				dbgotop()
				If cTipoLote == "S"
					cSeek:=xFilial("SB8")+cProduto+cLocal+cLoteCtl+cNumLote
					cCompara:="B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL+B8_NUMLOTE"
				ElseIf cTipoLote == "L"
					cSeek:=xFilial("SB8")+cProduto+cLocal+cLoteCtl
					cCompara:="B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL"
				EndIf
				lSeek:=MsSeek(cSeek)
				If cTipoLote == "S" .And. lApropri .And. lSeek .And. nMultiplic == 1
					Reclock("SB8",.F.)
					Replace B8_QTDORI With B8_QTDORI   + nQuantBaixa
					Replace B8_QTDORI2 With B8_QTDORI2 + nQuant2Baixa
					MsUnlock()
				EndIf
			EndIf

			lPotencLote := PotencLote(cProduto)

			//Ŀ
			// nMultiplic == 1 Significa que o movimento e' entrada  
			//
			If nMultiplic == 1
				TLogMov(@aLogMov,'101',STR0170,nQuant,cLoteCtl,cNumLote,nQuant,cLocaliz,cNumSerie) //"INICIO DE PROCESSAMENTO"
				If cTipoLote # "N"
					If IF(cTipoLote == "S",lCriaNew .And. !lSeek,lCriaNew)
						//Ŀ
						// Qdo for devolucao p/ Lote Novo cria o mesmo e grava   
						// o numero no registro origem                           
						//
						CriaLote(cAlias,cProduto,cLocal,@cLoteCtl,@cNumLote,cLoteFor,cCliFor,cLoja,cTm,cOrigLan,cChave,cNumSeq,cDoc,cSerie,cOp,nQuant,nQuant2UM,dData,dDtValid,NIL,nPotencia,cLotePrd,cSubLotePrd,dDataFabric,cNumDesp,lAgregaOri)
						TLogMov(@aLogMov,'102',STR0171,nQuant,cLoteCtl,cNumlote) //"Criacao de Lote/SubLote"
						nQtdSD5   := nQuant
						nRecnoSB8 := SB8->(Recno())
						//Ŀ
						// Flag utilizado para gravar empenho na criacao do lote 
						// (utilizado somente quando gera Producao Automatica)   
						//
						If !lDistribui .And. !(cLocal==cLocCQ) .And. !(lApropri)
							GravaB8Emp("+",nQuant,"F",,nQuant2UM)
						EndIf
					Else
						//Ŀ
						// Qdo for devolucao p/ Lote ja existente apenas atualiza
						// o saldo                                               
						//
						TLogMov(@aLogMov,'103',STR0172,nQuantBaixa,cLoteCtl,cNumlote) //"Inicio do Processo de Devolucao de saldo para Lote/SubLote ja Existente"
						nQtdSD5 := 0
						While QtdComp(nQuantBaixa) > QtdComp(0) .And. cSeek == &(cCompara)
							Reclock("SB8",.F.)
							If QtdComp(B8_QTDORI) >= QtdComp(SB8SALDO(,,,,,lEmpPrev,,,.T.)) .Or. (Trim(cDoc) == "INVENT" .And. cAlias == "SD3") .Or.;
								(cAlias == "SD1" .And. SD1->D1_TIPO == "D") .Or. (cAlias == "SD3" .And. SD3->D3_CF == "DE4")
								If (Trim(cDoc) == "INVENT" .And. cAlias == "SD3") .Or. (cAlias == "SD1" .And. SD1->D1_TIPO == "D") .Or.;
									(cAlias == "SD3" .And. SD3->D3_CF == "DE4")
									nBaixa   := nQuantBaixa
									nBaixa2  := nQuant2Baixa
								Else
									nBaixa   := Min(B8_QTDORI  - B8_SALDO ,nQuantBaixa)
									nBaixa2  := Min(B8_QTDORI2 - B8_SALDO2,nQuant2Baixa)
								EndIf
								GravaSD5(cAlias,cProduto,cLocal,SB8->B8_LOTECTL,SB8->B8_NUMLOTE,cNumSeq,cDoc,cSerie,cOp,cTm,cCliFor,cLoja,cLoteFor,nQuantBaixa,nQuant2Baixa,dData,SB8->B8_DTVALID,SB8->B8_POTENCI,cLotePrd,cSubLotePrd)
								TLogMov(@aLogMov,'104',STR0173,nQuantBaixa,SB8->B8_LOTECTL,SB8->B8_NUMLOTE) //"Atualizao do Registro SD5"
								nQtdSD5 += nQuantBaixa
								Replace SB8->B8_SALDO  With SB8->B8_SALDO  + Iif(cTipoLote == "S" .And. lSeek .And. IsInCallStack('MATA103') .And. SD1->D1_LOCAL <> SD2->D2_LOCAL ,nQuantBaixa ,nBaixa)
								Replace SB8->B8_SALDO2 With SB8->B8_SALDO2 + IiF(cTipoLote == "S" .And. lSeek .And. IsInCallStack('MATA103') .And. SD1->D1_LOCAL <> SD2->D2_LOCAL ,nQuant2Baixa,nBaixa2)
								Replace SB8->B8_DTVALID With dDtValid
								If (cDoc == "INVENT" .And. cAlias == "SD3") .Or. (cAlias == "SD1" .And. SD1->D1_TIPO == "D") .Or.;
									(cAlias == "SD3" .And. SD3->D3_CF == "DE4")
									If Rastro(cProduto,"L") .Or. (cAlias == "SD3" .And. SD3->D3_CF == "DE4")
										Replace SB8->B8_QTDORI  With SB8->B8_QTDORI  + nBaixa
										Replace SB8->B8_QTDORI2 With SB8->B8_QTDORI2 + nBaixa2
									EndIf
								EndIf
								nQuantBaixa  -= nBaixa
								nQuant2Baixa -= nBaixa2
							EndIf
							dbSelectArea("SB8")
							SB8->(MsUnlock())
							dbSkip()
						EndDo
						TLogMov(@aLogMov,'105',STR0174,nQtdSD5,cLoteCtl,cNumLote) //"Termino da Devolucao de saldo para o Lote/SubLote ja Existente"
					EndIf
				EndIf

				/*Se for uma devoluo de venda que foi gerada a partir do Controle de Lojas alteramos a varivel lDevLj720 para que a criao da SDA ocorra.*/
				If !Empty(cLocaliz) .And. IsInCallStack("LOJA720")
					lDevLj720 := .T.
				EndIf

				If lLocaliz .And. !(lWmsNew .And. IntDl(cProduto))
					If lApropri .Or. IIf(cPaisloc $ "ARG" .And. ((Alltrim(FunName()) $ "MATA102N|MATA101N") .Or. isBlind()), (Empty(cLocaliz).And.lDistribui), (Empty(cLocaliz).And.Empty(cNumSerie).And.lDistribui)) .Or. (IntDl(cProduto).And.!Empty(cServico).And.Empty(cTarefa).And.lDistribui) .Or. lDevLj720
						//Ŀ
						// Qdo for devolucao sem Localizacao/Numero de Serie     
						// cria registro no arquivo de saldos a distribuir (SDA) 
						//
						CriaSDA(cAlias,Nil,Nil,Nil,Nil,lApropri,lCriaNew,cNumLote)
						TLogMov(@aLogMov,'106',STR0175,,,,nQuant) //"Criacao do Saldo a Enderecar SDA"
						nQtdSDB := nQuant
					ElseIf !Empty(cLocaliz+cNumSerie)
						nRecnoSDB := 0
						nQtdLog   := 0
						CriaSDB(cProduto,cLocal,nQuant,cLocaliz,cNumSerie,cDoc,cSerie,cCliFor,cLoja,cTipoNf,cAlias,dData,cLoteCtl,cNumLote,cnumSeq,cTm,"M",StrZero(1,Len(SDB->DB_ITEM)),lEstorno,Nil,nQuant2UM,Nil,cEstFis,cServico,cTarefa,cAtividade,cAnomalia,cEstDest,cEndDest,cHrInicio,cAtuEst,cCarga,cUnitiza,cOrdTar,cOrdAti,cRHumano,cRFisico,,cIdDCF,@nRecnoSDB,cIdMovto,cOp)
						TLogMov(@aLogMov,'107',STR0206,nQuant,cLoteCtl,cNumLote,nQuant,cLocaliz,cNumSerie) //"Atualizao do Saldo por Endereco (SBF/SDB)"
						nQtdSDB := nQuant
						//Ŀ
						//Soma saldo em estoque por localizacao fisica (SBF)     
						//
						GravaSBF("SDB",,,nRecnoSDB,@nQtdLog)
						TLogMov(@aLogMov,'108',STR0207,nQtdLog,cLoteCtl,cNumLote,nQtdLog,cLocaliz,cNumSerie) //"Atualizao do Saldo por Endereco (SBF/SDB)"
					ElseIf !Empty(cOP) .And. cCF == "PR1"
        				SBE->(dbSetOrder(1)) //BE_FILIAL+BE_LOCAL+BE_LOCALIZ
        				If !SBE->(dbSeek(xFilial("SBE")+cLocal+cEndPR1))
							RecLock("SBE",.T.)
							Replace BE_FILIAL 	With xFilial("SBE")
							Replace BE_LOCAL  	With cLocal
							Replace BE_LOCALIZ	With cEndPR1
							MsUnlock()
        				EndIf
						nRecnoSDB := 0
						nQtdLog   := 0
						CriaSDB(cProduto,cLocal,nQuant,cEndPR1,cNumSerie,cDoc,cSerie,cCliFor,cLoja,cTipoNf,cAlias,dData,cLoteCtl,cNumLote,cNumSeq,cTm,"M",StrZero(1,Len(SDB->DB_ITEM)),lEstorno,Nil,nQuant2UM,Nil,cEstFis,cServico,cTarefa,cAtividade,cAnomalia,cEstDest,cEndDest,cHrInicio,cAtuEst,cCarga,cUnitiza,cOrdTar,cOrdAti,cRHumano,cRFisico,,cIdDCF,@nRecnoSDB,cIdMovto,cOp)
						TLogMov(@aLogMov,'107',STR0206,nQuant,cLoteCtl,cNumLote,nQuant,SBE->BE_LOCALIZ,cNumSerie) //"Atualizao do Saldo por Endereco (SBF/SDB)"
						nQtdSDB := nQuant
						//Ŀ
						//Soma saldo em estoque por localizacao fisica (SBF)     
						//
						GravaSBF("SDB",,,nRecnoSDB,@nQtdLog)

						//Ŀ
						// Flag utilizado para gravar empenho na criacao do lote 
						// (utilizado somente quando gera Producao Automatica)   
						//
						If lRastro
							dbSelectArea("SB8")
							dbGoto(nRecnoSB8)
							GravaB8Emp("-",nQuant,"F",,nQuant2UM)
							SB8->(MsUnlock())
						EndIf
						//Ŀ
						//Atualiza o empenho para o produto Producao Automatica  
						//
						dbSelectArea("SBF")
						GravaEmp(cProduto, cLocal, nQuant,nQuant2UM,cLoteCtl,cNumLote,;
								 cEndPR1, NIL, cOP, cTrt, NIL, NIL, "SD3", NIL, NIL,;
								 @aTravas, .F., NIL, .F., .F., NIL,.T.,.T.)
						TLogMov(@aLogMov,'108',STR0207,nQtdLog,cLoteCtl,cNumLote,nQtdLog,cLocaliz,cNumSerie) //"Atualizao do Saldo por Endereco (SBF/SDB)"
					EndIf
				EndIf
				If lBaixaEmp
					If lGeraDev
						If SB2->B2_SALPEDI > 0
							GravaB2Pre("-",nQuant,"F")
						Endif
					Else
						If !Empty(cPedido).And.!Empty(cItem)
							GravaB2Emp("+",nQuant,,.T., nQuant2UM )
						ElseIf !Empty(cOp)
							GravaB2Emp("+",nQuant,,,nQuant2UM)
						EndIf
					Endif
				EndIf
				TLogMov(@aLogMov,'199',STR0177,nQtdSD5,cLoteCtl,cNumLote,nQtdSDB,cLocaliz,cNumSerie) //"TERMINO DE PROCESSAMENTO"
				//Ŀ
				// nMultiplic == -1 Significa que o movimento e' saida   
				//
			ElseIf nMultiplic == -1
				//Ŀ
				//Verifica disponibilidade caso o movimento seja uma     
				//requisicao sem localizacao empenhada.                  
				//
				If !lBaixaEmp .Or. (lBaixaEmp .And. (!lLocaliz .Or. !lBxEmpB8))
					aArray:=SldPorLote(cProduto,cLocal,nQuant,nQuant2UM,cLoteCtl,cNumLote,cLocaliz,cNumSerie,@aTravas,lBxEmpB8,NIL,lConsVenc,NIL,NIL,dData,,IIf(lMVPerdInf,cPerdaOP,Nil),,,lAtuSB2)
					TLogMov(@aLogMov,'201',STR0178,nQuant,cLoteCtl,cNumLote,nQuant,cLocaliz,cNumSerie) //"INICIO DE PROCESSAMENTO BAIXA DE REQUISICAO SEM LOCALIZACAO EMPENHADA (SLDPORLOTE)"
					nQtdSD5   :=0
					nQtdSDB   :=0
					nQtd2SDB  :=0
					nQtd2SD5  :=0
					nQuantPMax:=0
					For i:=1 to Len(aArray)
						// Caso utilize registros da Rastreabilidade tira saldo e/ou empenho no SB8
						dbSelectArea("SB8")
						If lRastro
							If Len(aArray[i,10]) > 0
								For z:=1 to Len(aArray[i,10])
									dbGoto(aArray[i,10,z,1])
									Reclock("SB8",.F.)
									GravaSD5(cAlias,cProduto,cLocal,SB8->B8_LOTECTL,SB8->B8_NUMLOTE,cNumSeq,cDoc,cSerie,cOp,cTm,cCliFor,cLoja,cLoteFor,aArray[i,10,z,2],aArray[i,10,z,3],dData,SB8->B8_DTVALID,SB8->B8_POTENCI,cLotePrd,cSubLotePrd)
									TLogMov(@aLogMov,'203',STR0173,aArray[i,10,z,2],SB8->B8_LOTECTL,SB8->B8_NUMLOTE) //"Atualizao do Registro SD5"
									nQtdSD5 += aArray[i,10,z,2]
									nQtd2SD5+= aArray[i,10,z,3]
									If lPotencLote .And. (!lBxEmpB8 .Or. (lBxEmpB8 .And. Empty(cLoteCtl+cNumLote))) .And. !Empty(cOp)
										nQuantPMax+=A250PotMax(cProduto,SB8->B8_POTENCI,Min(SB8->B8_SALDO,aArray[i,10,z,2]))
									EndIf
									Replace SB8->B8_SALDO  With SB8->B8_SALDO  - Min(SB8->B8_SALDO,aArray[i,10,z,2])
									Replace SB8->B8_SALDO2 With SB8->B8_SALDO2 - Min(SB8->B8_SALDO2,aArray[i,10,z,3])
									If (lBxEmpB8 .And. QtdComp(SB8SALDO(.T.,,,,,lEmpPrev,,,.T.)) > QtdComp(0) .And. !Empty(cLoteCtl))
										GravaB8Emp("-",MAX(MIN(SB8->B8_EMPENHO, (aArray[i,10,z,2] - SD3->D3_QTMAIOR)),0) ,"F",NIL, If( Empty(aArray[i,10,z,3]),NIL,aArray[i,10,z,3]))
									EndIf
									MsUnlock()
								Next z
								//Pega lote obtido no posicionamento acima para nota de sada ter a data de fabricacao.
								If lDtFabric .And. (cAlias == "SD2") .And. Empty(SD2->D2_DFABRIC)
									RecLock("SD2", .F.)
									SD2->D2_DFABRIC := SB8->B8_DFABRIC
									SD2->(msUnLock())
								EndIf
							Else
								TLogMov(@aLogMov,'204',STR0179,nQuant,cLoteCtl,cNumLote) //"Nao foi Encontrado saldo por Lote na SLDPORLOTE"
							EndIf
						EndIf
						// Caso utilize registros da Localizacao Fisica tira saldo e/ou
						// empenho no SBF
						If lLocaliz .And. !(lWmsNew .And. IntDl(cProduto))
							If aArray[i,9] > 0
								dbSelectArea("SBF")
								dbGoto(aArray[i,9])
								RecLock("SBF")
								nRecnoSDB := 0
								CriaSDB(cProduto,cLocal,aArray[i,5],aArray[i,3],If(lNumSerDev,aArray[i,4],cNumSerie),cDoc,cSerie,cCliFor,cLoja,cTipoNf,cAlias,dData,aArray[i,1],aArray[i,2],cNumSeq,cTm,"M",StrZero(1,Len(SDB->DB_ITEM)),lEstorno,Nil,aArray[i,6],Nil,cEstFis,cServico,cTarefa,cAtividade,cAnomalia,cEstDest,cEndDest,cHrInicio,cAtuEst,cCarga,cUnitiza,cOrdTar,cOrdAti,cRHumano,cRFisico,,cIdDCF,@nRecnoSDB,cIdMovto,cOp)
								TLogMov(@aLogMov,'205',STR0176,aArray[i,5],aArray[i,1],aArray[i,2],aArray[i,5],aArray[i,3],aArray[i,4]) //"Atualizao do Saldo por Endereco (SBF/SDB)"
								nQtdSDB += aArray[i,5]
								nQtd2SDB+= aArray[i,6]
								//Ŀ
								//Soma saldo em estoque por localizacao fisica (SBF)     
								//
								GravaSBF("SDB",lBxEmpB8,,nRecnoSDB)
								SBF->(MsUnLock())
							Else
								TLogMov(@aLogMov,'206',STR0180,nQuant,cLoteCtl,cNumlote,nQuant,cLocaliz,cNumSerie) //"Nao foi Encontrado saldo por Endereco na SLDPORLOTE"
							EndIf
						EndIf
					Next i
					// Verifica Diferencas encontrada na baixa da SD5
					If lRastro
						nDifSD5  := nQuant-nQtdSD5
						nDif2SD5 := IIf(QtdComp(nQtd2SD5,.t.)==QtdComp(0),0,nQuant2UM-nQtd2SD5)
					EndIf
					// Verifica Diferencas encontrada na baixa da SDB
					If lLocaliz	.And. !(lWmsNew .And. IntDl(cProduto))
						nDifSDB  := nQuant   -nQtdSDB
						nDif2SDB := IIf(QtdComp(nQtd2SDB,.t.)==QtdComp(0),0,nQuant2UM-nQtd2SDB)
					EndIf
					If (lRastro .And. nDifSD5 > 0 ) .Or. (lLocaliz .And. nDifSDB > 0 )
						TLogMov(@aLogMov,'207',STR0181,nDifSD5,cLoteCtl,cNumLote,nDifSDB,cLocaliz,cNumSerie) //"Divergencia na Baixa de Saldo por Lote"
						If lRastro .Or. lLocaliz
							AtuSldMov(cProduto,cLocal,IIf(lRastro,nDifSD5,nDifSDB),IIf(lRastro,nDif2SD5,nDif2SDB),cLoteCtl,cNumLote,cLocaliz,cNumSerie,lBxEmpB8,lConsVenc,dData,cDoc,cSerie,cOp,cTm,cCliFor,cLoja,cLoteFor,cLotePrd,cSubLotePrd,@nQuantPMax,@aLogMov,@nQtdSD5,@nQtdSDB,lNumSerDev,cTipoNf,cAlias,cNumSeq,lEstorno,cEstFis,cServico,cTarefa,cAtividade,cAnomalia,cEstDest,cEndDest,cHrInicio,cAtuEst,cCarga,cUnitiza,cOrdTar,cOrdAti,cRHumano,cRFisico,cIdDCF,lEmpPrev,cIdMovto)
						EndIf
					EndIf
					TLogMov(@aLogMov,'299',STR0182,nQtdSD5,cLoteCtl,cNumLote,nQtdSDB,cLocaliz,cNumSerie) //"TERMINO DE PROCESSAMENTO BAIXA DE REQUISICAO SEM LOCALIZACAO EMPENHADA (SLDPORLOTE)"
				ElseIf lBaixaEmp .And. lLocaliz
					nQuantpMax:=0
					nQtdSDB   :=0
					nQtdSD5   :=0
					nQtd2SDB  :=0
					nQtd2SD5  :=0
					TLogMov(@aLogMov,'201',STR0183,nQuant,cLoteCtl,cNumLote,nQuant,cLocaliz,cNumSerie) //"INICIO DE PROCESSAMENTO DE BAIXA POR SDC"
					//Ŀ
					// Baixa empenhos a partir do SDC             
					//
					aInsert := {}
					Aadd(aInsert,RetSqlName("SDC"))
					Aadd(aInsert,xFilial("SDC"))

					cQuery := "SELECT SDC.*,R_E_C_N_O_ SDCRECNO "
					cQuery += "FROM ? SDC "
					cQuery += "WHERE SDC.DC_FILIAL= ? AND "

					dbSelectArea("SDC")
					If !Empty(cOp)
						dbSetOrder(2)
						cSeek    := xFilial("SDC")+cProduto+cLocal+cOp+cTrt
						cCompara := "DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT"
						Aadd(aInsert,cProduto)
						Aadd(aInsert,cLocal)
						Aadd(aInsert,cOp)
						Aadd(aInsert,cTrt)
						cQuery += "DC_PRODUTO= ? AND "
						cQuery += "DC_LOCAL= ? AND "
						cQuery += "DC_OP= ? AND "
						cQuery += "DC_TRT= ? AND "
					Else
						dbSetOrder(1)
						cSeek   := xFilial("SDC")+cProduto+cLocal+cOrigem+cPedido+cItem+cSeqLib
						cCompara:= "DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_ORIGEM+DC_PEDIDO+DC_ITEM+DC_SEQ"
						Aadd(aInsert,cProduto)
						Aadd(aInsert,cLocal)
						Aadd(aInsert,cOrigem)
						Aadd(aInsert,cPedido)
						Aadd(aInsert,cItem)
						Aadd(aInsert,cSeqLib)
						cQuery += "DC_PRODUTO= ? AND "
						cQuery += "DC_LOCAL= ? AND "
						cQuery += "DC_ORIGEM= ? AND "
						cQuery += "DC_PEDIDO= ? AND "
						cQuery += "DC_ITEM= ? AND "
						cQuery += "DC_SEQ= ? AND "
					EndIf
					If cTipoLote $ "S/L"
						If cTipoLote == "L"
							If !Empty(cLoteCtl)
								cSeek   += cLoteCtl
								cCompara+= "+DC_LOTECTL"
								Aadd(aInsert,cLoteCtl)
								cQuery += "DC_LOTECTL= ? AND "
							ElseIf !Empty(cOp)
								//Ŀ
								// Considera a Origem da Movimentacao para verificar se eh o registro do SDC correto 
								//
								Aadd(aInsert,cOrigem)
								cQuery += "DC_ORIGEM= ? AND "
							EndIf
						Else
							If !Empty(cLoteCtl+cNumLote)
								cSeek    += cLoteCtl+cNumLote
								cCompara += "+DC_LOTECTL+DC_NUMLOTE"
								Aadd(aInsert,cLoteCtl)
								Aadd(aInsert,cNumLote)
								cQuery += "DC_LOTECTL= ? AND "
								cQuery += "DC_NUMLOTE= ? AND "
							ElseIf !Empty(cOp)
								//Ŀ
								// Considera a Origem da Movimentacao para verificar se eh o registro do SDC correto 
								//
								Aadd(aInsert,cOrigem)
								cQuery += "DC_ORIGEM= ? AND "
							EndIf
						EndIf
					EndIf
					SDC->(dbCommit())
					aStruSDC := SDC->(dbStruct())
					cAliasSDC := "SDCMOVLOTE"
					If !Empty(cLocaliz)
						Aadd(aInsert,cLocaliz)
						cQuery += "DC_LOCALIZ= ? AND "
					EndIf
					cQuery += "SDC.D_E_L_E_T_=' ' "
					cQuery += "ORDER BY "+SqlOrder(SDC->(IndexKey()))
					nLen := Len(aInsert)
					cMD5 := MD5(cQuery)
					If (nPosPrepared := Ascan(__aPrepared,{|x| x[2] == cMD5})) == 0
						If __lCusaVLib
							Aadd(__aPrepared,{FwExecStatement():New(),cMD5})
						Else
							Aadd(__aPrepared,{FWPreparedStatement():New(),cMD5})
						EndIf
						nPosPrepared := Len(__aPrepared)
						__aPrepared[nPosPrepared][1]:SetQuery(ChangeQuery(cQuery))
					Endif
					__aPrepared[nPosPrepared][1]:SetUnsafe(1, aInsert[1])
					For nX := 2 to nLen
						__aPrepared[nPosPrepared][1]:SetString(nX, aInsert[nX])
					Next nX
					If __lCusaVLib
						cAliasSDC := __aPrepared[nPosPrepared][1]:OpenAlias(cAliasSDC)
						DbSelectArea(cAliasSDC)
					Else
						cQuery := __aPrepared[nPosPrepared][1]:getFixQuery()
						dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSDC)
					EndIf
					aInsert := aSize(aInsert,0)

					For nX :=  1 To Len(aStruSDC)
						If aStruSDC[nX][2] <> "C"
							TcSetField(cAliasSDC,aStruSDC[nX][1],aStruSDC[nX][2],aStruSDC[nX][3],aStruSDC[nX][4])
						EndIf
					Next nX

					Do While !Eof() .And. QtdComp(nQuantBaixa) > QtdComp(0) .And. cSeek == &(cCompara)

						SDC->(MsGoto((cAliasSDC)->SDCRECNO))

						lTemSDC := .T.
						nQtdLog := 0
						aTravas := {}
						Reclock("SDC")
						nBaixa :=Min(DC_QUANT  ,nQuantBaixa)
						nBaixa2:=Min(DC_QTSEGUM,nQuant2Baixa)
						If QtdComp(nBaixa) > QtdComp(0)
							nQuantBaixa  -= nBaixa
							nQuant2Baixa -= nBaixa2

							// Apenas desconta a quantidade do SDC se no for uma baixa de requisio de um apontamento de produo
							// com integrao WMS, pois o desconto ser feito na funo WmsBaixaRQ aps a utilizao da quantidade do SDC por endereo
							If !(!Empty(cOp) .And. lWmsNew .And. IntWms(DC_PRODUTO))
								// Baixar Saldo SDC
								Replace DC_QUANT   With DC_QUANT   - nBaixa
								Replace DC_QTSEGUM With DC_QTSEGUM - nBaixa2
							EndIf

							aArray:=SldPorLote(DC_PRODUTO,DC_LOCAL,nBaixa,nBaixa2,DC_LOTECTL,DC_NUMLOTE,DC_LOCALIZ,DC_NUMSERI,@aTravas,NIL,NIL,NIL,NIL,NIL,dData,,,.T.,,lAtuSB2)
							For i:=1 to Len(aArray)
								// Caso utilize registros da Rastreabilidade tira saldo e/ou empenho no SB8
								dbSelectArea("SB8")
								If lRastro
									If Len(aArray[i,10]) > 0
										For z:=1 to Len(aArray[i,10])
											dbGoto(aArray[i,10,z,1])
											Reclock("SB8",.F.)
											GravaSD5(cAlias,cProduto,cLocal,SB8->B8_LOTECTL,SB8->B8_NUMLOTE,cNumSeq,cDoc,cSerie,cOp,cTm,cCliFor,cLoja,cLoteFor,aArray[i,10,z,2],aArray[i,10,z,3],dData,SB8->B8_DTVALID,SB8->B8_POTENCI,cLotePrd,cSubLotePrd,,SDC->DC_TRT)
											TLogMov(@aLogMov,'202',STR0173,aArray[i,10,z,2],SB8->B8_LOTECTL,SB8->B8_NUMLOTE) //"Atualizao do Registro SD5/SB8"
											nQtdSD5  += aArray[i,10,z,2]
											nQtd2SD5 += aArray[i,10,z,3]
											If lPotencLote .And. (!lBxEmpB8 .Or. (lBxEmpB8 .And. Empty(cLoteCtl+cNumLote))) .And. !Empty(cOp)
												nQuantPMax+=A250PotMax(cProduto,SB8->B8_POTENCI,Min(SB8->B8_SALDO,aArray[i,10,z,2]))
											EndIf
											Replace SB8->B8_SALDO  With SB8->B8_SALDO  - Min(SB8->B8_SALDO ,aArray[i,10,z,2])
											Replace SB8->B8_SALDO2 With SB8->B8_SALDO2 - Min(SB8->B8_SALDO2,aArray[i,10,z,3])
											If (lBxEmpB8 .And. QtdComp(SB8SALDO(.T.,,,,,lEmpPrev,,,.T.)) >= QtdComp(0) .And. !Empty(SDC->DC_LOTECTL))
												GravaB8Emp("-",aArray[i,10,z,2],"F",NIL, If( Empty(aArray[i,10,z,3]),NIL,aArray[i,10,z,3]))
											EndIf
											MsUnlock()
										Next z
										//Pega lote obtido no posicionamento acima para nota de sada ter a data de fabricacao.
										If lDtFabric .And. (cAlias == "SD2") .And. Empty(SD2->D2_DFABRIC)
											RecLock("SD2", .F.)
											SD2->D2_DFABRIC := SB8->B8_DFABRIC
											SD2->(msUnLock())
										EndIf
									Else
										TLogMov(@aLogMov,'203',STR0179) //"Nao foi Encontrado saldo por Lote na SLDPORLOTE"
									EndIf
								EndIf
								// Caso utilize registros da Localizacao Fisica tira saldo e/ou empenho no SBF
								If lLocaliz .And. !(lWmsNew .And. IntDl(cProduto))
									If aArray[i,9] > 0
										dbSelectArea("SBF")
										dbGoto(aArray[i,9])
										RecLock("SBF")
										nRecnoSDB := 0
										SDB->(CriaSDB(SDC->DC_PRODUTO,SDC->DC_LOCAL,aArray[i,5],aArray[i,3],aArray[i,4],cDoc,cSerie,cCliFor,cLoja,cTipoNf,SDC->DC_ORIGEM,dData,aArray[i,1],aArray[i,2],cNumSeq,cTm,"M",StrZero(1,Len(SDB->DB_ITEM)),lEstorno,Nil,aArray[i,6],Nil,cEstFis,cServico,cTarefa,cAtividade,cAnomalia,cEstDest,cEndDest,cHrInicio,cAtuEst,cCarga,cUnitiza,cOrdTar,cOrdAti,cRHumano,cRFisico,,cIdDCF,@nRecnoSDB,cIdMovto,cOp))
										TLogMov(@aLogMov,'204',STR0176,aArray[i,5],aArray[i,1],aArray[i,2],aArray[i,5],aArray[i,3],aArray[i,4]) //"Atualizao do Saldo por Endereco (SBF/SDB)"
										nQtdSDB  += aArray[i,5]
										nQtd2SDB += aArray[i,6]
										//Ŀ
										//Soma saldo em estoque por localizacao fisica (SBF)     
										//
										If SBF->BF_EMPENHO >= aArray[i,5]
											GravaSBF("SDB",lBxEmpB8,,nRecnoSDB)
										Else
											GravaSBF("SDB",.F.,,nRecnoSDB)
										EndIf
										SBF->(MsUnLock())
									Else
										TLogMov(@aLogMov,'205',STR0180) //"Nao foi Encontrado saldo por Endereco na SLDPORLOTE"
									EndIf
								EndIf
							Next i
							//Ŀ
							// Remove travas dos registros utilizados               
							//
							MaDesTrava(aTravas)
	                	EndIf
						//Ŀ
						//Apaga o SDC qdo ZERA QTD na NF de Venda                
						//
						If (QtdComp(SDC->DC_QUANT) == QtdComp(0) .And. Empty(cOp))
							RecLock("SDC",.F.,.T.)
							dbDelete()
						EndIf
						SDC->(MSUnLock())
						dbSelectArea(cAliasSDC)
						dbSkip()
					EndDo

					(cAliasSDC)->(dbCloseArea())
					dbSelectArea("SDC")
					// Verifica Diferencas encontrada na baixa da SD5
					If lRastro
						nDifSD5  := nQuant-nQtdSD5
						nDif2SD5 := IIf(QtdComp(nQtd2SD5)==QtdComp(0),0,nQuant2UM-nQtd2SD5)
					EndIf
					// Verifica Diferencas encontrada na baixa da SDB
					If lLocaliz
						nDifSDB  := nQuant - nQtdSDB
						nDif2SDB := IIf(QtdComp(nQtd2SDB)==QtdComp(0),0,nQuant2UM-nQtd2SDB)
					EndIf
					// Quando nao existir SDC baixar saldo pela SldPorLote
					If !lTemSDC
						TLogMov(@aLogMov,'206',STR0185,nQuant,cLoteCtl,cNumLote,nQuant,cLocaliz,cNumSerie) //"Nao foi encontrado o movimento na tabela SDC / Baixando pela SldPorLote"
						If lRastro .Or. lLocaliz
							AtuSldMov(cProduto,cLocal,nQuant,nQuant2UM,cLoteCtl,cNumLote,cLocaliz,cNumSerie,lBxEmpB8,lConsVenc,dData,cDoc,cSerie,cOp,cTm,cCliFor,cLoja,cLoteFor,cLotePrd,cSubLotePrd,@nQuantPMax,@aLogMov,@nQtdSD5,@nQtdSDB,lNumSerDev,cTipoNf,cAlias,cNumSeq,lEstorno,cEstFis,cServico,cTarefa,cAtividade,cAnomalia,cEstDest,cEndDest,cHrInicio,cAtuEst,cCarga,cUnitiza,cOrdTar,cOrdAti,cRHumano,cRFisico,cIdDCF,lEmpPrev,cIdMovto)
						EndIf
					ElseIf lTemSDC .And. ( nDifSD5 > 0 .Or. nDifSDB > 0 )
						TLogMov(@aLogMov,'207',STR0186,nDifSD5,cLoteCtl,cNumLote,nDifSDB,cLocaliz,cNumSerie) //"Nao existe quantidade suficiente na tabela SDC / Baixando pela SldPorLote"
						If lRastro .Or. lLocaliz
							AtuSldMov(cProduto,cLocal,IIf(lRastro,nDifSD5,nDifSDB),IIf(lRastro,nDif2SD5,nDif2SDB),cLoteCtl,cNumLote,cLocaliz,cNumSerie,lBxEmpB8,lConsVenc,dData,cDoc,cSerie,cOp,cTm,cCliFor,cLoja,cLoteFor,cLotePrd,cSubLotePrd,@nQuantPMax,@aLogMov,@nQtdSD5,@nQtdSDB,lNumSerDev,cTipoNf,cAlias,cNumSeq,lEstorno,cEstFis,cServico,cTarefa,cAtividade,cAnomalia,cEstDest,cEndDest,cHrInicio,cAtuEst,cCarga,cUnitiza,cOrdTar,cOrdAti,cRHumano,cRFisico,cIdDCF,lEmpPrev,cIdMovto)
						EndIf
					EndIf
					TLogMov(@aLogMov,'299',STR0187,nQtdSD5,cLoteCtl,cNumLote,nQtdSDB,cLocaliz,cNumSerie) //"TERMINO DE PROCESSAMENTO DE BAIXA POR SDC"
				EndIf
				// Baixar Empenho SB2
				If lBaixaEmp
					If lPotencLote .And. (!lBxEmpB8 .Or. (lBxEmpB8 .And. Empty(cLoteCtl+cNumLote))) .And. !Empty(cOp)
						nQuant:=nQuantPMax
					EndIf
					If lGeraDev
						GravaB2Pre("+",nQuant,"F")
					Else
						If !Empty(cPedido).And.!Empty(cItem)
							GravaB2Emp("-",Min(SB2->B2_RESERVA,nQuant),,.T., Min(SB2->B2_RESERV2,nQuant2UM) )
						Else
							GravaB2Emp("-",MAX(Min(SB2->B2_QEMP,A250avalqt(nQuant-SD3->D3_QTMAIOR, SD3->D3_COD)),0),,,Min(SB2->B2_QEMP2,nQuant2UM))
						EndIf
					EndIf
				EndIf

			EndIf

			//Ŀ
			// Estorna movimento para Lote/Sub-Lote/Localizacao      
			//
		ElseIf lEstorno .And. !IsProdMod(cProduto)
			TLogMov(@aLogMov,'301',STR0188,nQuant,cLoteCtl,cNumLote,nQuant,cLocaliz,cNumSerie) //"INICIANDO ESTORNO"
			If (lBaixaEmp .And. !lLocaliz) .Or. (!IsInCallStack('MATA250') .and. !lBaixaEmp) .or. !lDistribui .Or. (!lAbreOP .And. !lLocaliz)
				If lDistribui .And. lLocaliz .And. !(lWmsNew .And. IntDl(cProduto))
					If lApropri .Or. (Empty(cLocaliz).And.Empty(cNumSerie)) .Or. (IntDl(cProduto).And.!Empty(cServico).And.Empty(cTarefa))
						lCriaSDA:=.T.
					Else
						If PergDevLoc(cAlias,cProduto,nQuant,cDoc,""   ,cLocaliz ,cNumSerie,cLocal,nPDevLoc, @lRmOrdSep )
							lCriaSDA:=.T.
							//Ŀ
							//Exibir Help quando nao informado Lote/SubLote 		  |
							//
							If Rastro(cProduto) .And. Empty(cLoteCtl) .And. Empty(cNumLote)
								TLogMov(@aLogMov,'302',STR0189) //"Nao Informado Lote/SubLote"
								Help(" ",1,"ATUARASTRO")
							EndIf
						Else
							TLogMov(@aLogMov,'303',STR0176,nQuant,cLoteCtl,cNumLote,nQuant,cLocaliz,cNumSerie) //"Atualizao do Saldo por Endereco (SBF/SDB)"
							nRecnoSDB := 0
							CriaSDB(cProduto,cLocal,nQuant,cLocaliz,cNumSerie,cDoc,cSerie,cCliFor,cLoja,cTipoNf,cAlias,dData,cLoteCtl,cNumLote,cnumSeq,cTm,"M",StrZero(1,Len(SDB->DB_ITEM)),lEstorno,Nil,nQuant2Baixa,Nil,cEstFis,cServico,cTarefa,cAtividade,cAnomalia,cEstDest,cEndDest,cHrInicio,cAtuEst,cCarga,cUnitiza,cOrdTar,cOrdAti,cRHumano,cRFisico,,cIdDCF,@nRecnoSDB,cIdMovto,cOp)
							//Ŀ
							//Soma saldo em estoque por localizacao fisica (SBF)     
							//
							GravaSBF("SDB",,,nRecnoSDB)
							//Ŀ
							//Exibir Help quando nao informado Lote/SubLote 		  |
							//
							If Rastro(cProduto) .And. Empty(cLoteCtl) .And. Empty(cNumLote)
								TLogMov(@aLogMov,'304',STR0189) //"Nao Informado Lote/SubLote"
								Help(" ",1,"ATUARASTRO")
							EndIf
						EndIf
					EndIf
				ElseIf lLocaliz .And. !lDistribui .And. !(lWmsNew .And. IntDl(cProduto))
					dbSelectArea("SDB")
					dbSetOrder(2)
					//cSeek    := xFilial("SDB")+cProduto+cLocal+cLoteCtl+cNumLote+cNumSerie+cLocaliz+cNumSeq
					cSeek    := xFilial("SDB")+cProduto+cLocal+cLoteCtl+IF(RASTRO(cProduto,"S"),cNumLote,CriaVar("DB_NUMLOTE"))+cNumSerie+cLocaliz+cNumSeq
					cCompara := "DB_FILIAL+DB_PRODUTO+DB_LOCAL+DB_LOTECTL+DB_NUMLOTE+DB_NUMSERI+DB_LOCALIZ+DB_NUMSEQ"
					lAchoPR1 := .F.
					If cAlias=="SD3" .And. (!Type('M->D3_OP')=="U") .And. !Empty(M->D3_OP) .And. M->D3_CF == "PR1" .And. M->D3_ESTORNO == "S"
						SBE->(dbSetOrder(1)) //BE_FILIAL+BE_LOCAL+BE_LOCALIZ
						If SBE->(dbSeek(xFilial("SBE")+cLocal+cEndPR1))
							/*
							If SDB->(dbSeek(xFilial("SDB")+cProduto+cLocal+cLoteCtl+cNumLote+cNumSerie+Substr(cEndPR1+Space(nTamLocaliz), 1, nTamLocaliz)+cNumSeq))
								cSeek := xFilial("SDB")+cProduto+cLocal+cLoteCtl+cNumLote+cNumSerie+Substr(cEndPR1+Space(nTamLocaliz), 1, nTamLocaliz)+cNumSeq
								lAchoPR1 := .T.
							EndIf
							*/

							If SDB->(dbSeek(xFilial("SDB")+cProduto+cLocal+cLoteCtl+IF(RASTRO(cProduto,"S"),cNumLote,CriaVar("DB_NUMLOTE"))+cNumSerie+Substr(cEndPR1+Space(nTamLocaliz), 1, nTamLocaliz)+cNumSeq))
								cSeek := xFilial("SDB")+cProduto+cLocal+cLoteCtl+IF(RASTRO(cProduto,"S"),cNumLote,CriaVar("DB_NUMLOTE"))+cNumSerie+Substr(cEndPR1+Space(nTamLocaliz), 1, nTamLocaliz)+cNumSeq
								lAchoPR1 := .T.
							EndIf
						EndIf
					EndIf
					If lAchoPR1 .Or. SDB->(dbSeek(cSeek))
						TLogMov(@aLogMov,'305',STR0190,nQuant,cLoteCtl,cNumLote,nQuant,If(lAchoPR1, cEndPR1, cLocaliz),cNumSerie) //"Estorno atraves do Registro da Tabela SDB"
						aRegistros:={}
						Do While !Eof() .And. cSeek == &(cCompara)
							//Estorno devido acerto do campo numseq para que seja utilizado do dcf
							//Nao mais um numseq por movimento (WMS)
							If lIntDL .And. !Empty(cIdMovto)
								If cIdMovto <> DB_IDMOVTO
									dbSkip()
									Loop
								EndIf
							EndIf
							If DB_ESTORNO == "S"
								dbSkip()
								Loop
							EndIf

							If Empty(cOp) .And. Empty(cPedido)
								cArquivo:=cAlias
							ElseIf !Empty(cOp)
								cArquivo:="SC2"
							ElseIf !Empty(cPedido)
								If cPaisLoc=="BRA"
									cArquivo:="SD2"
								Else
									cArquivo:=cAlias
								Endif
							EndIf

							If cArquivo == 'SC2'
								If Rastro(SDB->DB_PRODUTO) .And. !Empty(cLoteCtl) .AND. cLoteCtl != SDB->DB_LOTECTL
									dbSkip()
									Loop
								EndIf

								If lExistOP
									If !Empty(cOp) .And. !Empty(SDB->DB_OP) .AND. cOp != SDB->DB_OP
										dbSkip()
										Loop
									EndIf
								EndIf

								If nMultiplic > 0 .And. SDB->DB_TM < '500' .And. SDB->DB_ORIGEM == 'SD3'
									dbSkip()
									Loop
								EndIf
							EndIf

							aCampos:={}
							Reclock("SDB",.F.)
							Replace DB_ESTORNO With "S"
							MsUnlock()
							For nz := 1 To FCount()
								AADD(aCampos,FieldGet(nz))
							Next nz
							//Ŀ
							// Armazena em array registros a serem incluidos p/ estorno     
							//
							AADD(aRegistros,ACLONE(aCampos))
							dbSelectArea("SDB")
							dbSkip()
						EndDo
						//Ŀ
						//Cria os registros de estorno com os mesmos dados dos originais
						//qdo usuario seleciona voltar para a localizacao original.     
						//
						For i:=1 to Len(aRegistros)
							RecLock("SDB",.T.)
							For nz := 1 To FCount()
								FieldPut(nz,aRegistros[i,nz])
							Next nz
							//Ŀ
							// Inverte o tipo do movimento original                         
							//
							Replace DB_TM With cTm
							MsUnlock()
							//Ŀ
							//Soma saldo em estoque por localizacao fisica (SBF)     
							//
							lAtuEmpSDC := .F.

							dbSelectArea("SDC")
							//If !Empty(cOp)
							If SDB->DB_ORIGEM == "SD3"
								SDC->(dbSetOrder(2))
								cSeekDC   :=xFilial("SDC")+SDB->DB_PRODUTO+SDB->DB_LOCAL+SD4->D4_OP+SD4->D4_TRT+SDB->DB_LOTECTL+SDB->DB_NUMLOTE+SDB->DB_LOCALIZ+SDB->DB_NUMSERI
								cComparaDC:="SDC->DC_FILIAL+SDC->DC_PRODUTO+SDC->DC_LOCAL+SDC->DC_OP+SDC->DC_TRT+SDC->DC_LOTECTL+SDC->DC_NUMLOTE+SDC->DC_LOCALIZ+SDC->DC_NUMSERI"
								If SDC->(dbSeek(cSeekDC)) .And. lAbreOp
									Do While !Eof() .And. cSeekDC == &(cComparaDC)

										/*
										nSaldo:=SDC->DC_QTDORIG - SDC->DC_QUANT
										If nSaldo <=0
											SDC->(dbSkip())
											Loop
										EndIf
										*/

										If lUsaB8Emp
											If (!Empty(cOpOrig) .And. QtdComp(DC_QTDORIG) <= QtdComp(DC_QUANT))
												RecLock("SDC",.F.,.T.)
												dbDelete()
											EndIf
										EndIf

										lAtuEmpSDC := .T.
										Exit
									EndDo
								EndIf
							EndIf

							//GravaSBF("SDB")
							GravaSBF("SDB",lBxEmpB8 .And. !(SDB->DB_ORIGEM $ "SC6/SD3"),If (lUsaB8Emp,.F.,.T.),,,lUsaB8Emp,lAtuEmpSDC)
							TLogMov(@aLogMov,'306',STR0191,SDB->DB_QUANT,SDB->DB_LOTECTL,SDB->DB_NUMLOTE,SDB->DB_QUANT,SDB->DB_LOCALIZ,SDB->DB_NUMSERI) //"Registro efetivamente Estornado SDB/SBF"
						Next i
					ElseIf !lCriaSDA
						//Ŀ
						// Qdo for devolucao sem Localizacao/Numero de Serie     
						// cria registro no arquivo de saldos a distribuir (SDA) 
						// O parametro lEstorno deve ser sempre enviado, pois no 
						// caso de estono de produtos com apropriacao indireta   
						// devera ser excluido o enderecamento pendente (SDA)    
						//
						CriaSDA(cAlias,nQuant,lEstorno,NIL,nQuant2UM,lApropri)
						TLogMov(@aLogMov,'307',STR0192,,,,nQuant) //"Estorno do Saldo Enderecado SDA"
					EndIf
				EndIf
				//Ŀ
				//Estorna movimentos no arquivo de mov. por Lote  (SD5)  
				//
				If Rastro(cProduto)
					EstornaSD5(	cTipoLote,;
								cProduto,;
								cLocal,;
								cLoteCtl,;
								cNumLote,;
								cNumSeq,;
								lBxEmpB8 .And. !(cAlias $ "SD2/SCN") ,;
								Localiza(cProduto) .And. !lCriaSDA .And. (Empty(cLocaliz).Or.(IntDl(cProduto).And.!Empty(cServico).And.Empty(cTarefa))) .And. Empty(cNumSerie),;
								cTm,;
								@nQuantpMax,;
								@nQuantEstSD5,;
								cAlias,cCliFor,cLoja,cDoc,cSerie,lUsaB8Emp,,,lConsVenc)
					TLogMov(@aLogMov,'308',STR0193,nQuantpMax,cLoteCtl,cNumLote) //"Chamada da funcao EstornaSD5"
				EndIf

				//Ŀ
				// Cria registro no arquivo de saldos a distribuir (SDA) 
				//
				If lCriaSDA
					If lApropri .Or. (Empty(cLocaliz).And.Empty(cNumSerie))
						CriaSDA(cAlias,nQuant,lEstorno,NIL,nQuant2UM,lApropri)
					Else
						CriaSDA(cAlias,nQuant,NIL,NIL,nQuant2UM,lApropri)
					EndIf
					TLogMov(@aLogMov,'309',STR0194,nQuant) //"Gravacao do Saldo a Enderecar SDA"
				EndIf
				//Ŀ
				//Soma saldo em estoque (SB2)     
				//
				If lBaixaEmp .And. cAlias != "SD2"
					If lPotencLote .And. (!lBxEmpB8 .Or. (lBxEmpB8 .And. Empty(cLoteCtl+cNumLote))) .And. !Empty(cOp)
						nQuant:=nQuantPMax
					EndIf
					If lGeraDev
						GravaB2Pre("+",nQuant,"F")
					Else
						GravaB2Emp("+",Max(A250avalqt(nQuant-SD3->D3_QTMAIOR, SD3->D3_COD), 0),,If(lBaixaEmp .And. cAlias=="SCN",.T.,.F.),nQuant2UM)
					Endif
				EndIf
			ElseIf lLocaliz .and. !(lWmsNew .And. IntDl(cProduto))
				TLogMov(@aLogMov,'310',STR0195,nQuant,cLoteCtl,cNumLote,nQuant,cLocaliz,cNumSerie) //"Estorno por Localizacao"
				dbSelectArea("SDB")
				dbSetOrder(1)
				cSeek:=xFilial("SDB")+cProduto+cLocal+cNumSeq
				cCompara:="DB_FILIAL+DB_PRODUTO+DB_LOCAL+DB_NUMSEQ"
				dbSeek(cSeek)
				aRegistros:={}
				nQuantLoc :=nQuant
				nQtdSDB   := 0
				nQtd2SDB  := 0
				Do While !Eof() .And. cSeek == &(cCompara) .And. nQuantLoc > 0
					If DB_ESTORNO == "S" //.Or.!A250EstSDB(Recno())
						dbSkip()
						Loop
					EndIf
					If Empty(cOp) .And. Empty(cPedido)
						cArquivo:=cAlias
					ElseIf !Empty(cOp)
						cArquivo:="SC2"
					ElseIf !Empty(cPedido)
						If cPaisLoc=="BRA"
							cArquivo:="SD2"
						Else
							cArquivo:=cAlias
						Endif
					EndIf

					If cArquivo == 'SC2'
						If Rastro(SDB->DB_PRODUTO) .And. !Empty(cLoteCtl) .AND. cLoteCtl != SDB->DB_LOTECTL
							dbSkip()
							Loop
						EndIf

						If lExistOP
							If !Empty(cOp) .And. !Empty(SDB->DB_OP) .AND. cOp != SDB->DB_OP
								dbSkip()
								Loop
							EndIf
						EndIf

						If nMultiplic > 0 .And. SDB->DB_TM < '500' .And. SDB->DB_ORIGEM == 'SD3'
							dbSkip()
							Loop
						EndIf
					Else
						If !A250EstSDB(Recno())
							dbSkip()
							Loop
						EndIf
					EndIf

					RecLock("SDB")
					nQuantpMax:=0
					nQuantLoc -= SDB->DB_QUANT
					If PergDevLoc(cArquivo,SDB->DB_PRODUTO,SDB->DB_QUANT,SDB->DB_DOC,cItem,SDB->DB_LOCALIZ,SDB->DB_NUMSERI,SDB->DB_LOCAL,nPDevLoc, @lRmOrdSep )
						//Ŀ
						//Exibir Help quando nao informado Lote/SubLote 		  |
						//
						If Rastro(SDB->DB_PRODUTO) .And. Empty(SDB->DB_LOTECTL) .And. Empty(SDB->DB_NUMLOTE)
							TLogMov(@aLogMov,'311',STR0189) //"Nao Informado Lote/SubLote"
							Help(" ",1,"ATUARASTRO")
						EndIf
						//Ŀ
						// Volta o empenho no arquivo de composicao do empenho          
						//
						dbSelectArea("SDC")
						If !Empty(cOp)
							dbSetOrder(2)
							cSeekDC   :=xFilial("SDC")+SDB->DB_PRODUTO+SDB->DB_LOCAL+cOp+cTrt+SDB->DB_LOTECTL+SDB->DB_NUMLOTE+SDB->DB_LOCALIZ+SDB->DB_NUMSERI
							cComparaDC:="DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL+DC_NUMLOTE+DC_LOCALIZ+DC_NUMSERI"
							lSeek:=dbSeek(cSeekDC)
							If lSeek
								nQuantLoc2:=SDB->DB_QUANT
								nQuantLc22:=SDB->DB_QTSEGUM
								Do While !Eof() .And. QtdComp(nQuantLoc2) > QtdComp(0) .And. cSeekDC == &(cComparaDC)
									RecLock("SDC")
									nSaldo:=DC_QTDORIG - DC_QUANT
									If nSaldo > 0
										nBaixa:=Min(nSaldo,nQuantLoc2)
										nBaixa2:=nQuantLc22
										//Ŀ
										// Acerta a qtde Origem, porque na distribuicao sera     |
										//| gerado novo SDC com a quantidade estornada.			  |
										//
		   								SDC->DC_QTDORIG -= nBaixa

										//Ŀ
										// Apaga o SDC quando selecionada a opcao de redistribuir |
										//| e o saldo disponivel ja foi requisitado.               
										//
										If QtdComp(DC_QTDORIG) == QtdComp(0)
											SDC->(dbDelete())
										EndIf
										nQuantLoc2-=nBaixa
										nQuantLc22-=nBaixa2
									EndIf
									SDC->(MsunLock())
									dbSelectArea("SDC")
									dbSkip()
								EndDo
							EndIf
						EndIf
						dbSelectArea("SDB")
						//Ŀ
						//Estorna movimentos no arquivo de mov. por Lote  (SD5)  
						//
						If Rastro(cProduto)
							EstornaSD5(	cTipoLote,;
										SDB->DB_PRODUTO,;
										SDB->DB_LOCAL,;
										SDB->DB_LOTECTL,;
										SDB->DB_NUMLOTE,;
										SDB->DB_NUMSEQ,;
										lBxEmpB8 .And. !(SDB->DB_ORIGEM $ "SC6/SD2/SD3/SCN"),;
										NIL,;
										SDB->DB_TM,;
										NIL,;
										@nQuantEstSD5,;
										SDB->DB_ORIGEM,cCliFor,cLoja,cDoc,cSerie,lUsaB8Emp)
							TLogMov(@aLogMov,'312',STR0196,SDB->DB_QUANT,SDB->DB_LOTECTL,SDB->DB_NUMLOTE,SDB->DB_QUANT,SDB->DB_LOCALIZ,SDB->DB_NUMSERI) //"Chamada da funcao EstornaSD5 baseada na SDB"
						EndIf
						//Ŀ
						//Cria registro no arquivo de saldos a distribuir (SDA)  
						//quando usuario quer redistribuir e ja empenha material 
						//quando efetuar a distribuicao                          
						//
						CriaSDA(cAlias,SDB->DB_QUANT,Nil,!Empty(cOp).And.lSeek.And.!Empty(cLoteCtl+cNumLote),Nil,lApropri,NIL,NIL,SDB->DB_LOTECTL,SDB->DB_NUMLOTE)
						nQtdSDB  += SDB->DB_QUANT
						nQtd2SDB += SDB->DB_QTSEGUM
						TLogMov(@aLogMov,'313',STR0194,SDB->DB_QUANT,SDB->DB_LOTECTL,SDB->DB_NUMLOTE,SDB->DB_QUANT,SDB->DB_LOCALIZ,SDB->DB_NUMSERI) //"Gravacao do Saldo a Enderecar SDA"
						//Ŀ
						//Soma saldo em estoque (SB2)     
						//
						If lBaixaEmp .And. cAlias != "SD2"
							If lPotencLote .And. (!lBxEmpB8 .Or. (lBxEmpB8 .And. Empty(cLoteCtl+cNumLote))) .And. !Empty(cOp)
								SB8->(dbSetOrder(3))
								If cTipoLote == "L"
									SB8->(dbSeek(xFilial("SB8")+cProduto+cLocal+SDB->DB_LOTECTL))
								Else
									SB8->(dbSeek(xFilial("SB8")+cProduto+cLocal+SDB->DB_LOTECTL+SDB->DB_NUMLOTE))
								EndIf
								GravaB2Emp("+",A250PotMax(cProduto,SB8->B8_POTENCI,SDB->DB_QUANT),,If (lBaixaEmp .And. cAlias=="SCN",.T.,.F.))
								nQuant -= A250PotMax(cProduto,SB8->B8_POTENCI,SDB->DB_QUANT)
							Else
								GravaB2Emp("+",SDB->DB_QUANT,,If(lBaixaEmp .And. cAlias=="SCN",.T.,.F.),SDB->DB_QTSEGUM)
								nQuant -= SDB->DB_QUANT
							EndIf

						EndIf
					Else
						//Ŀ
						//Exibir Help quando nao informado Lote/SubLote 		  |
						//
						If Rastro(SDB->DB_PRODUTO) .And. Empty(SDB->DB_LOTECTL) .And. Empty(SDB->DB_NUMLOTE)
							TLogMov(@aLogMov,'314',STR0189) //"Nao Informado Lote/SubLote"
							Help(" ",1,"ATUARASTRO")
						EndIf

						Reclock("SDB",.F.)
						Replace DB_ESTORNO With "S"
						MsUnlock()
						aCampos:={}
						For nz := 1 To FCount()
							AADD(aCampos,FieldGet(nz))
						Next nz
						//Ŀ
						// Armazena em array registros a serem incluidos p/ estorno     
						//
						AADD(aRegistros,ACLONE(aCampos))
					EndIf
					SDB->(MsUnlock())
					dbSelectArea("SDB")
					dbSkip()
				EndDo
				//Ŀ
				//Cria os registros de estorno com os mesmos dados dos originais
				//qdo usuario seleciona voltar para a localizacao original.     
				//
				If Len(aRegistros) <=0 .And. lBaixaEmp .And. !Empty(cOP)
					If lPotencLote .And. (!lBxEmpB8 .Or. (lBxEmpB8 .And. Empty(cLoteCtl+cNumLote))) .And. !Empty(cOp)
						nQuant:=nQuantPMax
					EndIf
					GravaB2Emp("+",nQuant,,If ( lBaixaEmp .And. cAlias=="SCN",.T.,.F.),nQuant2UM)
				Else
					For	i:=1 to Len(aRegistros)
						nQuantpMax:=0
						RecLock("SDB",.T.)
						For nz := 1 To FCount()
							FieldPut(nz,aRegistros[i,nz])
						Next nz
						//Ŀ
						// Inverte o tipo do movimento original                         
						//

						cTm1:=If(SDB->DB_TM>"500","499","999")

						Replace DB_TM With cTm1
						MsUnlock()
						TLogMov(@aLogMov,'313',STR0197,SDB->DB_QUANT,SDB->DB_LOTECTL,SDB->DB_NUMLOTE,SDB->DB_QUANT,SDB->DB_LOCALIZ,SDB->DB_NUMSERI) //"Atualizacao do Registro SDB Invertido"
						nQtdSDB  += SDB->DB_QUANT
						nQtd2SDB += SDB->DB_QTSEGUM
						//Ŀ
						// Volta o empenho no arquivo de composicao do empenho          
						//
						lAtuEmpSDC := .F.

						dbSelectArea("SDC")
						If !Empty(cOp) .And. (lBxEmpB8 .Or. lUsaB8Emp)
							dbSetOrder(2)
							cSeekDC   :=xFilial("SDC")+SDB->DB_PRODUTO+SDB->DB_LOCAL+cOp+cTrt+SDB->DB_LOTECTL+SDB->DB_NUMLOTE+SDB->DB_LOCALIZ+SDB->DB_NUMSERI
							cComparaDC:="DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL+DC_NUMLOTE+DC_LOCALIZ+DC_NUMSERI"
							If dbSeek(cSeekDC) .and. lAbreOp
								nQuantLoc:=nQuant
								Do While !Eof() .And. QtdComp(nQuantLoc) > QtdComp(0) .And. cSeekDC == &(cComparaDC)
									nSaldo:=DC_QTDORIG - DC_QUANT
									If nSaldo <=0
										dbSkip()
										Loop
									EndIf
									nBaixa:=Min(nSaldo,SDB->DB_QUANT)
									nBaixa2:=SDB->DB_QTSEGUM
									RecLock("SDC",.F.)
									Replace DC_QUANT   With DC_QUANT   + nBaixa
									Replace DC_QTSEGUM With DC_QTSEGUM + nBaixa2
									MsUnlock()

									lAtuEmpSDC := .T.

									//Ŀ
									//Quando o SDC  originado no SD3, deve ser excluido     
									//
									If (SDC->DC_ORIGEM == "SD3" .And. QtdComp(DC_QTDORIG) <= QtdComp(DC_QUANT))
										RecLock("SDC",.F.,.T.)
										dbDelete()
									EndIf

									/*
									If lUsaB8Emp
										If (!Empty(cOpOrig) .And. QtdComp(DC_QTDORIG) <= QtdComp(DC_QUANT))
											RecLock("SDC",.F.,.T.)
											dbDelete()
										EndIf
									EndIf
									*/

									If lUsaB8Emp
										If (!Empty(cOpOrig) .And. QtdComp(DC_QTDORIG) <= QtdComp(DC_QUANT))
											RecLock("SDC",.F.)
											Replace DC_QTDORIG With 0
											Replace DC_QUANT   With 0
											MsUnlock()
										EndIf
									EndIf

									nQuantLoc-=nBaixa
									dbSkip()
								EndDo
							EndIf
						EndIf

						If lAbreOp
							If lUsaB8Emp .And. !lAtuEmpSDC
								dbSetOrder(2)
								cSeekDC   :=xFilial("SDC")+SDB->DB_PRODUTO+SDB->DB_LOCAL+cOp+cTrt+SDB->DB_LOTECTL+SDB->DB_NUMLOTE+SDB->DB_LOCALIZ+SDB->DB_NUMSERI
								cComparaDC:="DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL+DC_NUMLOTE+DC_LOCALIZ+DC_NUMSERI"
								If dbSeek(cSeekDC)

									Do While !Eof() .And. cSeekDC == &(cComparaDC)
										nSaldo:=DC_QTDORIG - DC_QUANT
										If nSaldo <=0
											dbSkip()
											Loop
										EndIf

										lAtuEmpSDC := .T.
										Exit
									EndDo
								EndIf
							Else
								lAtuEmpSDC := .T.
							EndIf
						EndIf

						dbSelectArea("SDB")
						//Ŀ
						//Estorna movimentos no arquivo de mov. por Lote  (SD5)  
						//
						If Rastro(cProduto)
							EstornaSD5(	cTipoLote,;
										SDB->DB_PRODUTO,;
										SDB->DB_LOCAL,;
										SDB->DB_LOTECTL,;
										SDB->DB_NUMLOTE,;
										SDB->DB_NUMSEQ,;
										lBxEmpB8 .And. !(SDB->DB_ORIGEM $ "SC6/SD2/SD3/SCN"),;
										NIL,;
										cTm,;
										@nQuantpMax,;
										@nQuantEstSD5,;
										SDB->DB_ORIGEM,;
										cCliFor,;
										cLoja,;
										cDoc,;
										cSerie,;
										lUsaB8Emp,;
										cLoteCtl,;
										cNumLote)
							TLogMov(@aLogMov,'314',STR0196,SDB->DB_QUANT,SDB->DB_LOTECTL,SDB->DB_NUMLOTE,SDB->DB_QUANT,SDB->DB_LOCALIZ,SDB->DB_NUMSERI) //"Chamada da funcao EstornaSD5 Baseada no SDB"
						EndIf
						//Ŀ
						//Soma saldo em estoque por localizacao fisica (SBF)     
						//
						If cPaisLoc=="BRA"
							GravaSBF("SDB",lBxEmpB8 .And. !(SDB->DB_ORIGEM $ "SC6/SD3"),If (lUsaB8Emp,.F.,.T.),,,lUsaB8Emp,lAtuEmpSDC)
						Else
							If SDB->DB_ORIGEM=="SD2" .And. Empty(cPedido)
								GravaSBF("SDB",.F.)
							Else
								GravaSBF("SDB",lBxEmpB8 .And. !(SDB->DB_ORIGEM $ "SC6/SD3"))
							Endif
						Endif
						//Ŀ
						//Soma saldo em estoque (SB2)     
						//
						If lBaixaEmp .And. cAlias != "SD2"
							If lPotencLote .And. (!lBxEmpB8 .Or. (lBxEmpB8 .And. Empty(cLoteCtl+cNumLote))) .And. !Empty(cOp)
								GravaB2Emp("+",nQuantpMax,,If (lBaixaEmp .And. cAlias=="SCN",.T.,.F.))
							Else
								GravaB2Emp("+",SDB->DB_QUANT,,If (lBaixaEmp .And. cAlias=="SCN",.T.,.F.),SDB->DB_QTSEGUM)
								nQtMaior := SD3->D3_QTMAIOR
							EndIf
						EndIf
					Next i
					//Subtrai a quantidade a maior da quantidade empenhada
					If nQtMaior > 0
						GravaB2Emp("+",-nQtMaior,,If (lBaixaEmp .And. cAlias=="SCN",.T.,.F.),SDB->DB_QTSEGUM)
					Endif
				EndIf
				//Ŀ
				//Realiza o estorno da quantidade pendente a ser Estornada |
				//
				If lLocaliz .And. lDistribui .And. QtdComp(nQtdSDB) < QtdComp(nQuant)
					CriaSDA(cAlias,(nQuant-nQtdSDB),Nil,Nil,(nQuant2UM-nQtd2SDB),lApropri,NIL,NIL,cLoteCtl,cNumlote)
					TLogMov(@aLogMov,'315',STR0203,,cLoteCtl,cNumLote,(nQuant-nQtdSDB)) //"Gravacao do Saldo a Enderecar SDA (Correcao Estorno)"
					If Rastro(cProduto) .And. !Empty(cLoteCtl+cNumLote)
						CriaLote(cAlias,cProduto,cLocal,@cLoteCtl,@cNumLote,cLoteFor,cCliFor,cLoja,cTm,cOrigLan,cChave,cNumSeq,cDoc,cSerie,cOp,(nQuant-nQtdSDB),(nQuant2UM-nQtd2SDB),dData,dDtValid,NIL,nPotencia,cLotePrd,cSubLotePrd,dDataFabric,Nil,lAgregaOri)
						TLogMov(@aLogMov,'316',STR0204,(nQuant-nQtdSDB),cLoteCtl,cNumLote,(nQuant-nQtdSDB)) //"Gravacao do Saldo por Lote (Correcao Estorno)"
					EndIf
					nQtdSD5  += nQtdSDB
					nQtdSDB  += (nQuant-nQtdSDB)
					nQtd2SDB += (nQuant2UM-nQtd2SDB)
				EndIf
			ElseIf lLocaliz .and. lWmsNew .And. IntWMS(cProduto)
				If IsInCallStack('MaDelNfs') .And. MV_PAR04==2
					WmsAtuSDC("SC6",,,SC9->C9_PEDIDO,SC9->C9_ITEM,SC9->C9_SEQUEN,SC9->C9_PRODUTO,SC9->C9_LOTECTL,SC9->C9_NUMLOTE,SC9->C9_NUMSERI,SC9->C9_QTDLIB,SC9->C9_QTDLIB2,SC9->C9_LOCAL,SC9->C9_ENDPAD,SC9->C9_IDDCF)
				EndIf
				//------------------------------------------------------
				// Estorna movimentos no arquivo de mov. por Lote  (SD5)
				//------------------------------------------------------
				If Rastro(cProduto)
					EstornaSD5(	cTipoLote,;
								cProduto,;
								cLocal,;
								cLoteCtl,;
								cNumLote,;
								cNumSeq,;
								.F.,;
								.F.,;
								cTm,;
								@nQuantpMax,;
								@nQuantEstSD5,;
								cAlias,cCliFor,cLoja,cDoc,cSerie,lUsaB8Emp)
					TLogMov(@aLogMov,'308',STR0193,nQuantpMax,cLoteCtl,cNumLote) //"Chamada da funcao EstornaSD5"
				EndIf
			EndIf
			TLogMov(@aLogMov,'399',STR0198,nQtdSD5,cLoteCtl,cNumLote,nQtdSDB,cLocaliz,cNumSerie) //"TERMINO DO ESTORNO"
		EndIf
		TLogMov(@aLogMov,'400',STR0199) //"TERMINO DE PROCESSAMENTO DA MOVLOTE"
		If	lAtuSB2
			SB2->(MsUnlock())
		EndIf
	EndIf

	//Ŀ
	// Remove travas dos registros utilizados                  
	//
	MaDesTrava(aTravas)

EndIf

//Ŀ
// Restaura status anterior das areas que foram atualizadas
//
RestArea(aArea)
RestArea(aAreaSB1)
RestArea(aAreaSB2)
RestArea(aAreaSB8)
RestArea(aAreaSBF)
RestArea(aAreaSD4)
RestArea(aAreaSD5)
RestArea(aAreaSDA)
RestArea(aAreaSDB)
Return Nil

/*


Ŀ
Funo     AvalLote  Autor  Luiz Claudio Barbosa   Data  11.05.95 
Ĵ
Descrio  Avalia se existe lote para o produto                       
Ĵ
Sintaxe    AvalLote()   				                              
Ĵ
Parametro  ExpC1 = Codigo do Produto                                  
           lGradeB4 - >indica se quem chamou a funcao foi o b1 ou b4  
Ĵ
 Uso       EST/PCP/FAT/COM	                                          
ٱ


*/
Function AvalLote(cProd,lGradeB4,lAltProd)

Local cRastro	:= SuperGetMV("MV_RASTRO",.F.,'N')
Local dDataFec	:= MVUlmes()
Local lRet		:= .F.
Local lLotUni :=  SuperGetMV('MV_LOTEUNI', .F., .F.)
Local nSaldo	:= 0
Local lEmpPrev	:= If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)
Local aSM0		:= FWLoadSM0()
Local lSB1Com	:= FWModeAccess("SB1") == "C"
Local aArea		:= GetArea()
Local aAreaSB8	:= SB8->(GetArea())
Local nX
Local cLocCQ     := SuperGetMV("MV_CQ",.F.,"98")
Local lRetCQ	 := .T.
Default lAltProd := .F.


lGradeB4 := IF(lGradeB4==NIL,.F.,lGradeB4)

If cRastro == "S"
	dbSelectArea("SB1")
	dbSetOrder(1)
	dbSeek(xFilial("SB1")+cProd)
	If IF(!lGradeB4,M->B1_RASTRO,M->B4_RASTRO) == "N" .And. IF(!lGradeB4,SB1->B1_RASTRO,SB4->B4_RASTRO) $ "SL "
		dbSelectArea("SB8")
		dbSetOrder(1)

		If lSB1Com // Se a SB1 for compartilhada valida em todas as filiais da empresa
			For nX := 1 To Len(aSM0)
				If aSM0[nX][1] == cEmpAnt
					dbSeek(xFilial("SB8",aSM0[nX][2])+cProd)
					If Eof()
						lRet := .T.
					Else
						Do While !Eof() .And. B8_FILIAL+B8_PRODUTO == xFilial("SB8",aSM0[nX][2])+cProd
							nSaldo += B8_SALDO
							If nSaldo > 0
								Exit
							EndIf
							dbSkip()
						EndDo
						// Verifica saldo para o produto
						If nSaldo > 0
							Help(" ",1,"TEMLOTE")
							lRet := .F.
							Exit
						Else
							lRet := .T.
						EndIf
					EndIf
				EndIf
			Next nX
		Else
			dbSeek(xFilial("SB8")+cProd)
			If Eof()
				lRet := .T.
			Else
				Do While !Eof() .And. B8_FILIAL+B8_PRODUTO == xFilial("SB8")+cProd
					nSaldo += B8_SALDO
					If nSaldo > 0
						Exit
					EndIf
					dbSkip()
				EndDo
				// Verifica saldo para o produto
				If nSaldo > 0
					Help(" ",1,"TEMLOTE")
					lRet := .F.
				Else
					lRet := .T.
				EndIf
			EndIf
		EndIf

	ElseIf IF(!lGradeB4,M->B1_RASTRO,M->B4_RASTRO) $ "SL" .And. IF(!lGradeB4,SB1->B1_RASTRO,SB4->B4_RASTRO) == "N"
		cAlias:=Alias()
		dbSelectArea("SB2")
		nRec	:=Recno()
		nOrder:=IndexOrd()
		dbSetOrder(1)
		dbGotop()
		If !dbSeek(xFilial("SB2")+cProd)
			lRet := .T.
		Else
			If dbSeek(xFilial("SB2")+cProd+cLocCQ) .And. SaldoSB2() > 0
				Aviso(STR0041,STR0244,{"Ok"}) //"Tipo de Rastreabilidade"###"Nao pode ser alterado. Existe saldo em anlise pelo controle de qualidade."
				lRetCQ	:= .F.
			EndIf
			If lRetCQ
				If SB2->(dbSeek(xFilial("SB2")+cProd)) .And. SaldoSB2() > 0
					ApMsgAlert(STR0243)
				EndIf
				lRet := .T.
			EndIf
		EndIf
		DbSetOrder(nOrder)
		dbGoTo(nRec)
		dbSelectArea(cAlias)
	ElseIf IF(!lGradeB4,M->B1_RASTRO,M->B4_RASTRO) == "N" .And. IF(!lGradeB4,SB1->B1_RASTRO,SB4->B4_RASTRO) == "N"
		lRet := .T.
	ElseIf IF(!lGradeB4,M->B1_RASTRO,M->B4_RASTRO) $ "SL" .And. IF(!lGradeB4,SB1->B1_RASTRO,SB4->B4_RASTRO) $ "SL "
		// Para mudar a rastreabilidade do tipo "L" para o tipo "S"
		// deve verificar alguns arquivos e avisar ao usuario o procedimento que deve
		// ser adotado
		If (IIF(!lGradeB4,M->B1_RASTRO,M->B4_RASTRO) == "S" .And. IIF(!lGradeB4,SB1->B1_RASTRO,SB4->B4_RASTRO) == "L");
		   .or. (IIF(!lGradeB4,M->B1_RASTRO,M->B4_RASTRO) == "L" .And. IIF(!lGradeB4,SB1->B1_RASTRO,SB4->B4_RASTRO) == "S")
			lRet:=.T.
			dbSelectArea("SD5")
			dbSetOrder(2)
			dbSeek(xFilial("SD5")+cProd)
			// Verifica se foi feito algum movimento depois do ultimo fechamento
			While !Eof() .And. D5_FILIAL+D5_PRODUTO == xFilial("SD5")+cProd
				If Empty(SD5->D5_ESTORNO) .And. SD5->D5_DATA > dDataFec
					Aviso(STR0041,STR0042,{"Ok"}) //"Tipo de Rastreabilidade"###"Nao pode ser alterado. Ja ocorreram movimentos deste produto apos o ultimo fechamento."
					lRet:=.F.
					Exit
				EndIf
				dbSkip()
			End
			// Verifica se existe algum empenho ou qtd a classificar pendente
			If lRet
				dbSelectArea("SB8")
				dbSetOrder(1)
				dbSeek(xFilial("SB8")+cProd)
				Do While !Eof() .And. B8_FILIAL+B8_PRODUTO == xFilial("SB8")+cProd
					If QtdComp(SB8SALDO(.T.,,,,,lEmpPrev,,,.T.)) > QtdComp(0) .Or. QtdComp(B8_QACLASS) > QtdComp(0)
						Aviso(STR0041,STR0043,{"Ok"}) //"Tipo de Rastreabilidade"###"Nao pode ser alterado. Existe saldo a distribuir ou saldo empenhado nos lotes deste produto."
						lRet := .F.
						Exit
					    //----------------------------------------------------------------------------------------//
						// Adicionado validao para tratamento de alterao de cadastro de produto                |
						// ao realizar tentativa de alterao com Saldo existente na tabela SB8 (Saldo por Lote)   |
						// no ser permitido alterao de forma de rastro somente aps zerar o saldo do Lote.     |
						//-----------------------------------------------------------------------------------------//
					ElseIf lLotUni .And. lAltProd
						If QtdComp(SB8SALDO(.F.,,,,,lEmpPrev,,,.T.)) > QtdComp(0)
							Aviso(STR0041,STR0233,{"Ok"}) //"Tipo de Rastreabilidade"###"Nao pode ser alterado. Existe saldo atrelado a Lote"
							lRet := .F.
							Exit
						EndIf
					EndIF
					dbSkip()
				EndDo
			EndIf
		Else
			lRet := .T.
		EndIf
	Endif
Else
	If IF(!lGradeB4,M->B1_RASTRO,M->B4_RASTRO) $ "SL"
		Help(" ",1,"NAORASTRO")
	ElseIf IF(!lGradeB4,M->B1_RASTRO,M->B4_RASTRO) == "N"
		lRet := .T.
	EndIf
Endif

RestArea(aAreaSB8)
RestArea(aArea)

Return lRet

/*


Ŀ
Funo    AvalLocali Autor Rodrigo de A. Sartorio  Data  01/02/99 
Ĵ
Descrio  Avalia se existe saldo por localizacao para o produto      
Ĵ
Sintaxe    AvalLocali() 				                              
Ĵ
           ExpC1= Codigo do produto                                   
Parametro  lGradeB4 - >indica se quem chamou a funcao foi o b1 ou b4  
Ĵ
 Uso       EST/PCP/FAT/COM	                                          
ٱ


*/
Function AvalLocali(cProd,lGradeB4)
Local lRet 			:= .T.
Local aArea			:= GetArea()
Local aAreaSB2 		:= SB2->( GetArea() )
Local aAreaSBF		:= SBF->( GetArea() )
Local cLocaliza 	:= Nil //SuperGetMV("MV_LOCALIZ",.F.,"N")
Local cBkpFil		:= cFilAnt
Local cB1_Localiz 	:= ""
Local cBZ_Localiz 	:= ""
Local cAuxFunName 	:= AllTrim(FunName())
Local lIsLoja	  	:= cAuxFunName == "LOJA110"
Local oModelAux		:= Nil
Local oSBZModel		:= Nil
Local cSBZFil		:= Nil
Local cSBZArm		:= Nil
Local lMt010Mvc		:= .F.
Local cSB1Locali	:= Nil
Local cQuery		:= Nil
Local nInd			:= 0
Local nTotReg		:= 0
Local nQtdExc		:= 0
Local lMvcInclui	:= .F.
Local lMvcAltera	:= .F.
Local lUpdLocaliz	:= .F.
Local l010Auto		:= Iif (Type("l010Auto") == "L", l010Auto, .F.)
Local lInclu010		:= IsInCallStack( "A010INCLUI" )
Local lAlt010		:= IsInCallStack( "A010ALTERA" )

Default lGradeB4	:= .F.

If  GetNewPar("MV_VEICULO","N") == 'S' .AND. Left(Upper(cAuxFunName),3) $ "OFI/VEI" .And. Inclui
	lRet := .T.
	Return lRet
EndIf

//Retorna o valor de B1_LOCALIZ em MVC
oModelAux := FWModelActive()
If oModelAux <> NIL .And. oModelAux:cId == "ITEM"
	lMt010Mvc	:= .T.
	lMvcInclui	:= oModelAux:GetOperation() == 3
	lMvcAltera	:= oModelAux:GetOperation() == 4
	oSBZModel	:= oModelAux:GetModel( "SBZDETAIL" )
	cB1_Localiz := oModelAux:GetValue("SB1MASTER","B1_LOCALIZ")
	cSB1Locali	:= IIf( lMvcInclui, CriaVar( 'B1_LOCALIZ', .F. ), Posicione( 'SB1', 1, FWxFilial( 'SB1' ) + cProd, 'B1_LOCALIZ' ) )
Else
	//SEM MVC // Chamada sendo feita do cadastro de produto, rotina automatica do produto ou Inclusao da Consulta Padrao do Produto
	If l010Auto .OR. lInclu010 .OR. lAlt010 .Or. lIsLoja .Or. (Type("lLoja110Auto") == "L" .And. lLoja110Auto)
		cB1_Localiz := GetMemVar( 'B1_LOCALIZ' )
	Else
		cB1_Localiz := SB1->B1_LOCALIZ
	EndIf
EndIf

cB1_Localiz := IIF( lGradeB4, GetMemVar( 'B4_LOCALIZ' ), cB1_Localiz )
If lGradeB4
	cLocaliza 	:= SuperGetMV("MV_LOCALIZ",.F.,"N")
EndIf

IIf( lMt010Mvc .And. ValType( oSBZModel ) == "O" .And. AllTrim( oSBZModel:cId ) == "SBZDETAIL", oSBZModel:GoLine( 1 ), Nil )
If ( lMt010Mvc ) .And. ValType( oSBZModel ) == "O" .And. AllTrim( oSBZModel:cId ) == "SBZDETAIL" .And. ( !( Empty( oSBZModel:GetValue( "BZ_FILIAL" ) ) ) .And. !( Empty( oSBZModel:GetValue( "BZ_LOCPAD" ) ) ) )
	For nInd := 1 To oSBZModel:Length()
		oSBZModel:GoLine( nInd )
		cSBZFil		:= oSBZModel:GetValue( "BZ_FILIAL" )
		cSBZArm		:= oSBZModel:GetValue( "BZ_LOCPAD" )
		cBZ_Localiz	:= oSBZModel:GetValue( "BZ_LOCALIZ" )
		cFilAnt		:= cSBZFil
		cLocaliza 	:= SuperGetMV("MV_LOCALIZ",.F.,"N")
		lUpdLocaliz	:= oModelAux:IsFieldUpdated("SB1MASTER", "B1_LOCALIZ")

		If Empty( cSBZFil ) .Or. Empty( cSBZArm )
			Loop
		EndIf

		If cLocaliza == "S"
			If !( lRet ) .Or. !( lUpdLocaliz )
				Exit
			ElseIf Empty( cSBZFil )
				nQtdExc ++
				Loop
			Else
				Do Case
				Case ( cB1_Localiz == "N" .And. ( cBZ_Localiz == "S" .Or. Empty( cBZ_Localiz ) ) )
					SBF->( dbSetOrder( 2 ) )
					If !SBF->( dbSeek( cSBZFil + cProd  ) )
						SB2->( dbSetOrder( 1 ) )
						If SB2->( dbSeek(  cSBZFil + cProd ) )
							While SB2->( !Eof() ) .And. SB2->B2_FILIAL == cSBZFil .And. SB2->B2_COD == cProd
									If QtdComp(SB2->B2_QACLASS) > QtdComp(0) .Or. SaldoSB2() > QtdComp(0)
										Help(" ",1,"SB1SBZ",, STR0237 + cSBZFil + STR0238 + STR0239 ,1,0)
										lRet := .F.
										Exit
									EndIf
								SB2->( dbSkip() )
							EndDo
						EndIf
					Else
						While SBF->( !Eof() ) .And. SBF->BF_FILIAL == cSBZFil .And. SBF->BF_PRODUTO == cProd
							If SBF->BF_QUANT > 0
								Help(" ",1,"SB1SBZ",, STR0240 + cSBZFil + STR0241 ,1,0)
								lRet := .F.
								Exit
							EndIf
							SBF->( dbSkip() )
						EndDo
					EndIf

				Case ( cB1_Localiz == "S" .Or. Empty( cB1_Localiz ) ) .And. cBZ_Localiz == "N"
					SB2->( dbSetOrder( 1 ) )
					If SB2->( dbSeek( cSBZFil + cProd ) )
						If SaldoSB2() > 0
							Help(" ",1,"SB1SBZ",, STR0237 + cSBZFil + STR0238 + STR0239 ,1,0)
							lRet := .F.
							Exit
						EndIf
					EndIf

				Case cB1_Localiz == "N" .And. cBZ_Localiz == "N"
					lRet := .T.

				Case cB1_Localiz == "S" .And. ( cBZ_Localiz == "S" .Or. Empty( cBZ_Localiz ) )
					lRet := .T.

				EndCase

			EndIf
		ElseIf cLocaliza == "N"
			If cB1_Localiz == "S"
				Help(" ",1,"NAOLOCALIZ")
				lRet := .F.
			ElseIf cB1_Localiz == "N"
				lRet := .T.
			EndIf
		EndIf

	Next nInd

	If lUpdLocaliz .And. nQtdExc == oSBZModel:Length() .And. lRet
		If cLocaliza == "S"
			SBF->( dbSetOrder( 2 ) )
			If !SBF->( dbSeek( FWxFilial( 'SBF' ) + cProd  ) )
				SB2->( dbSetOrder( 1 ) )
				If SB2->( dbSeek(  FWxFilial( 'SB2' ) + cProd ) )
					While SB2->( !Eof() ) .And. SB2->B2_FILIAL == FWxFilial( 'SB2' ) .And. SB2->B2_COD == cProd
							If QtdComp(SB2->B2_QACLASS) > QtdComp(0) .Or. SaldoSB2() > QtdComp(0)
								Help(" ",1,"SB1SBZ",, STR0237 + cSBZFil + STR0238 + STR0239 ,1,0)
								lRet := .F.
								Exit
							EndIf
						SB2->( dbSkip() )
					EndDo
				EndIf
			Else
				While SBF->( !Eof() ) .And. SBF->BF_FILIAL == FWxFilial( 'SBF' ) .And. SBF->BF_PRODUTO == cProd
					If SBF->BF_QUANT > 0
						Help(" ",1,"SB1SBZ",, STR0240 + FWxFilial( 'SBF' ) + STR0241 ,1,0)
						lRet := .F.
						Exit
					EndIf
					SBF->( dbSkip() )
				EndDo
			EndIf
		ElseIf cLocaliza == "N"
			If cB1_Localiz == "S"
				Help(" ",1,"NAOLOCALIZ")
				lRet := .F.
			ElseIf cB1_Localiz == "N"
				lRet := .T.
			EndIf
		EndIf
	EndIf
Else
	cLocaliza 	:= SuperGetMV("MV_LOCALIZ",.F.,"N")
	IIf( Select( 'TMPSBZ' ) > 0, TMPSBZ->( dbCloseArea() ), Nil )
	cQuery 	:= " SELECT SBZ.BZ_FILIAL, SBZ.BZ_COD, SBZ.BZ_LOCPAD, SBZ.BZ_LOCALIZ "
	cQuery 	+= " FROM "+ RetSQLName( 'SBZ' ) +" SBZ "
	cQuery 	+= " WHERE SBZ.BZ_FILIAL IS NOT NULL "
	cQuery 	+= " 	AND SBZ.BZ_COD = '"+ cProd +"' "
	cQuery 	+= " 	AND SBZ.D_E_L_E_T_ = ' ' "

	cQuery	:= ChangeQuery( cQuery )
	dbUseArea( .T., __cRdd, TcGenQry( ,, cQuery ), 'TMPSBZ', .T., .F. )

	dbSelectArea( 'TMPSBZ' )
	TMPSBZ->( dbEval( { || nTotReg ++ },,{ || !Eof() } ) )
	lUpdLocaliz	:= IIf( lMt010Mvc, oModelAux:IsFieldUpdated("SB1MASTER", "B1_LOCALIZ"), ( lAlt010 .And. GetMemVar( 'B1_LOCALIZ' ) <> SB1->B1_LOCALIZ ) )

	If nTotReg == 0
		If cLocaliza == "S"
			If lUpdLocaliz .Or. lGradeB4
				SBF->( dbSetOrder( 2 ) )
				If !SBF->( dbSeek( FWxFilial( 'SBF' ) + cProd  ) )
					SB2->( dbSetOrder( 1 ) )
					If SB2->( dbSeek(  FWxFilial( 'SB2' ) + cProd ) )
						While SB2->( !Eof() ) .And. SB2->B2_FILIAL == FWxFilial( 'SB2' ) .And. SB2->B2_COD == cProd
								If QtdComp(SB2->B2_QACLASS) > QtdComp(0) .Or. SaldoSB2() > QtdComp(0)
									If !l010Auto .and. lAlt010
										MSGALERT(STR0245)// "Como existe Saldo Fisico para este  produto  necessrio que seja executado  o Programa 'Cria Endereo' MATA805 para  adequao do Saldo por Endereo."
									EndIf
									lRet := .T.
									Exit
								EndIf
							SB2->( dbSkip() )
						EndDo
					EndIf
				Else
					While SBF->( !Eof() ) .And. SBF->BF_FILIAL == FWxFilial( 'SBF' ) .And. SBF->BF_PRODUTO == cProd
						If SBF->BF_QUANT > 0
							Help(" ",1,"TEMLOCALIZ")
							lRet := .F.
							Exit
						EndIf
						SBF->( dbSkip() )
					EndDo
				EndIf
			EndIf
		ElseIf cLocaliza == "N"
			If cB1_Localiz == "S"
				Help(" ",1,"NAOLOCALIZ")
				lRet := .F.
			ElseIf cB1_Localiz == "N"
				lRet := .T.
			EndIf
		EndIf
	Else

		TMPSBZ->( dbGoTop() )
		While TMPSBZ->( !Eof() )
			cSBZFil		:= TMPSBZ->BZ_FILIAL
			cBZ_Localiz	:= TMPSBZ->BZ_LOCALIZ
			cFilAnt		:= cSBZFil
			cLocaliza 	:= SuperGetMV("MV_LOCALIZ",.F.,"N")

			If !( lRet ) .Or. !( lUpdLocaliz )
				Exit
			Else
				If cLocaliza == "S"
					Do Case
					Case (cB1_Localiz == "N" .And. ( cBZ_Localiz == "S" .Or. Empty( cBZ_Localiz ) ) )
						SBF->( dbSetOrder( 2 ) )
						If !SBF->( dbSeek( cSBZFil + cProd  ) )
							SB2->( dbSetOrder( 1 ) )
							If SB2->( dbSeek(  cSBZFil + cProd ) )
								While SB2->( !Eof() ) .And. SB2->B2_FILIAL == cSBZFil .And. SB2->B2_COD == cProd
										If QtdComp(SB2->B2_QACLASS) > QtdComp(0) .Or. SaldoSB2() > QtdComp(0)
											Help(" ",1,"SB1SBZ",, STR0237 + cSBZFil + STR0238 + STR0239 ,1,0)
											lRet := .F.
											Exit
										EndIf
									SB2->( dbSkip() )
								EndDo
							EndIf
						Else
							While SBF->( !Eof() ) .And. SBF->BF_FILIAL == cSBZFil .And. SBF->BF_PRODUTO == cProd
								If SBF->BF_QUANT > 0
									Help(" ",1,"SB1SBZ",, STR0240 + cSBZFil + STR0241 ,1,0)
									lRet := .F.
									Exit
								EndIf
								SBF->( dbSkip() )
							EndDo
						EndIf

					Case ( cB1_Localiz == "S" .Or. Empty( cB1_Localiz ) ) .And. cBZ_Localiz == "N"
						SB2->( dbSetOrder( 1 ) )
						If SB2->( dbSeek( cSBZFil + cProd ) )
							If QtdComp(SB2->B2_QACLASS) > QtdComp(0) .Or. SaldoSB2() > QtdComp(0)
								If !l010Auto .and. lAlt010
									MSGALERT(STR0245)// "Como existe Saldo Fisico para este  produto  necessrio que seja executado  o Programa 'Cria Endereo' MATA805 para  adequao do Saldo por Endereo."
								EndIf
								lRet := .T.
								Exit
							EndIf
						EndIf
					Case cB1_Localiz == "N" .And. cBZ_Localiz == "N"
						lRet := .T.

					Case cB1_Localiz == "S" .And. ( cBZ_Localiz == "S" .Or. Empty( cBZ_Localiz ) )
						lRet := .T.

					EndCase
				ElseIf cLocaliza == "N"
					If cB1_Localiz == "S"
						Help(" ",1,"NAOLOCALIZ")
						lRet := .F.
					ElseIf cB1_Localiz == "N"
						lRet := .T.
					EndIf
				EndIf
			EndIf

			TMPSBZ->( dbSkip() )
		EndDo
		IIf( Select( 'TMPSBZ' ) > 0, TMPSBZ->( dbCloseArea() ), Nil )
	EndIf
EndIf

cFilAnt := cBkpFil
RestArea( aAreaSB2 )
RestArea( aAreaSBF )
RestArea( aArea )
Return lRet

/*


Ŀ
Funo    Rastro     Autor  Rodrigo de A. Sartorio Data  10/05/95 
Ĵ
Descrio Pesquisa no SB1 se produto corrente usa rastreabilidade     
Ĵ
Sintaxe    Rastro(cProd,cTipo)  	                                  
           cProd := Cdigo do produto a ser pesquisado no SB1.        
           cTipo := Tipo de Rastreabilidade a ser verificada.         
Ĵ
 Uso       EST/PCP/FAT/COM	                                          
ٱ


*/
Function Rastro(cProd,cTipo)
Local lUsaLote := SuperGetMV("MV_RASTRO",.F.,'N') == "S"
Local lRet     := .F.
Local lRetPE   := .F.
Local cAlias   :="",nRecno := 0,nOrder := 0
Static lTestLot
Static oRastro

cTipo    := If(cTipo == NIL,"",cTipo)
lTestLot := IIF(lTestLot == Nil,ExistBlock('TESTLOT'),lTestLot)

If lUsaLote
	If oRastro == nil
		oRastro := JsonObject():New()
	EndIf
	If oRastro[xFilial("SB1")+cProd+cTipo] == nil .or. lTestLot
		If (SB1->(B1_FILIAL+B1_COD) == xFilial("SB1")+cProd)
			lRet := If( Empty(cTipo),(SB1->B1_RASTRO $ "SL" ),(SB1->B1_RASTRO $ cTipo) )
			If lTestLot
				lRetPE:= Execblock("TESTLOT",.F.,.F.)
				If ValType(lRetPE) == "L"
					lRet := lRetPE
				EndIf
			Endif
		Else
			cAlias := Alias()
			If cAlias # "SB1"
				dbSelectArea("SB1")
			EndIf
			nRecno := Recno()
			nOrder := IndexOrd()
			If nOrder # 1
				dbSetOrder(1)
			EndIf
			If MsSeek(xFilial("SB1")+cProd,.F.)
				lRet := If( Empty(cTipo),(SB1->B1_RASTRO $ "SL" ),(SB1->B1_RASTRO $ cTipo) )
			EndIf
			If lTestLot
				lRetPE:= Execblock("TESTLOT",.F.,.F.)
				If ValType(lRetPE) == "L"
					lRet := lRetPE
				EndIf
			Endif
			If nRecno # Recno()
				dbGoto(nRecno)
			EndIf
			If nOrder # IndexOrd()
				dbSetOrder(nOrder)
			EndIf
			If cAlias # "SB1" .And. cAlias # ''
				dbSelectArea(cAlias)
			EndIf
		EndIf
		oRastro[xFilial("SB1")+cProd+cTipo] := lRet
	Else
		lRet := oRastro[xFilial("SB1")+cProd+cTipo]
	EndIf
EndIf
Return(lRet)

/*

Ŀ
Funo    EstornaProd Autor  Ary Medeiros          Data  02.07.93 
Ĵ
Descrio  Faz a Baixa de lote  usando FIFO                           
Ĵ
Sintaxe    EstornaProd(ExpC1)                                         
Ĵ
Parametros ExpC1 = cAlias                                             
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function EstornaProd(cAlias)
Local xAlias := Alias(), nOrdSB8, nRecSB8, nOrdSD5, nRecSD5, cLocal
IF cAlias == "SD3"
	nOrdSD5 := SD5-> ( IndexOrd() )
	nRecSD5 := SD5-> ( RecNo() )
	nOrdSB8 := SB8-> ( IndexOrd() )
	nRecSB8 := SB8-> ( RecNo() )
	If SD3->D3_CF == "RE2"
		cLocal := GetMvNNR('MV_LOCPROC','99')
	Else
		cLocal := SD3->D3_LOCAL
	Endif
	dbSelectArea("SD5")
	dbSetOrder(3)
	dbSeek(xFilial("SD5")+SD3->D3_NUMSEQ+SD3->D3_COD+cLocal)
	While !Eof() .and. xFilial("SD5")+SD3->D3_NUMSEQ+SD3->D3_COD+cLocal == D5_FILIAL+D5_NUMSEQ+D5_PRODUTO+D5_LOCAL
		IF D5_OP != SD3->D3_OP
			dbSkip()
			Loop
		Endif
		dbSelectArea("SB8")
		dbSetOrder(2)
		dbSeek(xFilial("SB8")+SD5->D5_NUMLOTE+SD5->D5_LOTECTL+SD5->D5_PRODUTO+SD5->D5_LOCAL)
		RecLock("SB8",.F.)
		Replace B8_SALDO  with B8_SALDO + SD5->D5_QUANT
		Replace B8_SALDO2 with B8_SALDO2 + SD5->D5_QTSEGUM
		RecLock("SD5",.F.,.T.)
		dbDelete()
		dbSelectArea("SD5")
		dbSkip()
	End
	dbSelectArea("SD5")
	dbSetOrder(nOrdSD5)
	dbGoto(nRecSD5)
	dbSelectArea("SB8")
	dbSetOrder(nOrdSB8)
	dbGoto(nRecSB8)
Endif
dbSelectArea(xAlias)
Return

/*

Ŀ
Funo    GravaSD5   Autor  Ary Medeiros           Data  02.07.93 
Ĵ
Descrio  Faz a Baixa de lote  usando FIFO                           
Ĵ
Parametros ExpC1 = Alias Origem do Movimento                          
           ExpC2 = Produto                                            
           ExpC3 = Almoxarifado                                       
           ExpC4 = Lote                                               
           ExpC5 = Sub-Lote                                           
           ExpC6 = Numero Sequencial                                  
           ExpC7 = Documento                                          
           ExpC8 = Serie do Documento                                 
           ExpC9 = Ordem de Producao                                  
           ExpC10= Tipo do Movimento                                  
           ExpC11= Cliente/Fornecedor                                 
           ExpC12= Loja                                               
           ExpC13= Lote do Fornecedor                                 
           ExpN1 = Quantidade                                         
           ExpN2 = Quantidade 2a UM                                   
           ExpD1 = Data                                               
           ExpD2 = Data de Validade                                   
           ExpN3 = Potencia do Lote                                   
           ExpC14= Lote produzido                                     
           ExpC15= Sub-Lote produzido                                 
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function GravaSD5(cAlias,cProduto,cLocal,cLoteCtl,cNumLote,cNumSeq,cDoc,cSerie,cOp,cTm,cCliFor,cLoja,cLoteFor,nQuant,nQuant2UM,dData,dDtValid,nPotencia,cLotePrd,cSubLotePrd,cProdMaior,cDCTrt)
Static lPontoGRSD5 := NIL
Local aArea    :=GetArea()
Local aAreaSD5 :={}
Local aAreaSB8 :={}
Local lWmsNew    := SuperGetMV("MV_WMSNEW",.F.,.F.)

Default cLotePrd    :=""
Default cSubLotePrd :=""
Default nPotencia   :=0
Default cProdMaior  :="N"
Default cDCTrt  	:=""

lPontoGRSD5 := If(ValType(lPontoGRSD5) # "L",ExistBlock("MTGRVSD5"),lPontoGRSD5)

dbSelectArea("SD5")
RecLock("SD5",.T.)
Replace D5_FILIAL  with cFilial,;
		D5_NUMSEQ  with cNumSeq,;
		D5_PRODUTO with cProduto,;
		D5_LOCAL   with cLocal,;
		D5_DOC     with cDoc,;
		D5_SERIE   with cSerie,;
		D5_OP      with cOp,;
		D5_DATA    with dData,;
		D5_ORIGLAN with cTm,;
		D5_NUMLOTE with cNumLote,;
		D5_CLIFOR  with cCliFor,;
		D5_LOJA    with cLoja,;
		D5_QUANT   with nQuant,;
		D5_LOTEFOR with cLoteFor,;
		D5_LOTECTL with IF(!Empty(cLoteCtl),cLoteCtl,"AUTO"+cNumLote),;
		D5_DTVALID with dDtValid,;
		D5_QTSEGUM With nQuant2UM,;
		D5_POTENCI With nPotencia

		If FieldPos("D5_PRMAIOR") > 0
			Replace D5_PRMAIOR With cProdMaior
		EndIf


// Grava dados do lote/sublote criados no apontamento de producao
If !Empty(cOp) .And. !Empty(cLotePrd)
	Replace D5_LOTEPRD with cLotePrd,;
		D5_SLOTEPR  with cSubLotePrd
EndIf
MsUnlock()

If IntWMS(cProduto) .And. lWmsNew .And. !Empty(cDCTrt) .And. ( IsInCallStack("A250Inclui") .Or. IsInCallStack("A250Atu") )
	If FieldPos("D5_TRT") > 0
		Replace D5_TRT with cDCTrt
	EndIf
EndIf

// Executa ponto de entrada
If lPontoGRSD5
	aAreaSB8:=SB8->(GetArea())
	aAreaSD5:=SD5->(GetArea())
	Execblock("MTGRVSD5",.F.,.F.,{cAlias,cProduto,cLocal,cLoteCtl,cNumLote,cOp,dDtValid,IIf(Type("l250")=="L",l250,.F.)})
	SB8->(RestArea(aAreaSB8))
	SD5->(RestArea(aAreaSD5))
EndIf
RestArea(aArea)
Return

/*

Ŀ
Funo     QtdLote    Autor  Waldemiro L. Lustosa  Data  07.11.94 
Ĵ
Descrio  Retorna Qtd. Ja' utilizada do Lote no cadastramento de um  
           mesmo Pedido de Venda (atraves da GetDados).               
Ĵ
Sintaxe    QtdLote(ExpC1,ExpC2,ExpC3,ExpL1)                           
Ĵ
Parametros ExpC1 = Produto a ser pesquisado                           
           ExpC2 = Almoxarifado a ser pesquisado                      
           ExpC3 = Numero do Lote a ser pesquisado (opcional)         
           ExpL1 = Indica se o campo  QtdLiberada (.F.)              
                   Indica se o campo  QtdVendida  (.T.)              
           ExpC4 = Lote                                               
Ĵ
Uso        MATA440                                                    
ٱ


*/
Function QtdLote(cProduto,cLocal,cLote,lQtd,cLoteCt)

Local cChkProduto := ""
Local cChkLocal   := ""
Local cChkLote    := ""

Local nMaxArray   := 0
Local nx          := 0
Local nQtdLote    := 0
Local nChkQtdLib  := 0
Local nPosPro     := Ascan(aHeader,{|x| Alltrim(x[2]) == "C6_PRODUTO"})
Local nPosLocal   := Ascan(aHeader,{|x| Alltrim(x[2]) == "C6_LOCAL"})
Local nPosLote    := Ascan(aHeader,{|x| Alltrim(x[2]) == "C6_NUMLOTE"})
Local nPosLoteCt  := Ascan(aHeader,{|x| Alltrim(x[2]) == "C6_LOTECTL"})
Local nPosQtdVen  := Ascan(aHeader,{|x| Alltrim(x[2]) == "C6_QTDVEN"})
Local nPosQtdLib  := Ascan(aHeader,{|x| Alltrim(x[2]) == "C6_QTDLIB"})

lQtd  := IF( lQtd  == NIL ,.F. , lQtd  )
cLote := IF( cLote == NIL , "" , cLote )
cLoteCt := IF( cLoteCt == NIL , "" , cLoteCt )

//Ŀ
// Cria array com lotes ja utilizados neste produto neste mesmo PV.
//
nMaxArray := Len(aCols)

For nx := 1 to nMaxArray

	//Ŀ
	// Executar somente se o item no estiver deletado                 
	//
	If Len(aHeader)==Len(aCols[nX]) .Or. (Valtype(aCols[nx,Len(aCols[nx])]) == "L" .And. !aCols[nx,Len(aCols[nx])])

		If nPosPro > 0
			cChkProduto := aCols[nx][nPosPro]
		Endif
		If nPosLocal > 0
			cChkLocal   := aCols[nx][nPosLocal]
		Endif
		If nPosQtdVen > 0 .And. nPosQtdLib > 0
			nChkQtdLib  := Iif(lQtd,aCols[nx][nPosQtdVen],aCols[nx][nPosQtdLib])
		Endif
		If nPosLote > 0
			cChkLote    := aCols[nx][nPosLote]
		Endif
		If nPosLoteCt > 0
			cChkLoteCt  := aCols[nx][nPosLoteCt]
		Endif

		If Rastro( cProduto, "S" )
			If cChkProduto+cChkLocal == cProduto+cLocal .And. !Empty(cChkLote);
					.And. nChkQtdLib != 0 .And. n != nx
				If cChkProduto+cChkLocal+cChkLoteCt+cChkLote = cProduto+cLocal+cLoteCt+cLote
					nQtdLote += nChkQtdLib
				EndIf
			EndIf
		Else
			If cChkProduto+cChkLocal == cProduto+cLocal .And. !Empty(cChkLoteCt);
					.And. nChkQtdLib != 0 .And. n != nx
				If cChkProduto+cChkLocal+cChkLoteCt = cProduto+cLocal+cLoteCt
					nQtdLote += nChkQtdLib
				EndIf
			EndIf
		EndIf
	Endif
Next nx
Return(nQtdLote)

/*


Ŀ
Funo     FormaBase Autor  Gilson do Nascimento   Data  17/04/95 
Ĵ
Descrio  Forma base de Dados para processamento em /NTX ou AS400    
Ĵ
Sintax     FormaBase(cExpr1,cExpr2,cExpr3,lExpr)                      
           cExpr1 := Alias do Arquivo. Se nao passar,  assume o Alias 
                     corrente                                         
           cExpr2 := Condicao/Filtro para Arquivo. Se nao passar,     
                     assume Branco ("")                               
           cExpr3 := Chave de Pesquisa para Index. Se nao passar,     
                     assume o index corrente (IndexKey())             
           cExpr4 := Nome do Arquivo. Se nao passar a rotina utiliza  
                     a CriaTrab()                                     
           lExpr  := Se DBFNTX,.T.                                    
                     Se AS400  ,.F.                                   
                     Se nao passar, assume DBFNTX (.T.)               
Ĵ
 Uso       Generico AS400                                             
ٱ


*/
Function FormaBase(cAlias,cCondicao,cChave,cArq)

cAlias	:= IF(cAlias==NIL,Alias(),cAlias)
cCondicao:= IF(cCondicao==NIL,"",cCondicao)
cChave   := IF(cChave==NIL,IndexKey(),cChave)
cArq 		:= IF(cArq==NIL,CriaTrab("",.F.),cArq)

IndRegua(cAlias,cArq,cChave,,,STR0002)	//"Selecionando Registros..."

Return

/*


Ŀ
Funo    SeekQuery  Autor  Gilson do Nascimento   Data  18/04/95 
Ĵ
Descrio Pesquiesa no arquivo ate que encontre um registro igual     
Ĵ
Sintax     SeekQuery(cExpr1,cExpr2)                                   
           cExpr1 := Campos do Arquivo.                               
           cExpr2 := Condicao a ser pesquisada.                       
Ĵ
 Uso       Generico AS400                                             
ٱ


*/
Function SeekQuery(cCampo,cExpressao)
While !Eof()
	If (&cCampo.) == (&cExpressao.)
		Exit
	Endif
	dbSkip()
EndDo
Return

/*

Ŀ
Funo    a410SomaC9 Autor  Rosane L. Chene        Data  11/05/95 
Ĵ
Descrio  Soma as notas fiscais de devolucao ja liberadas            
Ĵ
Sintaxe    A440SOMAC9(Expc1,Expc2)                                    
Ĵ
Parametros ExpC1 = Codigo do Cliente                                  
           ExpC2 = Codigo da Loja                                     
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function A410SOMAC9(cCLiFor,cLoja)
Local nSomaC9, cAlias, nRec, nInd

cAlias := Alias()
nRec := RecNo()
nInd := IndexOrd()
dbSelectArea("SC9")
dbSetOrder(2)
dbSeek(xFilial("SC9")+cCliFor+cLoja)
nSomaC9:= 0
While !Eof() .And. xFilial("SC9")+cCliFor+cLoja == C9_FILIAL+C9_CLIENTE+C9_LOJA

	//Verifica se refere-se ao mesmo produto e se este
	// item ja foi faturado, pois se ja foi faturado ja esta
	// no D1_QTDEDEV

	If C9_PRODUTO != SD1->D1_COD .Or. C9_BLEST == "10" .Or. C9_BLCRED == "10"
		DbSkip()
		Loop
	Endif

	dbSelectArea("SC5")
	dbSetOrder(1)
	dbSeek(xFilial("SC5")+SC9->C9_PEDIDO)
	If !Found()
		dbSelectArea("SC9")
		dbSkip()
		Loop
	Endif
	// Se Nao for Devolucao ignorar
	If SC5->C5_TIPO != "D"
		dbSelectArea("SC9")
		dbSkip()
		Loop
	Endif

	dbSelectArea("SC6")
	dbSetOrder(1)
	dbSeek(xFilial("SC6")+SC5->C5_NUM+SC9->C9_ITEM)
	If !Found() .Or. Empty(SC6->C6_NFORI)
		dbSelectArea("SC9")
		dbSkip()
		Loop
	Endif

	// Verifica se esta devolucao refere-se a mesma nota
	If SC6->C6_NFORI+SC6->C6_SERIORI+SC6->C6_ITEMORI == SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_ITEM
		nSomaC9+=SC9->C9_QTDLIB
	Endif
	dbSelectArea("SC9")
	dbSkip()
End

dbSelectArea(cAlias)
dbSetOrder(nInd)
dbGoto(nRec)
Return nSomaC9

/*

Ŀ
Funo    A120cCond  Autor  Eveli Morasco          Data  05/11/92 
Ĵ
Descrio  Critica da condicao de pagamento                           
Ĵ
           ExpC1 = Condicao de Pagamento                              
Ĵ
 Uso       MatA120                                                    
ٱ


*/
Function A120cCond(cCondicao)
Local lRet := .T.
dbSelectArea("SE4")
dbSetOrder(1)   && forca o indice na ordem certa
dbSeek( xFilial("SE4")+cCondicao )
If Eof()
	Help(" ",1,"A120COND")
	lRet := .F.
Endif

Return lRet

/*


Ŀ
Funo     SaldoTerc Autor  Cristina M. Ogura      Data  31.05.95 
Ĵ
Descrio  Retorna o Saldo do Produto no arquivo SB6                  
Ĵ
Sintaxe    ExpA1 := SaldoTerc(ExpC1,ExpC2,ExpC3,ExpD4,ExpC4)          
Ĵ
Parametros ExpC1 = Codigo da Produto                                  
           ExpC2 = Local do Produto                                   
           ExpC3 = Tipo de Poder de terceiros (D = De Terceiros,	  
                                               T = Em Terceiros)	  
           ExpD4 = Data de fechamento                                 
           ExpC5 = Local limite do produto                            
           ExpL6 = Indica se o saldo deve ser calculado por Cli/Forn. 
           ExpC7 = Codigo do Produto ate, utilizado para gerar a      
                   matriz aSaldoProd{}                                
           ExpL1 = Indica se considera TES de poder de 3os que nao    
           atualiza estoque                                           
           ExpL2 = Indica se Custo FIFO                               
           ExpL3 = Indica se o saldo deve ser calculado por Documento 
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function SaldoTerc(cCod,cLocal,cTipo,dDtFech,cLocalAte,lCliFor,cCodAte,lConsTesTerc,lCusFifo,lDocto,lTransito,aLocDeAte,lIdent)

Local aStruSB6   := {}
Local aStruSF4   := {}
Local aSaldoProd := {}
Local lLocalWhile:= .F.
Local lIsTransito:= .F.
Local lFoundSD3  := .F.
Local nX         := 0
Local nY         := 0
Local aSaldo     := Array(3)
Local cArq       := Alias()
Local cAliasSQL  := "SB6"
Local cAliasTES  := "SF4"
Local lConTerc   := SuperGetMv("MV_CONTERC",.F.,.F.)
Local cLocTerc	 := GetMvNNR('MV_ALMTERC','80')
Local lCusUnif   := AllTrim(SuperGetMv('MV_CUSFIL' ,.F.,"A")) <> "A"

DEFAULT cLocalAte	:= cLocal
DEFAULT lCliFor		:= .F.
DEFAULT lConsTesTerc:= .F.
DEFAULT lCusFifo    := .F.
DEFAULT lDocto      := .F.
DEFAULT lTransito   := .F.
DEFAULT cCodAte 	:= ""
DEFAULT aLocDeAte	:= {}
DEFAULT lIdent		:= .F.

lLocalWhile:=(cLocal == cLocalAte) .And. ("B6_LOCAL" $ SB6->(IndexKey()))

//Ŀ
//| Caso o processo de transito esteja configurado considerar os documentos |
//| que possuem o campo F4_TRANSIT='S' independente do F4_ESTOQUE.          |
//
lIsTransito:= lTransito .And. lConTerc .And. lCusUnif .And. !Empty(cLocTerc)

//Ŀ
// Ajusta o array a Saldo de acordo com o parametro lCliFor  
//
If lCliFor .Or. lDocto
	aSaldo := {}
Else
	aSaldo := {0,0,0}
EndIf

If cTipo=="T"
	cTipo:="E"
EndIf

//Ŀ
// Query utilizada para selecao de registros             
//
lPropr := SB6->(columnpos('B6_CLIPROP')) > 0 .And. SB6->(Columnpos('B6_LJCLIPR')) > 0 .and. IsIncallStack ('MATR460') .and. cTipo == 'D'

cAliasSQL := "SALDOTERC"
cAliasTES := "SALDOTERC"
aStruSB6  := SB6->(dbStruct())
cQuery := "SELECT B6_FILIAL,B6_PRODUTO,B6_LOCAL,B6_TIPO,B6_DTDIGIT,B6_TES,B6_ESTOQUE,B6_QUANT,B6_CUSTO1,B6_TPCF,B6_CLIFOR,B6_LOJA,B6_CUSFF1,B6_IDENT,B6_DOC,B6_SERIE,F4_ESTOQUE,F4_PODER3 "
If lPropr
	cQuery += ",B6_CLIPROP, B6_LJCLIPR"
EndIf
cQuery += " FROM " + RetSqlName("SB6") + " SB6 ," + RetSqlName("SF4")+" SF4 "
cQuery += " WHERE SB6.B6_FILIAL='" + xFilial("SB6") + "' AND "
If Empty(cCodAte)
	cQuery += " SB6.B6_PRODUTO =  '" + cCod + "' AND SB6.B6_TIPO = '" + cTipo + "' AND "
Else
	cQuery += " SB6.B6_PRODUTO >= '" + cCod + "' AND SB6.B6_PRODUTO <= '" + cCodAte + "' AND SB6.B6_TIPO ='" + cTipo + "' AND "
EndIf
cQuery += " SB6.B6_PRODUTO <> ' ' AND "

If !Empty(aLocDeAte)
	cQuery += " ( "
	For nY := 1 To Len(aLocDeAte[1]) -1
		cQuery += "( SB6.B6_LOCAL BETWEEN '" +aLocDeAte[1][nY] +"' AND '"+aLocDeAte[2][nY]+"' ) OR "
	Next nY
	cQuery += "( SB6.B6_LOCAL BETWEEN '" + aLocDeAte[1][nY] +"' AND '"+aLocDeAte[2][nY]+"' )) AND "
Else
	cQuery += " SB6.B6_LOCAL >= '" + cLocal + "' AND SB6.B6_LOCAL<='" + cLocalAte + "' AND "
EndIf
cQuery += " SB6.B6_DTDIGIT <= '" + Dtos(dDtFech) + "' AND SB6.D_E_L_E_T_=' ' AND"
cQuery += " SF4.F4_FILIAL ='" + xFilial("SF4")+"' AND SF4.F4_CODIGO=SB6.B6_TES AND"
If lConsTesTerc
	cQuery += " (SF4.F4_ESTOQUE = 'S' OR (SF4.F4_ESTOQUE = 'N' AND SF4.F4_PODER3 IN ('R','D')))"
Else
	If lIsTransito
		cQuery += " ( SF4.F4_ESTOQUE = 'S' OR SF4.F4_TRANSIT = 'S' ) "
	Else
		cQuery += " SF4.F4_ESTOQUE = 'S'"
	EndIf
EndIf
cQuery += " AND SF4.D_E_L_E_T_ = ' '"
SB6->(dbCommit())
SF4->(dbCommit())
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSQL,.F.,.T.)
For nX := 1 To Len(aStruSB6)
	If aStruSB6[nX][2]<>"C" .And. FieldPos(aStruSB6[nX][1])<>0
		TcSetField(cAliasSQL,aStruSB6[nX][1],aStruSB6[nX][2],aStruSB6[nX][3],aStruSB6[nX][4])
	EndIf
Next nX
For nX := 1 To Len(aStruSF4)
	If aStruSF4[nX][2]<>"C" .And. FieldPos(aStruSF4[nX][1])<>0
		TcSetField(cAliasSQL,aStruSF4[nX][1],aStruSF4[nX][2],aStruSF4[nX][3],aStruSF4[nX][4])
	EndIf
Next nX

While !Eof()

	If Empty(cCodAte)
		If (((cAliasTes)->F4_ESTOQUE == "S") .Or. (lConsTesTerc .And. (cAliasTes)->F4_PODER3 $ "RD"))

			//Ŀ
			// Calculo de Saldo por Cliente/Fornecedor                   
			// Retorno: aSaldo[nX,1] - B6_TPCF+B6_CLIFOR+B6_LOJA         
			//          aSaldo[nX,2] - B6_QUANT / F4_ESTOQUE = 'S'       
			//          aSaldo[nX,3] - B6_CUSTO1                         
			//          aSaldo[nX,4] - B6_QUANT / F4_ESTOQUE = 'N'       
			//
			If lCliFor
				If lIdent
					nX := aScan(aSaldo,{|x| x[5] == (cAliasSQL)->B6_IDENT})
					If nX == 0
						aAdd(aSaldo,{(cAliasSQL)->B6_TPCF+(cAliasSQL)->B6_CLIFOR+(cAliasSQL)->B6_LOJA,0,0,0,(cAliasSQL)->B6_IDENT})
						nX := Len(aSaldo)
					EndIf
				Else
					nX := aScan(aSaldo,{|x| x[1] == (cAliasSQL)->B6_TPCF+(cAliasSQL)->B6_CLIFOR+(cAliasSQL)->B6_LOJA})
					If nX == 0
						aAdd(aSaldo,{(cAliasSQL)->B6_TPCF+(cAliasSQL)->B6_CLIFOR+(cAliasSQL)->B6_LOJA,0,0,0})
						nX := Len(aSaldo)
					EndIf
				EndIf
				If (cAliasTES)->F4_PODER3 == "R"
					aSaldo[nX,2] += (cAliasSQL)->B6_QUANT
					If lCusFifo
						aSaldo[nX,3] += (cAliasSQL)->B6_CUSFF1
					Else
						aSaldo[nX,3] += (cAliasSQL)->B6_CUSTO1
					EndIf
					aSaldo[nx,4] += If((cAliasTes)->F4_ESTOQUE # "S",(cAliasSQL)->B6_QUANT,0)
				Else
					aSaldo[nX,2] -= (cAliasSQL)->B6_QUANT
					If lCusFifo
						aSaldo[nX,3] -= (cAliasSQL)->B6_CUSFF1
					Else
						aSaldo[nX,3] -= (cAliasSQL)->B6_CUSTO1
					EndIf
					aSaldo[nx,4] -= IIf((cAliasTes)->F4_ESTOQUE # "S",(cAliasSQL)->B6_QUANT,0)
				EndIf
			//Ŀ
			// Calculo de Saldo por Documento                                     
			// Retorno: aSaldo[nX,1] - B6_IDENT                                   
			//          aSaldo[nX,2] - B6_QUANT / F4_ESTOQUE = 'S'                
			//          aSaldo[nX,3] - B6_CUSTO1                                  
			//          aSaldo[nX,4] - B6_QUANT / F4_ESTOQUE = 'N'                
			//
			ElseIf lDocto
				nX := aScan(aSaldo,{|x| x[1] == (cAliasSQL)->B6_IDENT})
				If nX == 0
					aAdd(aSaldo,{(cAliasSQL)->B6_IDENT,(cAliasSQL)->B6_CLIFOR,(cAliasSQL)->B6_LOJA,0,0,0})
					nX := Len(aSaldo)
				EndIf
				If (cAliasTES)->F4_PODER3 == "R"
					aSaldo[nX,4] += (cAliasSQL)->B6_QUANT
					If lCusFifo
						aSaldo[nX,5] += (cAliasSQL)->B6_CUSFF1
					Else
						aSaldo[nX,5] += (cAliasSQL)->B6_CUSTO1
					EndIf
					aSaldo[nx,6] += IIf((cAliasTes)->F4_ESTOQUE # "S",(cAliasSQL)->B6_QUANT,0)
				Else
					aSaldo[nX,4] -= (cAliasSQL)->B6_QUANT
					If lCusFifo
						aSaldo[nX,5] -= (cAliasSQL)->B6_CUSFF1
					Else
						aSaldo[nX,5] -= (cAliasSQL)->B6_CUSTO1
					EndIf
					aSaldo[nx,6] -= IIf((cAliasTes)->F4_ESTOQUE # "S",(cAliasSQL)->B6_QUANT,0)
				EndIf
			//Ŀ
			// Calculo de Saldo por Produto                              
			// Retorno: aSaldo[nX,1] - B6_QUANT / F4_ESTOQUE = 'S'       
			//          aSaldo[nX,2] - B6_CUSTO                          
			//          aSaldo[nX,3] - B6_QUANT / F4_ESTOQUE = 'N'       
			//
			Else
				If (cAliasTES)->F4_PODER3 == "R"
					aSaldo[1] += (cAliasSQL)->B6_QUANT
					If lCusFifo
						aSaldo[2] += (cAliasSQL)->B6_CUSFF1
					Else
						aSaldo[2] += (cAliasSQL)->B6_CUSTO1
					EndIf
					aSaldo[3] += If((cAliasTes)->F4_ESTOQUE # "S",(cAliasSQL)->B6_QUANT,0)
				Else
					aSaldo[1] -= (cAliasSQL)->B6_QUANT
					If lCusFifo
						aSaldo[2] -= (cAliasSQL)->B6_CUSFF1
					Else
						aSaldo[2] -= (cAliasSQL)->B6_CUSTO1
					EndIf
					aSaldo[3] -= If((cAliasTes)->F4_ESTOQUE # "S",(cAliasSQL)->B6_QUANT,0)
				EndIf
			EndIf
		EndIf
	Else
		If (((cAliasTes)->F4_ESTOQUE == "S") .Or. ( (lConsTesTerc .Or. lIsTransito) .And. (cAliasTes)->F4_PODER3 $ "RD"))
			If !lCliFor
				If lIsTransito
					aMovSD3   := PesqMovTran(cAliasSQL) // Recupera o custo do armazem de transito
					lFoundSD3 := aMovSD3[1]
				EndIf
				nX := aScan(aSaldoProd,{|x| x[1] == (cAliasSQL)->B6_FILIAL+(cAliasSQL)->B6_PRODUTO})
				If nX == 0
					AADD(aSaldoProd,{(cAliasSQL)->B6_FILIAL+(cAliasSQL)->B6_PRODUTO,(cAliasSQL)->B6_LOJA,0,0,0,0})
					nX := Len(aSaldoProd)
				EndIf
				If (cAliasTES)->F4_PODER3 == "R"
					aSaldoProd[nX,3] += (cAliasSQL)->B6_QUANT
					If lCusFifo
						aSaldoProd[nX,4] += IIf(lFoundSD3,aMovSD3[4],(cAliasSQL)->B6_CUSFF1)
					Else
						aSaldoProd[nX,4] += IIf(lFoundSD3,aMovSD3[3],(cAliasSQL)->B6_CUSTO1)
					EndIf
					If lIsTransito .And. lFoundSD3
						aSaldoProd[nx,5] += aMovSD3[2]
						aSaldoProd[nx,6] += aMovSD3[3]
					Else
						aSaldoProd[nx,5] += IIf((cAliasTes)->F4_ESTOQUE # "S",(cAliasSQL)->B6_QUANT,0)
						aSaldoProd[nx,6] += IIf((cAliasTes)->F4_ESTOQUE # "S",(cAliasSQL)->B6_CUSTO1,0)
					EndIf
				Else
					aSaldoProd[nX,3] -= (cAliasSQL)->B6_QUANT
					If lCusFifo
						aSaldoProd[nX,4] -= IIf(lFoundSD3,aMovSD3[4],(cAliasSQL)->B6_CUSFF1)
					Else
						aSaldoProd[nX,4] -= IIf(lFoundSD3,aMovSD3[3],(cAliasSQL)->B6_CUSTO1)
					EndIf
					If lIsTransito .And. lFoundSD3
						aSaldoProd[nx,5] -= aMovSD3[2]
						aSaldoProd[nx,6] -= aMovSD3[3]
					Else
						aSaldoProd[nx,5] -= IIf((cAliasTes)->F4_ESTOQUE # "S" .or. ((cAliasSQL)->B6_ESTOQUE == "N" .and. lConsTesTerc),(cAliasSQL)->B6_QUANT,0)
						aSaldoProd[nx,6] -= IIf((cAliasTes)->F4_ESTOQUE # "S" .or. ((cAliasSQL)->B6_ESTOQUE == "N" .and. lConsTesTerc),(cAliasSQL)->B6_CUSTO1,0)
					EndIf
				EndIf
			Else
				// Recupera o custo do armazem de transito para autalizacao dos documentos de poder de terceiros
				If lIsTransito
					aMovSD3   := PesqMovTran(cAliasSQL) // Recupera o custo do armazem de transito
					lFoundSD3 := aMovSD3[1]
				EndIf
				If lCliFor .And. lIdent
					nX := aScan(aSaldoProd,{|x| x[5] == (cAliasSQL)->B6_IDENT})
					If nX == 0
						aadd(aSaldoProd,{(cAliasSQL)->B6_TPCF+(If(lPropr .And.  (cAliasSQL)->B6_CLIPROPR <> ' ',(cAliasSQL)->B6_CLIPROPR+(cAliasSQL)->B6_LJCLIPR,(cAliasSQL)->B6_CLIFOR+(cAliasSQL)->B6_LOJA))+(cAliasSQL)->B6_PRODUTO,0,0,0,(cAliasSQL)->B6_IDENT})
						nX := Len(aSaldoProd)
					EndIf
				Else
					nX := aScan(aSaldoProd,{|x| x[1] == (cAliasSQL)->B6_TPCF+(If(lPropr .And.  (cAliasSQL)->B6_CLIPROPR <> ' ',(cAliasSQL)->B6_CLIPROPR+(cAliasSQL)->B6_LJCLIPR,(cAliasSQL)->B6_CLIFOR+(cAliasSQL)->B6_LOJA))+(cAliasSQL)->B6_PRODUTO})
					If nX == 0
						aadd(aSaldoProd,{(cAliasSQL)->B6_TPCF+(If(lPropr .And.  (cAliasSQL)->B6_CLIPROPR <> ' ',(cAliasSQL)->B6_CLIPROPR+(cAliasSQL)->B6_LJCLIPR,(cAliasSQL)->B6_CLIFOR+(cAliasSQL)->B6_LOJA))+(cAliasSQL)->B6_PRODUTO,0,0,0})
					    nX := Len(aSaldoProd)
					EndIF
				EndIf
				If (cAliasTES)->F4_PODER3 == "R"
					aSaldoProd[nX,2] += (cAliasSQL)->B6_QUANT
					If lCusFifo
						aSaldoProd[nX,3] += IIf(lFoundSD3,aMovSD3[4],(cAliasSQL)->B6_CUSFF1)
					Else
						aSaldoProd[nX,3] += IIf(lFoundSD3,aMovSD3[3],(cAliasSQL)->B6_CUSTO1)
					EndIf
					If lIsTransito .And. lFoundSD3
						aSaldoProd[nx,4] += aMovSD3[2]
					Else
						aSaldoProd[nx,4] += IIf((cAliasTes)->F4_ESTOQUE # "S",(cAliasSQL)->B6_QUANT,0)
					EndIf
				Else
					aSaldoProd[nX,2] -= (cAliasSQL)->B6_QUANT
					If lCusFifo
						aSaldoProd[nX,3] -= IIf(lFoundSD3,aMovSD3[4],(cAliasSQL)->B6_CUSFF1)
					Else
						aSaldoProd[nX,3] -= IIf(lFoundSD3,aMovSD3[3],(cAliasSQL)->B6_CUSTO1)
					EndIf
					If lIsTransito .And. lFoundSD3
						aSaldoProd[nx,4] -= aMovSD3[2]
					Else
						aSaldoProd[nx,4] -= IIf((cAliasTes)->F4_ESTOQUE # "S",(cAliasSQL)->B6_QUANT,0)
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
	dbSelectArea(cAliasSQL)
	dbSkip()
EndDo
If lCliFor .And. Empty(aSaldo)
	aSaldo := {{"",0,0}}
EndIf
dbSelectArea(cAliasSQL)
dbCloseArea()

If !Empty(cArq)
	dbSelectArea(cArq)
EndIf
Return(iIf(Empty(cCodAte),aSaldo,aSaldoProd))

/*

Ŀ
Funo    	F4Saldo  Autor Rodrigo de A. Sartorio Data  24.10.96  
Ĵ
Descrio  Consulta Saldo em Estoque                                  
Ĵ
Sintaxe    F4Saldo(ExpC1,ExpC2)				                          
Ĵ
Parametros ExpC1 = Codigo do Produto                                  
           ExpC2 = Local do Produto                                   
Ĵ
Uso        Generico                                                   
ٱ


*/
Function F4Saldo(cProduto,cLocal)
Local cAlias:=Alias()
Local nOrder:=IndexOrd()
Local nRecno:=Recno()
Local nStoK := 0
Local oDlg

dbSelectArea("SB1")
dbSetOrder(1)
dbSeek(xFilial("SB1")+cProduto)
If Found()
	dbSelectArea("SB2")
	dbSetOrder(1)
	dbSeek(xFilial("SB2")+cProduto+cLocal)
	If Found()
		nStoK:=SaldoSB2()
	Endif

	DEFINE MSDIALOG oDlg FROM  62,1 TO 293,365 TITLE OemToAnsi(STR0003) PIXEL	//"Posio do Estoque"
	@ 0, 2 TO 28, 181 LABEL "" OF oDlg  PIXEL
	@ 31, 2 TO 91, 181 LABEL "" OF oDlg  PIXEL
	@ 8, 4 SAY OemToAnsi(STR0004) SIZE 31, 7 OF oDlg PIXEL	//"Produto :"
	@ 7, 39 SAY cProduto + " /" + Subs(SB1->B1_DESC,1,20) SIZE 140, 7 OF oDlg PIXEL
	@ 16, 5 SAY OemToAnsi(STR0005) SIZE 31, 7 OF oDlg PIXEL	//"Local    :"
	@ 16, 39 SAY cLocal SIZE 13, 7 OF oDlg PIXEL
	@ 37, 9 SAY OemToAnsi(STR0006) SIZE 92, 7 OF oDlg PIXEL	//"Pedido de Vendas em Aberto"
	@ 37, 118 SAY B2_QPEDVEN  SIZE 53, 7 OF oDlg PIXEL
	@ 45, 9 SAY OemToAnsi(STR0007) SIZE 88, 7 OF oDlg PIXEL	//"Quantidade Empenhada"
	@ 45, 118 SAY B2_QEMP SIZE 53, 7 OF oDlg PIXEL
	@ 53, 9 SAY OemToAnsi(STR0008) SIZE 88, 7 OF oDlg PIXEL	//"Qtd.Prevista p/Entrar"
	@ 53, 118 SAY B2_SALPEDI SIZE 53, 7 OF oDlg PIXEL
	@ 61, 9 SAY OemToAnsi(STR0009) SIZE 88, 7 OF oDlg PIXEL	//"Quantidade Reservada (A)"
	@ 61, 118 SAY B2_RESERVA SIZE 53, 7 OF oDlg PIXEL
	@ 69, 9 SAY OemToAnsi(STR0010) SIZE 53, 7 OF oDlg PIXEL	//"Saldo Atual (B)"
	@ 69, 118 SAY B2_QATU SIZE 53, 7 OF oDlg PIXEL
	@ 78, 9 SAY OemToAnsi(STR0011) SIZE 53, 7 OF oDlg PIXEL	//"Disponvel (B - A)"
	@ 78, 118 SAY nStoK SIZE 53, 7 OF oDlg PIXEL
	DEFINE SBUTTON FROM 98, 149 TYPE 1 ACTION oDlg:End() ENABLE OF oDlg
	ACTIVATE MSDIALOG oDlg
Endif
dbSelectArea(cAlias)
dbSetOrder(nOrder)
dbGoTo(nRecno)
Return

/*


Ŀ
Funo      MSGravaD3 Autor  Armando T. Buchina     Data  30.10.96 
Ĵ
Descrio   Atualizar o SD3 com Movimentacoes DE8 utilizando os Itens  
            do SD1 provenientes do SIGAEIC                             
Ĵ
Sintaxe     MsGravaD3(ExC1,ExC2,ExC3,ExN1,ExL1,ExC4,ExD1,ExN2,ExC5)    
Ĵ
 Parmetros ExpC1 = 01.Codigo do Produto                               
            ExpC2 = 02.Numero do Pedido                                
            ExpC3 = 03.Numero do Item na NF                            
            ExpN4 = 04.Quantidade a ser Movimentada                    
            ExpL5 = 05.Variavel Lgica que Ativa o Estorno             
            ExpC6 = 06.Lote                                            
            ExpD7 = 07.Data de Validade do Lote                        
            ExpN8 = 08.Quantidade na Segunda Unidade de Medida         
            ExpC9 = 09.Segunda Unidade de Medida Utilizada             
            ExpCA = 10.Local Padrao                                    
Ĵ
 Uso        Integracao entre os Modulos de Compras e Importacao        
ٱ

*/
Function MSGravaD3(cCod,cPedido,cItem,nQuant,aCusto,lEstorno,cLoteCTL,dDtValid,nQtSegUm,cSegUm,cLocal)

Local aAreaAnt   := GetArea()
Local aCampos    := {}
Local aAreaSD1   := {}
Local aAreaSD5   := {}
Local aAreaSD7   := {}
Local aAreaSWN   := {}
Local aEnvCele   := {}
Local aRecCele   := {}
Local aMov       := {}
Local aCM        := {}
Local aNumCQ     := {}
Local cLocCQ	 := GetMvNNR('MV_CQ','98')
Local cProdImp   := PadR(SuperGetMV('MV_PRODIMP',.F.,''),Len(SD1->D1_COD))
Local cNumCQ     := ''
Local cNumSeqD1  := ''
Local cSeek      := ''
Local cSeekSD1   := ''
Local cSeekSD7   := ''
Local cNumLote   := ''
Local cImpSWN    := ''
Local cIndSWN    := ''
Local nPrazoVld  := 0
Local lEstornado := .F.
Local lEnviaCQ	 := .F.
Local lQualiCQ   := .F.
Local lRet       := .T.
Local lCompImp   := .T.
Local nX         := 0
Local nAtraso    := 0
Local cDocSWN    := SWN->WN_PO_NUM
Local cLotCtlQie := ''
Local cNumLotQie := ''
Local lReferencia := .F.
Local cProdRef    := " "
Local lAchou      := .F.
//Ŀ
//Criada a mesma funcao que verifica a Integridade com SIGAEIC 
//Para os casos de atualizar apenas o SIGACUSA.                
//
Local lEIC
//Ŀ
// No Chile a NF que registra entrada no estoque  FAA-Factura 
// do Agente Aduaneiro (WN_TIPO_NF == 9) as NFs de complemento 
// so as posteriores (WN_TIPO_NF $ "AB").                     
// Para Argentina e Paraguay a entrada de estoque ocorre pelas 
// NFs CIF ou FOB WN_TIPO_NF $ "58", as NFs de complemento     
// so definidas por (WN_TIPO_NF $ "9AB").                     
// As NFs de Frete e Seguro no registram movimentos em estoque
// e tambm no incidem no custo (WN_TIPO_NF $ "67").          
//
If cPaisLoc <> "BRA"
	lCompImp := (SWN->WN_TIPO_NF $ '679AB')
	If SWN->WN_TIPO_NF $ "679AB"
		nQuant := 0
	EndIf
Else
	lCompImp := (SWN->WN_TIPO_NF == '2')
EndIf

cCod      := If(cCod==Nil,'',cCod)
cPedido   := If(cPedido==Nil,'',cPedido)
cItem     := If(cItem==Nil,'',cItem)
nQuant    := If(nQuant==Nil,0,nQuant)
aCusto	  := If(aCusto==Nil,{},aCusto)
lEstorno  := If(lEstorno==Nil,.F.,lEstorno)
cLoteCTL  := If(cLoteCTL==Nil,CRIAVAR('B8_LOTECTL'),cLoteCTL)
dDtValid  := If(dDtValid==Nil,CTOD('  /  /  '),dDtValid)
nQtSegUm  := If(nQtSegUm==Nil,0,nQtSegUm)
cSegUm    := If(cSegUm==Nil,'',cSegUm)

DEFAULT cLocal := RetFldProd(SB1->B1_COD,"B1_LOCPAD")

//Ŀ
// Posiciona o SB1                                       
//
dbSelectArea('SB1')
dbSetorder(1)
If !dbSeek(xFilial('SB1')+cCod, .F.)
	Help(' ', 1, 'NOFOUNDSB1')
	lRet := .F.
Else
	nPrazoVld := B1_PRVALID
EndIf

//Ŀ
// Consiste Complemento de Importacao                    
//
If lRet .And. ((lCompImp.And.QtdComp(nQuant)>QtdComp(0)).Or.(!lCompImp.And.QtdComp(nQuant)==QtdComp(0)))
	Aviso('MSGRAVAD3',STR0104+cCod+STR0105,{'Ok'}) //'O Produto '###' esta com Quantidade Invalida.'
	lRet := .F.
EndIf

If lRet
	If !lEstorno
		//Ŀ
		// >> Inclusao no SD3 <<                                 
		//
		//Ŀ
		// Verifica se a Movimentaao ir Entrar no CQ           
		//
		If lCompImp //-- Item da NF de Complemento
			aAreaSWN := SWN->(GetArea())
			dbSelectArea('SWN')
			dbSetOrder(1)
			If dbSeek(cSeek:=xFilial('SWN')+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_TEC, .F.)
				aAreaSD1 := SD1->(GetArea())
				cImpSWN  := WN_HAWB
				cIndSWN  := CriaTrab('',.F.)
				IndRegua('SWN',cIndSWN,"WN_FILIAL+WN_DOC+WN_SERIE+WN_TEC+WN_EX_NCM+WN_EX_NBM+WN_HAWB",,'WN_FILIAL=="'+WN_FILIAL+'".And.WN_HAWB=="'+cImpSWN+'"',STR0002)
				dbGoTop()
				SD1->(dbSetOrder(1))
				Do While !Eof()
					If (cCod==WN_PRODUTO) .And. QtdComp(WN_QUANT)>QtdComp(0) .And. SD1->(dbSeek(cSeekSD1:=xFilial('SD1')+SWN->WN_DOC+SWN->WN_SERIE+SWN->WN_FORNECE+SWN->WN_LOJA+cProdImp, .F.))
						cNumSeqD1 := ''
						Do While !SD1->(Eof()) .And. cSeekSD1==SD1->D1_FILIAL+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD
							If WN_TEC+WN_EX_NCM+WN_EX_NBM==SD1->D1_TEC
								cNumSeqD1 := If(cPaisLoc=="BRA",SD1->D1_NUMSEQ,SWN->WN_NUMSEQ)
								Exit
							EndIf
							SD1->(dbSkip())
						EndDo
						SD7->(dbSetOrder(3))
						If SD7->(dbSeek(cSeekSD7:=xFilial('SD7')+cCod+cNumSeqD1, .F.)) .And. SD7->D7_ORIGLAN=='IM'
							Do While !SD7->(Eof()) .And. cSeekSD7==SD7->D7_FILIAL+SD7->D7_PRODUTO+SD7->D7_NUMSEQ
								lEIC := IntegEIC(SD7->D7_DOC,SD7->D7_SERIE,SD7->D7_FORNECE,SD7->D7_LOJA)
								If SD7->D7_TIPO == 0 .And. If(lEIC,SD7->D7_DOCSWN+SD7->D7_ITEMSWN == cDocSWN+cItem,If(Rastro(SD7->D7_PRODUTO),cLoteCTL == SD7->D7_LOTECTL,.T.))
									aAdd(aNumCQ, SD7->D7_NUMERO)
								EndIf
								SD7->(dbSkip())
							EndDo
							Exit
						EndIf
					EndIf
					dbSkip()
				EndDo
				DbSelectArea("SWN")
				If __TTSInUse
					dbSetOrder(1)
				Else
					RetIndex("SWN")
				EndIf
				dbSelectArea('SD7')
				dbSetOrder(1)
				cNumCQ := ''
				For nX := 1 to Len(aNumCQ)
					If dbSeek((cSeekSD7:=xFilial('SD7')+aNumCQ[nX]+cCod+cLocCQ)+'001', .F.)
						Do While !Eof() .And. cSeekSD7==D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL
							lEIC := IntegEIC(SD7->D7_DOC,SD7->D7_SERIE,SD7->D7_FORNECE,SD7->D7_LOJA)
							If If(lEIC,D7_ITEMSWN==cItem,If(Rastro(D7_PRODUTO),cLoteCTL==D7_LOTECTL,.T.))
								If D7_TIPO == 0
									cNumCQ := D7_NUMERO
								EndIf
							EndIf
							dbSkip()
						EndDo
						If !Empty(cNumCQ)
							Exit
						EndIf
					EndIf
				Next nX
				RestArea(aAreaSD1)
			EndIf
			If !Empty(cNumCQ)
				lQualiCQ   := .F.
				lEnviaCQ   := .T.
			EndIf
			RestArea(aAreaSWN)
		ElseIf RetFldProd(SB1->B1_COD,"B1_TIPOCQ") $' M' //-- CQ Materiais
			cNumSeqD1	:= If(cPaisLoc<>"BRA",SWN->WN_NUMSEQ,SD1->D1_NUMSEQ)
			cProdRef	:= cCod
			lReferencia := MatGrdPrrf(@cProdRef,.T.)
			dbSelectArea("SA5")
			dbSetOrder(1)
			lAchou	:= MsSeek(xFilial("SA5")+SD1->D1_FORNECE+SD1->D1_LOJA+cCod,.F.)
			If !lAchou .And. lReferencia
				dbSelectArea("SA5")
				dbSetOrder(9)
				lAchou := MsSeek(xFilial("SA5")+SD1->D1_FORNECE+SD1->D1_LOJA+cProdRef,.F.)
			Endif
			If lAchou .And. (QtdComp(SB1->B1_NOTAMIN)>QtdComp(A5_NOTA).Or.QtdComp(A5_SKIPLOT)>QtdComp(0))
				If QtdComp(Mod(A5_ENTREGA,A5_SKIPLOT))==QtdComp(0) .Or. QtdComp(SB1->B1_NOTAMIN)>QtdComp(A5_NOTA)
					lEnviaCQ := .T.
				EndIf
				If QtdComp(A5_SKIPLOT)>QtdComp(0)
					RecLock('SA5',.F.)
					Replace A5_ENTREGA With (A5_ENTREGA+1)
					MsUnlock()
				EndIf
			Endif
		ElseIf RetFldProd(SB1->B1_COD,"B1_TIPOCQ") == 'Q' //-- CQ SigaQuali
			lQualiCQ   := .T.
			lEnviaCQ   := .T.
		EndIf
		//Ŀ
		// Achar Custo das Moedas 3,4 e 5 pela RecMoeda
		//
		If Len(aCusto)>0 .And. Len(aCusto)<5
			For nX := 1 To (5-Len(aCusto))
				aAdd(aCusto, 0)
			Next nX
		ElseIf Len(aCusto) == 0
			aCusto := PegaCMD1()
		EndIf
		//Ŀ
		// Gravar no SD3 a 'DE8' para o Produto                  
		//
		RecLock('SD3',.T.)
		Replace D3_FILIAL  With xFilial('SD3')
		Replace D3_COD	   With cCod
		Replace D3_GRUPO   With SB1->B1_GRUPO
		Replace D3_TIPO    With SB1->B1_TIPO
		Replace D3_LOCAL   With If(lEnviaCQ,cLocCQ,cLocal)
		Replace D3_UM	   With SB1->B1_UM
		Replace D3_CONTA   With SB1->B1_CONTA
		Replace D3_DOC	   With SD1->D1_DOC
		Replace D3_QUANT   With nQuant
		Replace D3_CF	   With 'DE8' 	//-- Identifica Movimentacao com Origem no SIGAEIC
		Replace D3_TM	   With '499'
		Replace D3_USUARIO With CUSERNAME
		Replace D3_NUMSEQ  With If(cPaisLoc<>"BRA",SWN->WN_NUMSEQ,SD1->D1_NUMSEQ)
		Replace D3_EMISSAO With SD1->D1_DTDIGIT
		Replace D3_CHAVE   With 'E9' 	//-- No Alterar !!!
		Replace D3_LOTECTL With cLoteCTL
		Replace D3_DTVALID With dDtValid
		Replace D3_QTSEGUM With nQtSegUm
		Replace D3_SEGUM   With cSegUm
		Replace D3_IDENT   With cNumSeqD1  //-- Diferencia as Movimentacoes
		Replace D3_CUSTO1  With aCusto[1]
		Replace D3_CUSTO2  With aCusto[2]
		Replace D3_CUSTO3  With aCusto[3]
		Replace D3_CUSTO4  With aCusto[4]
		Replace D3_CUSTO5  With aCusto[5]
		If IntegEIC(SD1->D1_DOC,SD1->D1_SERIE,SD1->D1_FORNECE,SD1->D1_LOJA)
			Replace D3_DOCSWN  With cDocSWN
			Replace D3_ITEMSWN With cItem
		EndIf
		MsUnlock()
		aCM := aClone(aCusto)
	Else
		//Ŀ
		// >> Estorno no SD3 <<                                  
		//
		dbSelectArea('SD3')
		dbSetOrder(4)
		If dbSeek(cSeek:=xFilial('SD3')+If(cPaisLoc<>"BRA",SWN->WN_NUMSEQ,SD1->D1_NUMSEQ)+'E9'+cCod, .F.)
			Do While !Eof() .And. cSeek==D3_FILIAL+D3_NUMSEQ+D3_CHAVE+D3_COD
				If D3_ESTORNO=='S' .Or. !(D3_QUANT==nQuant) .Or. !(D3_DOC==SD1->D1_DOC)
					dbSkip()
					Loop
				EndIf
				//Ŀ
				// Tenta encontrar o Registro Correto no SD3 com base no SWN    
				//
				If Rastro(cCod) .And.  !Empty(SWN->WN_LOTECTL)
					If !(SWN->WN_LOTECTL==D3_LOTECTL)
						dbSkip()
						Loop
					EndIf
				Else
					If IntegEIC(SD1->D1_DOC,SD1->D1_SERIE,SD1->D1_FORNECE,SD1->D1_LOJA)
						If !Empty(D3_DOC+D3_ITEMSWN)
							If (SWN->WN_DOC+SWN->WN_ITEM # D3_DOC+D3_ITEMSWN)
								dbSkip()
								Loop
							EndIf
						EndIf
					Else
						If !Empty(D3_IDENT)
							If !(AllTrim(SWN->WN_ITEM)==AllTrim(D3_IDENT))
								dbSkip()
								Loop
							EndIf
						EndIf
					EndIf
				EndIf
				//Ŀ
				// Estorna no SD3 a 'DE8' para o Produto                 
				//
				lEstornado := .T.
				//aCM        := PegaCMD3()
				aCM		   := {D3_CUSTO1,D3_CUSTO2,D3_CUSTO3,D3_CUSTO4,D3_CUSTO5}
				aCampos    := {}
				RecLock('SD3',.F.)
				Replace D3_ESTORNO With 'S'
				MsUnlock()
				For nX := 1 To fCount()
					aAdd(aCampos, FieldGet(nX))
				Next nX
				RecLock('SD3',.T.)
				For nX := 1 To fCount()
					FieldPut(nX,aCampos[nX])
				Next nX
				Replace D3_CF  With 'RE8'
				Replace D3_TM  With '999'
				MsUnlock()
				Exit
			EndDo
		EndIf
		lRet := lEstornado
	Endif
EndIf

If lRet .And. (!lEstorno.Or.lEstornado)
	If !lEstorno
		//Ŀ
		// >> Atualizacoes Posteriores a Inclusao no SD3 <<            
		//
		//Ŀ
		// Baixar o Pedido de Compras (SC7)                            
		//
		If !lCompImp .And. !Empty(cPedido+cItem)
			dbSelectArea('SC7')
			dbSetOrder(1)
			If dbSeek(xFilial('SC7')+cPedido+'01'+cItem, .F.)
				RecLock('SC7',.F.)

				Replace C7_QTDACLA With (C7_QTDACLA - nQuant)
				Replace C7_QUJE    With (C7_QUJE + nQuant)
				Replace C7_ENCER   With (If(C7_QUANT-C7_QUJE>0,Space(1),'E'))
				MsUnlock()
				dbSelectArea('SB2')
				dBSetOrder(1)
				If !MsSeek(xFilial('SB2')+cCod+SC7->C7_LOCAL)
					CriaSB2(cCod,SC7->C7_LOCAL)
				EndIf
				RecLock('SB2', .F.)
				Replace B2_NAOCLAS With (B2_NAOCLAS-nQuant)
				Replace B2_SALPEDI With (B2_SALPEDI-nQuant)
				MsUnlock()
				If !MsSeek(xFilial("SB2")+SD3->D3_COD+SD3->D3_LOCAL)
					CriaSB2(SD3->D3_COD,SD3->D3_LOCAL)
				EndIf
			EndIf
		Endif
		//Ŀ
		// Atualiza o Saldo em Estoque                        
		//
		dbSelectArea('SD3')
		B2AtuComD3(aCM,,,,,,,,,,,,,,,,.F.)

		//Ŀ
		// Atualiza campos de Sub-Lote e Data de validade     
		//
		cLoteCtl := SD3->D3_LOTECTL
		cNumLote := SB8->B8_NUMLOTE //O SB8 esta posicionado, cfe 17 parametro da B2AtuComD3
		dDtValid := SD3->D3_DTVALID
		If Rastro(cCod)
			If !(SWN->WN_LOTECTL==cLoteCtl)
				RecLock('SWN', .F.)
				Replace WN_LOTECTL With cLoteCtl
				MsUnlock()
			EndIf
			If Rastro(cCod)
				If  !(SWN->WN_NUMLOTE==cNumLote)
					RecLock('SWN', .F.)
					Replace WN_NUMLOTE With cNumLote
					MsUnlock()
				EndIf
			EndIf
			If Empty(dDtValid)
				dDtValid := (SD3->D3_EMISSAO+nPrazoVld)
				RecLock('SD3', .F.)
				Replace D3_DTVALID With dDtValid
				MsUnlock()
			EndIf
			If  !(SWN->WN_DTVALID==dDtValid)
				RecLock('SWN', .F.)
				Replace WN_DTVALID With dDtValid
				MsUnlock()
			EndIf
		EndIf
		//Ŀ
		// Atualiza o CQ Materiais (SD7)                         
		//
		If lEnviaCQ
			If lCompImp
				fGeraCQ8(SD1->D1_DOC, SD1->D1_SERIE, SD1->D1_FORNECE, SD1->D1_LOJA, cCod, SD1->D1_ITEM, 'IM', cLocCQ, Nil,cNumCQ, .T., cItem, cDocSWN)
			Else
				If SF4->F4_PODER3 $'RD' .And. !Empty(SD1->D1_IDENTB6)
					SB6->(dbSetOrder(3))
					If SB6->(dbSeek(xFilial('SB6')+SD1->D1_IDENTB6+cCod+SF4->F4_PODER3, .F.))
						RecLock('SB6', .F.)
						Replace B6_LOCAL With cLocCQ
						MsUnlock()
					EndIf
				EndIf
				cNumCQ := CriaVar('D7_NUMERO')
				If fGeraCQ0('SD3', cCod, 'IM')
					cNumCQ := SD7->D7_NUMERO
				ElseIf lQualiCQ
					lQualiCQ := .F.
					Help(' ',1,'NOQAIMPENT')
				EndIf
				//Ŀ
				// Distribuicao Automatica (So para Produtos no CQ)   
				//
				If Localiza(cCod) .And. !Empty(GetMV('MV_DISTAUT'))
					A100Distri(cCod, SD3->D3_LOCAL, SD3->D3_NUMSEQ, SD3->D3_DOC, Nil, Nil, Nil, Nil, Nil, nQuant,SD3->D3_LOTECTL,SD3->D3_NUMLOTE, Nil, Nil, If(lEIC,SD3->D3_DOCSWN, Nil), If(lEIC,SD3->D3_ITEMSWN, Nil), SD3->D3_QUANT)
				EndIf
			EndIf
		EndIf

		//Ŀ
		// Envia a Entrada do Material para inspecao no SIGAQIE		 
		// Somente envia se houver controle de CQ e Rastreabilidade.	 
		//
		If lQualiCQ
			SB1->(dbSetOrder(1))
			lQualiCQ := SB1->(dbSeek(xFilial("SB1")+SD3->D3_COD)) .And. RetFldProd(SB1->B1_COD,"B1_TIPOCQ") == 'Q'
		EndIf

		//Ŀ
		// Realiza a Integracao com Inspecao de Entradas (QIE)			 
		//
		If lQualiCQ

			If a100SeekPC(SD1->D1_PEDIDO, SD1->D1_ITEMPC, cCod, xFilial('SC7'), SD1->D1_FORNECE)
				nAtraso := SD1->D1_DTDIGIT-SC7->C7_DATPRF
			Else
				nAtraso := 0
			Endif

			//Ŀ
			//Posiciona o Registro do SD5, para envio do LOTECTL+NUMLOTE a  
			// qAtuMatQie().												 
			//
			cLotCtlQie := ''
			cNumLotQie := ''
			If Rastro(SB1->B1_COD,"L") .Or. Rastro(SB1->B1_COD,"S")
				aAreaSD5 := SD5->(GetArea())
				SD5->(dbSetOrder(3))
				If SD5->(dbSeek(xFilial('SD5')+SD3->D3_NUMSEQ+SD3->D3_COD+SD3->D3_LOCAL+SD3->D3_LOTECTL+cNumLote, .F.))
					cLotCtlQie := SD5->D5_LOTECTL
					cNumLotQie := SD5->D5_NUMLOTE
				EndIf
				SD5->(dbSetOrder(aAreaSD5[2]))
				SD5->(dbGoto(aAreaSD5[3]))
			EndIf

			//Ŀ
			// Grava os dados referentes ao Inspecao de Entradas (SIGAQIE)  
			//
			aEnvCele := {SD1->D1_DOC,; //Numero da Nota Fiscal
				SD1->D1_SERIE,;   		 //Serie da Nota Fiscal
				SD1->D1_TIPO,;    		 //Tipo da Nota Fiscal
				SD1->D1_EMISSAO,; 		 //Data de Emissao da Nota Fiscal
				SD1->D1_DTDIGIT,; 		 //Data de Entrada da Nota Fiscal
				"NFEIC",; 	  			 //Tipo de Documento
				SD1->D1_ITEM,; 		 	 //Item da Nota Fiscal
				SD1->D1_REMITO,; 		 //Numero do Remito (Localizacoes)
				SD1->D1_PEDIDO,; 		 //Numero do Pedido de Compra
				SD1->D1_ITEMPC,; 		 //Item do Pedido de Compra
				SD1->D1_FORNECE,; 		 //Codigo Fornecedor/Cliente
				SD1->D1_LOJA,; 		 	 //Loja Fornecedor/Cliente
				SD1->D1_LOTEFOR,; 		 //Numero do Lote do Fornecedor
				Space(6),; 			 	 //Codigo do Solicitante
				SD3->D3_COD,; 			 //Codigo do Produto
				SD3->D3_LOCAL,; 		 //Local Origem
				cLotCtlQie,;		 	 //Numero do Lote
				cNumLotQie,; 		 	 //Sequencia do Sub-Lote
				SD3->D3_NUMSEQ,; 		 //Numero Sequencial
				cNumCQ,; 		 		 //Numero do CQ
				nQuant,; 				 //Quantidade
				SD1->D1_TOTAL,; 		 //Preco
				nAtraso,;		 		 //Dias de atraso
				SD1->D1_TES,;			 //TES
				AllTrim(FunName()),;	 //Origem
				" ",;					 //Origem TXT
				0 }					     //Quantidade original do Lote

			//Ŀ
			// Realiza a integracao Materiais x Inspecao de Entradas		 
			//
			aRetQIE := qAtuMatQie(aEnvCele,1)

			//Ŀ
			// Liberao Automatica (FREE-PASS) - Parametrizada no SigaQIE  
			//
			If aRetQIE[1] == 'C' .Or. aRetQIE[1] == 'L'
				aMov := {}
				aAdd(aMov, {})
				aAdd(aMov[Len(aMov)], 1)
				aAdd(aMov[Len(aMov)], SD7->D7_SALDO)
				aAdd(aMov[Len(aMov)], SD7->D7_LOCDEST)
				aAdd(aMov[Len(aMov)], SD7->D7_DATA)
				aAdd(aMov[Len(aMov)], '')
				aAdd(aMov[Len(aMov)], '')
				aAdd(aMov[Len(aMov)], aRecCele[2])
				aAdd(aMov[Len(aMov)], SD7->D7_QTSEGUM)
				fGravaCQ(cCod, cNumCQ, .F., aMov, aCM)
			EndIf

			//Ŀ
			// Executa execblock QIEA210T apos gravacao da movim. do CQ Celerina 
			//
			If ExistBlock('QIEA210T')
				ExecBlock('QIEA210T', .F., .F., {'EST'})
			EndIf

		ElseIf lQualiCQ
			If ExistBlock('QIEA210T')
				ExecBlock('QIEA210T', .F., .F., {'EST'})
			EndIf

		EndIf
	ElseIf lEstornado
		//Ŀ
		// >> Atualizacoes Posteriores ao Estorno no SD3 <<            
		//
		//Ŀ
		// Estorna o Pedido de Compras (SC7)                           
		//
		If !lCompImp .And. !Empty(cPedido+cItem)
			dbSelectArea('SC7')
			dbSetOrder(1)
			If dbSeek(xFilial('SC7')+cPedido+'01'+cItem, .F.)
				RecLock('SC7',.F.)
				Replace C7_QUJE  With (C7_QUJE-SWN->WN_QUANT)
				Replace C7_ENCER With Space(1)
				MsUnlock()
				dbSelectArea('SB2')
				dBSetOrder(1)
				If !MsSeek(xFilial('SB2')+cCod+SC7->C7_LOCAL)
					CriaSB2(cCod,SC7->C7_LOCAL)
				EndIf
				RecLock('SB2', .F.)
				Replace B2_SALPEDI With (B2_SALPEDI+nQuant)
				MsUnlock()
				If !MsSeek(xFilial("SB2")+SD3->D3_COD+SD3->D3_LOCAL)
					CriaSB2(SD3->D3_COD,SD3->D3_LOCAL)
				EndIf
			EndIf
		Endif
		//Ŀ
		//Estorna Movimentacoes Referentes a CQ (Materiais e Quality)     
		//
		dbSelectArea('SD7')
		dbSetOrder(3)
		If dbSeek(cSeekSD7:=xFilial('SD7')+cCod+SD3->D3_NUMSEQ, .F.) .And. D7_ORIGLAN=='IM'
			Do While !Eof() .And. cSeekSD7==D7_FILIAL+D7_PRODUTO+D7_NUMSEQ
				If !(D7_ORIGLAN=='IM') .Or. If(lCompImp,!Empty(D7_ESTORNO),.F.)
					dbSkip()
					Loop
				EndIf
				cSeek := xFilial('SD7')+D7_NUMERO+D7_PRODUTO+D7_LOCAL
				fEstoCQ8(SD7->D7_NUMERO, cCod, SD3->D3_LOCAL, Nil)
				If !lCompImp
					dbSelectArea('SD7')
					dbSetOrder(1)
					If dbSeek(cSeek, .F.)
						Do While !Eof() .And. cSeek==D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL
							If D7_TIPO==0 .And. RetFldProd(SB1->B1_COD,"B1_TIPOCQ") == 'Q'
								aAreaSD7 := GetArea()
								nAtraso  := 0
								If a100SeekPC(SD1->D1_PEDIDO, SD1->D1_ITEMPC, cCod, xFilial('SC7'), SD1->D1_FORNECE)
									nAtraso := SD1->D1_DTDIGIT-SC7->C7_DATPRF
								Endif

								//Ŀ
								//Posiciona o registro no SD5 para que o LOTECTL+NUMLOTE seja en
								//viado para qAtuMatQie()										 
								//
								cLotCtlQie := ''
								cNumLotQie := ''
								If Rastro(SD7->D7_PRODUTO,"L") .Or. Rastro(SD7->D7_PRODUTO,"S")
									aAreaSD5 := SD5->(GetArea())
									SD5->(dbSetOrder(3))
									If SD5->(dbSeek(xFilial('SD5')+SD7->D7_NUMSEQ+SD7->D7_PRODUTO+SD7->D7_LOCAL+SD7->D7_LOTECTL+SWN->WN_NUMLOTE, .F.))
										cLotCtlQie := SD5->D5_LOTECTL
										cNumLotQie := SD5->D5_NUMLOTE
									EndIf
									SD5->(dbSetOrder(aAreaSD5[2]))
									SD5->(dbGoto(aAreaSD5[3]))
								EndIf

								aEnvCele := {SD1->D1_DOC,;  	 	  //Numero da Nota Fiscal
									SD1->D1_SERIE,;   				  //Serie da Nota Fiscal
									SD1->D1_TIPO,;    				  //Tipo da Nota Fiscal
									SD1->D1_EMISSAO,; 				  //Data de Emissao da Nota Fiscal
									SD1->D1_DTDIGIT,; 				  //Data de Entrada da Nota Fiscal
									"NFEIC",;  						  //Tipo de Documento
									SD1->D1_ITEM,; 				  	  //Item da Nota Fiscal
									SD1->D1_REMITO,; 				  //Numero do Remito (Localizacoes)
									SD1->D1_PEDIDO,; 				  //Numero do Pedido de Compra
									SD1->D1_ITEMPC,; 				  //Item do Pedido de Compra
									SD1->D1_FORNECE,; 				  //Codigo Fornecedor/Cliente
									SD1->D1_LOJA,; 				  	  //Loja Fornecedor/Cliente
									SD1->D1_LOTEFOR,; 				  //Numero do Lote do Fornecedor
									Space(6),; 					  	  //Codigo do Solicitante
									cCod,; 					  		  //Codigo do Produto
									SD1->D1_LOCAL,; 				  //Local Origem
									cLotCtlQie,;					  //Numero do Lote
									cNumLotQie,; 					  //Sequencia do Sub-Lote
									SD5->D5_NUMSEQ,; 				  //Numero Sequencial
									SD7->D7_NUMERO,; 				  //Numero do CQ
									SD7->D7_SALDO,; 				  //Quantidade
									SD1->D1_TOTAL,; 				  //Preco
									nAtraso,;					      //Dias de atraso
									SD1->D1_TES	,;			  		  //TES da Nota Fiscal de Entrada
									AllTrim(FunName()),;	  		  //Origem
									" ",;							  //Origem TXT
									0 }				 			      //Quantidade do Lote Original

								//Ŀ
								// Realiza a exclusao do material enviado para Inspecao		 
								//
								aRecCele := qAtuMatQie(aEnvCele,2)

								RestArea(aAreaSD7)

							EndIf
							RecLock('SD7', .F.)
							dbDelete()
							MsUnlock()
							dbSkip()
						EndDo
					EndIf
				EndIf
			EndDo
		EndIf
		//Ŀ
		// Atualiza o Estoque com o Estorno da Importacao     
		//
		dbSelectArea('SD3')
		B2AtuComD3(aCM)
	EndIf
EndIf

If ExistBlock("MSGRVD3")
	ExecBlock("MSGRVD3",.F.,.F.)
EndIf
RestArea(aAreaAnt)

Return lRet

/*

Ŀ
Funo     DigiPerda Autor Rodrigo de A. Sartorio Data  24/12/96  
Ĵ
Descrio  Faz digitao do motivo da perda.                          
Ĵ
Sintaxe    DigiPerda(ExpC1,ExpC2,ExpN1) 			                  
Ĵ
Parametros ExpC1 = Produto a ser produzido                            
           ExpC2 = Numero da OP                                       
           ExpN1 = Qtd da Perda                                       
Ĵ
Uso        Generico                                                   
ٱ


*/
Function DigiPerda(cProduto,cNumOp,nQtd)
Local cAlias   :="SBC"
Local nOpca	   :=0
Local cTitulo
Local nX	   :=0
Local lContinua:=.T.
Local lAltModulo := .F.
Local lRet	   :=.T.
Local nPos     := 0
Local aNoFields:={"BC_OP","BC_OPERAC","BC_RECURSO","BC_NUMSEQ","BC_SEQSD3"}

PRIVATE oGet

DEFAULT cProduto   := ""
DEFAULT cNumOp	   := ""
DEFAULT nQtd	   := 0
//DEFAULT lAutomacao := .F.
//DEFAULT aColsAut   := {}


If (Type("l680Auto") == "L" .And. l680Auto) .Or. ;
   (Type("l681Auto") == "L" .And. l681Auto) .Or. ;
   (Type("l250Auto") == "L" .And. l250Auto)
	lRet	 := .T.
	lContinua:= .F.
Endif

If lContinua .And. GetMV("MV_DIGIPER") != "S"
	lRet	 := .T.
	lContinua:= .F.
EndIf

If (lContinua .And. nQtd > 0) .Or. ;
	(lRet .And. ;
	Type("l681Auto") == "L" .And. ;
	l681Auto .And. ;
	GetMV("MV_DIGIPER") == "S" .And. ;
	nQtd > 0 .And. ;
	Type("aRotAuto") == "A" .And. ;
	aScan(aRotAuto,{|x|Upper(AllTrim(x[1]))=="AUTREFUGO"}) > 0)

	PRIVATE nPerda := nQtd
	PRIVATE aCols  := {}
	PRIVATE aHeader[0]
	PRIVATE nUsado :=0
	PRIVATE nPosAtu:=0
	PRIVATE nPosAnt:=9999
	PRIVATE nColAnt:=9999
	PRIVATE bCols  :={|x,y|aCols[x][y]}
	PRIVATE nPosQuant,nPosMot,nPosDesc,nPosTipo,nPosCod,nPosLoc,nPosLote,nPosLotCtl,nPosDValid
	PRIVATE nPosLocFis,nPosNumSer,nPosProDes,nPosLocDes,nPosQtdDes,nPosLocFDe,nPosNSeDes,nPosOper
	PRIVATE nPosData
	
	Pergunte("MTA685",.F.)
	PRIVATE lParam  := IIf(mv_par01 == 1, .T. , .F.)
EndIf

If lContinua .And. nQtd > 0
	//Ŀ
	// Verifica a existencia de um campo sequencial                 
	//
	If SBC->(FieldPos("BC_SEQSD3")) == 0
		Aviso(STR0110,STR0111,{"Ok"})  //"Atencao"###"Deve ser criado o campo BC_SEQSD3 com o mesmo tamanho e caracteristica do campo BC_NUMSEQ para utilizacao dessa rotina."
		lRet	 := .F.
		lContinua:= .F.
	EndIf
	If lContinua
		//Ŀ
		// Monta aHeader e aCols utilizando a funcao FillGetDados       
		//
		//Ŀ
		// Sintaxe da FillGetDados(/*nOpcX*/,/*Alias*/,/*nOrdem*/,/*cSeek*/,/*bSeekWhile*/,/*uSeekFor*/,/*aNoFields*/,/*aYesFields*/,/*lOnlyYes*/,/*cQuery*/,/*bMontCols*/,/*lEmpty*/,/*aHeaderAux*/,/*aColsAux*/,/*bAfterCols*/),/*bBeforeCols*/) |
		//
		FillGetDados(1,cAlias,1,,,,aNoFields,,,,,.T.)

		aHdPerda:=aClone(aHeader)

		For nx = 1 To Len(aHeader)
			If Trim(aHeader[nx][2]) == "BC_QUANT"
				nPosQuant:=nX
			ElseIf Trim(aHeader[nx][2]) == "BC_MOTIVO"
				nPosMot:=nX
			ElseIf Trim(aHeader[nx][2]) == "BC_DESCRI"
				nPosDesc:=nX
			ElseIf Trim(aHeader[nx][2]) == "BC_TIPO"
				nPosTipo:=nX
			ElseIf Trim(aHeader[nx][2]) == "BC_PRODUTO"
				nPosCod:=nX
			ElseIf Trim(aHeader[nx][2]) == "BC_LOCORIG"
				nPosLoc:=nX
			ElseIf Trim(aHeader[nx][2]) == "BC_NUMLOTE"
				nPosLote:=nX
			ElseIf Trim(aHeader[nx][2]) == "BC_LOTECTL"
				nPosLotCtl:=nX
			ElseIf Trim(aHeader[nx][2]) == "BC_DTVALID"
				nPosDValid:=nX
			ElseIf Trim(aHeader[nx][2]) == "BC_LOCALIZ"
				nPosLocFis:=nX
			ElseIf Trim(aHeader[nx][2]) == "BC_NUMSERI"
				nPosNumSer:=nX
			ElseIf Trim(aHeader[nx][2]) == "BC_CODDEST"
				nPosProDes:=nX
			ElseIf Trim(aHeader[nx][2]) == "BC_LOCAL"
				nPosLocDes:=nX
			ElseIf Trim(aHeader[nx][2]) == "BC_LOCDEST"
				nPosLocFDe:=nX
			ElseIf Trim(aHeader[nx][2]) == "BC_NSEDEST"
				nPosNSeDes:=nX
			ElseIf Trim(aHeader[nx][2]) == "BC_QTDDEST"
				nPosQtdDes:=nX
			ElseIf Trim(aHeader[nx][2]) == "BC_OPERADO"
				nPosOper:=nX
			ElseIf Trim(aHeader[nx][2]) == "BC_DATA"
				nPosData:=nX
			EndIf
		Next nx

		//Forca o preenchimento da Data na 1a Linha do Acols
		If Len(aCols)>0 .And. nPosDValid <> Nil
			If Empty(aCols[1][nPosDValid])
				aCols[1][nPosDValid]:=dDataBase
			EndIf
		EndIf

		If lSavePerda
			aCols:={}
			aCols:=aClone(aPerda)
		EndIf

 		//Ŀ
		// Ponto de entrada MTDGPERD para preencher o aCols.. 			 
		//
		If ExistBlock("MTDGPERD")
			ExecBlock("MTDGPERD",.F.,.F.,{cProduto,cNumOP,nQtd})
		EndIf

		cTitulo:=OemToAnsi(STR0012+cProduto+STR0013+cNumOP)	//"Classificao da Perda - "###" - OP "
		nOpca  := 0
		Set Key VK_F4 To A685ShowF4()
		DEFINE MSDIALOG oDlg TITLE cTitulo From 0,0 To 20,80 OF oMainWnd

		oSize := FWDefSize():New(.T.,,,oDlg)
		oSize:AddObject("Panel1", 100, 100, .T., .T. ) //Panel 1 em 100% da tela
		oSize:lProp := .T. //permite redimencionar as telas de acordo com a proporo do AddObject
		oSize:Process() //executa os calculos

		oPanel := TPanel():New(oSize:GetDimension("Panel1","LININI"),;
		                       oSize:GetDimension("Panel1","COLINI"),,oDlg,,,,,,;
		                       oSize:GetDimension("Panel1","XSIZE"),;
		                       oSize:GetDimension("Panel1","YSIZE"))

		oGet := MSGetDados():New(5,5,110,310,3,"PerdaLinOK","PerdaTudOk","",.T.,/*10*/,/*11*/,/*12*/,/*13*/,/*14*/,/*15*/,/*16*/,/*17*/,oPanel)
		//If !lAutomacao
			ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,if(oGet:TudoOk(),oDlg:End(),nOpca := 0)},{||oDlg:End()})
		//Else
		//	aCols := aClone(aColsAut)
		//EndIf
		Set Key VK_F4 To
		If nOpca == 1
			lSavePerda:=.T.
			aPerda:=aClone(aCols)
		EndIf
	EndIf
Else
	//Tratativa para rotina automtica
	If lRet .And. ;
		( (Type("l681Auto") == "L" .And. l681Auto) .Or. ;
		  (Type("l250Auto") == "L" .And. l250Auto) ) .And. ;
		GetMV("MV_DIGIPER") == "S" .And. ;
		nQtd > 0 .And. ;
		Type("aRotAuto") == "A"
		nPos := aScan(aRotAuto,{|x|Upper(AllTrim(x[1]))=="AUTREFUGO"})
		If nPos > 0
			aAutoItens := aRotAuto[nPos,2]

			//Se est executando pelo SFC, altera a varivel nModulo para carregar os campos corretamente.
			lAltModulo := .F.
			If nModulo == 79
				nModulo := 10
				lAltModulo := .T.
			EndIf

			FillGetDados(1,cAlias,1,,,,aNoFields,,,,,.T.)
			If lAltModulo
				nModulo := 79
			EndIf
			aHdPerda := aClone(aHeader)

			For nx = 1 To Len(aHeader)
				If Trim(aHeader[nx][2]) == "BC_QUANT"
					nPosQuant:=nX
				ElseIf Trim(aHeader[nx][2]) == "BC_MOTIVO"
					nPosMot:=nX
				ElseIf Trim(aHeader[nx][2]) == "BC_DESCRI"
					nPosDesc:=nX
				ElseIf Trim(aHeader[nx][2]) == "BC_TIPO"
					nPosTipo:=nX
				ElseIf Trim(aHeader[nx][2]) == "BC_PRODUTO"
					nPosCod:=nX
				ElseIf Trim(aHeader[nx][2]) == "BC_LOCORIG"
					nPosLoc:=nX
				ElseIf Trim(aHeader[nx][2]) == "BC_NUMLOTE"
					nPosLote:=nX
				ElseIf Trim(aHeader[nx][2]) == "BC_LOTECTL"
					nPosLotCtl:=nX
				ElseIf Trim(aHeader[nx][2]) == "BC_DTVALID"
					nPosDValid:=nX
				ElseIf Trim(aHeader[nx][2]) == "BC_LOCALIZ"
					nPosLocFis:=nX
				ElseIf Trim(aHeader[nx][2]) == "BC_NUMSERI"
					nPosNumSer:=nX
				ElseIf Trim(aHeader[nx][2]) == "BC_CODDEST"
					nPosProDes:=nX
				ElseIf Trim(aHeader[nx][2]) == "BC_LOCAL"
					nPosLocDes:=nX
				ElseIf Trim(aHeader[nx][2]) == "BC_LOCDEST"
					nPosLocFDe:=nX
				ElseIf Trim(aHeader[nx][2]) == "BC_NSEDEST"
					nPosNSeDes:=nX
				ElseIf Trim(aHeader[nx][2]) == "BC_QTDDEST"
					nPosQtdDes:=nX
				ElseIf Trim(aHeader[nx][2]) == "BC_OPERADO"
					nPosOper:=nX
				ElseIf Trim(aHeader[nx][2]) == "BC_DATA"
					nPosData:=nX
				EndIf
			Next nx

			If nPosQuant == Nil
				nPosQuant := 0
			EndIf
			If nPosMot == Nil
				nPosMot := 0
			EndIf
			If nPosDesc == Nil
				nPosDesc := 0
			EndIf
			If nPosTipo == Nil
				nPosTipo := 0
			EndIf
			If nPosCod == Nil
				nPosCod := 0
			EndIf
			If nPosLoc == Nil
				nPosLoc := 0
			EndIf
			If nPosLote == Nil
				nPosLote := 0
			EndIf
			If nPosLotCtl == Nil
				nPosLotCtl := 0
			EndIf
			If nPosDValid == Nil
				nPosDValid := 0
			EndIf
			If nPosLocFis == Nil
				nPosLocFis := 0
			EndIf
			If nPosNumSer == Nil
				nPosNumSer := 0
			EndIf
			If nPosProDes == Nil
				nPosProDes := 0
			EndIf
			If nPosLocDes == Nil
				nPosLocDes := 0
			EndIf
			If nPosLocFDe == Nil
				nPosLocFDe := 0
			EndIf
			If nPosNSeDes == Nil
				nPosNSeDes := 0
			EndIf
			If nPosQtdDes == Nil
				nPosQtdDes := 0
			EndIf
			If nPosOper == Nil
				nPosOper := 0
			EndIf

			//Forca o preenchimento da Data na 1a Linha do Acols
			If Len(aCols)>0 .And. nPosDValid>0
				If Empty(aCols[1][nPosDValid])
					aCols[1][nPosDValid]:=dDataBase
				EndIf
			EndIf

			msAuto2Acols(3)
			If !SBC->(MsVldAcAuto(aCols,"PerdaLinOK()","PerdaTudOk()",,3))
				lRet := .F.
			Else
				lSavePerda := .T.
				aPerda := aClone(aCols)
			EndIf
		Else
			aPerda := {}
		EndIf
	Else
		aPerda := {}
	EndIf
EndIf
Return lRet

/*


Ŀ
Ĵ
Descrio  Grava no Arquivo de perda por OP e gera uma devolucao do   
           material destino da perda.                                 
Ĵ
           ExpC1 = Numero da OP                                       
           ExpC2 = Numero da Operacao                                 
           ExpC3 = Codigo do Recurso                                  
           ExpC4 = Rotina                                             
ٱ


*/
Function GravaSBC(cNumOP,cOperac,cRecurso,cProg,cNumSeq,cIdenSH6,cDoctoExec)
LOCAL i:=0,n:=0,nRecSD4:=0
LOCAL aAreaAnt := {}
LOCAL aSldLote := {}
LOCAL aAreaSD3 := {}
LOCAL aCM      := {}
LOCAL lFirst   := .T.
LOCAL lDigita  := .T.
LOCAL lAglutina:= .T.
LOCAL lSBCIncl := ExistBlock("SBCIncl")
LOCAL lSBCDocto:= ExistBlock("SBCDOCT")
LOCAL aArea    := GetArea()
LOCAL lCustoOp := GetNewPar("MV_TPCPERD",.T.)
LOCAL cMay     :=""
LOCAL cCodPai  := Posicione("SC2",1,xFilial("SC2")+cNumOP,"C2_PRODUTO")
LOCAL dDatRfOp := Posicione("SC2",1,xFilial("SC2")+cNumOP,"C2_DATRF")
LOCAL aCtbDia  := {}
LOCAL cSeek    := ""
LOCAL lMVPerdInf:= If(Type('lPerdInf')#"L",SuperGetMV('MV_PERDINF',.F.,.F.),lPerdInf)
LOCAL nRecnoSD3:= 0
LOCAL nX       := 0
LOCAL nZ       := 0
LOCAL nSaldo   := 0
LOCAL cSeek2	:= ""
LOCAL nDifD4	:= 0
LOCAL nTotBC    := 0
LOCAL nLimpaDC  := 0
LOCAL lNewReg 	:= .T.
Local lSBCREQORI := ExistBlock('SBCREQORI')
Local cRetReq	:= ''
Local cReq		:= ''
Local cD3OP     := ''
Local lLoteVenc := SuperGetMV("MV_LOTVENC") == "S"
Local aAreaSD4N := {}
Local lPrdIntWMS := .F.
Local lWmsNew    := SuperGetMV("MV_WMSNEW",.F.,.F.)
Local nNewqtdori := 0

Local aTRTsSD4   := {}
Local aDadosSMN   := {}
Local lBrakeSD4  := .F.

Default cDoctoExec := ''
DEFAULT cNumSeq  := ""
DEFAULT cIdenSH6 := ""


// Salva a area no SD3
dbSelectArea("SD3")
aAreaSD3:=GetArea()


If Empty(cDoctoExec)
	//-- S preenche o campo D3_DOC se este no possuir inicializador padro, ou se estiver sem nenhum valor.
	If Empty(GetSX3Cache("D3_DOC","X3_RELACAO"))
		cDocto := NextNumero("SD3",2,"D3_DOC",.T.)
		cDocto := A261RetINV(cDocto)

		//Verifica sequencia de documento
		dbSetOrder(2)
		dbSeek(xFilial("SD3")+cDocto)
		cMay := "SD3"+Alltrim(xFilial("SD3"))+cDocto
		While D3_FILIAL+D3_DOC==xFilial("SD3")+cDocto.Or.!MayIUseCode(cMay)
			If D3_ESTORNO # "S"
				cDocto := Soma1(cDocto)
				cMay := "SD3"+Alltrim(xFilial("SD3"))+cDocto
				dbSeek(xFilial("SD3")+cDocto)
			Else
				SD3->(dbSkip())
			EndIf
		EndDo
	else
		//Executa o inicializador Padro do campo D3_DOC
		 cDocto := InitPad(GetSX3Cache("D3_DOC","X3_RELACAO"))
	EndIf
Else
	cDocto := cDoctoExec
Endif

// Executa ponto de entrada para alterar documento
If lSBCDocto
	cMay:=ExecBlock("SBCDOCT",.F.,.F.,{cDocto})
	If ValType(cMay) == "C"
		cDocto:=cMay
	EndIf
EndIf

// Restaura a area no SD3
RestArea(aAreaSD3)

cOperac  :=If(cOperac==NIL,CriaVar("BC_OPERAC"),cOperac)
cRecurso :=If(cRecurso==NIL,CriaVar("BC_RECURSO"),cRecurso)
cProg    :=If(cProg==NIL,"MATA685",cProg)

If cProg == "MATA685"
	//Ŀ
	// Chama a pergunte que verifica relacao com lancament. contabil
	//
	pergunte("MTA240",.F.)
	lDigita   := Iif(mv_par01 == 1,.T.,.F.)
	lAglutina := Iif(mv_par02 == 1,.T.,.F.)
EndIf

//Ŀ
// Chama a pergunte que verifica se grava ou no a requisicao   
// do produto origem.                                           
//

If !IsInCallStack("MATA685")
	Pergunte("MTA685",.F.)
Else
	If !l685Auto
		Pergunte("MTA685",.F.)
	Else
		mv_par01 := Iif(lParam, 1, 2)
	EndIf
EndIf
//Ŀ
// Inicia a Transacao                         
//
Begin Transaction

For i:=1 to Len(aPerda)
	If !(aPerda[i,Len(aPerda[i])])

			nDifD4	:= 0 //--Reinicializa variavel utilizada para identificar quebra do empenho
			
			If lFirst
				//Ŀ
				// Pega o numero sequencial do movimento      
				//
				cNumseq := If(cNumSeq == "",ProxNum(),cNumSeq)
				lFirst:=.F.
			EndIf
			RecLock("SBC",.T.)
			Replace	BC_FILIAL	With xFilial("SBC"),;
				BC_OP		With cNumOp,;
				BC_OPERAC	With cOperac,;
				BC_RECURSO	With cRecurso,;
				BC_NUMSEQ	With cNumSeq
			For n:=1 to Len(aHdPerda)
				If aHdPerda[n,10] # "V"
					Replace &(aHdPerda[n,2]) With aPerda[i,n]
				EndIf
			Next n

			//Funo para carregar lote e data destino caso esteja em branco
			CargaLtD()

			Replace BC_SEQSD3 With ProxNum()

			If FieldPos("BC_IDENSH6") > 0
			   Replace BC_IDENSH6 With cIdenSH6		//TRMOP5 - Vivian - para estorno da perda sem movimentao de estoque.
			EndIf

			//Ŀ
			// Verifica se o custo medio e' calculado On-Line               
			//
			If cCusMed == "O" .And. lCriaHeader
				//Ŀ
				// Se necessario cria o cabecalho do arquivo de prova           
				//
				lCriaHeader:=.F.
				nHdlPrv := HeadProva(cLoteEst,cProg,Subs(cUsuario,7,6),@cArquivo)
			EndIf

			lPrdIntWMS := IntWMS(SBC->BC_PRODUTO)

			If mv_par01 == 1
				//Ŀ
				// Tratamento para Utilizacao do parametro MV_PERDINF 
				//
				//If lMVPerdInf
					aAreaAnt := GetArea()
					If Rastro(SBC->BC_PRODUTO)
						nSaldo := 0
						lNewReg := .T.
						If lPrdIntWMS .And. lWmsNew
							nSaldo := WmsSldD14(SBC->BC_LOCORIG,SBC->BC_LOCALIZ,SBC->BC_PRODUTO,SBC->BC_NUMSERI,SBC->BC_LOTECTL,SBC->BC_NUMLOTE,,.T.)			
						Else
							//Ŀ
							// Parametros do array aSldLote[]:              |
							//| aSldLote[nX,1] - Lote de Controle            |
							//| aSldLote[nX,2] - Sub-Lote                    |
							//| aSldLote[nX,3] - Localizacao                 |
							//| aSldLote[nX,4] - Numero de Serie             |
							//| aSldLote[nX,5] - Quantidade                  |
							//| aSldLote[nX,6] - Quantidade 2aUM             |
							//| aSldLote[nX,7] - Data de Validade            |
							//
							aSldLote := SldPorLote(SBC->BC_PRODUTO,SBC->BC_LOCORIG,SBC->BC_QUANT,SBC->BC_QTSEGUM,SBC->BC_LOTECTL,IIf(Rastro(SBC->BC_PRODUTO,'S'),SBC->BC_NUMLOTE,""),SBC->BC_LOCALIZ,SBC->BC_NUMSERI,,.F.,,lLoteVenc)
							For nX:=1 to Len(aSldLote)
								If Len(aSldLote[nX,10]) > 0
									For nZ :=1 to Len(aSldLote[nX,10])
										nSaldo+=aSldLote[nx,10,nZ,2]
									Next nZ
								Else
									Exit
								EndIf
							Next nX
						EndIf
						//-- Se o saldo do lote for menor que a quantidade empenhada limpar o Lote/SubLote
						dbSelectArea("SD4")
						dbSetOrder(2)
						dbSeek(cSeek:=xFilial("SD4")+cNumOP+SBC->BC_PRODUTO+SBC->BC_LOCORIG)
						Do While !Eof() .And. cSeek == SD4->(D4_FILIAL+D4_OP+D4_COD+D4_LOCAL)
							If SD4->(D4_LOTECTL+If(Rastro(D4_COD,"S"),D4_NUMLOTE,"")) == SBC->(BC_LOTECTL+If(Rastro(SBC->BC_PRODUTO,"S"),BC_NUMLOTE,""))
								If lPrdIntWMS .And. lWmsNew .AND. nTotBC > 0 
								    If nSaldo < 0 
									   nSaldo := nSaldo * - 1
									EndIf
									nSaldo += (SD4->D4_QUANT-nTotBC)
								Else
							        nTotBC := SBC->BC_QUANT - nSaldo
									nSaldo += (SD4->D4_QUANT-SBC->BC_QUANT)
								ENDIF
								nNewqtdori := (SD4->D4_QTDEORI - nTotBC )
								If !Empty(SD4->D4_QUANT) .And. nSaldo < SD4->D4_QUANT
									//--Verifica a existencia de relacionamento no SDC
									dbSelectArea("SDC")
									dbSetOrder(2)
									dbSeek(cSeek2:=xFilial("SDC")+SD4->(D4_COD+D4_LOCAL+D4_OP+D4_TRT+D4_LOTECTL+D4_NUMLOTE)+SBC->(BC_LOCALIZ+BC_NUMSERI))
									While (!EOF() .And. cSeek2 == SDC->(DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL+DC_NUMLOTE)+SBC->(BC_LOCALIZ+BC_NUMSERI)) .And. (nTotBC > 0)
										nLimpaDC := Min(nTotBC,SDC->DC_QUANT)

										//Realiza baixa da SBF quando no realiza controle de estoque atravs do novo WMS
										If !lPrdIntWMS .Or. !lWmsNew
											SBF->(dbSetOrder(1))
											If SBF->(dbSeek(xFilial("SBF")+SDC->(DC_LOCAL+DC_LOCALIZ+DC_PRODUTO+DC_NUMSERI+DC_LOTECTL+DC_NUMLOTE)))
												GravaBFEmp("-",nLimpaDC,"F",NIL,ConvUm(SD4->D4_COD,nLimpaDC,0,2))
											EndIf
										EndIf

										RecLock("SDC",.F.)
										If nLimpaDC < SDC->DC_QUANT
											Replace SDC->DC_QTDORIG With SDC->DC_QTDORIG - nLimpaDC
											Replace SDC->DC_QUANT With SDC->DC_QUANT - nLimpaDC
											Replace SDC->DC_QTSEGUM With ConvUm(SD4->D4_COD,(SDC->DC_QUANT - nLimpaDC),0,2)
										Else
											SDC->(dbDelete())
										EndIf
										MsUnLock()
										nTotBC -= nLimpaDC
										SDC->(dbSkip())
									End

									If nSaldo > 0 .or. nNewqtdori > 0
										nDifD4 := SD4->D4_QUANT - nSaldo

										RecLock("SD4",.F.)
										Replace SD4->D4_QTDEORI With nNewqtdori
										Replace SD4->D4_QUANT With nSaldo
										Replace SD4->D4_QTSEGUM With ConvUm(SD4->D4_COD,nSaldo,0,2)
										MsUnLock()

										SB8->(dbSetOrder(3))
										SB8->(dbSeek(xFilial("SB8")+SD4->(D4_COD+D4_LOCAL+D4_LOTECTL+D4_NUMLOTE)))
										GravaB8Emp("-",nDifD4,"F",NIL,ConvUm(SD4->D4_COD,nDifD4,0,2))

										// Se o produto possuir controle WMS, realiza a baixa do empenho D14_QTDEMP
										If lPrdIntWMS .And. lWmsNew .And. FindFunction("WmsBxEmp")
											If !( WmsBxEmp(SBC->(Recno()), nDifD4) )
												DisarmTransaction()
												Break
											EndIf
										EndIf

										nRecSD4 := SD4->(Recno())
										cTRTSD4 := SD4->D4_TRT

										SD4->(dbSetOrder(1))
										If SD4->(dbSeek(cSeek2:=xFilial("SD4")+SBC->(BC_PRODUTO+cNumOP+CriaVar("D4_TRT",.F.)+CriaVar("D4_LOTECTL",.F.)+CriaVar("D4_NUMLOTE",.F.))))
											While !EOF() .And. cSeek2 == SD4->(D4_FILIAL+D4_COD+D4_OP+D4_TRT+D4_LOTECTL+D4_NUMLOTE)
												If SD4->D4_LOCAL == SBC->BC_LOCORIG
													lNewReg := .F.
													Exit
												EndIf
												SD4->(dbSkip())
											End
										EndIf

										RecLock("SD4",lNewReg)
										If lNewReg
											Replace SD4->D4_FILIAL With xFilial("SD4"), SD4->D4_COD With SBC->BC_PRODUTO,;
														SD4->D4_LOCAL With SBC->BC_LOCORIG, SD4->D4_OP With cNumOP, D4_DATA With dDataBase,;
														SD4->D4_QTDEORI With nDifD4, SD4->D4_QUANT With nDifD4, SD4->D4_QTSEGUM With ConvUm(SBC->BC_PRODUTO,nDifD4,0,2),;
														SD4->D4_TRT With Iif(!lPrdIntWMS,cTRTSD4,Soma1(WMaxTrtSD4(SD4->D4_OP,SD4->D4_COD)))

											//--Grava tabela de estorno de apontamento de perda, utilizando o D4_TRT como referencia para o WMS
											If TableInDic("SMN")
												If lPrdIntWMS .And. lWmsNew												
													RecLock('SMN', .T.)
													SMN->MN_FILIAL := xFilial("SMN")
													SMN->MN_SEQSD3 := SBC->BC_SEQSD3
													SMN->MN_SEQSBC := SBC->BC_NUMSEQ
													SMN->MN_TRTSD4 := SD4->D4_TRT
													SMN->MN_QTDSD4 := SD4->D4_QUANT
													SMN->(MsUnlock())	
												EndIf
											EndIf
										Else
											Replace SD4->D4_QTDEORI With (SD4->D4_QTDEORI + nDifD4),;
													 SD4->D4_QUANT With (SD4->D4_QUANT + nDifD4),;
													 SD4->D4_QTSEGUM With (SD4->D4_QTSEGUM + ConvUm(SBC->BC_PRODUTO,nDifD4,0,2))
										EndIf
										MsUnLock()

										SD4->(dbSetOrder(2))
										SD4->(dbGoTo(nRecSD4))
										AADD(aTRTsSD4, SD4->D4_TRT)
										lBrakeSD4 := .T.
									Else
										aAreaSD4N := SD4->(GetArea())

										cCodN     := SD4->D4_COD
										cOpN      := SD4->D4_OP
										cTrtN     := SD4->D4_TRT
										cLoteCtlN := Space(TamSX3("D4_LOTECTL")[1])
										cNumLoteN := Space(TamSX3("D4_NUMLOTE")[1])
										nQtdOrigN := SD4->D4_QTDEORI
										nQuantN   := SD4->D4_QUANT
										nQTSEGUM  := SD4->D4_QTSEGUM

										DbSelectArea("SD4")
										SD4->(DbSetOrder(1))
										SD4->(dbGoTop())
										If SD4->(dbSeek(xFilial("SD4")+cCodN+cOpN+cTrtN+cLoteCtlN+cNumLoteN))
											//Atualiza o registro que no possui lote
											RecLock("SD4",.F.)
											Replace D4_QTDEORI      With D4_QTDEORI + nQuantN
											Replace D4_QUANT        With D4_QUANT + nQuantN
											Replace SD4->D4_QTSEGUM With ConvUm(SD4->D4_COD,(SD4->D4_QTSEGUM+nQuantN),0,2)
											MsUnLock()

											//Delete o registro com lote
											SD4->(RestArea(aAreaSD4N))
											If nQtdOrigN == nQuantN
												RecLock("SD4",.F.)
												dbDelete()
												MsUnlock()
											Else
												//Zera saldo
												RecLock("SD4",.F.)
												Replace D4_QTDEORI With (nQtdOrigN-nQuantN)
												Replace D4_QUANT   With 0
												MsUnLock()
											EndIF

											SB8->(dbSetOrder(3))
											SB8->(dbSeek(xFilial("SB8")+SD4->(D4_COD+D4_LOCAL+D4_LOTECTL+D4_NUMLOTE)))
											GravaB8Emp("-",nQuantN,"F",NIL,nQTSEGUM)
										Else
											SD4->(RestArea(aAreaSD4N))

											SB8->(dbSetOrder(3))
											SB8->(dbSeek(xFilial("SB8")+SD4->(D4_COD+D4_LOCAL+D4_LOTECTL+D4_NUMLOTE)))
											GravaB8Emp("-",SD4->D4_QUANT,"F",NIL,SD4->D4_QTSEGUM)

											// Se o produto possuir controle WMS, realiza a baixa do empenho D14_QTDEMP
											If lPrdIntWMS .And. lWmsNew .And. FindFunction("WmsBxEmp")
												If !( WmsBxEmp(SBC->(Recno()), SD4->D4_QUANT) )
													DisarmTransaction()
													Break
												EndIf
											EndIf

											RecLock("SD4",.F.)
											Replace D4_LOTECTL With CriaVar("D4_LOTECTL")
											Replace D4_NUMLOTE With CriaVar("D4_NUMLOTE")
											Replace D4_DTVALID With CriaVar("D4_DTVALID")
											If lPrdIntWMS .And. lWmsNew //Se limpou o lote deve limpar a DCF para requisitar novamente. 
												Replace D4_IDDCF With CriaVar("D4_IDDCF")
											EndIf
											MsUnLock()

											//--Grava tabela de estorno de apontamento de perda, utilizando o D4_TRT como referencia para o WMS
											If TableInDic("SMN")
												If lPrdIntWMS .And. lWmsNew												
													RecLock('SMN', .T.)
													SMN->MN_FILIAL := xFilial("SMN")
													SMN->MN_SEQSD3 := SBC->BC_SEQSD3
													SMN->MN_SEQSBC := SBC->BC_NUMSEQ
													SMN->MN_TRTSD4 := SD4->D4_TRT
													SMN->MN_QTDSD4 := SD4->D4_QUANT
													SMN->(MsUnlock())	
												EndIf
											EndIf

										EndIf

										AADD(aTRTsSD4, SD4->D4_TRT)
										lBrakeSD4 := .T.
									EndIf
								EndIf
							EndIf
							SD4->(dbSkip())
						EndDo
					ElseIf Localiza(SBC->BC_PRODUTO)
						nSaldo := SBC->(SaldoSBF(BC_LOCORIG,BC_LOCALIZ,BC_PRODUTO,BC_NUMSERI,NIL,NIL,.F.,NIL,NIL,NIL))
						nTotBC := SBC->BC_QUANT - nSaldo
						nDifD4 := nTotBC

						dbSelectArea("SDC")
						dbSetOrder(2)
						dBSeek(cSeek:=xFilial("SDC")+SBC->(BC_PRODUTO+BC_LOCORIG+BC_OP))
						While !EOF() .And. cSeek == SDC->(DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP)
							If SDC->(DC_LOCALIZ+DC_NUMSERI) == SBC->(BC_LOCALIZ+BC_NUMSERI) .And. nSaldo < SBC->BC_QUANT
								nLimpaDC := Min(nTotBC,SDC->DC_QUANT)

								SBF->(dbSetOrder(1))
								SBF->(dbSeek(xFilial("SBF")+SDC->(DC_LOCAL+DC_LOCALIZ+DC_PRODUTO+DC_NUMSERI+DC_LOTECTL+DC_NUMLOTE)))
								GravaBFEmp("-",nLimpaDC,"F",NIL,ConvUm(SBC->BC_PRODUTO,SBC->BC_QUANT,0,2))

								RecLock("SDC",.F.)
								If nLimpaDC < SDC->DC_QUANT
									Replace SDC->DC_QTDORIG With (SDC->DC_QUANT - nLimpaDC)
									Replace SDC->DC_QUANT With (SDC->DC_QUANT - nLimpaDC)
									Replace SDC->DC_QTSEGUM With ConvUm(SD4->D4_COD,(SDC->DC_QUANT - nLimpaDC),0,2)
								Else
									SDC->(dbDelete())
								EndIf
								MsUnLock()
								nTotBC -= nLimpaDC

								DbSelectArea("SD4")
								SD4->(dbSetOrder(1)) //D4_FILIAL+D4_COD+D4_OP+D4_TRT+D4_LOTECTL+D4_NUMLOTE
								IF SD4->(DbSeek(xFilial("SD4")+SDC->(DC_PRODUTO+DC_OP+DC_TRT+DC_LOTECTL+DC_NUMLOTE)))
									AADD(aTRTsSD4, SD4->D4_TRT)
									lBrakeSD4 := .T.
								ENDIF
								SD4->(DbCloseArea())
							EndIf
							SDC->(dbSkip())
						End
					EndIf
					RestArea(aAreaAnt)
				//EndIf

				//Ŀ
				// Faz a movimentacao de origem.              
				//
				dbSelectArea("SB1")
				dbSeek(xFilial("SB1")+SBC->BC_PRODUTO)
				RecLock("SD3",.T.)
				Replace	D3_FILIAL	With xFilial("SD3"),;
					D3_COD		With SBC->BC_PRODUTO,;
					D3_QUANT	With SBC->BC_QUANT,;
					D3_QTSEGUM	With If(SBC->BC_QTSEGUM>0, SBC->BC_QTSEGUM, ConvUm(SBC->BC_PRODUTO,SBC->BC_QUANT,0,2)),;
					D3_NUMLOTE  With SBC->BC_NUMLOTE,;
					D3_LOTECTL  With SBC->BC_LOTECTL,;
					D3_DTVALID  With SBC->BC_DTVALID,;
					D3_LOCAL 	With SBC->BC_LOCORIG,;
					D3_GRUPO 	With SB1->B1_GRUPO,;
					D3_TIPO  	With SB1->B1_TIPO,;
					D3_UM    	With SB1->B1_UM,;
					D3_SEGUM   	With SB1->B1_SEGUM,;
					D3_CHAVE	With "E0",;
					D3_TM		With "999",;
					D3_NUMSEQ	With If(!Empty(SBC->BC_SEQSD3),SBC->BC_SEQSD3,cNumSeq),;
					D3_USUARIO	With CUSERNAME,;
					D3_EMISSAO	With SBC->BC_DATA,;					
					D3_LOCALIZ  With SBC->BC_LOCALIZ,;
					D3_NUMSERI  With SBC->BC_NUMSERI,;
					D3_DOC      With cDocto,;
					D3_CONTA	With SB1->B1_CONTA,;
					D3_OBSERVA  With SBC->BC_OBSERVA

				
				If !EMPTY( dDatRfOp ) .And. !l681 .And. !l250
					cD3OP := " "
				Else
					cD3OP := If(Empty(SBC->BC_CODDEST) .And. (cCodPai <> SBC->BC_PRODUTO) ,cNumOP,"")
				EndIf

				Replace D3_OP With cD3OP
				
				//Tratamento do tipo de requisio
				If !Empty(SBC->BC_CODDEST)
					cReq := "RE4"
				Else
					IF !Empty(dDatRfOp) .And. !l681 .And. !l250
						cReq := "RE0"
					Else
						If SB1->B1_AGREGCU == "2"
							cReq := "RE0"
						Else
							cReq := "RE9"
						EndIf
					EndIf
				EndIf			

				// - Ponto de Entrada que permite a alterao do Cod. Da requiso na Origem do Apont. de Perda
				IF lSBCREQORI
					cRetReq := ExecBlock("SBCREQORI",.F.,.F.,{cReq})

					IF  Valtype(cRetReq) <> "C" .OR. EMPTY(cRetReq) .OR. SUBSTR(ALLTRIM(cRetReq),1,2) <> "RE"
						cRetReq := cReq
					Endif

					Replace D3_CF With cRetReq

				Else
					Replace D3_CF With cReq
				Endif

				If  !Empty(SBC->BC_CC)
					Replace D3_CC With SBC->BC_CC
				ElseIf Empty(SBC->BC_CODDEST) .And. (cCodPai <> SBC->BC_PRODUTO)
					Replace D3_CC With Posicione("SC2",1,xFilial("SC2")+cNumOP,"C2_CC")
				EndIf

				MsUnlock()
				//Ŀ
				// Grava o custo da movimentacao              
				//
				aCM    := PegaCmAtu(SD3->D3_COD,SD3->D3_LOCAL)
				aCusto := GravaCusD3(aCM)
				nRecnoSD3 := SD3->(RECNO())

				//Se houve quebra da SD4 grava a tabela auxiliar de estorno de apontamento de perda
				IF lBrakeSD4
					AADD(aDadosSMN, {{SBC->BC_NUMSEQ, IIF(EMPTY(nDifD4), SBC->BC_QUANT, nDifD4)}, aTRTsSD4, SD3->D3_NUMSEQ})
					aTRTsSD4 := {}
					lBrakeSD4  := .F.
				ENDIF
				//Ŀ
				// Atualiza o saldo atual (VATU) com os dados do SD3     
				//
				lRetAtuB2 := B2AtuComD3(aCusto,,,,,,,,,,,,,,,,,,,,,,,,,,IIf(lMVPerdInf,cNumOp,Nil))
				SB2->(MsUnlock())

				//Verifica se ocorreu algum erro na atualizao do B2
				If lRetAtuB2
					//Caso o retorno seja negativo, disarma a transao.
					DisarmTransaction()
					Break
				EndIf
				SB2->(MsUnlock())
				//Ŀ
				// Atualiza os saldos atuais (VATU) das OP's 
				//
				If !Empty(SD3->D3_OP) .And. SD3->D3_CF # "RE9"
					C2AtuComD3(aCusto)
				EndIf
				//Ŀ
				// Verifica se o custo medio e' calculado On-Line               
				//
				If cCusMed == "O"
					//Ŀ
					// Verifica se ira gerar TRANSFERENCIA OU NAO 
					//
					If SD3->D3_CF == "RE4"
						//Ŀ
						// Gera o lancamento no arquivo de prova           
						//
						nTotal+=DetProva(nHdlPrv,"670",cProg,cLoteEst)
					ElseIf SD3->D3_CF == "RE1"
						nTotal+=DetProva(nHdlPrv,"666",cProg,cLoteEst)
					EndIf
				EndIf
				// Se o produto possuir controle WMS, deve realizar a baixa do saldo WMS neste momento
				If lPrdIntWMS .And. lWmsNew .And. FindFunction("WmsPerdaOP")
					If !( WmsPerdaOP(SBC->(Recno()),.F.,cProg) )
						//Caso o retorno seja negativo, desarma a transao.
						DisarmTransaction()
						Break
					EndIf
				EndIf
			EndIf
			//Ŀ
			// Faz a movimentacao de destino.             
			//
			If !Empty(SBC->BC_CODDEST)
				dbSelectArea("SB1")
				dbSeek(xFilial("SB1")+SBC->BC_CODDEST)
				RecLock("SD3",.T.)
				Replace	D3_FILIAL	With xFilial("SD3"),;
					D3_COD		With SBC->BC_CODDEST,;
					D3_QUANT	With SBC->BC_QTDDEST,;
					D3_QTSEGUM	With If(SBC->BC_QTDDES2 >0, SBC->BC_QTDDES2, ConvUm(SBC->BC_CODDEST,SBC->BC_QTDDEST,0,2)),;
					D3_DTVALID  With SBC->BC_DTVALID,;
					D3_LOCAL 	With SBC->BC_LOCAL,;
					D3_GRUPO 	With SB1->B1_GRUPO,;
					D3_TIPO  	With SB1->B1_TIPO,;
					D3_UM    	With SB1->B1_UM,;
					D3_SEGUM   	With SB1->B1_SEGUM,;
					D3_CF 		With IF(mv_par01 == 1,"DE4","DE1"),;
					D3_CHAVE	With SubStr(D3_CF,2,1)+IIF(D3_CF=="DE4","9","0"),;
					D3_TM		With "499",;
					D3_NUMSEQ	With If(!Empty(SBC->BC_SEQSD3),SBC->BC_SEQSD3,cNumSeq),;
					D3_USUARIO	With CUSERNAME,;
					D3_EMISSAO	With SBC->BC_DATA,;
					D3_LOCALIZ  With SBC->BC_LOCDEST,;
					D3_NUMSERI  With SBC->BC_NSEDEST,;
					D3_OP       With IF(mv_par01 == 1,"",If(lCustoOp  .And. (cCodPai <> SBC->BC_CODDEST),cNumOp,"")),;
					D3_DOC      With cDocto,;
					D3_CONTA	With SB1->B1_CONTA,;
					D3_OBSERVA  With SBC->BC_OBSERVA

				If SBC->(FieldPos("BC_LOTDEST")) > 0 .And. Rastro(SBC->BC_CODDEST) .and. !Empty(SBC->BC_LOTDEST)
					Replace D3_LOTECTL With SBC->BC_LOTDEST
					If SBC->(FieldPos("BC_DTVLDES")) > 0 .And. !Empty(SBC->BC_DTVLDES)
						Replace D3_DTVALID With SBC->BC_DTVLDES
					EndIf
				ElseIf Rastro(SBC->BC_CODDEST) .and. !Empty(SBC->BC_LOTECTL)
					Replace D3_LOTECTL  With SBC->BC_LOTECTL
				EndIf

				If  !Empty(SBC->BC_CC)
					Replace D3_CC With SBC->BC_CC
				ElseIf cCodPai <> SBC->BC_CODDEST
					Replace D3_CC With Posicione("SC2",1,xFilial("SC2")+cNumOP,"C2_CC")
				EndIf

				MsUnlock()
				//Ŀ
				// Grava o custo da movimentacao              
				//
				If SD3->D3_CF == "DE1"
					aCM := PegaCmAtu(SD3->D3_COD,SD3->D3_LOCAL)
					aCusto := GravaCusD3(aCM)
				ElseIf SD3->D3_CF == "DE4"
					// Grava o mesmo custo total do movimento RE4, independente das qtdes Origem/Destino.
					aCusto := GravaCusD3(aCusto,.T.)
				EndIf
				//Ŀ
				// Atualiza o saldo atual (VATU) com os dados do SD3     
				//
				lRetAtuB2 := B2AtuComD3(aCusto)
				SB2->(MsUnlock())
				//Verifica se ocorreu algum erro na atualizao do B2
				If lRetAtuB2
					//Caso o retorno seja negativo, disarma a transao.
					DisarmTransaction()
					Break
				EndIf

				If SBC->(FieldPos('BC_LOTDEST')) > 0
					Replace SBC->BC_LOTDEST With SD3->D3_LOTECTL
					If SBC->(FieldPos('BC_DTVLDES')) > 0
						Replace SBC->BC_DTVLDES With SD3->D3_DTVALID
					EndIf
				EndIF

				//Ŀ
				// Atualiza o CQ dos Modulos de Materiais (SD7)          
				//
				If !GeraQuality()
					//Caso o retorno seja negativo, disarma a transao.
					DisarmTransaction()
					Break
				EndIf

				//Ŀ
				// Atualiza os saldos atuais (VATU) das OP's 
				//
				If !Empty(SD3->D3_OP)
					C2AtuComD3(aCusto)
				EndIf
				//Ŀ
				// Verifica se o custo medio e' calculado On-Line               
				//
				If cCusMed == "O"
					//Ŀ
					// Verifica se ira gerar TRANSFERENCIA OU NAO 
					//
					If SD3->D3_CF == "DE4"
						//Ŀ
						// Gera o lancamento no arquivo de prova           
						//
						nTotal+=DetProva(nHdlPrv,"672",cProg,cLoteEst)
					ElseIf SD3->D3_CF == "DE1"
						nTotal+=DetProva(nHdlPrv,"668",cProg,cLoteEst)
					EndIf
				EndIf
			EndIf
			//Ŀ
			// Executa execblock SBCIncl apos inclusao do movimento              
			//
			If lSBCIncl
				ExecBlock("SBCIncl",.F.,.F.)
			EndIf

		If cCusMed == "O" .And. cProg == "MATA685" .And. !lCriaHeader
			//Ŀ
			// Se ele criou o arquivo de prova ele deve gravar o rodape'    
			//
			RodaProva(nHdlPrv,nTotal)
			If UsaSeqCor()
				cCodiario := CtbaVerdia()
				aCtbDia := {{"SD3",SD3->(RECNO()),cCodiario,"D3_NODIA","D3_DIACTB"}}
			Else
	    		aCtbDia := {}
			EndIF
			cA100Incl(cArquivo,nHdlPrv,3,cLoteEst,lDigita,lAglutina,,,,,,aCtbDia)
			lCriaHeader := .T.
		EndIf
	EndIf
Next i

//Grava a tabela auxiliar de controle de estorno de aontamento de perda SMN
If Findfunction("f685GRVSMN")
	If !(lPrdIntWMS .And. lWmsNew)
		f685GRVSMN(aDadosSMN)
	EndIf
EndIf

//Ŀ
// Encerra a Transacao                        
//
End Transaction

dbSelectArea("SD3")
RestArea(aAreaSD3)
RestArea(aArea)
RETURN cNumSeq

/*

Ŀ
Funo    AtuEmpSB8  Autor  Rodrigo de A. Sartorio Data  22.03.99 
Ĵ
Descrio  Retira empenho e quantidade do SB8                         
Ĵ
Parametros ExpC1 = Tipo de Rastreabilidade                            
           ExpC2 = Produto                                            
           ExpC3 = Almoxarifado                                       
           ExpC4 = Lote                                               
           ExpC5 = Sub-Lote                                           
           ExpN1 = Quantidade da Baixa                                
           ExpA1 = Array utilizado para gerar movimentos no SD5       
           ExpN2 = Quantidade da Baixa segunda UM                     
           ExpL1 = Indica se considera somente o saldo fisico         
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function AtuEmpSB8(cTipoLote,cProduto,cLocal,cLoteCtl,cNumLote,nBaixa,aSD5,nBaixa2,lConsEmp)
Local aArea      := GetArea()
Local aAreaSB2   := SB2->(GetArea())
Local nBaixaLot  := 0
Local nBaixaLot2 := 0
Local cSeek      := ""
Local cCompara   := ""
Local cAliasSB8  := "SB8"
Local lEmpPrev   := If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)
Local cQuery := ""

Default nBaixa2 := 0
Default lConsEmp:= .T.

If !Empty(cLoteCtl)
	//Ŀ
	//Verifica se o estoque pode ser alterado                                 
	//
	dbSelectArea("SB2")
	dbSetOrder(1)
	If !MsSeek(xFilial("SB2")+cProduto+cLocal)
		CriaSB2(cProduto,cLocal)
	EndIf
	If RecLock("SB2")
		dbSelectArea("SB8")
		dbSetOrder(3)
		cAliasSB8 := GetNextAlias()
		cQuery := "SELECT B8_FILIAL,B8_PRODUTO,B8_LOCAL,B8_LOTECTL,B8_NUMLOTE,R_E_C_N_O_ SB8RECNO "
		cQuery += "FROM "+RetSqlName("SB8")+" SB8 "
		cQuery += "WHERE "
		cQuery += "B8_FILIAL='"+xFilial("SB8")+"' AND "
		cQuery += "B8_PRODUTO='"+cProduto+"' AND "
		cQuery += "B8_LOCAL='"+cLocal+"' AND "
		cQuery += "B8_LOTECTL='"+cLotectl+"' AND "
		If cTipoLote="S"
			cQuery += "B8_NUMLOTE='"+cNumLote+"' AND "
		EndIf
		If lConsEmp
			cQuery += "B8_EMPENHO>0 AND "
		EndIf
		cQuery += "D_E_L_E_T_=' ' "
		cQuery += "ORDER BY "+SqlOrder(SB8->(IndexKey()))
		cQuery := ChangeQuery(cQuery)
		SB8->(dbCommit())
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB8)

		nBaixa2    := ConvUM(cProduto, nBaixa, nBaixa2, 2)
		nBaixaLot  := nBaixa
		nBaixaLot2 := nBaixa2
		While !Eof() .And. nBaixaLot > 0 .And. If(cAliasSB8=="SB8",cSeek == &(cCompara),.T.)
			SB8->(MsGoto((cAliasSB8)->SB8RECNO))

			//Ŀ
			//Verifica o estoque real que pode ser baixado                            
			//
			RecLock("SB8",.F.)
			If SB8SALDO(lConsEmp,,,,,lEmpPrev,,,.T.) > 0
				If lConsEmp
					nBaixa     :=Min(nBaixaLot ,B8_EMPENHO)
					nBaixa2    :=Min(nBaixaLot2,B8_EMPENH2)
				Else
					nBaixa     := nBaixaLot
					nBaixa2    := nBaixaLot2
				EndIf
				nBaixa     :=Min(nBaixa ,B8_SALDO )
				nBaixa2    :=Min(nBaixa2,B8_SALDO2)
				nBaixaLot  -= nBaixa
				nBaixaLot2 -= nBaixa2
				//Ŀ
				// Array utilizado para aglutinar movimentos por 
				// sub-lote no SD5                               
				//
				nAchou:=ASCAN(aSD5,{|x| x[1] == SB8->B8_NUMLOTE .And. x[3] == SB8->B8_LOTECTL})
				If nAchou > 0
					aSD5[nAchou,2] += nBaixa
					aSD5[nAchou,6] += nBaixa2
				Else
					AADD(aSD5,{SB8->B8_NUMLOTE,nBaixa,SB8->B8_LOTECTL,SB8->B8_DTVALID,SB8->B8_POTENCI,nBaixa2})
				EndIf
				Replace B8_SALDO  With B8_SALDO  - nBaixa
				Replace B8_SALDO2 With B8_SALDO2 - nBaixa2
				GravaB8Emp("-",IIf(SB8->B8_EMPENHO>=nBaixa,nBaixa,SB8->B8_EMPENHO),"F",NIL,IIf(SB8->B8_EMPENH2>=nBaixa2,nBaixa2,SB8->B8_EMPENH2))
			EndIf
			MsUnLock()
			dbSelectArea(cAliasSB8)
			dbSkip()
		EndDo
		dbSelectArea(cAliasSB8)
		dbCloseArea()
		dbSelectArea("SB8")
		SB2->(MsUnlock())
	EndIf
EndIf
RestArea(aAreaSB2)
RestArea(aArea)
Return

/*

Ŀ
Funo    EstornaSD5 Autor  Rodrigo de A. Sartorio Data  22.03.99 
Ĵ
Descrio  Estorna movimentos de Lote/Sub-Lote baseado no SD5         
Ĵ
Parametros ExpC1 = Tipo de Rastreabilidade                            
           ExpC2 = Produto                                            
           ExpC3 = Almoxarifado                                       
           ExpC4 = Lote                                               
           ExpC5 = Sub-Lote                                           
           ExpC6 = Numero Sequencial                                  
           ExpL1 = Flag ref. atualizacao empenho                      
           ExpL2 = Flag ref. atualizacao qtd a distribuir             
           ExpC7 = Tipo do Movimento                                  
           ExpN1 = Variavel com a quantidade na potencia maxima       
           ExpN2 = Variavel com a quantidade                          
           ExpC8 = Alias origem do estorno                            
           ExpC9 = Cliente/Fornecedor                                 
           ExpCA = Loja                                               
           ExpCB = Documento                                          
           ExpCC = Serie                                              
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function EstornaSD5(cTipoLote,cProduto,cLocal,cLoteCtl,cNumLote,cNumSeq,lBaixaEmp,lBxQtdClass,cOrigLan,nQuantPMax,nQuant,cAliasOri,cCliFor,cLoja,cDocumento,cSerie,lUsaB8Emp,cLoteCtlPa,cNumLotePa,lConsVenc)
Local nMultiplic:=1,nz:=0,i:=0
Local cTm:="",cSeek:="",cSeek2:="",cCampos:=""
Local aArea:=GetArea(),aEstorno:={},aCampos:={}
Local nPosLote,nPosNumLote,nPosQuant,nPosEstorno,nPosNumSeq,nPosOrigLan
Local dNewDtVal  := CtoD('  /  /  ')
Local nQtdSD5    := 0
Local nQtd1SD5   := 0
Local cAlmoCQ    := GetMvNNR('MV_CQ','98')
Local _lBxQtdCla := .F. //-- Guarda o valor original da variavel
Local aRecnos   :={}
Local nBaixa    :=0
Local nRecOri   :=0
Local nQaClass  :=0
Local nQuantEmp :=0
Local cSeekEmp  :=""
Local lEmpPrev  := If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)
Local cLocProc  := GetMvNNR('MV_LOCPROC','99')
Local lExistD5  := .F.
Local lWmsNew   := SuperGetMV("MV_WMSNEW",.F.,.F.)
Local cLocTran	:= SuperGetMV("MV_LOCTRAN",.F.,.F.)

DEFAULT cAliasOri   := Alias()
DEFAULT nQuant:=0
DEFAULT lBxQtdClass := .F.
DEFAULT cOrigLan    := Criavar("D5_ORIGLAN",.F.)
DEFAULT nQuantpMax  := 0
DEFAULT cCliFor     := Criavar("D5_CLIFOR",.F.)
DEFAULT cLoja       := Criavar("D5_LOJA",.F.)
DEFAULT cDocumento  := Criavar("D5_DOC",.F.)
DEFAULT cSerie      := Criavar("D5_SERIE",.F.)
DEFAULT lUsaB8Emp   := .F.
DEFAULT cLoteCtlPa  := cLoteCtl
DEFAULT cNumLotePa  := cNumLote

lConsVenc := If(lConsVenc == NIL,SUPERGETMV("MV_LOTVENC",.T.,"S") == "S",lConsVenc)

If lUsaB8Emp
	lEmpPrev := .F.
EndIF


_lBxQtdCla := lBxQtdClass
dbSelectArea("SD5")
dbSetOrder(3)
cCampos:="D5_FILIAL+D5_NUMSEQ+D5_PRODUTO+D5_LOCAL"
cSeek:=xFilial("SD5")+cNumSeq+cProduto+cLocal
If cTipoLote == "S"
	cSeek  +=If(!Empty(cLoteCtl+cNumLote),cLoteCtl+cNumLote,"")
	cCampos+=If(!Empty(cLoteCtl+cNumLote),"+D5_LOTECTL+D5_NUMLOTE","")
ElseIf cTipoLote == "L"
	cSeek  +=If(!Empty(cLoteCtl),cLoteCtl,"")
	cCampos+=If(!Empty(cLoteCtl),"+D5_LOTECTL","")
EndIf

//Ŀ
// Verifica movimentos no arquivo de movimentos da Rastreabilidade
//
dbSeek(cSeek)
Do While !Eof() .And. &(cCampos) == cSeek .And. nQuant > 0
	//Se for movimento de produo da SD3, processa somente o registro referente  ordem que est sendo estornada.
	If (cAliasOri == 'SD3' .Or. cAliasOri == 'SC2') .And. !Empty(SD3->D3_OP) .And. SD3->D3_OP <> SD5->D5_OP
		dbSkip()
		Loop
	EndIf
	//Ŀ
	// Desconsidera registros estornados                            
	//
	If D5_ESTORNO == "S"
		dbSkip()
		Loop
	EndIf
	If D5_LOCAL == cAlmoCQ .And. !Empty(cOrigLan)
		If cOrigLan > "500" .And. D5_ORIGLAN > "500"
			dbSkip()
			Loop
		ElseIf cOrigLan <= "500" .And. D5_ORIGLAN <= "500"
			dbSkip()
			Loop
		EndIf
	EndIf
	If (D5_CLIFOR # cCliFor) .Or. (D5_LOJA # cLoja) .Or. (D5_DOC # cDocumento) .Or. (D5_SERIE # cSerie)
		dbSkip()
		Loop
	EndIf
	If SD5->D5_LOCAL == cLocTran .And. cOrigLan == SD5->D5_ORIGLAN
		dbSkip()
		Loop
	EndIf
	RecLock("SD5",.F.)
	nQuant -= SD5->D5_QUANT
	//Ŀ
	// Salva a integridade dos campos de Bancos de Dados            
	//
	Replace D5_ESTORNO With "S"
	aCampos:={}
	For nz := 1 To FCount()
		If FIELDNAME(nz) == "D5_NUMLOTE"
			nPosNumLote:=nz
		ElseIf FIELDNAME(nz) == "D5_LOTECTL"
			nPosLote:=nz
		Elseif FIELDNAME(nz) == "D5_QUANT"
			nPosQuant:=nz
		Elseif FIELDNAME(nz) == "D5_ESTORNO"
			nPosEstorno:=nz
		Elseif FIELDNAME(nz) == "D5_NUMSEQ"
			nPosNumSeq:=nz
		Elseif FIELDNAME(nz) == "D5_ORIGLAN"
			nPosOrigLan:=nz
		EndIf
		AADD(aCampos,FieldGet(nz))
	Next nz
	AADD(aEstorno,ACLONE(aCampos))
	//Ŀ
	// Verifica se e' possivel inverter movimento no sub-lote origem
	// Caso nao consiga, le movimentos para refaze-los em mais de um
	// sub-lote.                                                    
	//
	dbSelectArea("SB8")
	dbSetOrder(2)
	// Inverte nMultiplic pois ainda nao inverteu movimento
	nMultiplic:=IF(Substr(SD5->D5_ORIGLAN,1,1)$"D01234",-1,1)
	If !dbSeek(xFilial("SB8")+SD5->D5_NUMLOTE+SD5->D5_LOTECTL+SD5->D5_PRODUTO+SD5->D5_LOCAL)
		SB1->(dbSetOrder(1))
		If SB1->(dbSeek(xFilial('SB1')+SD5->D5_PRODUTO, .F.))
			dNewDtVal := dDataBase + SB1->B1_PRVALID
		Else
			dNewDtVal := dDataBase
		EndIf
		RecLock('SB8',.T.)
		Replace B8_FILIAL with xFilial('SB8'),;
			B8_SALDO   With If(Substr(SD5->D5_ORIGLAN,1,1)$'D01234',SD5->D5_QUANT,0),;
			B8_SALDO2  With ConvUM(SD5->D5_PRODUTO,If(Substr(SD5->D5_ORIGLAN,1,1)$'D01234',SD5->D5_QUANT,0),0,2),;
			B8_NUMLOTE With SD5->D5_NUMLOTE,;
			B8_PRODUTO With SD5->D5_PRODUTO,;
			B8_LOCAL   With SD5->D5_LOCAL,;
			B8_DATA    With dDataBase,;
			B8_DTVALID With dNewDtVal,;
			B8_ORIGLAN With 'MS',;
			B8_LOTEFOR With '',;
			B8_CHAVE   With 'SUBLOTE ORIG='+SD5->D5_NUMLOTE,;
			B8_QTDORI  With If(Substr(SD5->D5_ORIGLAN,1,1)$'D01234',SD5->D5_QUANT,0),;
			B8_LOTECTL With SD5->D5_LOTECTL,;
			B8_POTENCI With SD5->D5_POTENCI
		MsUnlock()
		// Nao achou saldo para estornar o movimento
	Else
		RecLock("SB8")
		If Localiza(SD5->D5_PRODUTO,.T.)
			If !(lWmsNew .And. IntDl(SD5->D5_PRODUTO))
				SDA->(MsSeek(xFilial("SDA")+SD5->D5_PRODUTO+SD5->D5_LOCAL+SD5->D5_NUMSEQ))
				While !SDA->(Eof()) .And. SD5->D5_PRODUTO == SDA->DA_PRODUTO .And. SD5->D5_LOCAL == SDA->DA_LOCAL .And. SD5->D5_NUMSEQ == SDA->DA_NUMSEQ
					If Rastro(SD5->D5_PRODUTO,"L")
						If SDA->DA_LOTECTL != SD5->D5_LOTECTL .And. SDA->DA_SALDO <= 0
							SDA->(DbSkip())
						Else
							nQaClass += SDA->DA_SALDO
							SDA->(DbSkip())
						EndIf
					Else
						If SDA->DA_LOTECTL != SD5->D5_LOTECTL .And. SDA->DA_NUMLOTE != SD5->D5_NUMLOTE
							SDA->(DbSkip())
						Else
							nQaClass += SDA->DA_SALDO
							SDA->(DbSkip())
						EndIf
					EndIf
				EndDo
			Else
				// D0G_FILIAL+D0G_PRODUT+D0G_LOCAL+D0G_NUMSEQ+D0G_DOC+D0G_SERIE+D0G_CLIFOR+D0G_LOJA
				D0G->(dbSetOrder(1))
				D0G->(dbSeek(xFilial("D0G")+SD5->D5_PRODUTO+SD5->D5_LOCAL+SD5->D5_NUMSEQ))
				While D0G->(!Eof()) .And. SD5->D5_PRODUTO == D0G->D0G_PRODUT .And. SD5->D5_LOCAL == D0G->D0G_LOCAL .And. SD5->D5_NUMSEQ == D0G->D0G_NUMSEQ
					If Rastro(SD5->D5_PRODUTO,"L")
						If D0G->D0G_LOTECT != SD5->D5_LOTECTL .And. D0G->D0G_SALDO <= 0
							D0G->(DbSkip())
						Else
							nQaClass += D0G->D0G_SALDO
							D0G->(DbSkip())
						EndIf
					Else
						If D0G->D0G_LOTECT != SD5->D5_LOTECTL .And. D0G->D0G_NUMLOT != SD5->D5_NUMLOTE
							D0G->(DbSkip())
						Else
							nQaClass += D0G->D0G_SALDO
							D0G->(DbSkip())
						EndIf
					EndIf
				EndDo
			EndIf
		EndIf
		If nMultiplic == -1 .And. (SB8Saldo(lUsaB8Emp,NIL,lBxQtdClass,,,lEmpPrev)+nQaClass < SD5->D5_QUANT)
			aRecnos:={}
			dbSelectArea("SD5")
			aAreaDesfaz:=GetArea()
			dbSetOrder(2)
			cCampos2:="D5_FILIAL+D5_PRODUTO+D5_LOCAL+D5_LOTECTL+D5_NUMLOTE"
			cSeek2:=xFilial("SD5")+D5_PRODUTO+D5_LOCAL+D5_LOTECTL+D5_NUMLOTE
			cSeekEmp:=D5_PRODUTO+D5_LOCAL+D5_LOTECTL
			dbSeek(cSeek2)
			Do While !Eof() .And. &(cCampos2) == cSeek2
				// Ignora entradas e ja estornados
				If Substr(SD5->D5_ORIGLAN,1,1) $ "D01234" .Or. SD5->D5_ESTORNO == "S"
					dbSkip()
					Loop
				EndIf
				AADD(aRecnos,Recno())
				dbSkip()
			EndDo
			// Se nao achou movimentos verifica saldo empenhado do sub-lote
			If Len(aRecnos) == 0 .And. QtdComp(SB8->B8_EMPENHO) > QtdComp(0)
				dbSelectArea("SB8")
				nQuantEmp:=SB8->B8_EMPENHO
				nRecOri  :=Recno()
				dbSetOrder(3)// B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL+B8_NUMLOTE+DTOS(B8_DTVALID)
				dbSeek(xFilial("SB8")+cSeekEmp)
				While !Eof() .And. B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL == xFilial("SB8")+cSeekEmp .And. QtdComp(nQuantEmp) > QtdComp(0)
					If Recno() # nRecOri
						Reclock("SB8",.F.)
						nBaixa :=Min(SB8Saldo(lBaixaEmp,NIL,lBxQtdClass,,,lEmpPrev),nQuantEmp)
						nQuantEmp -=nBaixa
						If QtdComp(nBaixa) > QtdComp(0)
							Replace B8_EMPENHO With B8_EMPENHO+nBaixa
						EndIf
						SB8->(MsUnlock())
					EndIf
					dbSkip()
				EndDo
				//Ŀ
				// Verifica se o Empenho foi transferido para outros Sub-lotes. Neste caso subtrai do Sub-lote original o Empenho utilizado 
				//
				dbGoto(nRecOri)
				If !(QtdComp(nQuantEmp)==QtdComp(SB8->B8_EMPENHO))
					Reclock('SB8', .F.)
					Replace B8_EMPENHO With B8_EMPENHO - (QtdComp(B8_EMPENHO)-QtdComp(nQuantEmp))
					MsUnlock()
				EndIf
			EndIf
			RestArea(aAreaDesfaz)
		EndIf
		SB8->(MsUnLock())
	EndIf
	SD5->(MsUnlock())
	dbSelectArea("SD5")
	dbSkip()
EndDo

For i:=Len(aRecnos) to 1 Step -1
	dbSelectArea("SD5")
	dbGoto(aRecnos[i])
	Reclock("SD5",.F.)
	Replace D5_ESTORNO With "S"
	MsUnlock()
	aCampos:={}
	For nz := 1 To FCount()
		If FIELDNAME(nz) == "D5_NUMLOTE"
			nPosNumLote:=nz
		ElseIf FIELDNAME(nz) == "D5_LOTECTL"
			nPosLote:=nz
		Elseif FIELDNAME(nz) == "D5_QUANT"
			nPosQuant:=nz
		Elseif FIELDNAME(nz) == "D5_ESTORNO"
			nPosEstorno:=nz
		Elseif FIELDNAME(nz) == "D5_NUMSEQ"
			nPosNumSeq:=nz
		EndIf
		AADD(aCampos,FieldGet(nz))
	Next nz
	AADD(aEstorno,ACLONE(aCampos))
	nQtdSD5:=SD5->D5_QUANT
	cTm:=D5_ORIGLAN
	If Substr(cTm,1,1) $"DR"
		cTm:=If(Substr(cTm,1,1)=="D","R","D")+Substr(cTm,2,2)
	Else
		cTm:=If(cTm>"500","499","999")
	EndIf
	dbSelectArea("SB8")
	dbSetOrder(3)
	dbSeek(xFilial("SB8")+SD5->D5_PRODUTO+SD5->D5_LOCAL+SD5->D5_LOTECTL)
	While !Eof() .And. nQtdSD5 > 0 .And. xFilial("SB8")+SD5->D5_PRODUTO+SD5->D5_LOCAL+SD5->D5_LOTECTL == B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL
		RecLock("SB8")
		nQtd1SD5:=SB8Saldo(lBaixaEmp,NIL,lBxQtdClass,,,lEmpPrev)
		If nQtd1SD5 > 0 .And. SB8->B8_NUMLOTE # SD5->D5_NUMLOTE
			AADD(aEstorno,ACLONE(aCampos))
			aEstorno[Len(aEstorno),nPosNumLote]:=SB8->B8_NUMLOTE
			aEstorno[Len(aEstorno),nPosQuant]  :=Min(nQtd1SD5,nQtdSD5)
			// Inverte o movimento pq e invertido novamente na atualizacao de saldo
			aEstorno[Len(aEstorno),nPosOrigLan]:=cTm
			// Limpa o flag de estorno
			aEstorno[Len(aEstorno),nPosEstorno]:=" "
			nQtdSD5-=Min(nQtd1SD5,nQtdSD5)
		Else
			SB8->(MsUnLock())
		EndIf
		dbSkip()
	EndDo
Next i

//Ŀ
// Cria o registro de Estorno dos sub-lotes originais           
// Le o array do maior numero sequencial para o menor           
//
For i:=Len(aEstorno) to 1 Step -1
	//Ŀ
	// Volta o saldo no lote origem                                 
	//
	RecLock("SD5",.T.)
	For nz := 1 To FCount()
		FieldPut(nz,aEstorno[i,nz])
	Next nz
	//Ŀ
	// Preparacao para Estorno da Dev. do Lote p/Armazem de Processo
	//
	lBxQtdClass := If((ChkSD5Proc() .And. SD5->D5_ORIGLAN<='500'), .T., _lBxQtdCla)
	cTm:=D5_ORIGLAN
	If Substr(cTm,1,1) $"DR"
		cTm:=If(Substr(cTm,1,1)=="D","R","D")+Substr(cTm,2,2)
	Else
		cTm:=If(cTm>"500","499","999")
	EndIf
	Replace D5_ORIGLAN With cTm
	MsUnlock()

	lExistD5 := .F.
	If FieldPos("D5_PRMAIOR") > 0
		lExistD5 := .T.
	EndIf

	dbSelectArea("SB8")
	dbSetOrder(3)
	If dbSeek(xFilial("SB8")+SD5->D5_PRODUTO+SD5->D5_LOCAL+SD5->D5_LOTECTL+SD5->D5_NUMLOTE)
		// Nao inverte nMultiplic pois refaz movimento em outro sub-lote
		nMultiplic:=IF(Substr(SD5->D5_ORIGLAN,1,1)$"D01234",1,-1)
		RecLock("SB8",.F.)
		// quanto for subproduto sempre passar lbaixaemp como .F. pois nao possui empenho para o lote do subproduto
		//If If(nMultiplic == -1,SB8Saldo(lBaixaEmp,NIL,lBxQtdClass,,,lEmpPrev)+nQaClass > 0,.T.)
		If If(nMultiplic == -1,SB8Saldo(lUsaB8Emp,lConsVenc,lBxQtdClass,,,lEmpPrev)+nQaClass > 0,.T.)
			nQuantPMax += A250PotMax(SB8->B8_PRODUTO,SB8->B8_POTENCI,(SD5->D5_QUANT * nMultiplic))
			Replace B8_SALDO with B8_SALDO + (SD5->D5_QUANT * nMultiplic)
			Replace B8_SALDO2 with B8_SALDO2 + (ConvUM(B8_PRODUTO, aCampos[nPosQuant],SD5->D5_QTSEGUM  , 2) * nMultiplic)
			If (lBxQtdClass .And. !lUsaB8Emp) .Or. (cLocProc == SB8->B8_LOCAL .And. nMultiplic == -1 .And. SB1->B1_LOCALIZ == "S")
				Replace B8_QACLASS with B8_QACLASS + (SD5->D5_QUANT * nMultiplic)
				Replace B8_QACLAS2 with B8_QACLAS2 + (ConvUM(B8_PRODUTO, aCampos[nPosQuant], SD5->D5_QTSEGUM , 2)* nMultiplic)
			EndIf

			lAtuB8 := .F.
			If (nMultiplic > 0 .And. lUsaB8Emp) .Or. !lUsaB8Emp
				lAtuB8 := lUsaB8Emp
			Else
				If nMultiplic < 0 .And. lUsaB8Emp .And. lBaixaEmp
					lAtuB8 := .F.
					lBaixaEmp := .F.
				EndIf
			EndIf

			If lExistD5 == .T.
				If !SD5->D5_PRMAIOR = 'S'
					If ((lBaixaEmp .Or. lAtuB8) .And. !Empty(cLoteCtlPa+If(Rastro(cProduto,"S"),cNumLotePa,"")))
						GravaB8Emp("+",MAX((SD5->D5_QUANT * nMultiplic)/* -SD3->D3_QTMAIOR */,0) ,"F",, SD5->D5_QTSEGUM * nMultiplic)
					ElseIf QtdComp(SB8SALDO(,,,,,lEmpPrev,,,.T.)) < QtdComp(SB8SALDO(.T.,,,,,lEmpPrev,,,.T.))
						GravaB8Emp("-",SB8->B8_EMPENHO-SB8->B8_SALDO,"F",,SB8->B8_EMPENH2-SB8->B8_SALDO2)
					EndIf
				EndIf
			Else
				If ((lBaixaEmp .Or. lAtuB8) .And. !Empty(cLoteCtlPa+If(Rastro(cProduto,"S"),cNumLotePa,"")))
					GravaB8Emp("+",MAX((SD5->D5_QUANT * nMultiplic)-SD3->D3_QTMAIOR,0),"F",, SD5->D5_QTSEGUM * nMultiplic)
				ElseIf QtdComp(SB8SALDO(,,,,,lEmpPrev,,,.T.)) < QtdComp(SB8SALDO(.T.,,,,,lEmpPrev,,,.T.))
					GravaB8Emp("-",SB8->B8_EMPENHO-SB8->B8_SALDO,"F",,SB8->B8_EMPENH2-SB8->B8_SALDO2)
				EndIf
			EndIf

			If cTipoLote == "S" .And. SB8SALDO(,,,,,lEmpPrev,,,.T.) < 0
				cValue:=Transform(B8_SALDO,PesqPictQt("B8_SALDO",14))
				cHelp:=AllTrim(B8_NUMLOTE)+Space(1)+B8_LOCAL+Space(6)+ALLTRIM(cValue)
				Help ( " ", 1, "LOTENEG",,cHelp,4,1)
			EndIf
		EndIf
		SB8->(MsUnlock())
	EndIf
Next i
RestArea(aArea)
Return

/*


Ŀ
Funo     A100SegUm Autor  Claudinei M. Benzi     Data  10.01.92 
Ĵ
Descrio  Trata UM e segunda UM no MATA100/MATA110/MATA120           
Ĵ
 Uso       MatA100                                                    
ٱ


*/
//Ŀ
// ATENCAO!!!!!!!!!!!!!!!!!!!!!!!!!!!!                           
// A funcao A100SegUm e utilizada em varios programas do sistema 
// portanto TODOS os campos utilizados com ref. no aCols deverao 
// verificados ( nPosXXX > 0 ) antes de serem utilizados.        
// ATENCAO!!!!!!!!!!!!!!!!!!!!!!!!!!!!                           
//
Function A100SegUm()
LOCAL nPosCod	:= 0,nPosQtd:=0,nPosQtd2:=0,nPosTotal:=0,nPosDesc:=0,nPosPDesc:=0
LOCAL cVarCod	:= "",cVarQtd:="",cVarQtd2:="",cVarTotal:=""
LOCAL nx,cCampo	:= Alltrim(ReadVar()),nQuant:=0,cProduto:=""
LOCAL lMudou	:= .F.
LOCAL cAlias	:= Alias(),nOrder:=IndexOrd(),nRecno:=Recno()
LOCAL nOrdSB1	:= SB1->(IndexOrd()),nRecSB1:=SB1->(Recno())
LOCAL nValQDa	:= 0 // quantidade anterior - Calculo do Desconto Devolucao
LOCAL nValQDb	:= 0 // quantidade atual    - Calculo do Desconto Devolucao
LOCAL lTpCompl	:= .T.
LOCAL lVal		:= .T.
LOCAL nDecQtd	:= 0
Local cFunName 	:= AllTrim(FunName())
Local cDescsai	:= ""
//Ŀ
// Ponto de Entrada para ignorar campos de usuarios 
//
LOCAL lA100CPO	 := ExistBlock('A100SEGCPO')
LOCAL lRet    	 := .T.
Local lRuTotZero := .F.

Private lModCant := .F.
Private nValUnit := 0
Private nValCant := 0


nPosQtd := aScan(aHeader,{|x| AllTrim(x[2])=="D1_QUANT"})
If nPosQtd > 0
	nQtdAnt := aCols[n][nPosQtd]
Endif
nPosQtd := 0

For nx:= 1 To Len(aHeader)
	If lA100CPO
		lRet := ExecBlock('A100SEGCPO', .F., .F., aHeader[nx][2])
		If ValType(lRet) != 'L'
			lRet := .F.
		EndIf
	EndIf

	If lRet
		If Trim(Substr(aHeader[nx][2],3)) == "_COD" .Or. Trim(Substr(aHeader[nx][2],3)) == "_PRODUTO"
			nPosCod:=nx
			cVarCod:="M->"+AllTrim(aHeader[nx][2])
		ElseIf Trim(Substr(aHeader[nx][2],3)) == "_QUANT"
			nPosQtd:=nx
			cVarQtd:="M->"+AllTrim(aHeader[nx][2])
		ElseIf Trim(Substr(aHeader[nx][2],3)) == "_QTSEGUM"
			nPosQtd2:=nx
			cVarQtd2:="M->"+AllTrim(aHeader[nx][2])
		ElseIf Trim(Substr(aHeader[nx][2],3)) == "_TOTAL"
			nPosTotal:=nx
			cVarTotal:="M->"+AllTrim(aHeader[nx][2])
		ElseIf Trim(Substr(aHeader[nx][2],3)) == "_VALDESC" .OR. Trim(Substr(aHeader[nx][2],3)) == "_DESCON"
			nPosDesc:=nx
		ElseIf Trim(Substr(aHeader[nx][2],3)) == "_DESC"
			nPosPDesc:=nx
		EndIf
		// Caso j achou todos, abandona o Loop
		If nPosCod > 0 .And. nPosQtd > 0 .And. nPosQtd2 > 0 .And. nPosTotal > 0 .And. nPosDesc > 0
			Exit
		EndIf
	EndIf
Next nx

// Caso esteja no codigo do produto, obtem o produto
If cCampo == cVarCod
	cProduto:=&(ReadVar())
Else
	nQuant:=&(ReadVar())
	cProduto:=aCols[n][nPosCod]
EndIf

lRuTotZero := (cPaisLoc == "RUS" .And. cFunName $ "MATA465N|MATA466N" .And. (SF4->F4_QTDZERO == "1") )

dbSelectArea("SB1")
dbSetOrder(1)
If dbSeek(xFilial("SB1")+cProduto)
	// Altera campo da Quantidade na Segunda UM
	If cCampo == cVarQtd
		If nPosQtd2 > 0
			nValQDa := aCols[n][nPosQtd]
			aCols[n][nPosQtd2]:=	ConvUm(SB1->B1_COD,nQuant,aCols[n][nPosQtd2],2)
			nValQDb :=&(ReadVar())
			&(cVarQtd2):= aCols[n][nPosQtd2]
			lMudou:=.T.
		EndIf
		// Altera campo da Quantidade na Primeira UM
	ElseIf cCampo == cVarQtd2
		If cPaisLoc == "COL"
			nDecQtd := TAMSX3(aHeader[nPosQtd2][2])[2]
			lVal := (&(cVarQtd2) # Round(aCols[n][nPosQtd2],nDecQtd))
		Else
			lVal := (&(cVarQtd2) # aCols[n][nPosQtd2])
		EndIf
		If nPosQtd > 0 .AND. lVal
			nValQDa   := aCols[n][nPosQtd]
			aCols[n][nPosQtd]:=	ConvUm(SB1->B1_COD,aCols[n][nPosQtd],nQuant,1)
			nValQDb   := aCols[n][nPosQtd]
			&(cVarQtd):= aCols[n][nPosQtd]

			//Ŀ
			// Tratamento para atualizacao do campo qtdsol no pedido de compra 
			//
			If Right( AllTrim( ReadVar() ), 10 ) == "C7_QTSEGUM"
				A120QtdSol( aCols[n,nPosQtd] )
			EndIf

			lMudou:=.T.
		EndIf
		// Altera campo da Quantidade na Segunda UM ou na Primeira UM
	ElseIf cCampo == cVarCod
		If nPosQtd > 0 .And. nPosQtd2 > 0
			If !Empty(aCols[n][nPosQtd])
				aCols[n][nPosQtd2]:=	ConvUm(SB1->B1_COD,aCols[n][nPosQtd],aCols[n][nPosQtd2],2)
				&(cVarQtd2):= aCols[n][nPosQtd2]
			ElseIf !Empty(aCols[n][nPosQtd2])
				aCols[n][nPosQtd]:=	ConvUm(SB1->B1_COD,aCols[n][nPosQtd],aCols[n][nPosQtd2],1)
				&(cVarQtd):= aCols[n][nPosQtd]
				lMudou:=.T.
			EndIf
		EndIf
	EndIf
	// Zera total qdo mudou quantidade
	If lMudou .And. nPosTotal > 0
		If !lRuTotZero
			aCols[n][nPosTotal]:= 0
			&(cVarTotal):= 0
		EndIf
		If Type("cTipo")=="C" .And. !IsInCallStack("MATA140")
			If nPosDesc > 0
				aCols[n][nPosDesc] := (aCols[n][nPosDesc]/nValQDa)*nValQDb
			EndIF
		EndIf
		//Ŀ
		// Compatibilizacao com programas que utilizam a Funcao Fiscal  
		//
		If MaFisFound("IT",n)
            If MaFisRet(n,"IT_QUANT") <> &(cVarQtd)
                nValUnit := MaFisRet(n, "IT_PRCUNI")
				MaFisAlt("IT_QUANT",&(cVarQtd),n)
				nValCant := MaFisRet(n, "IT_QUANT")
				If !lRuTotZero
					MaFisAlt("IT_VALMERC",0,n)
				EndIf
				If nPosDesc > 0
					MaFisAlt("IT_DESCONTO",aCols[n][nPosDesc],n)
				EndIf
				If cFunName $ "MATA462DN|MATA465N|MATA462N" .And. cPaisLoc $ "PER|MEX|COL|EQU"
					If nPosTotal > 0 .And. nPosDesc > 0 .And. nPosPDesc > 0
						MaFisAlt("IT_PRCUNI", nValUnit, n)
						aCols[n][nPosTotal]	:= (nValUnit * nValCant)
						If cFunName == "MATA465N"
							cDescsai	:= SuperGetMV("MV_DESCSAI",.F.)
							If cDescsai == "1"
								aCols[n][nPosPDesc]  := Round((aCols[n][nPosDesc]*100)/(aCols[n][nPosTotal] + aCols[n][nPosDesc]),TamSx3("D1_DESC")[2])
							EndIf
						EndIf
						aCols[n][nPosDesc]	:= aCols[n][nPosTotal] * (aCols[n][nPosPDesc] / 100)
						MaFisAlt("IT_VALMERC", aCols[n][nPosTotal], n)
					EndIf
				EndIf
            EndIf
		EndIf
	EndIf
EndIf
If cPaisLoc	==	"BRA"
	If Type("cTipo")=="C".And. !(cTipo$"IP")
		lTpCompl:= !Empty(MaFisScan("NF_TPCOMPL",.F.))
	EndIf
	// Zera quantidade p/notas de complemento.
	If Type("cTipo")=="C".And.(cTipo$"IP" .Or. (lTpCompl .And. MaFisFound("NF") .And. MaFisRet(,"NF_TPCOMPL") $ "1*3") .Or. (!lTpCompl .And. cTipo == "C"))
		//Ŀ
		// Compatibilizacao com programas que utilizam a Funcao Fiscal  
		//
		If MaFisFound("IT",n)
			MaFisAlt("IT_QUANT",0,n)
		EndIf
		If nPosQtd2 <> 0
			aCols[n][nPosQtd2]:=0
		EndIf
		aCols[n][nPosQtd]:=0
		M->D1_QUANT:=0
		M->D1_QTSEGUM:=0
	Endif
EndIF

If !Empty(cAlias)
	dbSelectArea(cAlias)
	dbSetOrder(nOrder)
	dbGoto(nRecno)
EndIf

SB1->(dbSetOrder(nOrdSB1))
SB1->(dbGoto(nRecSB1))

Return .T.

/*


Ŀ
Funo    PerdaLinOK Autor Rodrigo de A. Sartorio  Data  24/12/96 
Ĵ
Descrio  Validao da linha da GetDados                             
ٱ


*/
Function PerdaLinOK()
LOCAL lRet       := .T., nx
LOCAL cSeek      := ""
LOCAL nSaldo     :=0,nQtdTot:=0,nSldLocF:=0,nSldLote:=0,lParam:=.F.
LOCAL lEmpPrev   := If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)
LOCAL lMT685LOk  := ExistBlock('MT685LOk')
LOCAL lMVPerdInf := If(Type('lPerdInf')#"L",SuperGetMV('MV_PERDINF',.F.,.F.),lPerdInf)
Local cOprod     := ""
Local cOp        := ""
LOCAL cCampoPrd  := ""
LOCAL cCampoPT   := ""
LOCAL nQtdReqs   := 0
LOCAL cRotOrig	 := FunName()
LOCAL aEmpOP	 := {0,0}
Local lPerbQtd   := SuperGetMV("MV_PERBQTD",.F.,.F.)
Local nQtdeSD4   := 0
Local aAreaSBC	 := {}
Local lWmsNew    := SuperGetMv("MV_WMSNEW",.F.,.F.)
Local lPrdIntWMS := .F.
Local cLocFisn   := ""
Local cLocFisnx  := ""
Local cTpSaldo	 := SuperGetMV("MV_TPSALDO",.F.,.F.)

//Ŀ
// Variavel lPyme utilizada para Tratamento do Siga PyME        
//
Private lPyme:= Iif(Type("__lPyme") <> "U",__lPyme,.F.)

Pergunte("MTA685",.F.)
lParam := IIf(mv_par01 == 1, .T. , .F.)

If lMVPerdInf
	If cRotOrig == "MATA250"
		cOprod := M->D3_OP
		cCampoPrd := "M->D3_QUANT"
		cCampoPT  := "M->D3_PARCTOT"
	ElseIf cRotOrig $ "MATA680*MATA681"
		cOprod := M->H6_OP
		cCampoPrd := "M->H6_QTDPROD"
		cCampoPT  := "M->H6_PT"
	EndIf
EndIf

If aCols[n,nPosQuant] == 0 .And. !aCols[n,Len(aCols[n])]
	Help(1," ","OBRIGAT2",,"=> "+aHeader[nPosQuant,1],3,0)
	lRet:=.F.
Endif

If aCols[n,nPosQtdDes] == 0 .And. !aCols[n,Len(aCols[n])]
	Help(1," ","OBRIGAT2",,"=> "+aHeader[nPosQtdDes,1],3,0)
	lRet:=.F.
Endif

For nx := 1 To Len(aCols)
	If aCols[nx,nPosCod]+aCols[nx,nPosLoc] == aCols[n,nPosCod]+aCols[n,nPosLoc]
		nQtdTot += If(aCols[nx,Len(aCols[nx])],0,aCols[nx,nPosQuant])
	EndIf
Next nx

If !lPyme
	If nPosLocFis > 0
		For nx := 1 To Len(aCols)
			If aCols[nx,nPosCod]+aCols[nx,nPosLoc]+aCols[nx,nPosLocFis]+IIF(Rastro(aCols[nx,nPosCod]), aCols[nx,nPosLotCtl]+aCols[nx,nPosLote], "") == aCols[n,nPosCod]+aCols[n,nPosLoc]+aCols[n,nPosLocFis]+IIF(Rastro(aCols[n,nPosCod]), aCols[n,nPosLotCtl]+aCols[n,nPosLote], "")
				nSldLocF += If(aCols[nx,Len(aCols[nx])],0,aCols[nx,nPosQuant])
			EndIf
		Next nx
	EndIf
EndIf

If nPosLotCtl > 0 .And. nPosLote > 0
	For nx := 1 To Len(aCols)
		If aCols[nx,nPosCod]+aCols[nx,nPosLoc]+aCols[nx,nPosLotCtl]+aCols[nx,nPosLote] == aCols[n,nPosCod]+aCols[n,nPosLoc]+aCols[n,nPosLotCtl]+aCols[n,nPosLote]
			nSldLote += If(aCols[nx,Len(aCols[nx])],0,aCols[nx,nPosQuant])
		EndIf
	Next nx
EndIf

If !Empty(aCols[n,nPosData]) .And. cRotOrig $ "MATA680*MATA681*MATA250"
	If lRet .And. FindFunction("a250ConsDtOp")
		If cRotOrig == "MATA250"
			cOp := M->D3_OP
		ElseIf cRotOrig $ "MATA680*MATA681"
			cOp := M->H6_OP
		EndIf	
		lRet := a250ConsDtOp(aCols[n,nPosData],cOp)
	EndIf
EndIf

If !(aCols[n,Len(aCols[n])])
	// Nao permite digitar endereco quando nao for transferencia
	If !lParam
		If Localiza(aCols[n,nPosCod],.T.)
			If Empty(aCols[n,nPosLocFis])
				Help(" ",1,"LOCALIZOBR",,"=> "+aHeader[nPosLocFis,1],5,0)
			EndIf

			If !SBE->(dbSeek(xFilial("SBE")+aCols[n,nPosLoc]+aCols[n,nPosLocFis]))
				Help(" ",1,"REGNOIS",,"=> "+aHeader[nPosLoc,1]+" + "+aHeader[nPosLocFis,1],5,0)
				lRet:=.F.
			EndIf
		EndIf
	Else
		SB2->(dbSetOrder(1))
		SB2->(dbSeek(xFilial("SB2")+aCols[n,nPosCod]+aCols[n,nPosLoc]))
		If lParam
			//-- Verifica se o saldo esta Disponivel
			lRet :=	SldBlqSB2()
		Endif
		nSaldo := SaldoMov(Nil,__lEmpenho,Nil,Nil)
		If lRet .And. (Empty(aCols[n,nPosCod]) .Or. Empty(aCols[n,nPosLoc]))
			Help( ,, 'Help',, STR0234, 1, 0 ) //"Quando o parmetro 'Requisita Produto Origem' estiver com o valor 'Sim',  necessrio informar o Produto origem e o Armazem origem."
			lRet := .F.
		EndIf
		If lMVPerdInf .And. !Empty(cCampoPT)
			nQtdReqs := CalcQtdReq(cOprod,&(cCampoPrd),aCols[n,nPosCod],aCols[n,nPosLoc],,,,,&(cCampoPT),"R")
			aEmpOP   := SldEmpOP(aCols[n,nPosCod],aCols[n,nPosLoc],,,cOprod)
			nSaldo   += If(SuperGetMV("MV_TPSALDO",.F.,"Q") == "Q",0,aEmpOP[1]) - nQtdReqs
		EndIf

		If lRet.And.(nSaldo-nQtdTot) < 0 .And. If(GETMV("MV_ESTNEG")=="S",.F.,.T.)
			If !VldQtdPerd(cRotOrig, nSaldo, nQtdTot, aCols[n,nPosCod], aCols[n,nPosLoc], aCols[n,nPosLotCtl], aCols[n,nPosLote] ,aCols[n,nPosLocFis], aCols[n,nPosNumSer]  )
				Help(" ",1,"SEMSALDO")
				lRet:=.F.
			EndIf
		Endif

		If lRet.And.Empty(aCols[n,nPosQuant]) .Or. Empty(aCols[n,nPosMot])
			Help(" ",1,"MA260OBR")
			lRet:=.F.
		EndIf
		If lRet .And. Localiza(aCols[n,nPosCod],.T.)
			lPrdIntWMS := IntWMS(aCols[n,nPosCod])
			If lMVPerdInf .And. !Empty(cCampoPT)
				nQtdReqs := CalcQtdReq(cOprod,&(cCampoPrd),aCols[n,nPosCod],aCols[n,nPosLoc],aCols[n,nPosLotCtl],aCols[n,nPosLote],;
								aCols[n,nPosLocFis],aCols[n,nPosNumSer],&(cCampoPT),"L")
			EndIf
			If Empty(aCols[n,nPosLocFis])
				Help(" ",1,"LOCALIZOBR",,"=> "+aHeader[nPosLocFis,1],5,0)
				lRet:=.F.
			ElseIf !Empty(aCols[n,nPosLocFis])
				If !(lWmsNew .And. lPrdIntWMS)
					nSaldo := SaldoSBF(aCols[n,nPosLoc],aCols[n,nPosLocFis],aCols[n,nPosCod],aCols[n,nPosNumSer],aCols[n,nPosLotCtl],aCols[n,nPosLote],,,,cOprod)
				Else
					If FindFunction("WmsSldD13") .And. cTpSaldo == "C"
						nSaldo := QtdComp( WmsSldD13(aCols[n,nPosLoc],aCols[n,nPosLocFis],aCols[n,nPosCod],aCols[n,nPosNumSer],aCols[n,nPosLotCtl],aCols[n,nPosLote],aCols[n,nPosData]) )

						//--Verifica se h saldo do produto no endereo informado na data(BC_DATA) em que o apontamento de perda esta sendo realizado 
						If nSaldo <= QtdComp(0)
							Help(" ",1,"SALDOLOCLZ",,"=> "+aHeader[nPosLocFis,1],4,0)
							lRet := .F.
						EndIf

					Else
						nSaldo := WmsSldD14(aCols[n,nPosLoc],aCols[n,nPosLocFis],aCols[n,nPosCod],aCols[n,nPosNumSer],aCols[n,nPosLotCtl],aCols[n,nPosLote],,.T.)
					EndIf
				EndIf

				If lRet
					If QtdComp(nSaldo) < QtdComp(nSldLocF)
						//Ver QTD empenhada para a OP
						nSldEmpLE := 0
						If cRotOrig $ "MATA685"
							nSldEmpLE := SldEmpLE(aCols[n,nPosCod], aCols[n,nPosLoc], aCols[n,nPosLotCtl], aCols[n,nPosLote])
						EndIf

						If nSldEmpLE < QtdComp(nSldLocF)
							Help(" ",1,"SALDOLOCLZ",,"=> "+aHeader[nPosLocFis,1],4,0)
							lRet:=.F.
						EndIf
					Else
						If !(lWmsNew .And. lPrdIntWMS)
							nSaldo := (QtdComp(SaldoSBF(aCols[n,nPosLoc],If(lMVPerdInf,NIL,aCols[n,nPosLocFis]),aCols[n,nPosCod],If(lMVPerdInf,NIL,aCols[n,nPosNumSer]),aCols[n,nPosLotCtl],aCols[n,nPosLote],,,,cOprod)) - nQtdReqs)
						Else
							nSaldo := (QtdComp(WmsSldD14(aCols[n,nPosLoc],Iif(lMVPerdInf,Nil,aCols[n,nPosLocFis]),aCols[n,nPosCod],Iif(lMVPerdInf,Nil,aCols[n,nPosNumSer]),aCols[n,nPosLotCtl],aCols[n,nPosLote],,.T.)) - nQtdReqs)
						EndIf

						//Ver QTD empenhada para a OP
						nSldEmpLE := 0
						If cRotOrig $ "MATA685"
							nSldEmpLE := SldEmpLE(aCols[n,nPosCod], aCols[n,nPosLoc], aCols[n,nPosLotCtl], aCols[n,nPosLote])
						EndIf

						If !lMVPerdInf
							If (nSaldo + nSldEmpLE) < nSldLocF
								Help(" ",1,"SALDOLOCLZ",,"=> "+aHeader[nPosLocFis,1],4,0)
								lRet:=.F.
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
			// Validaes complementares do WMS
			If lRet .And. lWmsNew .And. lPrdIntWMS .And. FindFunction("WMSVldPerda")
				lRet := WMSVldPerda()
			EndIf
		EndIf
		If !Empty(aCols[n,nPosProDes])
			If lRet
				If Localiza(aCols[n,nPosProDes],.T.)
					If Empty(aCols[n,nPosLocFDe])
						Help(" ",1,"LOCALIZOBR",,"=> "+aHeader[nPosLocFDe,1],5,0)
						lRet:=.F.
					EndIf
					If !SBE->(dbSeek(xFilial("SBE")+aCols[n,nPosLocDes]+aCols[n,nPosLocFDe]))
						Help(" ",1,"REGNOIS",,"=> "+aHeader[nPosLocDes,1]+" + "+aHeader[nPosLocFDe,1],5,0)
						lRet:=.F.
					EndIf
					If !Capacidade(aCols[n,nPosLocDes],aCols[n,nPosLocFDe],nSldLocF,aCols[n,nPosProDes])
						lRet:=.F.
					EndIf
				Else
					If !lPyme
						aCols[n,nPosLocFDe]:=Criavar("BF_LOCALIZ",.F.)
						aCols[n,nPosNSeDes]:=Criavar("BF_NUMSERI",.F.)
					EndIf
				EndIf
			EndIf
		EndIf
		If lRet .And. Rastro(aCols[n,nPosCod])
			If Rastro(aCols[n,nPosCod],"S") .And. Empty(aCols[n,nPosLote])
				Help(" ",1,"BC_NUMLOTE")
				lRet:=.F.
			ElseIf Rastro(aCols[n,nPosCod],"L") .And. Empty(aCols[n,nPosLotCtl])
				Help(" ",1,"BC_LOTECTL")
				lRet:=.F.
			Else
				dbSelectArea("SB8")
				nOrdSB8 := IndexOrd()
				nRecSB8 := RecNo()
				If Rastro(aCols[n,nPosCod],"S")
					dbSetOrder(2)
					cSeek:=xFilial("SB8")+aCols[n,nPosLote]+aCols[n,nPosLotCtl]+aCols[n,nPosCod]+aCols[n,nPosLoc]
				Else
					dbSetOrder(3)
					cSeek:=xFilial("SB8")+aCols[n,nPosCod]+aCols[n,nPosLoc]+aCols[n,nPosLotCtl]
				EndIf
				If dbSeek(cSeek)
					If lMVPerdInf .And. !Empty(cCampoPT)
						nQtdReqs := CalcQtdReq(cOprod,&(cCampoPrd),aCols[n,nPosCod],aCols[n,nPosLoc],aCols[n,nPosLotCtl],;
										aCols[n,nPosLote],aCols[n,nPosLocFis],aCols[n,nPosNumSer],&(cCampoPT),"R",.F.)
					EndIf
					If Rastro(aCols[n,nPosCod],"S")
						If SB8Saldo(NIL,NIL,NIL,NIL,NIL,lEmpPrev,NIL,aCols[n,nPosData],,cOprod) < nSldLote
							Help(" ",1,"A240LOTENE")
							lRet := .f.
						Else
							nSaldo:=SaldoLote(aCols[n,nPosCod],aCols[n,nPosLoc],If(lMVPerdInf,NIL,aCols[n,nPosLotCtl]),If(lMVPerdInf,NIL,aCols[n,nPosLote]),NIL,NIL,NIL,aCols[n,nPosData],cOprod) - nQtdReqs
							If lMVPerdInf
								For nX := 1 to Len(aCols)
									If aCols[n,nPosCod] == aCols[nX,nPosCod] .And. aCols[n,nPosLoc] == aCols[nX,nPosLoc] .And. nX # n
										nSaldo -= aCols[nX,nPosQuant]
									EndIf
								Next nX
							EndIf
							If nSaldo < nSldLote
								Help(" ",1,"A240LOTENE")
								lRet := .f.
							Endif
						Endif
					Else
						nSaldo := SaldoLote(aCols[n,nPosCod],aCols[n,nPosLoc],If(lMVPerdInf,NIL,aCols[n,nPosLotCtl]),If(lMVPerdInf,NIL,aCols[n,nPosLote]),NIL,NIL,NIL,aCols[n,nPosData],cOprod)
						If nSaldo >= nSldLote
							nSaldo:= nSaldo - nQtdReqs

							//Ver QTD empenhada para a OP
							nSldEmpLS := 0
							If cRotOrig $ "MATA685"
								nSldEmpLS := SldEmpLS(aCols[n,nPosCod], aCols[n,nPosLoc], aCols[n,nPosLotCtl], aCols[n,nPosLote],aCols[n,nPosData])
							EndIf

							If !lMVPerdInf .Or. cRotOrig $ "MATA685"
								If (nSaldo + nSldEmpLS) < nSldLote
									Help(" ",1,"A240LOTENE")
									lRet := .f.
								Endif
							EndIf
						Else
							//Ver QTD empenhada para a OP
							nSldEmpLS := 0
							If cRotOrig $ "MATA685"
								nSldEmpLS := SldEmpLS(aCols[n,nPosCod], aCols[n,nPosLoc], aCols[n,nPosLotCtl], aCols[n,nPosLote],aCols[n,nPosData])
							EndIf

							If !lMVPerdInf .Or. cRotOrig $ "MATA685"
								If (nSaldo + nSldEmpLS) < nSldLote
									Help(" ",1,"A240LOTENE")
									lRet := .f.
								EndIf
							EndIf
						EndIf
					EndIf
				Else
					Help(" ",1,"A240LOTERR")
					lRet := .f.
				EndIf
			EndIf
		EndIf
	EndIf
	If lRet
		For nx:=1 to Len(aCols)
			cLocFisn  := ""
			cLocFisnx := ""

			If nPosLocFis > 0
				cLocFisn  := aCols[n,nPosLocFis]
				cLocFisnx := aCols[nx,nPosLocFis]
			EndIf

			If nx # n .And. !aCols[nx,len(aCols[nx])] .and. aCols[n,nPosCod]+(aCols[n,nPosMot])+aCols[n,nPosOper]+If(nPosLotCtl>0,aCols[n,nPosLotCtl],"")+If(nPosLote>0,aCols[n,nPosLote],"")+aCols[n,nPosLoc]+If(nPosNumSer>0,aCols[n,nPosNumSer],"")+cLocFisn == aCols[nx,nPosCod]+(aCols[nx,nPosMot])+aCols[nx,nPosOper]+If(nPosLotCtl>0,aCols[nx,nPosLotCtl],"")+If(nPosLote>0,aCols[nx,nPosLote],"")+aCols[nx,nPosLoc]+If(nPosNumSer>0,aCols[nx,nPosNumSer],"")+cLocFisnx
				Help(" ",1,"MOTJACAD")
				lRet:=.F.
			EndIf
		Next nx
	EndIf
EndIf

//Validacaoo para no permitir perda maior que a quantidade prevista para consumo pela OP
If lRet .And. lPerbQtd .And. !lMVPerdInf
	If cRotOrig == "MATA250"
		cOprod := M->D3_OP
	ElseIf cRotOrig == "MATA685"
		cOprod := cOrdemP
	ElseIf cRotOrig $ "MATA680*MATA681"
		cOprod := M->H6_OP
	EndIf

	SD4->(dbSetOrder(2))
	SD4->(dbSeek(xFilial("SD4")+cOprod+aCols[n,nPosCod]+aCols[n,nPosLoc]))
	While !SD4->(EOF()) .And. SD4->(D4_FILIAL+D4_OP+D4_COD+D4_LOCAL) == xFilial("SD4")+cOprod+aCols[n,nPosCod]+aCols[n,nPosLoc]
		nQtdeSD4 += SD4->D4_QUANT
		SD4->(dbSkip())
	End

	aAreaSBC:=SBC->(GetArea())
	SBC->(dbSetOrder(1))
	SBC->(dbSeek(xFilial("SBC")+cOprod))
	While !SBC->(Eof()) .And.  SBC->(BC_FILIAL+BC_OP) ==  xFilial("SBC")+cOprod
		If SBC->(BC_PRODUTO+BC_LOCORIG) == aCols[n,nPosCod]+aCols[n,nPosLoc]
			nQtdTot += SBC->BC_QUANT
		EndIF
		SBC->(dbSkip())
	End
	RestArea(aAreaSBC)

	If nQtdeSD4 > 0 .And. nQtdTot > nQtdeSD4
		Help(" ",1,"PERBQTD")
		lRet := .F.
	EndIf
EndIf

If lMT685LOk .And. lRet
	lRet:=ExecBlock('MT685LOk', .F., .F., {lRet})
	If ValType(lRet) <> "L"
		lRet := .F.
	EndIf
EndIf

Return lRet

/*

Ŀ
Funo    PerdaTudOK    Autor Marcelo Iuspa        Data  13/07/01 
Ĵ
Descrio Validacao na digitacao de perdas                            
Ĵ
Sintaxe   PerdaTudOK                                                  
Ĵ
 Uso                                                                  
ٱ


*/
Function PerdaTudOk
Local cBlock  := "DIGPEROK"
Local lRetorna := .T.
If ( ExistBlock(cBlock) )
	lRetorna  := ExecBlock(cBlock,.F.,.F.)
	lRetorna  := If(ValType(lRetorna) = "L", lRetorna, .T.)
EndIf
Return(lRetorna)

/*


Ŀ
Funo    LotePerda  Autor Rodrigo de A. Sartorio  Data  25/07/97 
Ĵ
Descrio  Valida o Lote                                              
ٱ


*/
Function LotePerda()
Local cVar:=ReadVar(),cConteudo:=&(ReadVar())
Local cAlias:=Alias(),nRecno:=Recno(),nOrdem:=IndexOrd()
Local lRet:=.T.
Local cCod,cLocal,cLote,cLoteDigi
cCod     := aCols[n,nPosCod]
cLocal   := aCols[n,nPosLoc]
cLote    := aCols[n,nPosLote]
cLoteDigi:= aCols[n,nPosLotCTL]

If !Rastro(cCod)
	Help(" ",1,"NAORASTRO")
	lRet:=.F.
EndIf

If lRet
	If cVar == "M->BC_LOTECTL"
		If Rastro(cCod,"S")
			If !Empty(cLote)
				dbSelectArea("SB8")
				dbSetOrder(2)
				If dbSeek(xFilial("SB8")+cLote)
					If cCod+cLocal == SB8->B8_PRODUTO+SB8->B8_LOCAL .And. cConteudo != SB8->B8_LOTECTL
						Help(" ",1,"A240LOTCTL")
						lRet:=.F.
					Else
						M->BC_DTVALID:=SB8->B8_DTVALID
						aCols[n,nPosDValid]:=M->BC_DTVALID
					EndIf
				EndIf
			EndIf
		Else
			lRet:=NaoVazio(cConteudo)
			If lRet
				dbSelectArea("SB8")
				dbSetOrder(3)
				If !(dbSeek(xFilial("SB8")+cCod+cLocal+cConteudo))
					Help(" ",1,"A240LOTERR")
					lRet := .F.
				Else
					M->BC_DTVALID:=SB8->B8_DTVALID
					aCols[n,nPosDValid]:=M->BC_DTVALID
				EndIf
			EndIf
		EndIf
	ElseIf cVar == "M->BC_NUMLOTE"
		If Rastro(cCod,"S")
			lRet:=NaoVazio(cConteudo)
			If lRet
				dbSelectArea("SB8")
				dbSetOrder(2)
				If dbSeek(xFilial("SB8")+cConteudo) .And. cCod+cLocal == SB8->B8_PRODUTO+SB8->B8_LOCAL
					M->BC_LOTECTL:=SB8->B8_LOTECTL
					aCols[n,nPosLotCTL]:=M->BC_LOTECTL
					lRefresh:=.T.
				Else
					Help(" ",1,"A240LOTERR")
					lRet := .f.
				EndIf
			EndIf
		Else
			M->BC_NUMLOTE:=CriaVar("BC_NUMLOTE")
			aCols[n,nPosLote]:=M->BC_NUMLOTE
			lRefresh:=.T.
		EndIf
	EndIf
EndIf
dbSelectArea(cAlias)
dbSetOrder(nOrdem)
dbGoTo(nRecno)
Return lRet

/*


Ŀ
Funo    PerdaIniCp Autor Rodrigo de A. Sartorio  Data  24/12/96 
Ĵ
Descrio  Preenche descricao do Campo Virtual                        
ٱ

*/
Function PerdaIniCp()
Local cAlias := Alias()
Local nOrder := IndexOrd()
Local nRecno := Recno()
Local lRet   := .T.
Local aTabGen := {}
Local cValue  := &(ReadVar())
Local lIntgSFC := Iif(SuperGetMV("MV_INTSFC",.F.,0)==1,.T.,.F.)
Local nTamNum := TamSX3("X5_CHAVE")[1]

DbSelectArea("CYO")
If ReadVar() == 'M->D7_MOTREJE' .And. Empty(&(ReadVar()))
    If (aCols # Nil .And. Len(aCols) > 0) .And. (n # Nil .And. n > 0) .And. ;
            (nPosDesc # Nil .And. nPosDesc > 0)
        aCols[n,nPosDesc]:=Space(Len(aCols[n,nPosDesc]))
    EndIf
ElseIf ReadVar() == 'M->D7_MOTREJE' .And. (nPosTipo # Nil .And. nPosTipo > 0) .And. ;
        aCols[n,nPosTipo] # 2
    Help(" ",1,"NOTIPO2")
    lRet := .F.
Elseif CYO->(FieldPos("CYO_LGRT")) > 0 .Or. (lIntgSFC .And. CYO->(FieldPos("CYO_LGRT")) == 0) //Se o cliente possui os novos campos na tabela CYO, ento ele deixa
    dbSelectArea("CYO")        // de utilizar a SX5 e passar a utilizar o cadastro SFCA003 para
    CYO->(dbSetOrder(1))       // motivo de refugo
    If CYO->(dbSeek(xFilial("CYO")+&(ReadVar())))
        If (aCols # Nil .And. Len(aCols) > 0) .And. (n # Nil .And. n > 0) .And. ;
                (nPosDesc # Nil .And. nPosDesc > 0)
            aCols[n,nPosDesc]:=Trim(CYO->CYO_DSRF)
        EndIf
    ElseIf (aCols # Nil .And. Len(aCols) > 0) .And. (n # Nil .And. n > 0) .And. ;
            (nPosDesc # Nil .And. nPosDesc > 0)
            aTabGen := FWGetSX5('43')

            nI := ASCAN(aTabGen, {|x| x[3]==Padr(cValue,nTamNum)})
            If nI > 0
                aCols[n,nPosDesc]:=Trim(aTabGen[nI][4])
            EndIf
    Else
        Help(" ",1,"REGNOIS")
        lRet := .F.
    EndIf
EndIf

dbSelectArea(cAlias)
dbSetOrder(nOrder)
dbGoto(nRecno)
Return lRet

/*


Ŀ
Funo    B2AtuConIn Autor Rodrigo de A. Sartorio  Data  13/05/99 
Ĵ
Descrio  Preenche o consumo inicial no caso de saida de material    
Ĵ
Parametros ExpN1 = Fator de Multiplicacao                             
           ExpC1 = Data de conversao                                  
ٱ


*/
Function B2AtuConIn(nMultiplic,dDataCon)
If nMultiplic == - 1 .And. Empty(RetFldProd(SB1->B1_COD,"B1_CONINI"))
	If RetArqProd(SB1->B1_COD)
		Reclock("SB1",.F.)
		Replace B1_CONINI With dDataCon
		MsUnlock()
	Else
		Reclock("SBZ",.F.)
		Replace BZ_CONINI With dDataCon
		MsUnlock()
	EndIf
EndIf
Return


/*


Ŀ
Funo     LogMov    Autor  Fernando Joly Siquini  Data  08.02.00 
Ĵ
Descrio  Gera um arquivo de Log (tipo TXT, CM??????.LOG) caso encon-
           tre alguma inconsistncia na movimentao efetuada.        
Ĵ
Sintaxe    LogMov(ExpC1, ExpL1, ExpL2, ExpC2, ExpC3)                  
Ĵ
Parametros ExpC1 = Alias de Origem da Movimentao                    
           ExpL1 = Efetua conferncia de Movimentao                 
           ExpL2 = Efetua conferncia de Saldos                       
           ExpC2 = Cdigo do Produto                                  
           ExpD1 = Cdigo do Local                                    
           ExpL3 = Efetua conferncia de empenhos                     
           ExpL4 = Inverte o Tipo de Entrada/Saida                    
           ExpC3 = Alias real (i.e.: alias quando usa QUERY)          
           ExpL5 = Forca conferencia da movimentacao                  
Ĵ
 Uso       Gernrico                                                  
ٱ

*/
Function LogMov(cAlias, lChkMov, lChkSld, cProduto, cLocal , lChkEmp, lInverte, cAliasReal, lForcaChk, lSldAnt, aSldAnt, aLogMov, lSC9, nQtdeSC9, nQtdeMov)

//-- Inicializa Variaveis Estaticas
Static lLogMov    := Nil
Static cArmLogMoI := Nil
Static cArmLogMoF := Nil
Static lLMovAviso := Nil
Static __oSQLSB8  := Nil
Static __oSQLSBF  := Nil
Static __oSQLSDA  := Nil

//-- Inicializa Variaveis Locais
Local nX         := 0
Local nPos       := 0
Local nCall      := 1
Local nLogHdl    := 0
Local nQuantMov  := 0
Local nQuantSD5  := 0
Local nQuantSDA  := 0
Local nQuantSDB  := 0
Local nSaldoSB2  := 0
Local nSaldoSB8  := 0
Local nSaldoSBF  := 0
Local nSaldoSDA  := 0
Local nMultiplic := 1

Local cPictOrig  := ''
Local cPictSB2   := ''
Local cPictSB8   := ''
Local cPictSBF   := ''
Local cPictSD5   := ''
Local cPictSDB   := ''
Local cSeek      := ''
Local cNumSeq    := ''
Local cLoteCtl   := ''
Local cNumLote   := ''
Local cLocaliz   := ''
Local cNumSeri   := ''
Local cString    := ''
Local cDescri    := ''
Local cLogFile   := ''
Local cInfoOrig  := ''
Local cInfoDest  := ''
Local cD1VTES    := ''
Local cD2VTES    := ''
Local cProcesso  := ''
Local cTes       := ''
Local cOp        := ''
Local cArqLog    := 'LOGMOVMT'
Local cQuery     as character

Local aLog       := {}
Local aAreaAnt   := {}
Local aAreaSB1   := {}
Local aAreaSB2   := {}
Local aAreaSB8   := {}
Local aAreaSBF   := {}
Local aAreaSDA   := {}
Local aAreaSDB   := {}
Local aAreaSD5   := {}

Local lProcessou := .F.
Local lIntDL     := .F.
Local lRastro    := .F.
Local lLocaliz   := .F.
Local lEstorno   := .F.
Local lProcessa  := .T.
Local lProd      := .F.
Local lSubLote	 := .F.

Default cAlias     := Alias()
Default cAliasReal := cAlias

Default cProduto   := ''
Default cLocal     := ''

Default lChkMov    := .T.
Default lChkSld    := .T.
Default lChkEmp    := .T.
Default lForcaChk  := .F.
Default lSldAnt    := .F.
Default lSC9       := .F.
Default lInverte   := .F.

Default aSldAnt    := {}
Default aLogMov    := {}

Default nQtdeSC9   := 0
Default nQtdeMov   := 0

__lCusaVLib := IIf(__lCusaVLib == NIL,FWLibVersion() >= "20211116",__lCusaVLib)

cProdutoLog:= IIF(cProdutoLog == Nil,SuperGetMv('MV_PRODLOG',.F.,""),cProdutoLog)

//-- Verifica Parmetro
If (lLogMov == Nil)
	//-- Conteudo Esperado no SX6:
	//-- LIIFFA
	//-- 123456, onde:
	//-- L  = 1a posicao:       S/N para ATIVAR ou DESATIVAR o LOG de Movimentacao
	//-- II = 2a e 3a posicoes: Armazem Inicio para Checagem
	//-- FF = 4a e 5a posicoes: Armazem Final para Checagem
	//-- A  = 6a posicao:       S/N para ATIVAR ou DESATIVAR qualquer aviso ao usuario emitido por essa funcao / Obs.: Caso desativado (DEFAULT) nenhuma mensagem serah exibida para usuario; a funcao somente irah gravar o LOG
	cLogMov    := GetMV('MV_LOGMOV')
	lLogMov    := AllTrim(SubStr(cLogMov,1,1))=='S'
	cArmLogMoI := AllTrim(SubStr(cLogMov,2,2))
	cArmLogMoF := AllTrim(SubStr(cLogMov,4,2))
	lLMovAviso := AllTrim(SubStr(cLogMov,6,1))=='S'
EndIf

If (!lLogMov .And. !lForcaChk) .Or. (!Empty(cProdutoLog) .And. !(cProduto $ cProdutoLog))
	Return Nil
EndIf

//-- Reinicializa Variaveis Locais
aAreaAnt  := GetArea()
aAreaSB1  := SB1->(GetArea())
aAreaSB2  := SB2->(GetArea())
aAreaSB8  := SB8->(GetArea())
aAreaSBF  := SBF->(GetArea())
aAreaSDA  := SDA->(GetArea())
aAreaSDB  := SDB->(GetArea())
aAreaSD5  := SD5->(GetArea())
cPictSB2  := PesqPict('SB2', 'B2_QATU')
cPictSB8  := PesqPict('SB8', 'B8_SALDO')
cPictSBF  := PesqPict('SBF', 'BF_QUANT')
cPictSD5  := PesqPict('SD5', 'D5_QUANT')
cPictSDB  := PesqPict('SDB', 'DB_QUANT')
cPictOrig := PesqPict('SB2', 'B2_QATU')

If cAlias == 'SD1'
	cProduto   := (cAliasReal)->D1_COD
	cLocal     := (cAliasReal)->D1_LOCAL
	cNumSeq    := (cAliasReal)->D1_NUMSEQ
	cLoteCtl   := (cAliasReal)->D1_LOTECTL
	cNumLote   := (cAliasReal)->D1_NUMLOTE
	nQuantMov  := (cAliasReal)->D1_QUANT
	cD1VTES    := If(lInverte, Soma1('5'+SubStr((cAliasReal)->D1_TES, 2)), (cAliasReal)->D1_TES)
	nMultiplic := If(cD1VTES>'500',-1,1)
	cInfoOrig  := OemToAnsi(STR0063) + AllTrim(Str((cAliasReal)->(Recno())))
	cPictOrig  := PesqPict('SD1','D1_QUANT')
ElseIf cAlias == 'SD2'
	cProduto   := SD2->D2_COD
	cLocal     := SD2->D2_LOCAL
	cNumSeq    := SD2->D2_NUMSEQ
	cLoteCtl   := SD2->D2_LOTECTL
	cNumLote   := SD2->D2_NUMLOTE
	nQuantMov  := SD2->D2_QUANT
	cD2VTES    := If(lInverte, '1'+Subs((cAliasReal)->D2_TES, 2), (cAliasReal)->D2_TES)
	nMultiplic := If(cD2VTes > '500',-1,1)
	cInfoOrig  := OemToAnsi(STR0064) + AllTrim(Str(SD2->(Recno())))
	cPictOrig  := PesqPict('SD2','D2_QUANT')
ElseIf cAlias == 'SD3'
	cProduto   := SD3->D3_COD
	cLocal     := SD3->D3_LOCAL
	cNumSeq    := SD3->D3_NUMSEQ
	cLoteCtl   := SD3->D3_LOTECTL
	cNumLote   := SD3->D3_NUMLOTE
	nQuantMov  := SD3->D3_QUANT
	nMultiplic := If(SD3->D3_TM>'500',-1,1)
	cLocaliz   := SD3->D3_LOCALIZ
	cNumSeri   := SD3->D3_NUMSERI
	cInfoOrig  := OemToAnsi(STR0065) + AllTrim(Str(SD3->(Recno())))
	cPictOrig  := PesqPict('SD3','D3_QUANT')
	cTes       := SD3->D3_TM
	cOp        := SD3->D3_OP
	lEstorno   := SD3->D3_ESTORNO == 'S'
	lProd      := !Empty(cLoteCtl) .And. !Empty(cOp)
Else
	If Select(cAlias) > 0
		dbSelectArea(cAlias)
	EndIf
	cInfoOrig := OemToAnsi(STR0066) + Alias() + ': ' + AllTrim(Str(Recno()))
	lChkMov   := .F.
	lChkSld   := (!Empty(cProduto).And.!Empty(cLocal))
EndIf

lRastro    := Rastro(cProduto)
lLocaliz   := Localiza(cProduto)
lSubLote   := Rastro(cProduto, 'S')

If lRastro .Or. lLocaliz

	//Ŀ
	// Realiza a Abertura/Criacao da tabela 'LOG'                      
	//
	If !MsFile("LOGMOVMT",,"TOPCONN")
		StartJob("LOGCRITMP",GetEnvServer(),.T.,cEmpAnt,cFilAnt)
	EndIf

	//-- Verifica se possui integracao com WMS
	If !Empty(cProduto)
		lIntDL := IntDL(cProduto)
	Else
		lIntDL := IntDL()
	EndIf

	//-- Considera Somente os Armazens Parametrizados
	If !Empty(cLocal) .And. (!Empty(cArmLogMoI) .And. !Empty(cArmLogMoF))
		If cLocal < cArmLogMoI .Or. cLocal > cArmLogMoF
			Return Nil
		EndIf
	EndIf

	If cAlias $'SD1SD2SC6'
		dbSelectArea(cAliasReal)
		If (nPos := FieldPos(Left(cAlias,2) +'_TES')) > 0
			If !AvalTES(FieldGet(nPos), 'S')
				lChkMov := .F.
			EndIf
		EndIf
	ElseIf cAlias $ 'SD3'
		If SD3->D3_ESTORNO == 'S' .And. SD3->D3_CF == 'DE4'
			lChkSld := .F.
		EndIf
		If lChkSld
			//-- Nao verifica o Saldo  (Ex.: Producoes onde nao se informa o Lote)
			If !(lRastro .Or. lLocaliz)
				lChkSld := .F.
			EndIf
		EndIf
	EndIf

	If lChkMov .And. !lSldAnt
		If QtdComp(nQuantMov) == QtdComp(0)
			lChkMov := .F.
		EndIf
		If lChkMov
			//-- Nao verifica a Movimentacao (Ex.: Producoes onde nao se informa o Lote)
			If lRastro
				If lSubLote
					lChkMov := !(Empty(cLoteCtl).And.!Empty(cNumLote))
				Else
					lChkMov := !Empty(cLoteCtl)
				EndIf
			Else
				If !lLocaliz
					lChkMov := .F.
				EndIf
			EndIf
		EndIf
	EndIf

	//-- Verifica se a Movimentao foi gravada corretamente
	If lChkMov .And. !lSldAnt

		//-- Consiste o SD5 para Rastreabilidade
		nQuantSD5  := 0
		lProcessou := .F.
		If lRastro
			dbSelectArea('SD5')
			dbSetOrder(3)
			If dbSeek(cSeek := xFilial("SD5")+cNumSeq+cProduto+cLocal+(If(lProd,cLoteCtl,"")), .F.)
				Do While !Eof() .And. If(lProd, (D5_FILIAL+D5_NUMSEQ+D5_PRODUTO+D5_LOCAL+D5_LOTECTL), (D5_FILIAL+D5_NUMSEQ+D5_PRODUTO+D5_LOCAL)) == cSeek

					//-- Desconsider Estornados e Tipos de Movimentos Invertidos
					If D5_ESTORNO == 'S' .Or. ;
							nMultiplic == -1 .And. !(D5_ORIGLAN >  '500') .Or. ;
							nMultiplic == 1  .And. !(D5_ORIGLAN <= '500')
						dbSkip()
						Loop
					Else
						cInfoDest  := OemToAnsi(STR0067) + AllTrim(Str(Recno()))
						lProcessou := .T.
					EndIf

					//-- Verifica Lote
					If D5_LOTECTL # cLoteCtl
						aAdd(aLog, { OemToAnsi(STR0068) + cAlias + ' (' + AllTrim(D5_LOTECTL) + '/' + AllTrim(cLoteCtl) + ') - ' + cInfoDest })
					EndIf

					//-- Verifica Sub-Lote
					If lSubLote .And. D5_NUMLOTE # cNumLote
						aAdd(aLog, { OemToAnsi(STR0069)+ cAlias + ' (' + AllTrim(D5_NUMLOTE) + '/' + AllTrim(cNumLote) + ') - ' + cInfoDest })
					EndIf

					nQuantSD5 += D5_QUANT
					dbSkip()
				EndDo

				//-- Verifica Quantidade
				If lProcessou .And. QtdComp(nQuantSD5) # QtdComp(nQuantMov)
					aAdd(aLog, { OemToAnsi(STR0070) + cAlias + ' (' + AllTrim(Transform(nQuantSD5, cPictSD5)) + '/' + AllTrim(Transform(nQuantMov, cPictOrig)) + ')' })
				EndIf
			Else
				aAdd(aLog, { OemToAnsi(STR0071) })
			EndIf
		EndIf

		//-- Consiste o SDA/SDB para Localizacao
		nQuantSDA  := 0
		nQuantSBD  := 0
		lProcessou := .F.
		If lLocaliz
			dbSelectArea('SDB')
			dbSetOrder(1)
			If dbSeek(cSeek := xFilial("SDB")+cProduto+cLocal+cNumSeq, .F.)
				//-- Verifica primeiro o SDB, para os produtos j Distribuidos
				Do While !Eof() .And. DB_FILIAL+DB_PRODUTO+DB_LOCAL+DB_NUMSEQ == cSeek

					//-- Desconsidera Estornados e Tipos de Movimentos Invertidos
					If DB_ESTORNO == 'S' .Or. ;
							DB_ATUEST  == 'N' .Or. ;
							nMultiplic == -1 .And. !(DB_TM >  '500') .Or. ;
							nMultiplic == 1  .And. !(DB_TM <= '500') .Or. ;
							(cAlias=='SD3' .And. lEstorno .And. !Empty(cOp) .And. cTes > '500' .And. DB_TIPO <> 'D')
						dbSkip()
						Loop
					Else
						cInfoDest  := OemToAnsi(STR0072) + AllTrim(Str(Recno()))
						lProcessou := .T.
					EndIf

					//-- Verifica Lote
					If lProd
						If DB_LOTECTL # cLoteCtl .And. !LMovSBD(cProduto,cLocal,cNumSeq,cLoteCtl)
							aAdd(aLog, { OemToAnsi(STR0073) + cAlias + ' (' + AllTrim(DB_LOTECTL) + '/' + AllTrim(cLoteCtl) + ') - ' + cInfoDest })
						EndIf
					Else
						If DB_LOTECTL # cLoteCtl
							aAdd(aLog, { OemToAnsi(STR0073) + cAlias + ' (' + AllTrim(DB_LOTECTL) + '/' + AllTrim(cLoteCtl) + ') - ' + cInfoDest })
						EndIf
					EndIf

					//-- Verifica Sub-Lote
					If lSubLote .And. DB_NUMLOTE # cNumLote
						aAdd(aLog, { OemToAnsi(STR0074) + cAlias + ' (' + AllTrim(DB_NUMLOTE) + '/' + AllTrim(cNumLote)+ ') - ' + cInfoDest })
					EndIf

					If lProd
						If DB_LOTECTL == cLoteCtl
							nQuantSDB += DB_QUANT
						EndIf
					Else
						nQuantSDB += DB_QUANT
					EndIf
					dbSkip()
				EndDo

				//-- Verifica tambm SDA para produtos no distribuidos
				dbSelectArea('SDA')
				dbSetOrder(1)
				If dbSeek(cSeek := xFilial("SDA")+cProduto+cLocal+cNumSeq, .F.)
					Do While !Eof() .And. DA_FILIAL+DA_PRODUTO+DA_LOCAL+DA_NUMSEQ == cSeek

						//-- Desconsidera Produtos NO distribuidos
						If DA_QTDORI == DA_SALDO
							dbSkip()
							Loop
						Else
							cInfoDest  := OemToAnsi(STR0075) + AllTrim(Str(Recno()))
							lProcessou := .T.
						EndIf

						//-- Verifica Lote
						If DA_LOTECTL # cLoteCtl
							aAdd(aLog, { OemToAnsi(STR0076) + cAlias + ' (' + AllTrim(DA_LOTECTL) + '/' + AllTrim(cLoteCtl) + ') - ' + cInfoDest})
						EndIf

						//-- Verifica Sub-Lote
						If lSubLote
							If DA_NUMLOTE # cNumLote
								aAdd(aLog, { OemToAnsi(STR0077) + cAlias + ' (' + AllTrim(DA_NUMLOTE)+ '/' + AllTrim(cNumLote) + ') - ' + cInfoDest})
							EndIf
						EndIf

						nQuantSDA += DA_SALDO

						dbSkip()
					EndDo
				EndIf

				//-- Verifica Quantidade
				If lProcessou .And. QtdComp(nQuantSDA+nQuantSDB) # QtdComp(nQuantMov)
					aAdd(aLog, { OemToAnsi(STR0078) + cAlias + ' (' + AllTrim(Transform(nQuantSDB+nQuantSDA, cPictSDB)) + '/' + AllTrim(Transform(nQuantMov, cPictOrig)) + ')' })
				EndIf
			Else
				//-- Procura somente no SDA, para produtos sem nenhuma distribuicao
				dbSelectArea('SDA')
				dbSetOrder(1)
				If dbSeek(cSeek := xFilial("SDA")+cProduto+cLocal+cNumSeq, .F.)
					Do While !Eof() .And. DA_FILIAL+DA_PRODUTO+DA_LOCAL+DA_NUMSEQ == cSeek

						//-- Desconsidera Produto J distribuidos
						If DA_QTDORI # DA_SALDO
							dbSkip()
							Loop
						Else
							cInfoDest  := OemToAnsi(STR0075)+ AllTrim(Str(Recno()))
							lProcessou := .T.
						EndIf

						//-- Verifica Lote
						If DA_LOTECTL # cLoteCtl
							aAdd(aLog, { OemToAnsi(STR0076) + cAlias + ' (' + AllTrim(DA_LOTECTL) + '/' + AllTrim(cLoteCtl) + ') - ' + cInfoDest })
						EndIf

						//-- Verifica Sub-Lote
						If lSubLote
							If DA_NUMLOTE # cNumLote
								aAdd(aLog, { OemToAnsi(STR0077) + cAlias + ' (' + AllTrim(DA_NUMLOTE)+ '/' + AllTrim(cNumLote) + ') - ' + cInfoDest })
							EndIf
						EndIf

						nQuantSDA += DA_QTDORI

						dbSkip()
					EndDo

					//-- Verifica Quantidade
					If lProcessou .And. QtdComp(nQuantSDA) # QtdComp(nQuantMov)
						aAdd(aLog, { OemToAnsi(STR0079) + cAlias + ' (' + AllTrim(Transform(nQuantSDB, cPictSDB)) + '/' + AllTrim(Transform(nQuantMov, cPictOrig)) + ')' })
					EndIf

				ElseIf nMultiplic == 1
					aAdd(aLog, { OemToAnsi(STR0080) })
				EndIf
			EndIf
		EndIf
	EndIf

	//-- Verifica se o Saldo foi atualizado corretamente
	If lChkSld
		nSaldoSB2 := 0
		nSaldoSB8 := 0
		nSaldoSBF := 0
		nSaldoSDA := 0
		dbSelectArea('SB2')
		dbSetOrder(1)
		If dbSeek(xFilial("SB2") + cProduto + cLocal, .F.)

			nSaldoSB2 := SB2->B2_QATU
			cInfoDest := OemToAnsi(STR0081) + AllTrim(Str(Recno()))

			If lRastro
				nSaldoSB8 := 0
				dbSelectArea('SB8')
				dbSetOrder(3)
				If __oSQLSB8 == nil
					cQuery := "SELECT SUM(B8_SALDO) B8_SALDO FROM "+RetSqlName("SB8") + " "
					cQuery += " WHERE B8_FILIAL = ? "               //- 1
					cQuery += " AND B8_PRODUTO  = ? "               //- 2
					cQuery += " AND B8_LOCAL    = ? "               //- 3
					cQuery += " AND D_E_L_E_T_  = ? "               //- 4
					cQuery := ChangeQuery(cQuery)
					If __lCusaVLib
						__oSQLSB8 := FwExecStatement():New(cQuery)
					Else
						__oSQLSB8 := FWPreparedStatement():New(cQuery)
					EndIf
				EndIf
				__oSQLSB8:SetString(1, xFilial('SB8'))
				__oSQLSB8:SetString(2, cProduto)
				__oSQLSB8:SetString(3, cLocal)
				__oSQLSB8:SetString(4, ' ')

				If __lCusaVLib
					nSaldoSB8 := __oSQLSB8:ExecScalar('B8_SALDO')
				Else
					cQuery := __oSQLSB8:GetFixQuery()
					MpSysOpenQuery(cQuery,'QLogMov')
					IF QLogMov->(!Eof())
						nSaldoSB8 += QLogMov->B8_SALDO
					EndIf
					QLogMov->(dbCloseArea())
				EndIf

				If nSaldoSB8 > 0
					If QtdComp(nSaldoSB2) # QtdComp(nSaldoSB8)
						aAdd(aLog, { OemToAnsi(STR0082) + AllTrim(Transform(nSaldoSB2, cPictSB2)) + '/' + AllTrim(Transform(nSaldoSB8, cPictSB8)) + ')' })
					EndIf
				Else
					If QtdComp(nSaldoSB2) > QtdComp(0)
						aAdd(aLog, { OemToAnsi(STR0083) })
					EndIf
				EndIf
			EndIf

			If lLocaliz
				dbSelectArea('SBF')
				dbSetOrder(2)
				If __oSQLSBF == nil
					cQuery := "SELECT SUM(BF_QUANT) BF_QUANT FROM " +RetSqlName("SBF")+ " "
					cQuery += " WHERE BF_FILIAL = ? "
					cQuery += " AND BF_PRODUTO  = ? "
					cQuery += " AND BF_LOCAL    = ? "
					cQuery += " AND D_E_L_E_T_  = ? "
					cQuery := ChangeQuery(cQuery)
					If __lCusaVLib
						__oSQLSBF := FwExecStatement():New(cQuery)
					Else
						__oSQLSBF := FWPreparedStatement():New(cQuery)
					EndIf
				EndIf
				__oSQLSBF:SetString(1, xFilial('SBF'))
				__oSQLSBF:SetString(2, cProduto)
				__oSQLSBF:SetString(3, cLocal)
				__oSQLSBF:SetString(4, ' ')

				If __lCusaVLib
					nSaldoSBF  := __oSQLSBF:ExecScalar('BF_QUANT')
				Else
					cQuery := __oSQLSBF:GetFixQuery()
					MpSysOpenQuery(cQuery,'QLogMov')
					If QLogMov->(!Eof())
						nSaldoSBF += QLogMov->BF_QUANT
					EndIf
					QLogMov->(dbCloseArea())
				EndIf

				If nSaldoSBF > 0
					If QtdComp(nSaldoSB2-SB2->B2_QACLASS) # QtdComp(nSaldoSBF)
						aAdd(aLog, { OemToAnsi(STR0084) + AllTrim(Transform(nSaldoSB2, cPictSB2)) + '/' + AllTrim(Transform(nSaldoSBF+SB2->B2_QACLASS, cPictSBF)) + ')' })
					EndIf
				Else
					If QtdComp(nSaldoSB2) > QtdComp(0)
						If !(SDA->(dbSeek(xFilial("SDA")+cProduto+cLocal)))
							aAdd(aLog, { OemToAnsi(STR0085) })
						EndIf
					EndIf
				EndIf

				If QtdComp(nSaldoSB2) > QtdComp(0)
					If __oSQLSDA == nil
						cQuery := "SELECT SUM(DA_SALDO) DA_SALDO FROM " +RetSqlName("SDA")+ " "
						cQuery += " WHERE DA_FILIAL = ? "
						cQuery += " AND DA_PRODUTO  = ? "
						cQuery += " AND DA_LOCAL    = ? "
						cQuery += " AND DA_SALDO    > ?"
						cQuery += " AND D_E_L_E_T_  = ? "
						cQuery := ChangeQuery(cQuery)
						If __lCusaVLib
							__oSQLSDA := FwExecStatement():New(cQuery)
						Else
							__oSQLSDA := FWPreparedStatement():New(cQuery)
						EndIf
					EndIf
					__oSQLSDA:SetString(1, xFilial('SDA'))
					__oSQLSDA:SetString(2, cProduto)
					__oSQLSDA:SetString(3, cLocal)
					__oSQLSDA:SetNumeric(4, 0)
					__oSQLSDA:SetString(5, ' ')

					If __lCusaVLib
						nSaldoSDA  := __oSQLSDA:ExecScalar('DA_SALDO')
					Else
						cQuery := __oSQLSDA:GetFixQuery()
						MpSysOpenQuery(cQuery,'QLogMov')
						If QLogMov->(!Eof())
							nSaldoSDA += QLogMov->DA_SALDO
						EndIf
						QLogMov->(dbCloseArea())
					EndIf
				EndIf
			EndIf
		Else
			aAdd(aLog, { OemToAnsi(STR0086) })
		EndIf
	EndIf

	//-- Cria o LOG de Ocorrencias
	If Len(aLog)>0

		cString := ''
		nCall   := 1

		dbSelectArea('SB1')
		If dbSeek(xFilial("SB1") + cProduto)
			cDescri := SB1->B1_DESC
		Else
			aAdd(aLog, { OemToAnsi(STR0087) })
		EndIf

		If lSldAnt
			cString += If(Len(aLog)>1, OemToAnsi(STR0094) + AllTrim(Str(Len(aLog))) + ') : ', OemToAnsi(STR0095)) + _CRLF
			For nX := 1 to Len(aLog)
				cString += AllTrim(Str(nX)) + '. ' + aLog[nX, 1] + _CRLF + If(nX==Len(aLog),_CRLF,'')
			Next nX
			aSldAnt := {nSaldoSB2,nSaldoSBF,nSaldoSB8,cString,nSaldoSDA}
		Else
			If File(cLogFile := 'CM' + Subs(CriaTrab('',.F.),3,6) + '.LOG')
				nLogHdl := fOpen(cLogFile, 2+64)
				fSeek(nLogHdl, 0, 2)
				cString := _CRLF + _CRLF
			Else
				nLogHdl := MsfCreate(cLogFile)
				cString := OemToAnsi(STR0088) + cLogFile + _CRLF + _CRLF
			EndIf
			cString += OemToAnsi(STR0089) + DtoC(dDataBase) + OemToAnsi(STR0090)  + Time() + _CRLF + _CRLF
			cString += OemToAnsi(STR0091) + _CRLF
			Do While !Empty(ProcName(nCall))
				cString += 'Called from ' + AllTrim(ProcName(nCall)) + '(' + AllTrim(Str(ProcLine(nCall))) + ')' + _CRLF
				nCall ++
			EndDo
			cString += _CRLF + OemToAnsi(STR0092) + AllTrim(SubStr(cUsuario,7,15)) + _CRLF + _CRLF
			cString += OemToAnsi(STR0093) + cAlias + ', ' + cInfoOrig + _CRLF + _CRLF
			cString += OemToAnsi(STR0004)+ AllTrim(cProduto) + If(Empty(cDescri),'',' - ' + AllTrim(cDescri)) + ', '+OemToAnsi(STR0005) + AllTrim(cLocal) + _CRLF + _CRLF
			cString += " **** AMBIENTE *****" + _CRLF + _CRLF
			cString += "Ambiente      : "     + GetEnvServer()	+ _CRLF
			dbSelectArea("SM0")
			dbSeek(cEmpAnt+cFilAnt)
			cString += "Empresa        : " + cEmpAnt	+ " - " + SM0->M0_NOME							+ _CRLF
			cString += "Filial         : " + cFilAnt	+ " - " + SM0->M0_FILIAL	                    + _CRLF
			cString += "Integracao WMS : " + IIf(IntDl(cProduto),"Sim","Nao")   						+ _CRLF
			cString += "Pedido Vendas  : " + IIf(lSC9,"Sim","Nao")            							+ _CRLF
			cString += "Qtde Liberada  : " + AllTrim(Str(nQtdeSC9))										+ _CRLF
			cString += "Qtde Movimento : " + AllTrim(Str(nQtdeMov))										+ _CRLF
			cString += "Data MV_ULMES  : " + DTOC(GetMV("MV_ULMES"))									+ _CRLF + _CRLF
			If Len(aSldAnt) > 0
				cString += " **** SALDO ANTERIOR *****" + _CRLF + _CRLF
				cString += "Saldo SB2: " + AllTrim(Transform(aSldAnt[1], cPictSB2)) + _CRLF + IIf(lLocaliz,"Saldo SBF: " + AllTrim(Transform(aSldAnt[2], cPictSBF)) + _CRLF + "Saldo SDA: " + AllTrim(Transform(aSldAnt[5], cPictSBF)),"") + _CRLF + IIf(lRastro,"Saldo SB8: " + AllTrim(Transform(aSldAnt[3], cPictSB8)),"") + _CRLF + _CRLF
				cString += aSldAnt[4] + _CRLF + _CRLF
			EndIf
			cString += " **** SALDO ATUAL *****" + _CRLF + _CRLF
			cString += "Saldo SB2: " + AllTrim(Transform(nSaldoSB2, cPictSB2)) + _CRLF + IIf(lLocaliz,"Saldo SBF: " + AllTrim(Transform(nSaldoSBF, cPictSBF)) + _CRLF + "Saldo SDA: " + AllTrim(Transform(nSaldoSDA, cPictSBF)) ,"") + _CRLF + IIf(lRastro,"Saldo SB8: " + AllTrim(Transform(nSaldoSB8, cPictSB8)),"") + _CRLF + _CRLF
			cString += If(Len(aLog)>1, OemToAnsi(STR0094) + AllTrim(Str(Len(aLog))) + ') : ', OemToAnsi(STR0095)) + _CRLF
			For nX := 1 to Len(aLog)
				cString += AllTrim(Str(nX)) + '. ' + aLog[nX, 1] + _CRLF + If(nX==Len(aLog),_CRLF,'')
			Next nX
			cString += _CRLF + _CRLF
			If (ValType(aLogMov) == "A" .And. Len(aLogMov) > 0)
				cString += " **** DETALHES DE PROCESSAMENTO (MOVLOTE) *****" + _CRLF + _CRLF
			EndIf

			For nX := 1 to Len(aLogMov)
				// Define o tipo de processo
				If SubStr(aLogMov[nX,1,1],1,1)     == "1"
					cProcesso := "ENTRADA/DEVOLUCAO"
				ElseIf SubStr(aLogMov[nX,1,1],1,1) == "2"
					cProcesso := "SAIDA/REQUISICAO"
				ElseIf SubStr(aLogMov[nX,1,1],1,1) == "3"
					cProcesso := "ESTORNO"
				EndIf
				// Carrega Log
				If nX == 1 .And. Len(aLogMov[nX])==1
					cString += aLogMov[nX,1,2]	+ _CRLF
				Else
					cString += cProcesso + ' - ' + "Seq: " + aLogMov[nX,1,1] + " - "+ aLogMov[nX,1,2] + _CRLF
					If lRastro .And. Len(aLogMov[nX])==3 .And.(aLogMov[nX,1,1] <> '400')
						cString += "Quantidade: "	+ AllTrim(Str(aLogMov[nX,2,1]))+ _CRLF
						cString += "Lote......: "	+ aLogMov[nX,2,2]	+ _CRLF
						cString += "SubLote...: "	+ aLogMov[nX,2,3]	+ _CRLF
					EndIf
					If lLocaliz .And. Len(aLogMov[nX])==3 .And.(aLogMov[nX,1,1] <> '400')
						cString += "Quantidade: " + AllTrim(Str(aLogMov[nX,3,1]))+ _CRLF
						cString += "Endereco..: "	+ aLogMov[nX,3,2]	+ _CRLF
						cString += "Nro.Serie.: "	+ aLogMov[nX,3,3]	+ _CRLF
					EndIf
				EndIf
				cString += _CRLF + _CRLF
			Next nX

			If nLogHdl < 0
				If lLMovAviso
					If lIntDL
						DLAviso(Nil, 'MV_LOGMOV', OemToAnsi(STR0096)+ '"' + cLogFile + '".')
					Else
						Aviso('MV_LOGMOV', OemToAnsi(STR0096)+ '"' + cLogFile + '".', {'Ok'})
					EndIf
				EndIf
			Else
				If fWrite(nLogHdl, cString, Len(cString)) < Len(cString)
					If lLMovAviso
						If lIntDL
							DLAviso(Nil, 'MV_LOGMOV', OemToAnsi(STR0097)+'"' + cLogFile + '".')
						Else
							Aviso('MV_LOGMOV', OemToAnsi(STR0097)+'"' + cLogFile + '".', {'Ok'})
						EndIf
					EndIf
				Else
					If !fClose(nLogHdl)
						If lLMovAviso
							If lIntDL
								DLAviso(Nil, 'MV_LOGMOV', OemToAnsi(STR0098)+'"' + cLogFile + '".')
							Else
								Aviso('MV_LOGMOV', OemToAnsi(STR0098)+'"' + cLogFile + '".', {'Ok'})
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
			// Atualiza a tabela de controle de Log de Processamento
			lProcessa := .T.

			If Select("LOGMOVMT") <= 0
				dbUseArea(.T.,"TOPCONN",cArqLog ,"LOGMOVMT",.T.,.F.)
				dbSetIndex("LOGMOVMT")
				dbSetOrder(1)
			EndIf

			If LOGMOVMT->(dbSeek(cFilAnt+cProduto+cLocal+DTOS(dDataBase)))
				If LOGMOVMT->LOG_STATUS < 1
					RecLock("LOGMOVMT",.F.)
					Replace LOG_STATUS With LOG_STATUS+1
					MsUnLock()
				Else
					lProcessa := .F.
				EndIf
			Else
				RecLock("LOGMOVMT",.T.)
				Replace LOG_FILIAL With cFilAnt
				Replace LOG_COD    With cProduto
				Replace LOG_LOCAL  With cLocal
				Replace LOG_DATA   With dDataBase
				Replace LOG_STATUS With 1
				MsUnLock()
			EndIf


			If ExistBlock('LOGMOV') .And. lProcessa
				ExecBlock('LOGMOV', .F., .F., {cLogFile, cProduto, {nSaldoSB2, nSaldoSB8, nSaldoSBF}, nQuantMov, nQuantSDA , nQuantSD5, nQuantSDB})
			EndIf
		EndIf
	Else
		aSldAnt := {nSaldoSB2,nSaldoSBF,nSaldoSB8,'',nSaldoSDA}
	EndIf
	If lLMovAviso .And. Len(aLog) > 0 .And. File('CM*.LOG') .And. lLogMov .And. !lSldAnt
		If lIntDL
			DLAviso(Nil, "MV_LOGMOV",OemToAnsi(STR0099))
		Else
			Aviso("MV_LOGMOV",OemToAnsi(STR0099),{"Ok"})
		EndIf
	EndIf
EndIf

RestArea(aAreaSDB)
RestArea(aAreaSDA)
RestArea(aAreaSD5)
RestArea(aAreaSBF)
RestArea(aAreaSB8)
RestArea(aAreaSB2)
RestArea(aAreaSB1)
RestArea(aAreaAnt)

FWFreeArray(aAreaSDB)
FWFreeArray(aAreaSDA)
FWFreeArray(aAreaSD5)
FWFreeArray(aAreaSBF)
FWFreeArray(aAreaSB8)
FWFreeArray(aAreaSB2)
FWFreeArray(aAreaSB1)
FWFreeArray(aAreaAnt)

Return (Len(aLog)>0)

/*


Ŀ
 Funo     EmpLocLz                                                   
Ĵ
 Autor      Rodrigo de Almeida Sartorio               Data  31/05/00 
Ĵ
 Descrio  Busca saldo empenhado das localizacoes                     
Ĵ
Sintaxe     ExpN1:=EmpLocLz(ExpC1,ExpC2,ExpC3,ExpC4,ExpL5,ExpL6)       
Ĵ
Parametros  ExpC1 = String com o codigo do produto                     
            ExpC2 = String com o local a ser pesquisado                
            ExpC3 = String com o lote de Controle                      
            ExpC4 = String com o Numero do lote                        
            ExpC5 = String com a Localizacao                           
            ExpC6 = String com o Numero de Serie                       
Ĵ
  Uso       Generico Rastreabilidade                                   
ٱ


*/
Function EmpLocLz(cProduto,cLocal,cLoteCTL,cNumLote,cLocaliz,cNumSeri)
Local aArea    := GetArea()
Local aAreaSBF := SBF->(GetArea())
Local nRetorno	:= 0

cLoteCtl:=If(cLoteCtl==NIL.Or.Empty(cLoteCtl),Criavar("BF_LOTECTL"),cLoteCtl)
cNumLote:=If(cNumLote==NIL.Or.Empty(cNumLote),Criavar("BF_NUMLOTE"),cNumLote)
cLocaliz:=If(cLocaliz==NIL.Or.Empty(cLocaliz),Criavar("BF_LOCALIZ"),cLocaliz)
cNumSeri:=If(cNumSeri==NIL.Or.Empty(cNumSeri),Criavar("BF_NUMSERI"),cNumSeri)

dbSelectArea("SBF")
dbSetOrder(1)

If dbSeek(xFilial("SBF")+cLocal+cLocaliz+cProduto+cNumSeri+cLoteCtl+cNumLote)
	While !Eof() .And. SBF->BF_FILIAL 	== xFilial("SBF") .And.;
			SBF->BF_LOCAL == cLocal .And.;
			SBF->BF_LOCALIZ == cLocaliz .And.;
			SBF->BF_PRODUTO == cProduto .And.;
			SBF->BF_NUMSERI == cNumSeri .And.;
			SBF->BF_LOTECTL == cLoteCtl .And.;
			SBF->BF_NUMLOTE == cNumLote
		nRetorno+=SBF->BF_EMPENHO
		dbSelectArea("SBF")
		dbSkip()
	EndDo
EndIf
RestArea(aAreaSBF)
RestArea(aArea)
Return nRetorno

/*


Ŀ
Funo	 BlqProduto Autor Rodrigo de A. Sartorio  Data  08/06/00 
Ĵ
Descrio Verifica se o produto esta bloqueado ou nao para movimento  
Ĵ
Sintaxe    ExpL1:=BlqProduto(ExpC1)                                   
Ĵ
Parametros ExpC1 = String com o codigo do produto                     
Ĵ
 Uso		  Generico 												  
ٱ


*/
Function BlqProduto(cCod)
Local lBloq := .F.
Local aAreaSB1:=SB1->(GetArea())
SB1->(dbSetOrder(1))
SB1->(dbSeek(xFilial("SB1")+cCod))
// Produto bloqueado para tudo
If SB1->B1_ATIVO == "N"
	lBloq:=.T.
	Help(" ",1,"PRODINATIV")
EndIf
SB1->(RestArea(aAreaSB1))
Return lBloq

/*


Ŀ
Funo     CriaTRT   Autor Rodrigo de A. Sartorio  Data  16/06/00 
Ĵ
Descrio  Funcao padrao para criar registros no arquivo de saldos em 
           estoque unificado por empresa                              
Ĵ
Sintaxe    CriaTRT(ExpC1)                                             
Ĵ
Parametros ExpC1 = Codigo da Filial                                   
           ExpC2 = Codigo do produto                                  
Ĵ
 Uso       MATA330                                                    
ٱ


*/
Function CriaTRT(cFilTrt,cCodProd)

	//Ŀ
	// Analise se possui a nova funcao GetSPName                      |
	//

	//Ŀ
	// MV_M330JCM - Habilita o calculo do custo atraves de threads    |
	//
	Local lM330JCM   := !Empty(SuperGetMv("MV_M330JCM" ,.F.,""))

	//Ŀ
	// variaveis utilizadas em ambiente Top com Stored Procedures     |
	//
	Local cSPMAT004  :=  GetSPName("MAT004","19")
	Local cSPMAT007  :=  GetSPName("MAT007","19")
	Local cSPMAT009  :=  GetSPName("MAT009","19")
	Local cSPMAT016  :=  GetSPName("MAT016","19")
	Local cSPMAT052  :=  GetSPName("MAT052","19")
	Local aResult		:={}
	Local lExistProc	:= .F.

	Local cNomeTab  := "SP"

	Local lExistTRT	:= TCCanOpen( "TRT"+cEmpAnt+cNomeTab )


	lExistProc	:= ExistProc(cSPMAT052,VerIDProc()) .And.;
				   ExistProc(cSPMAT004,VerIDProc()) .And.;
	               ExistProc(cSPMAT007,VerIDProc()) .And.;
	               ExistProc(cSPMAT009,VerIDProc()) .And.;
	               ExistProc(cSPMAT016,VerIDProc()) .And.;
	               !lM330JCM

	If lExistProc
		If lExistTRT
			aResult:= TCSPExec(	xProcedures(cSPMAT052)		,;  // Chamada da procedure MAT052
								cFilTrt						,;	// 01. Codigo da filial corrente
								cCodProd )						// 03. Codigo do Produto
			//Ŀ
			// Posiciona no local a ser atualizado                   
			//
			dbSeek(cFilTrt+cCodProd)
		Else
			//Ŀ
			// Finalizar o processo quando verificado que a tabela   
			//| temporaria TRT no existe no banco de dados.          |
			//
			Final(STR0143) //"Atualizar CFGX051 e Instalar Procedures"
		EndIf
	Else
		RecLock("TRT",.T.)
		TRT->TRB_FILIAL:= cFilTrt
		TRT->TRB_COD   := cCodProd
		MsUnlock()
	EndIf
Return

/*


Ŀ
Funo     LogSaldo  Autor  Larson Zordan          Data  05/06/01 
Ĵ
Descrio  Monta array com os lancamentos de produtos sem saldos      
Ĵ
Sintaxe    LogSaldo(ExpC1,ExpC2,ExpC3,ExpC4,ExpN5,ExpC6,ExpC7,ExpD8,  
                     ExpC9,ExpC10,ExpA11)                             
Ĵ
Parametros ExpC1 = Produto                                            
           ExpC2 = Descricao do Produto                               
           ExpC3 = Unidade de Medida (UM)                             
           ExpC4 = Local (Almoxarfado)                                
           ExpN5 = Quantidade                                         
           ExpC6 = Lote                                               
           ExpC7 = Sub-Lote                                           
           ExpD8 = Data de Validade do Lote                           
           ExpC9 = Localizacao Fisica                                 
           ExpC10= Numero de Serie                                    
           ExpA11= Array a ser atualizado                             
           ExpC12= Numero do Documento                                
           ExpD13= Data de Emissao                                    
Ĵ
 Uso       Sigaest                                                    
ٱ

*/
Function LogSaldo(cProduto,cDescricao,cUM,cLocal,nQuant,cLote,cSLote,dDtValid,cLocFis,cNumSer,aLogSld,cDocto,dEmissao)

AADD(aLogSld,{cProduto,cDescricao,cUM,cLocal,nQuant,cLote,cSLote,dDtValid,cLocFis,cNumSer,cDocto,dEmissao})

Return .T.

/*


Ŀ
Funo    RelLogMov  Autor  Larson Zordan          Data  05/06/01 
Ĵ
Descrio  Programa de impressao de lancamentos sem saldos            
Ĵ
Sintaxe    RelLogMov(ExpA1)                                           
Ĵ
Parametros ExpA1 = Array com os lancamentos sem saldos                
Ĵ
 Uso       Sigaest                                                    
ٱ

*/
Function RelLogMov(aLogSld)

Local cTitulo  := STR0052       //"Relacao dos Produtos Lancados Sem Saldos "
Local cDesc1   := STR0053       //"Este relatorio lista os produtos lancados nas transferencias MODII   "
Local cDesc2   := STR0054       //"dos quais os saldos estao zerados e que geraram movimentos.          "
Local cDesc3   := " "
Local cString  := "SD3"
Local wnrel    := "LOGSALDO"
Local Tamanho  := "M"
Local lRet	   := .T.

PRIVATE cPerg   :="      "
PRIVATE aReturn := { STR0055, 1,STR0056, 1, 2, 1, "",1 }		//"Zebrado"###"Administracao"
PRIVATE nLastKey:=0

wnRel:= SetPrint(cString,wnrel,cPerg,cTitulo,cDesc1,cDesc2,cDesc3,.F.,"",,,,.F.)

If nLastKey = 27
	lRet := .F.
Endif

If lRet

	SetDefault(aReturn,cString)

	If nLastKey = 27
		lRet := .F.
	EndIf

	If lRet
		RptStatus({|lEnd| RLogImpr(@lEnd,wnRel,Tamanho,cTitulo,aLogSld)},cTitulo)
	EndIf

EndIf

Return .T.

/*


Ŀ
Funo     RLogImpr  Autor  Larson Zordan          Data  05/06/01 
Ĵ
Descrio  Preparacao do Arquivo de Trabalho p/ Relatorio             
Ĵ
Parametros ExpL1 = Parametro referente a impressao do relatorio       
           ExpN2 = Parametro referente a impressao do relatorio       
           ExpN3 = Tamanho do Relatorio                               
           ExpC4 = Titulo do Relatorio                                
           ExpA5 = Array contendo o Saldo                             
Ĵ
 Uso       SIGAEST                                                    
ٱ


*/
Static Function RLogImpr(lEnd,wnRel,Tamanho,Titulo,aLogSld)
Local n := 0
Private Li     := 80
Private M_Pag  := 1

cCab01 := OemToAnsi(STR0057)        //"CODIGO          DESCRICAO                        UM ALM   QUANTIDADE LOTE       SUB     DATA DE  LOCALIZACAO     NUMERO DE"
cCab02 := OemToAnsi(STR0058)        //"                                                                                LOTE    VALIDADE FISICA          SERIE    "
//										123456789012345 12345678901234567890123456789012 12 12  9.999.999,99 1234567890 123456  99/99/99 123456789012345 12345678901234567890
//										0         1         2         3         4         5         6         7         8         9        10        11        12        13
//										0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012

For n := 1 to Len(aLogSld)

	If (LastKey() == 286)
		n := Len(aLogSld)
	EndIf

	If (Li > 58)
		Cabec( Titulo,cCab01,cCab02,wnRel,Tamanho )

		Li ++

		@ Li,000 PSay OemToAnsi(STR0059)    //"Numero do Documento:"
		@ Li,023 PSay aLogSld[n,11]
		@ Li,040 PSay OemToAnsi(STR0060)    //"Data de Emissao:"
		@ Li,058 PSay aLogSld[n,12]

		Li += 2
	EndIf

	@ Li,000 PSay aLogSld[n,1]
	@ Li,016 PSay Substr(aLogSld[n,2],1,32)
	@ Li,049 PSay aLogSld[n,3]
	@ Li,052 PSay aLogSld[n,4]
	@ Li,056 PSay aLogSld[n,5] Picture PesqPictQT("D3_QUANT",12)
	@ Li,069 PSay aLogSld[n,6]
	@ Li,080 PSay aLogSld[n,7]
	@ Li,088 PSay aLogSld[n,8]
	@ Li,097 PSay aLogSld[n,9]
	@ Li,113 PSay aLogSld[n,10]
	Li++

Next n

If (LastKey() == 286)
	@ pRow()+1,00 PSay OemToAnsi(STR0061)     //"CANCELADO PELO OPERADOR."
Else
	Roda( Len(aLogSld), OemToAnsi(STR0062), Tamanho )    //"Registro(s) processado(s)"
EndIf

SET DEVICE TO SCREEN
If aReturn[5] == 1
	Set Printer TO
	dbCommitAll()
	ourspool(wnrel)
Endif

MS_FLUSH()

Return( nil )


/*


Ŀ
Funo    AtuCPSC2   Autor Rodrigo de A. Sartorio  Data  03/08/01 
Ĵ
Descrio  Atualiza o CUSTO EM PARTES no arquivo SC2                  
Ĵ
Sintaxe    AtuCPSC2(EXPL1,EXPA1,EXPN1)                                
Ĵ
Parametros ExpL1 = Variavel logica que indica se utiliza o custo em   
                   partes ou nao                                      
           ExpA1 = Array com o custo em partes a ser atualizado no SC2
           ExpN1 = Multiplicador do movimento                         
Ĵ
 Uso       MATA330                                                    
ٱ


*/
Function ATUCPSC2(lCstPart,aRetPartes,nMultiplic)
LOCAL _cCampo := "C2_CPF"
LOCAL _nLoop0 :=0
LOCAL _nLoop1 :=0
LOCAL _nValorAtu:=0
LOCAL aArea
LOCAL nPosicao:=0

DEFAULT lCstPart := .F.

If lCstPart

	aArea   := GetArea()
	cMoeda330C:= IIF(cMoeda330C == Nil,SuperGetMv('MV_MOEDACM',.F.,"2345"),cMoeda330C)

	//Ŀ
	// Grava informacao do custo em partes no SB2           
	//
	For _nLoop0:=1 to Len(aRetPartes)/5
		For _nLoop1:=1 to 5
			_cCampo     := "C2_CPF"
			_cCampo     :=_cCampo+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0)
			nPosicao    :=FieldPos(_cCampo)
			If _nLoop1 # 1 .And. !(Str(_nLoop1,1,0) $ cMoeda330C)
				_nValorAtu  := 0
			Else
				_nValorAtu  :=FIELDGET(nPosicao)
			EndIf
			If nPosicao > 0
				FIELDPUT(nPosicao,_nValorAtu+(	aRetPartes[_nLoop1+If(_nLoop0==1,0,(_nLoop0-1)*5)]*nMultiplic))
			EndIf
		Next _nLoop1
	Next _nLoop0
RestArea(aArea)
EndIf
RETURN

/*


Ŀ
Funo    RetCParte  Autor Rodrigo de A. Sartorio  Data  03/08/01 
Ĵ
Descrio  Retorna qual a parte do custo que esse produto se encontra 
Ĵ
Sintaxe    ExpN1 := RetCParte(ExpC1,ExpA1)                            
Ĵ
Parametros ExpN1 = Retorno numerico que indica qual parte do custo    
                   pertence o produto                                 
           ExpC1 = Codigo do produto a ter a parte do custo verificada
           ExpA1 = Array com as regras do custo em partes             
Ĵ
 Uso       MATA330                                                    
ٱ


*/
Function RetCParte(cProduto,aRegracp)
LOCAL aArea:=GetArea()
LOCAL aAreaSB1:=SB1->(GetArea())
LOCAL nParte:=Len(aRegraCP)+1
LOCAL nzy
LOCAL cForm:=""
//Ŀ
// Posiciona no produto a ser pesquisado                 
//
dbSelectArea("SB1")
dbSetOrder(1)
If MsSeek(xFilial("SB1")+cProduto)
	//Ŀ
	// Executa as condicoes para descobrir qual a parte      
	// do custo que se aplica a este produto.                
	//
	For nzy:=1 to Len(aRegraCP)
		cForm:=ALLTRIM(aRegraCP[nzy])
		If &cForm
			nParte:=nzy
			Exit
		EndIf
	Next nzy
EndIf
RestArea(aAreaSB1)
RestArea(aArea)
RETURN nParte

/*


Ŀ
Funo    MA330AvlCP Autor  Rodrigo de A. Sartorio Data  22/03/01 
Ĵ
Descrio  Avalia se sera utilizado o Custo em Partes no sistema      
Ĵ
Sintaxe    ExpL1 := MA330AvlCP(ExpA1,ExpA2)                           
Ĵ
Parametros ExpL1 := Retorno logico com utilizacao do custo em partes  
           ExpA1 := Array com as regras do Custo em Partes            
           ExpA2 := Array com os campos que nao existem na base       
Ĵ
 Uso       MATA330                                                    
ٱ


*/
Function MA330AvlCp(_aPartes,aLogsPart)
Local _cCampo:=""
Local _cCampo1:=""
Local _nLoop1:=1
Local _nLoop2:=1
Local _nLoop3:=1
Local _nLoop4:=1
// Array com os campos que precisam ser criados para calculo do custo
// (Campos para gravacao do custo em partes)
Local _aAreas :={{"SB2","B2_CP","B2_CPF"},{"SB6","B6_CP"},{"SB9","B9_CP","B9_CPM"},{"SC2","C2_CPF","C2_CPI","C2_API","C2_APF"},{"SD1","D1_CP"},{"SD2","D2_CP"},{"SD3","D3_CP"}}
cMoeda330C:= IIF(cMoeda330C == Nil,SuperGetMv('MV_MOEDACM',.F.,"2345"),cMoeda330C)
// Verifica se todos os campos necessarios foram criados
// OS CAMPOS SAO DEFINIDOS COM A SEGUINTE REGRA
// XXXXXXYYZZ
// XXXXXX     - NOME BASE DO CAMPO - ATE 6 POSICOES
//       YY   - PARTE DO CUSTO (ATE 2 POSICOES)
//         ZZ - MOEDA DO CUSTO (ATE 2 POSICOES)
For _nLoop1:=1 to Len(_aAreas)
	For _nLoop2:=2 to Len(_aAreas[_nLoop1])
		_cCampo:=_aAreas[_nLoop1,_nLoop2]
		For _nLoop3:=1 to Len(_aPartes)+1
			For _nLoop4:=1 to 5
				// Verifica se moeda devera ser considerada
				If _nLoop4 # 1 .And. !(Str(_nLoop4,1,0) $ cMoeda330C)
	               	Loop
				EndIf
				_cCampo1:=_cCampo+Strzero(_nLoop3,2,0)+Strzero(_nLoop4,2,0)
				dbSelectArea(_aAreas[_nLoop1,1])
				// Inclui campo no array para indicar problemas ao usuario
				If FIELDPOS(_cCampo1) <= 0
					AADD(aLogsPart,{_aAreas[_nLoop1,1],_cCampo1})
				EndIf
			Next _nLoop4
		Next _nLoop3
	Next _nLoop2
Next _nLoop1
RETURN (Len(aLogsPart)==0)

/*


Ŀ
Funo     A330TTFim Autor Rodrigo de A. Sartorio  Data  16/06/00 
Ĵ
Descrio  Devolve array com os 05 custos medios finais qdo roda custo
           unificado por empresa                                      
Ĵ
 Uso       MATA330                                                    
ٱ


*/
Function A330TTFim(cCodProd,cLocal,cTipo,aCusRec,cAlias,cProg,lDevCompra,lCusFifo,lCstPart,nRegras,lCusEmp)
LOCAL aRetPartes := {}
LOCAL nDec       := Set(3,8)
LOCAL aArea      := GetArea()
LOCAL aRet       := {0,0,0,0}

LOCAL nX,aCM[05],aVFim[05],aAux
LOCAL cTipoCF,aCustox[05]
LOCAL cCUSZERO := EstGetMV("MV_CUSZERO",.F.,"N")

//Ŀ
// MV_ADEVCOM - Utilizado para verificar se nas devolucoes |
//| de compras o custo de devolucao da nota de saida sera   |
//| ajustado quando o saldo final for menor que o valor do  |
//| custo de origem.                                        |
//
LOCAL lAjuDevCom:= EstGetMV("MV_ADEVCOM",.F.,.T.)

DEFAULT lCusEmp := IIf(ValType(EstGetMV('MV_CUSFIL',.F.)) == "C",AllTrim(EstGetMV('MV_CUSFIL',.F.))=="E",.F.)


cMoeda330C  := IIF(cMoeda330C == Nil,EstGetMv('MV_MOEDACM',.F.,"2345"),cMoeda330C)
aCustox[01] :=0
aCustox[02] :=0
aCustox[03] :=0
aCustox[04] :=0
aCustox[05] :=0

cTipo 	 := IIF(cTipo    == NIL," ",cTipo)
cAlias   := IIF(cAlias   == NIL,"SD3",cAlias)
cProg    := IIF(cProg    == NIL,Space(03),cProg)
lCusFIFO := IIF(lCusFifo == NIL,.F.,lCusFifo)
cTipoCF  := IIF(cAlias   == "SD3",Substr(SD3->D3_CF,1,2),Space(02))

//Ŀ
// Cria registro quando nao existir                      
//
dbSelectArea("TRT")
If !(MsSeek(If(lCusEmp,Space(Len(cFilAnt)),cFilAnt)+cCodProd))
	CriaTRT(If(lCusEmp,Space(Len(cFilAnt)),cFilAnt),cCodProd)
EndIf

//Ŀ
// Verifica tipo de saida para calculo do custo de saida 
//
If cTipo == "D"
	aAux:={ aCusRec }
	aAux := RetCusEnt( , aAux , , lDevCompra,,,lCstPart,nRegras,cProg,aRetPartes)
	aCM  := aAux[1]
	If cProg == "330" .And. lDevCompra .And. cAlias == "SD2" .And. TRB_VFIM1 < aCM[01] .And. lAjuDevCom
		aCM[01] := TRB_CM1 * SD2->D2_QUANT
		aCM[02] := TRB_CM2 * SD2->D2_QUANT
		aCM[03] := TRB_CM3 * SD2->D2_QUANT
		aCM[04] := TRB_CM4 * SD2->D2_QUANT
		aCM[05] := TRB_CM5 * SD2->D2_QUANT
		// Obtem o custo em partes unitario
		aRetPartes:=PegaCMPFim("TRB_CP",lCstPart,nRegras,1)
		For nx:=1 to Len(aRetPartes)
			aRetPartes[nx]:=aRetPartes[nx]*SD2->D2_QUANT
		Next nx
	EndIf
Else
	aCM[01] := TRB_CM1
	aCM[02] := TRB_CM2
	aCM[03] := TRB_CM3
	aCM[04] := TRB_CM4
	aCM[05] := TRB_CM5
	If !IsProdMod(cCodProd)
		aVFim[01] := TRB_VFIM1
		aVFim[02] := TRB_VFIM2
		aVFim[03] := TRB_VFIM3
		aVFim[04] := TRB_VFIM4
		aVFim[05] := TRB_VFIM5
		For nX := 1 to 5
			// Verifica se moeda devera ser considerada
			If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
				aCM[nX] := 0
				Loop
			EndIf
			If TRB_QFIM > 0 .And. aVFim[nX] > 0
				aCM[nX] := CusRound(aVFIM[nX]/TRB_QFIM,nX)
			Else
				If cCUSZERO == "S"
					aCM[nX] := 0
				EndIf
			EndIf
		Next nX
		// Obtem o custo em partes unitario
		aRetPartes:=PegaCMPFim("TRB_VF",lCstPart,nRegras,TRB_QFIM)
	EndIf
EndIf
//-- Retorna Integridade do Sistema
RestArea(aArea)
Set(3,nDec)
If cProg == "330"
	aRet[01] := aCM
	aRet[02] := aCM
	aRet[03] := aRetPartes
	Return aRet
Else
	Return aCM
EndIf

/*


Ŀ
Funo    AtuCPSB2   Autor Rodrigo de A. Sartorio  Data  03/08/01 
Ĵ
Descrio  Atualiza o CUSTO EM PARTES no arquivo TOTALIZADOR          
Ĵ
Sintaxe    AtuCPSB2(EXPL1,EXPA1,EXPN1,EXPC1)                          
Ĵ
Parametros ExpL1 = Variavel logica que indica se utiliza o custo em   
                   partes ou nao                                      
           ExpA1 = Array com os custos a serem atualizados            
           ExpN1 = Multiplicador do movimento                         
           ExpC1 = Arquivo totalizador                                
           ExpA2 = Array com os custos unitario Historicos            
Ĵ
 Uso       MATA330                                                    
ٱ


*/
Function AtuCPSB2(lCstPart,aRetPartes,nMultiplic,_cCampoBack,aCMHist)
Local _cCampo     := ""
Local _cCampoTot  := ""
Local _cCampoUnit := "B2_CP"
Local _nLoop0     := 0
Local _nLoop1     := 0
Local _nValorAtu  := 0
Local nPosicao    := 0
Local lUtilProp   := .F.
Local aHistParte
Local lPropCP

Default lCstPart    := .F.
Default _cCampoBack := "B2_CPF"
Default aCMHist     := {}

If lCstPart

	aHistParte  := aClone(aRetPartes)
	lPropCP     := EstGetMv("MV_PROPCP",.F.,.F.)
	cMoeda330C:= IIF(cMoeda330C == Nil,EstGetMv('MV_MOEDACM',.F.,"2345"),cMoeda330C)

	//Ŀ
	// Grava informacao do custo em partes no SB2           
	//
	For _nLoop0:=1 to Len(aRetPartes)/5
		For _nLoop1:=1 to 5
			_cCampo     := _cCampoBack+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0)
			nPosicao    :=FieldPos(_cCampo)
			If _nLoop1 # 1 .And. !(Str(_nLoop1,1,0) $ cMoeda330C)
				_nValorAtu  := 0
			Else
				_nValorAtu  :=FIELDGET(nPosicao)
			EndIf
			If nPosicao > 0
				FIELDPUT(nPosicao,_nValorAtu+(	aRetPartes[_nLoop1+If(_nLoop0==1,0,(_nLoop0-1)*5)]*nMultiplic))
			EndIf
		Next _nLoop1
	Next _nLoop0
	//Ŀ
	// Grava informacao do custo em partes UNITARIO no SB2  
	//
	If Alias() == "SB2" .And. QtdComp(SB2->B2_QFIM) > QtdComp(0)
		aFill(aHistParte,0)
		For _nLoop0:=1 to Len(aRetPartes)/5
			For _nLoop1:=1 to 5
				If &("SB2->B2_VFIM"+StrZero(_nLoop1,1,0)) > 0
					_cCampo     := _cCampoUnit+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0)
					_cCampoTot  := _cCampoBack+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0)
					nPosicao    := FieldPos(_cCampoTot)
					If _nLoop1 # 1 .And. !(Str(_nLoop1,1,0) $ cMoeda330C)
						_nValorAtu  := 0
					Else
						_nValorAtu  :=FIELDGET(nPosicao)
					EndIf
					If nPosicao > 0
						If lPropCP
							aHistParte[_nLoop1+((_nLoop0-1)*5)] := FIELDGET(FieldPos(_cCampo))
							If Len(aCMHist) > 0 .And. (_nValorAtu/SB2->B2_QFIM) < 0 .And. (_nLoop0 <> Len(aRetPartes)/5)
								lUtilProp := .T.
							EndIf
						EndIf
						FIELDPUT(FieldPos(_cCampo),_nValorAtu/SB2->B2_QFIM)
					EndIf
				EndIf
			Next _nLoop1
		Next _nLoop0
		//Ŀ
		// Grava o custo unitario em partes utilizando o calculo 
		// de proporcao para unitarios negativos                 
		//
        If lUtilProp
			For _nLoop0:=1 to Len(aRetPartes)/5
				For _nLoop1:=1 to 5
					_cCampo     := _cCampoUnit+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0)
					_cCampoTot  := _cCampoBack+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0)
					nPosicao    := FieldPos(_cCampoTot)
					If _nLoop1 # 1 .And. !(Str(_nLoop1,1,0) $ cMoeda330C)
						_nValorAtu  := 0
					Else
						_nValorAtu  := (aHistParte[_nLoop1+((_nLoop0-1)*5)]/aCMHist[_nLoop1]) * &("SB2->B2_CM"+StrZero(_nLoop1,1,0))
					EndIf
					If nPosicao > 0
						FIELDPUT(FieldPos(_cCampo),_nValorAtu)
					EndIf
				Next _nLoop1
			Next _nLoop0
        EndIf
	EndIf
	aSize(aHistParte,0)
EndIf
RETURN

/*


Ŀ
Funo    PegaCMPFim Autor Rodrigo de A. Sartorio  Data  15/08/01 
Ĵ
Descrio  Devolve array com os custos em parte finais                
Ĵ
Sintaxe    ExpA1 := PegaCMPFim(ExpC1,ExpL1,ExpN1,ExpN2,ExpA1,ExpA2)   
Ĵ
Parametros ExpA1 = Array com os 05 custos medios possiveis            
           ExpC1 = Campo com os custos em partes                      
           ExpL1 = Expressao logica indicando se usa custo em partes  
           ExpN1 = Numero de regras para custo em partes              
           ExpN2 = Quantidade para divisao e calculo do custo unitario
           ExpA1 = Array com o custo medio historico nas 5 moedas     
           ExpA2 = Array das regras para utilizacao do custo em partes
Ĵ
 Uso       CUSTO EM PARTES                                            
ٱ


*/
Function PegaCMPFim(cCampoPar,lCstPart,nRegras,nDivisor,aCustoMedio,aRegraCP)
LOCAL _nPosCP 	:= 0
LOCAL _nLoop0 	:= 0
LOCAL _nLoop1 	:= 0
LOCAL _cCampo 	:= cCampoPar
LOCAL aRet	  	:= {}
LOCAL aArea
LOCAL lValor 	:= .F.
LOCAL cCUSZERO

DEFAULT lCstPart    := .F.
DEFAULT nDivisor    := 1
DEFAULT aCustoMedio :={0,0,0,0,0}

If lCstPart

	aArea := GetArea()
	cCUSZERO := EstGetMV("MV_CUSZERO",.F.,"N")
	cMoeda330C := IIF(cMoeda330C == Nil,EstGetMV('MV_MOEDACM',.F.,"2345"),cMoeda330C)

	//Ŀ
	// Grava informacao do custo em partes no SB2           
	//
	For _nLoop0:=1 to nRegras
		For _nLoop1:=1 to 5
			// Verifica se moeda devera ser considerada
			If _nLoop1 # 1 .And. !(Str(_nLoop1,1,0) $ cMoeda330C)
				AADD(aRet,0)
            Loop
			EndIf
			_cCampo     := cCampoPar
			_cCampo     :=_cCampo+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0)
			If Alias() == "SB2"
				If QtdComp(nDivisor) <= QtdComp(0) .Or. FIELDGET(FieldPos("B2_CPF"+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0))) < 0
					If cCUSZERO == "S"
						AADD(aRet,0)
					Else
						AADD(aRet,FIELDGET(FieldPos("B2_CP"+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0))))
						If aRet[Len(aRet)] > 0
							lValor := .T.
						EndIf
					EndIf
				Else
					AADD(aRet,CusRound(FieldGet(FieldPos(_cCampo))/nDivisor,_nLoop1))
				EndIf
			ElseIf Alias() == "TRT"
				If QtdComp(nDivisor) <= QtdComp(0) .Or. FIELDGET(FieldPos("TRB_VF"+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0))) < 0
					If cCUSZERO == "S"
						AADD(aRet,0)
					Else
						AADD(aRet,FIELDGET(FieldPos("TRB_CP"+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0))))
						If aRet[Len(aRet)] > 0
							lValor := .T.
						EndIf
					EndIf
				Else
					AADD(aRet,CusRound(FieldGet(FieldPos(_cCampo))/nDivisor,_nLoop1))
				EndIf
			ElseIf cPaisLoc == "RUS" .And. Empty(FieldGet(FieldPos(_cCampo)))
				aAdd(aRet, 0)
			Else
				AADD(aRet,CusRound(FieldGet(FieldPos(_cCampo))/nDivisor,_nLoop1))
			EndIf
		Next _nLoop1
	Next _nLoop0
	//Ŀ
	// Caso tenha Custo Medio historico e nao tenha Custo   
	// em Partes assume o valor do custo medio historico no 
	// Custo em Partes .                                    
	//
	If Alias() == "SB2" .And. QtdComp(nDivisor) <= QtdComp(0) .And. !lValor .And. cCUSZERO # "S"
		//Ŀ
		// Descobre qual parte do custo deve ser atualizada     
		//
		_nPosCP:=RetCParte(SB2->B2_COD,aRegraCP)
		//Ŀ
		// Grava informacao do custo em partes no SB2           
		//
		For _nLoop0:=1 to nRegras
			If _nLoop0 == _nPosCP
				For _nLoop1:=1 to 5
					// Verifica se moeda devera ser considerada
					If _nLoop1 # 1 .And. !(Str(_nLoop1,1,0) $ cMoeda330C)
						aRet[((_nLoop0-1)*5)+_nLoop1]:=0
	                	Loop
					EndIf
					aRet[((_nLoop0-1)*5)+_nLoop1]:=aCustoMedio[_nLoop1]
				Next _nLoop1
				Exit
			EndIf
		Next _nLoop0
	EndIf
	RestArea(aArea)
EndIf
RETURN aRet

/*


Ŀ
Funo    GravaCusCP Autor Rodrigo de A. Sartorio  Data  03/08/01 
Ĵ
Descrio  Atualiza o CUSTO EM PARTES no arq. de movimentos passado   
Ĵ
Sintaxe    GravaCusCP(EXPL1,EXPA1,EXPA2,EXPC1,EXPC2,EXPA3,EXPN1,EXPC3,
           ExpA4)                                                     
Ĵ
Parametros ExpL1 = Variavel logica que indica se utiliza o custo em   
                   partes ou nao                                      
           ExpA1 = Array com as regras do custo em partes             
           ExpA2 = Array com os valores a serem somados               
           ExpC1 = Variavel caracter que indica o alias a ter o custo 
                   em partes atualizado                               
           ExpC2 = Variavel caracter que indica o codigo do produto   
           ExpA3 = Array com o custo em partes do movimento           
           ExpN1 = Quantidade do movimento realizado                  
           ExpC3 = Nome do campo a ser atualizado                     
           ExpA4 = Array com o custo TOTAL para conferencia           
Ĵ
 Uso       MATA330                                                    
ٱ


*/
Function GravaCusCP(lCstPart,aRegraCP,aValorSoma,cAliasAtu,cProduto,aRetPartes,nQuantMov,_cCampo,aConferencia,lTotalCP)
LOCAL _cCampo1	:= ""
LOCAL _nLoop1	:= 0
LOCAL _nPosCP	:= 0
Local nVar		:= 0
LOCAL aArea
LOCAL _nLoop0 	:= 0
LOCAL aTotais
LOCAL lContinua := .T.
LOCAL nCustoAtu := 0

// Criada para evitar diferenca de arredondamento
LOCAL aValorResto

STATIC lA330E6CP
STATIC lA330D1CP

DEFAULT lCstPart  := .F.
DEFAULT lTotalCP  := .F.
DEFAULT nQuantMov := 1
DEFAULT _cCampo   := Substr(cAliasAtu,2,2)+"_CP"

If lCstPart
	aArea := GetArea()

	// Criada para evitar diferenca de arredondamento
	aValorResto:= If(ValType(aConferencia) == "A",ACLONE(aConferencia),{0,0,0,0,0})

	aTotais	:= {0,0,0,0,0}
	lA330E6CP := IIF( lA330E6CP == nil,ExistBlock("A330E6CP"), lA330E6CP)
	lA330D1CP := IIF( lA330D1CP == nil,ExistBlock("A330D1CP"), lA330D1CP)
	cMoeda330C:= IIF(cMoeda330C == Nil,EstGetMv('MV_MOEDACM',.F.,"2345"),cMoeda330C)

	If ValType(aRetPartes) # "A" .Or. Len(aRetPartes) <= 0
		//Ŀ
		// A330E6CP - Ponto de Entrada utilizado para verificar se deseja      
		//|            manter o valores do custo em partes para movimentos      |
		//|            SD3 - RE6/DE6.                                           |
		//
		//Ŀ
		//| A330D1CP - Ponto de Entrada utilizado para verificar se deseja      |
		//|            manter os valores do custo em partes para movimentos SD1.|
		//
		If	(lA330E6CP .And. cAliasAtu == "SD3" .And. ExecBlock("A330E6CP",.F.,.F.) .And. Alltrim((cAliasAtu)->D3_CF) $ "DE6/RE6") .Or. ;
		    (lA330D1CP .And. cAliasAtu == "SD1" .And. ExecBlock("A330D1CP",.F.,.F.))
			//Ŀ
			// Inicializa o array aRetPartes com valor zerado       
			//
			aRetPartes:=ARRAY((Len(aRegraCP)+1)*5)
			AFILL(aRetPartes,0)
			//Ŀ
			// Carrega aRetPartes com os custos ja informados nos campos 
			//
			For _nLoop0:=1 to Len(aRegraCP)+1
				For _nLoop1:=1 to 5
					// Verifica se moeda devera ser considerada
					If _nLoop1 # 1 .And. !(Str(_nLoop1,1,0) $ cMoeda330C)
						aRetPartes[_nLoop1+((_nLoop0-1)*5)]:=0
	                	Loop
					EndIf
					_cCampo1  :=_cCampo+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0)
					nCustoAtu := (cAliasAtu)->(FIELDGET(FieldPos(_cCampo1)))
					aRetPartes[_nLoop1+((_nLoop0-1)*5)]:=nCustoAtu
					aTotais[_nLoop1] +=  nCustoAtu
				Next _nLoop1
			Next _nLoop0
			//Ŀ
			// Manter os valores somente quando nao ha divergencias.     
			//
			If	QtdComp(aTotais[1]) == QtdComp(IIf(cAliasAtu="SD1",(cAliasAtu)->D1_CUSTO ,(cAliasAtu)->D3_CUSTO1)) .And. ;
				QtdComp(aTotais[2]) == QtdComp(IIf(cAliasAtu="SD1",(cAliasAtu)->D1_CUSTO2,(cAliasAtu)->D3_CUSTO2)) .And. ;
				QtdComp(aTotais[3]) == QtdComp(IIf(cAliasAtu="SD1",(cAliasAtu)->D1_CUSTO3,(cAliasAtu)->D3_CUSTO3)) .And. ;
				QtdComp(aTotais[4]) == QtdComp(IIf(cAliasAtu="SD1",(cAliasAtu)->D1_CUSTO4,(cAliasAtu)->D3_CUSTO4)) .And. ;
				QtdComp(aTotais[5]) == QtdComp(IIf(cAliasAtu="SD1",(cAliasAtu)->D1_CUSTO5,(cAliasAtu)->D3_CUSTO5))
				lContinua := .F.
			EndIf
		EndIf

		If lContinua
			//Ŀ
			// Inicializa o array aRetPartes com valor zerado       
			//
			aRetPartes:=ARRAY((Len(aRegraCP)+1)*5)
			AFILL(aRetPartes,0)
			//Ŀ
			// Descobre qual parte do custo deve ser atualizada     
			//
			_nPosCP:=RetCParte(cProduto,aRegraCP)
			//Ŀ
			// Grava informacao do custo em partes no ALIAS do parametro 
			//
			Reclock(cAliasAtu,.F.)
			For _nLoop1:=1 to 5
				// Verifica se moeda devera ser considerada
				If _nLoop1 # 1 .And. !(Str(_nLoop1,1,0) $ cMoeda330C)
					aRetPartes[_nLoop1+If(_nPosCP==1,0,(_nPosCP-1)*5)]:=0
                	Loop
				EndIf
				_cCampo1:=_cCampo+Strzero(_nPosCP,2,0)+Strzero(_nLoop1,2,0)
				FIELDPUT(FieldPos(_cCampo1),aValorSoma[_nLoop1])
				aRetPartes[_nLoop1+If(_nPosCP==1,0,(_nPosCP-1)*5)]:=aValorSoma[_nLoop1]
			Next _nLoop1
			//Ŀ
			// Grava VALOR ZERO nas outras partes do custo               
			//
			For _nLoop0:=1 to Len(aRegraCP)+1
				If _nLoop0 # _nPosCP
					For _nLoop1:=1 to 5
						// Verifica se moeda devera ser considerada
						If _nLoop1 # 1 .And. !(Str(_nLoop1,1,0) $ cMoeda330C)
							Loop
						EndIf
						_cCampo1    :=_cCampo+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0)
						nVar := FieldPos(_cCampo1)
						FIELDPUT(nVar,0)
					Next _nLoop1
				EndIf
			Next _nLoop0
			MsUnlock()
		EndIf
	Else
		//Ŀ
		// Multiplica o custo pela quantidade do movimento      
		//
		For _nLoop0:=1 to Len(aRetPartes)
			aRetPartes[_nLoop0]:=Iif(empty(aRetPartes[_nLoop0]), 0, aRetPartes[_nLoop0]*IIf(!lTotalCP,nQuantMov,1))
		Next _nLoop0
		//Ŀ
		// Grava informacao do custo em partes no ALIAS do parametro 
		//
		Reclock(cAliasAtu,.F.)
		For _nLoop0:=1 to Len(aRetPartes)/5
			For _nLoop1:=1 to 5
				// Verifica se moeda devera ser considerada
				If _nLoop1 # 1 .And. !(Str(_nLoop1,1,0) $ cMoeda330C)
					aRetPartes[_nLoop1+If(_nLoop0==1,0,(_nLoop0-1)*5)]:=0
                	Loop
				EndIf
				_cCampo1    :=_cCampo+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0)
				nVar := FieldPos(_cCampo1)
				// Processa valores passados pelo array
				If _nLoop0 < Len(aRetPartes)/5
					FIELDPUT(nVar,aRetPartes[_nLoop1+If(_nLoop0==1,0,(_nLoop0-1)*5)])
					aValorResto[_nLoop1] -= FieldGet(nVar)
					// Na ultima parte processa o valor da diferenca para evitar problemas de arredondamento
				Else
					FIELDPUT(nVar,aValorResto[_nLoop1])
				EndIf
				aRetPartes[_nLoop1+If(_nLoop0==1,0,(_nLoop0-1)*5)]:=FieldGet(nVar)
			Next _nLoop1
		Next _nLoop0
		MsUnlock()
	EndIf

	aSize(aTotais,0)
	aSize(aValorResto,0)

RestArea(aArea)

EndIf
RETURN aRetPartes

/*

Ŀ
Funo    IntegEIC   Autor  Larson Zordan          Data  20/08/02 
Ĵ
Descrio  Valida a integracao com SIGAEIC com criacao de campos D3/D7
Ĵ
Sintaxe    IntegEIC()                                                 
Ĵ
Retorno	  ExpL1 = retorno da confirmacao da integracao com SIGAEIC e 
       	  a validacao da existencia de campos no SD3 e SD7.          
Ĵ
Parametros ExpC1 = Documento  (Nota Fiscal)                           
           ExpC2 = Serie da NF                                        
           ExpC3 = Fornecedor                                         
           ExpC4 = Loja                                               
Ĵ
 Uso       Gerrico                                                   
ٱ

*/
Function IntegEIC(cDoc,cSerie,cFornece,cLoja)
Local aAreaAnt := GetArea()
Local lEIC     := If(GetMv("MV_EASY")=="S",.T.,.F.)

SF1->(dbSetOrder(1))
dbSeek(xFilial("SF1")+cDOC+cSERIE+cFORNECE+cLOJA)
lEIC := If(SF1->F1_IMPORT # "S",.F.,lEIC)

RestArea(aAreaAnt)
Return(lEIC)


/*

Ŀ
Funo    A250PotMax Autor Rodrigo de A Sartorio   Data  15/01/03 
Ĵ
Descrio  Programa para calcular a qtd na potencia maxima (100%)     
Ĵ
Sintaxe    A250PotMax(ExpC1,ExpN1,ExpN2,ExpN3)                        
Ĵ
Parametros ExpC1 = Produto                                            
           ExpN1 = Potencia do Empenho                                
           ExpN2 = Quantidade do Empenho                              
           ExpN3 = Decimais para arredondamento                       
Ĵ
 Uso       MATA250                                                    
ٱ


*/
Function A250PotMax(cProduto,nPotencia,nQuant,nDecimais)
Local nRet:=nQuant
DEFAULT nDecimais:=0
If PotencLote(cProduto) .And. nPotencia > 0
	nRet:= QtdComp(nQuant) * (QtdComp(nPotencia)/QtdComp(100))
	If nDecimais > 0
		nRet:=Round(nRet,nDecimais)
	EndIf
EndIf
Return nRet

/*

Ŀ
Funo    A250PotOrg Autor Rodrigo de A Sartorio   Data  15/01/03 
Ĵ
Descrio  Programa para calcular a qtd na potencia original          
Ĵ
Sintaxe    A250PotOrg(ExpC1,ExpN1,ExpN2,ExpN3)                        
Ĵ
Parametros ExpC1 = Produto                                            
           ExpN1 = Potencia Original do Empenho                       
           ExpN2 = Quantidade do Empenho                              
           ExpN3 = Decimais para arredondamento                       
Ĵ
 Uso       MATA250                                                    
ٱ


*/
Function A250PotOrg(cProduto,nPotencia,nQuant,nDecimais)
Local nRet:=nQuant
DEFAULT nDecimais:=0
If PotencLote(cProduto) .And. nPotencia > 0
	nRet:= QtdComp(nQuant) * (QtdComp(100)/QtdComp(nPotencia))
	If nDecimais > 0
		nRet:=Round(nRet,nDecimais)
	EndIf
EndIf
Return nRet

/*


Ŀ
Funo    MatBuyBN   Autor  Rodrigo de A. Sartorio Data  19/06/03 
Ĵ
Descrio Identifica se produtos tipo BN devem ou nao serem comprados 
Ĵ
Sintaxe    lRet:=MatBuyBN()       	                                  
           lRet:= Retorna se produtos do tipo BN devem ser comprados  
           (.t.) ou nao (.f.)                                         
Ĵ
 Uso       GENERICO       	                                          
ٱ


*/
Function MatBuyBN()
Local lRet:= SuperGetMV("MV_COMPRBN",NIL,.F.)
RETURN lRet

/*


Ŀ
Funo    MatLenDif Autor  Alex Egydio             Data 27.08.2003
Ĵ
Descrio  Verifica se ha divergencia entre campos                    
Ĵ
Parametros ExpA1 = Vetor com os campos para analise                   
                                                                      
                   Formato do vetor ExpA1                             
                   ExpA1[1,1] = Alias ou Nome do arquivo              
                   ExpA1[1,2] = Campo                                 
                   ExpA1[1,3] = .T. = Indica que o campo servira como 
                                      referencia                      
                                .F. = Verifica se as caracteristicas  
                                      deste campo divergem do campo   
                                      indicado como referencia        
           ExpL1 = .T. = Apresenta lista de cpos divergentes          
ٱ
*/
Function MatLenDif(aCampo,lHelp)
Local aTamanho	:= {}
Local aMsgErr	:= {}
Local cTipo		:= ''
Local lRet		:= .F.
Local nCntFor	:= 0
Local nInteiro	:= 0
Local nDecimal	:= 0

DEFAULT lHelp	:= .T.

For nCntFor := 1 To Len(aCampo)
	aTamanho := TamSX3(aCampo[nCntFor,2])
	//-- Obtem caracteristicas do campo indicado como referencia
	If	aCampo[nCntFor,3]
		nInteiro := aTamanho[1]
		nDecimal := aTamanho[2]
		cTipo		:= aTamanho[3]
		AAdd(aMsgErr,{'( '+aCampo[nCntFor,1]+' )',aCampo[nCntFor,2],cTipo,nInteiro,nDecimal})
		//-- Verifica se ha divergencia Inteiro, decimal e tipo
	Else
		If nInteiro#aTamanho[1] .Or. nDecimal#aTamanho[2] .Or. cTipo#aTamanho[3]
			lRet := .T.
			AAdd(aMsgErr,{'  '+aCampo[nCntFor,1]+'  ',aCampo[nCntFor,2],aTamanho[3],aTamanho[1],aTamanho[2]})
		EndIf
	EndIf
Next
//-- Apresenta lista com os campos divergentes
If lRet .And. lHelp
	TmsF3Array( {'Arquivo','Campo','Tipo','Inteiro','Decimal'}, aMsgErr, 'Campos com divergencia', .F. )
EndIf

Return(lRet)

/*


Ŀ
Funo    TmsF3Array Autor  Alex Egydio            Data 08.08.2002
Ĵ
Descrio  Consulta F3 baseada em vetor.                              
Ĵ
Parametros ExpA1 - Vetor contendo a descricao do cabecalho            
           ExpA2 - Item                                               
           ExpC1 - Titulo da consulta                                 
           ExpL1 - .F. Nao apresenta o botao de cancelamento          
           ExpA3 - Array contendo botao adicional:                    
                   [1,1] - (N) Tipo do Botao                          
                   [1,2] - {B} Bloco com a acao do botao*             
                                                                      
           * Recebe como parametro o N.o da Linha Posicionada         
           ExpL1 - Utiliza Tela de pesquisa                           
                   (Deve ser passado o titulo dos campos p/pesquisa)  
Ĵ
Retorno    Numero do elemento do vetor selecionado.                   
ٱ


*/
Function TmsF3Array( aHeadTms, aItemTms, cTitulo, lCancel, aNewButton, aCabec, aDadosProt )
Local nTmsItem	 := 0
Local nTmsOpcA	 := 0
Local oTmsBtn1
Local oTmsBtn2
Local oTmsDlg
Local oTmsBrw
Local oNewBtn
Local bActionBtn

//-- Tratamento da Janela
Local aCoordWnd  := {}
Local aCoordObj  := {}
Local aCoordPE   := {}
Local lTMSWndF3  := ExistBlock('TMSWndF3')
Local nHRes      := oMainWnd:nClientWidth //--Resolucao horizontal do monitor
Local nAjuste    := 0
Local bActionPsq := {}

DEFAULT lCancel    := .T.
DEFAULT aNewButton := {}
DEFAULT aCabec     := {}
DEFAULT aDadosProt	:= {}
If ValType(aCabec) == "A"
	If Len(aCabec) > 0
		bActionPsq := {||TMSPesqBrw(aItemTms,aCabec,oTmsBrw,.F.)}
	EndIf
EndIf

//Ŀ
// Trata as Coordenadas da tela/objetos de acordo com a resolucao de tela 
//
If ( Upper(Alltrim(GetTheme())) == "FLAT") .Or. SetMdiChild()
	nAjuste := 0.90
Else
	//Ŀ
	//TEMA: OCEAN e CLASSIC
	//
	If nHRes == 640	// Resolucao 640x480 (soh o Ocean e o Classic aceitam 640)
		nAjuste := 0.8
	ElseIf (nHRes == 798) .Or. (nHRes == 800) // Resolucao 800x600
		nAjuste := 1
	Else // Resolucao 1024x768 e acima
		nAjuste := 1.1
	EndIf
EndIf

//-- Coordenadas da Janela
aCoordWnd := {	0 ,;
				0,;
				Int(350 * nAjuste),;
				Int(850 * nAjuste) }

If ValType(aCabec) == "A"
	If Len(aCabec) > 0
		//-- Coordenadas dos objetos da tela
		aCoordObj := {	{Int(5   * nAjuste),; 	//
							 Int(5   * nAjuste),;	//--  Coordenadas do TWBrowse
							 Int(370 * nAjuste),;	//
							 Int(145 * nAjuste)},;	//
							{Int(5  * nAjuste), Int(380 * nAjuste) },;	//-- Coordenadas do Botao "OK"
							{Int(20 * nAjuste), Int(380 * nAjuste)},;	   //-- Coordenadas do Botao "CANCELAR"
							{Int(35 * nAjuste), Int(380 * nAjuste)},;    //-- Coordenadas do Botao adicional, passado pelo parametro aNewButton
							{Int(50 * nAjuste), Int(380 * nAjuste)}}	   //-- Coordenadas do Botao Pesquisar
	Else
		//-- Coordenadas dos objetos da tela
		aCoordObj := {	{Int(5   * nAjuste),; 	//
						 Int(5   * nAjuste),;	//--  Coordenadas do TWBrowse
						 Int(370 * nAjuste),;	//
						 Int(145 * nAjuste)},;	//
						{Int(5  * nAjuste), Int(380 * nAjuste) },;	//-- Coordenadas do Botao "OK"
						{Int(20 * nAjuste), Int(380 * nAjuste)},;	//-- Coordenadas do Botao "CANCELAR"
						{Int(35 * nAjuste), Int(380 * nAjuste)} }	//-- Coordenadas do Botao adicional, passado pelo parametro aNewButton
	EndIf
EndIf

//Ŀ
// PONTO DE ENTRADA PARA MUDAR AS COORDENADAS DA JANELA E DOS OBJETOS 
//
If lTMSWndF3
	aCoordPE := Execblock( "TMSWndF3", .f., .f.,{aCoordWnd, aCoordObj} )
	If ValType( aCoordPE ) == 'A' .And. Len(aCoordPE) == 2 .And. Len(aCoordPE[1]) == 4 .And. Len(aCoordPE[2]) == 4
		aCoordWnd := aCoordPE[1]
		aCoordObj := aCoordPE[2]
	EndIf
EndIf


DEFINE MSDIALOG oTmsDlg TITLE STR0138 + cTitulo From aCoordWnd[1],aCoordWnd[2] To aCoordWnd[3],aCoordWnd[4] OF oMainWnd PIXEL
oTmsBrw := TWBrowse():New( aCoordObj[1,1], aCoordObj[1,2], aCoordObj[1,3], aCoordObj[1,4],, aHeadTms,,oTmsDlg,,,,,,,,,,,,.T.,,.T. )
oTmsBrw:SetArray( aItemTms )
If FindFunction('FWPDCanUse') .And. FWPDCanUse(.T.) .And. !Empty(aDadosProt)
	oTmsBrw:aObfuscatedCols=aDadosProt
EndIf
oTmsBrw:bLine := { || aItemTms[ oTmsBrw:nAT ] }

oTmsBrw:bLDblClick := { || ( nTmsOpcA := 1, nTmsItem := oTmsBrw:nAt, oTmsDlg:End() ) }

DEFINE SBUTTON oTmsBtn1 FROM  aCoordObj[2,1], aCoordObj[2,2] PIXEL TYPE  1 ACTION (nTmsOpcA := 1,nTmsItem := oTmsBrw:nAt,oTmsDlg:End()) ENABLE OF oTmsDlg

If	lCancel
	DEFINE SBUTTON oTmsBtn2 FROM aCoordObj[3,1], aCoordObj[3,2] PIXEL TYPE  2 ACTION (nTmsOpcA := 0,oTmsDlg:End()) ENABLE OF oTmsDlg
EndIf

If Len(aNewButton) > 0
	bActionBtn:= aNewButton[1,2]

	DEFINE SBUTTON oNewBtn;
	FROM aCoordObj[4,1], aCoordObj[4,2] PIXEL;
	TYPE aNewButton[1,1];
	ACTION Eval(bActionBtn, oTmsBrw:nAt);
	ENABLE OF oTmsDlg

EndIf

If ValType(aCabec) == "A"
	If Len(aCabec) > 0
		oNewBtn := SButton():New(aCoordObj[5,1], aCoordObj[5,2], 17, bActionPsq, oTmsDlg, .T., 'Pesquisar')
	EndIf
EndIf
ACTIVATE MSDIALOG oTmsDlg Centered

Return( Iif( nTmsOpcA == 1, nTmsItem, 0 ) )

/*


Ŀ
Funo    MatQtdZero Autor Rodrigo de A Sartorio   Data 07.10.2003
Ĵ
Descrio  Zera a qtd na segunda unidade de medida                    
Ĵ
Parametros ExpL1 - Variavel logica indicando se atualiza qtd atual    
           ExpL2 - Variavel logica indicando se atualiza qtd final    
           ExpL3 - Variavel logica indicando se atualiza qtd final    
Ĵ
Retorno    Numero do elemento do vetor selecionado.                   
ٱ

*/
Function MatQtdZero(lQAtu,lQFim,lTravado)
Local lQtdZero2:=EstGetMV("MV_ZERA2UM",NIL,.F.)
Local cAlias:=Alias()
DEFAULT lQatu:=.T.
DEFAULT lQFim:=.F.
DEFAULT lTravado:=.F.
// Verifica se deve zerar qtd na segunda unidade de medida qdo zerar na primeira
If lQtdZero2
	// Verifica o alias corrente
	If cAlias <> "SB2"
		dbSelectArea("SB2")
	EndIf
	// Trava o registro
	If !lTravado
		Reclock("SB2",.F.)
	EndIf
	// Zera a qtd na segunda unidade de medida
	If lQatu .And. QtdComp(SB2->B2_QATU) == QtdComp(0)
		Replace B2_QTSEGUM With 0
	EndIf
	If lQFim .And. QtdComp(SB2->B2_QFIM) == QtdComp(0)
		Replace B2_QFIM2 With 0
	EndIf
	// Destrava o registro
	If !lTravado
		MsUnlock()
	EndIf
	// Restaura o alias corrente
	If cAlias <> "SB2"
		dbSelectArea(cAlias)
	EndIf
EndIf
RETURN

/*


Ŀ
Funo     ExplEstr  Autor  Eveli Morasco          Data  20/08/92 
Ĵ
Descrio  Calcula a quantidade usada de um componente da estrutura   
Ĵ
Sintaxe    ExpN1 := ExplEstr(ExpN2,ExpD1,ExpC1,ExpC2)                 
Ĵ
Parametros ExpN1 = Quantidade utilizada pelo componente               
           ExpD1 = Data para validacao do componente na estrutura     
           ExpC1 = String contendo os opcionais utilizados            
           ExpC2 = Revisao da estrutura utilizada                     
           ExpN2 = Variavel com valor numerico que justifica o motivo 
                   pelo qual a quantidade esta zerada.                
                   1 - Componente fora das datas inicio / fim         
                   2 - Componente fora dos grupos de opcionais        
                   3 - Componente fora das revisoes                   
           ExpL1 = Indica se processa preestrutura                    
           ExpL2 = Indica se processa o tipo de decimais da OP        
           ExpC3 = Alias da tabela SG1                                
           ExpC4 = Alias da tabela SB1                                
           ExpL3 = Indica de foi chamado do MRP                       
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function ExplEstr(nQuant,dDataStru,cOpcionais,cRevisao,nMotivo,lPreEstr,lTipoDec,cAliasSG1,cAliasSB1,lMRP,cProOpc,lVldData,lVlOpc,lProBlq,lVldRev)
LOCAL nQuantItem:=0,cUnidMod,nG1Quant:=0,nQBase:=0,nDecimal:=0,nBack:=0
LOCAL cAlias:=Alias(),nRecno:=Recno(),nOrder:=IndexOrd()
LOCAL lOk:=.T.
LOCAL nDecOrig:=Set(3,8)
LOCAL cCodigo
LOCAL cComponente
LOCAL cOpcArq
LOCAL dDataIni
LOCAL dDataFim
LOCAL nQtdCampo
LOCAL nQtdPerda
LOCAL cFixVar
LOCAL cTRT
LOCAL aVldEstr := {.T.,.T.,.T.} //na ordem, indica se valida datas, grupo de opc. e revisoes na estrutura
LOCAL aUsrVlEstr := {}
LOCAL aOpc := Nil
LOCAL nI        := 0
LOCAL nAltPer   := 0
LOCAL nPos      := 0
LOCAL lAchouB1  := .F.
Local lTemQBP   := TemQBP()
Local lUsaMOpc	:= If(SuperGetMv('MV_REPGOPC',.F.,"N") == "S",.T.,.F.)
Local lProdMod  := .T.
Local lPCPREVATU	:= FindFunction('PCPREVATU')
Local cRevAtu		:= ''

STATIC lUSRVLESTR
STATIC lMQTBASEST
STATIC lMQTDESTR
STATIC nDecSGG
STATIC nDecSG1
STATIC lEMPREVVAZ := Nil
STATIC oRevisao	  := NIL

DEFAULT nMotivo	    := 0
DEFAULT lPreEstr	:= .F.
DEFAULT lTipoDec	:= .T.
DEFAULT cAliasSG1	:= "SG1"
DEFAULT cAliasSB1	:= "SB1"
DEFAULT lMRP		:= .F.
DEFAULT cProOpc     := ""
DEFAULT lVldData := .T.
DEFAULT lVlOpc   := .T.
DEFAULT lProBlq  := .T. // Considera se o Produto est bloqueado.
DEFAULT lVldRev  := .T.

cCodigo    :=If(lPreEstr,SGG->GG_COD,(cAliasSG1)->G1_COD)
cComponente:=If(lPreEstr,SGG->GG_COMP,(cAliasSG1)->G1_COMP)
cOpcArq    :=If(lPreEstr,SGG->GG_GROPC+SGG->GG_OPC,(cAliasSG1)->G1_GROPC+(cAliasSG1)->G1_OPC)
cOpcArq    :=If(lUsaMOpc .And. !Empty(cProOpc) .And. !Empty(cOpcArq), cProOpc, cOpcArq)
nG1Quant   :=If(lPreEstr,SGG->GG_QUANT,(cAliasSG1)->G1_QUANT)
nQtdCampo  :=If(lPreEstr,SGG->GG_QUANT,(cAliasSG1)->G1_QUANT)
nQtdPerda  :=If(lPreEstr,SGG->GG_PERDA,(cAliasSG1)->G1_PERDA)
cFixVar    :=If(lPreEstr,SGG->GG_FIXVAR,(cAliasSG1)->G1_FIXVAR)
cTRT       :=If(lPreEstr,SGG->GG_TRT,(cAliasSG1)->G1_TRT)
lUSRVLESTR	 := IIF(lUSRVLESTR == Nil,ExistBlock('USRVLESTR'),lUSRVLESTR)
lMQTBASEST	 := IIF(lMQTBASEST == Nil,ExistBlock('MQTBASEST'),lMQTBASEST)
lMQTDESTR	 := IIF(lMQTDESTR  == Nil,ExistBlock('MQTDESTR'),lMQTDESTR)
nDecSGG	 := IIF(nDecSGG    == Nil,TamSX3("GG_QUANT")[2],nDecSGG)
nDecSG1	 := IIF(nDecSG1    == Nil,TamSX3("G1_QUANT")[2],nDecSG1)

lEMPREVVAZ := IIF(lEMPREVVAZ == Nil, ExistBlock("EMPREVVAZ") .And. ExecBlock('EMPREVVAZ',.F.,.F.), lEMPREVVAZ)

If lMRP
	dDataIni   :=If(lPreEstr,SGG->GG_INI,Stod((cAliasSG1)->G1_INI))
	dDataFim   :=If(lPreEstr,SGG->GG_FIM,Stod((cAliasSG1)->G1_FIM))
Else
	dDataIni   :=If(lPreEstr,SGG->GG_INI,(cAliasSG1)->G1_INI)
	dDataFim   :=If(lPreEstr,SGG->GG_FIM,(cAliasSG1)->G1_FIM)
EndIf

If lPreEstr
	nDecimal:=nDecSGG
Else
	nDecimal:=nDecSG1
EndIf

//Verifica os opcionais cadastrados na Estrutura
cOpcionais:= If((cOpcionais == NIL),"",cOpcionais)

If !Empty(cOpcionais)
	nPos := aScan(aOpcCache,{|x| x[1] == cOpcionais})
	If nPos > 0
		aOpc := aOpcCache[nPos][2]
	Else
		aOpc := Str2Array(cOpcionais,.F.)
		aAdd(aOpcCache,{cOpcionais,aOpc})
	EndIf

	If aOpc != Nil
		cOpcArq := cProOpc
	EndIf
EndIf

//Verifica a Revisao Atual do Componente
cRevisao:= If((cRevisao == NIL),"",cRevisao)

//Verifica a data de validade
dDataStru := If((dDataStru == NIL),dDataBase,dDataStru)

If lUSRVLESTR
	//Posiciona na SG1 para PE
	If lMRP
		dbSelectArea("SG1")
		MsSeek(xFilial("SG1")+cCodigo)
	EndIf

	aUsrVlEstr := ExecBlock("USRVLESTR",.F.,.F.,{cCodigo,cComponente,cTRT})

	For nI := 1 To 3
		If ValType(aUsrVlEstr[nI]) == "L"
			aVldEstr[nI] := aUsrVlEstr[nI]
		EndIf
	Next nI
EndIf

If lMRP
	lAchouB1 := .T.
Else
	dbSelectArea("SB1")
	dbSetOrder(1)
	lAchouB1 := MsSeek(xFilial("SB1")+cCodigo)
EndIf

If lAchouB1
	If cOpcionais == Nil .And. !Empty(RetFldProd((cAliasSB1)->B1_COD,"B1_OPC",cAliasSB1))
		cOpcionais:=RetFldProd((cAliasSB1)->B1_COD,"B1_OPC",cAliasSB1)
	EndIf
	If oRevisao == NIL
		oRevisao := JsonObject():New()
	EndIf
	If oRevisao[(cAliasSB1)->B1_COD] == NIL
		//Alterao para considerar REV por filial
		cRevAtu :=  IIF(lPCPREVATU , PCPREVATU((cAliasSB1)->B1_COD), (cAliasSB1)->B1_REVATU)
		oRevisao[(cAliasSB1)->B1_COD] := cRevAtu
	Else
		cRevAtu := oRevisao[(cAliasSB1)->B1_COD]
	EndIf
	If Empty(cRevisao) .And. !Empty(cRevAtu)
		cRevisao:= cRevAtu
	EndIf
	If aVldEstr[1] .And. !(dDataStru >= dDataIni .And. dDataStru <= dDataFim) .And. lVldData
		nMotivo:=1 // Componente fora das datas inicio / fim
		lOk:=.F.
	EndIf
	If aVldEstr[2] .And. lOk .And. cOpcionais != Nil .And. !Empty(cOpcArq) .And. !(cOpcArq $ cOpcionais) .And. lVlOpc
		nMotivo:=2  // Componente fora dos grupos de opcionais
		lOk:=.F.
	EndIf

	If Empty(cRevisao)
		cRevisao := Space(Len((cAliasSG1)->G1_REVINI))
	EndIf

	If aVldEstr[3] .And. lOk .And. !lPreEstr .And. ((cAliasSG1)->G1_REVINI > cRevisao .Or. (cAliasSG1)->G1_REVFIM < cRevisao) .And. lVldRev
		If ! (lEMPREVVAZ .And. Empty(cRevisao)) //PE para empenhar o componente quando a reviso est em branco.
			nMotivo:=3	// Componente fora das revisoes
			lOk:=.F.
		EndIf
	EndIf
EndIf

If !lMRP .And. cAlias <> ''
	dbSelectArea(cAlias)
	dbSetOrder(nOrder)
	MsGoto(nRecno)
EndIf

If lOk
	cUnidMod := SuperGetMv("MV_UNIDMOD")

	SB1->(MsSeek(xFilial("SB1")+cCodigo))
	nQBase:=RetFldProd(cCodigo,If(lPreEstr.And.lTemQBP,"B1_QBP","B1_QB"))

	//Ŀ
	// Ponto de Entrada p/ alterar qtde. base da estrutura    
	//
	If lMQTBASEST
		nAltPer:=ExecBlock('MQTBASEST', .F., .F., {nQBase})
		IF Valtype(nAltPer) == 'N'
			nQBase := nAltPer
		EndIf
	EndIf

	If !lMRP
		IF lProBlq
			SB1->(MsSeek(xFilial("SB1")+cComponente))
			IF ((RetFldProd(SB1->B1_COD,"B1_FANTASM") != 'S') .and. (SB1->B1_MSBLQL == '1'))
				nQuantItem := 0
				lOk := .F.
			EndIf

			IF SB1->B1_MSBLQL == '1'
				nQuantItem := 0
				lOk := .F.
			END IF

		EndIf
	EndIf

	If lOk
		lProdMod := IsProdMod(cComponente)

		If lProdMod
			cTpHr := SuperGetMv("MV_TPHR")
			If cTpHr == "N"
				nG1Quant := Int(nG1Quant)
				nG1Quant += ((nQtdCampo-nG1Quant)/60)*100
			EndIf
		EndIf

		If cFixVar $ " V"
			If lProdMod .And. cUnidMOD != "H"
				nQuantItem := ((nQuant / nG1Quant) / (100 - nQtdPerda)) * 100
			Else
				nQuantItem := ((nQuant * nG1Quant) / (100 - nQtdPerda)) * 100
			EndIf
			nQuantItem := nQuantItem / Iif(nQBase <= 0,1,nQBase)
		Else
			If lProdMod .And. cUnidMOD != "H"
				nQuantItem := (nG1Quant / (100 - nQtdPerda)) * 100
			Else
				nQuantItem := (nG1Quant / (100 - nQtdPerda)) * 100
			EndIf
		Endif

	EndIf
	nQuantItem:=Round(nQuantItem,nDecimal)
EndIf

//Ŀ
// Ponto de Entrada p/ alterar qtde. do componente        
//
If lMQTDESTR
	nAltPer:=ExecBlock('MQTDESTR', .F., .F., {nQuant,nQuantItem,lOk,nMotivo,cOpcArq,cOpcionais})
	If Valtype (nAltPer) == 'N'
		nQuantItem:= nAltPer
	EndIf
EndIf

//vai ser calculado no proprio MATA712
If !lMRP
	Do Case
		Case (SB1->B1_TIPODEC == "A" .And. lTipoDec)
			nBack := Round( nQuantItem,0 )
		Case (SB1->B1_TIPODEC == "I" .And. lTipoDec)
			nBack := Int(nQuantItem)+If(((nQuantItem-Int(nQuantItem)) > 0),1,0)
		Case (SB1->B1_TIPODEC == "T" .And. lTipoDec)
			nBack := Int( nQuantItem )
		OtherWise
			nBack := nQuantItem
	EndCase
Else
	nBack := nQuantItem
EndIf

Set(3,nDecOrig)

Return( nBack )

/*


Ŀ
Funcao    TemQBP     Autor Norberto M de Melo       Data   08/05/01 
Ĵ
Descriao  Esta funo tem como objetivo validar a existncia da coluna 
           SB1->B1_QBP                                                  
Ĵ
Parametros                                                              
Ĵ
Retorno   .T. ou .F.                                                    
Ĵ
Uso        SIGACUSA.PRX                                                 
ٱ


*/
STATIC Function TemQBP( )

Local lRet	:= .F.
Local aArea	:= GetArea()

dbSelectArea("SB1")
lRet := FieldPos( "B1_QBP" ) > 0

RestArea(aArea)

Return lRet

/*

Ŀ
FUNO     CalcPrazo   AUTOR  ARY MEDEIROS         DATA  25/08/92 
Ĵ
DESCRIO  DEVOLVE O PRAZO DE ENTREGA DE UM PRODUTO                   
Ĵ
SINTAXE    ExpN1 := CalcPrazo(Expc2)                                  
Ĵ
PARAMETROS ExpC1 := Codigo do produto cujo prazo sera calculado.	  
           ExpN2 := Quantidade a comprar/produzir.					  
           ExpC3 := Codigo do fornecedor de compra.					  
           ExpC4 := Loja do fornecedor de compra.					  
           ExpL5 := Indica se calcula pela data inicio.				  
           ExpD6 := Data de referencia para calculo do prazo.		  
Ĵ
 USO       Generico                                                   
ٱ


*/
Function CalcPrazo(cProduto,nQuant,cFornece,cLoja,lIniFim,dData,cRot)
Local nPrazo   := 0

//Funo migrada para o PCPXFUNA
nPrazo := ClcPrzPcp(@cProduto,@nQuant,@cFornece,@cLoja,@lIniFim,@dData,@cRot)

Return nPrazo

/*

Ŀ
Funo     ProxNum   Autor  Fernando Joly Siquini  Data  20/08/99 
Ĵ
Descrio  Devolve o proximo numero sequencial de movimentacoes       
Ĵ
Sintaxe    ProxNum(lSave)                                             
Ĵ
Parametro  lSave - Indica se grava SX6 ou nao                         
ٱ
Uso        Generico                                                   


*/
Function ProxNum(lSave,lShowFinal)
Local lFalhou     as Logical
Local cTexto      as character //"O parametro MV_DOCSEQ nao foi conseguiu ser travado. O numero sequencial do movimento sera "
Local nTentativas as numeric
Local aArea       as array
Local nTam        as numeric
Local cNumSeq     as character

If __RpoRelease == NIL
	__RpoRelease := GetRPORelease()
EndIf

If __RpoRelease >= "12.1.2210"
	cNumSeq := _ProxNum(lSave,lShowFinal)
	Return cNumSeq
EndIf

cTexto      := STR0125 //"O parametro MV_DOCSEQ nao foi conseguiu ser travado. O numero sequencial do movimento sera "
nTentativas := 0
aArea       := GetArea()
nTam        := TamSx3("D3_NUMSEQ")[1]
cNumSeq     := Replicate("0",nTam)

If ValType(lShowFinal) != "L"
	lShowFinal := .T.
Endif

IF ValType(lSave) != "L"
	lSave := .t.
Endif
IF lSave == .T.
	__lNoErro := Nil
Endif
If __lD1D2D3 == Nil
	__lD1D2D3 := .F.
EndIf

lFalhou := lSave

If lSave .And. !__lD1D2D3 //-- Se for gravar o NUMSEQ os 3 arquivos DEVEM ESTAR ABERTOS!
	If Select('SD1') <= 0
		dbSelectArea('SD1')
	EndIf
	If Select('SD2') <= 0
		dbSelectArea('SD2')
	EndIf
	If Select('SD3') <= 0
		dbSelectArea('SD3')
	EndIf
	__lD1D2D3 := (Select('SD1')>0) .And. (Select('SD2')>0) .And. (Select('SD3')>0)
	RestArea(aArea)
Endif

IF lxProxNum == Nil
	lxProxNum := ExistBlock("XPROXNUM")
Endif
IF lxProxNum
	cNumSeq := ExecBlock("xProxNum",.f.,.f.)
	If ValType(cNumSeq) == "C"
		Return cNumSeq
	EndIf
Endif

IF __lNoErro == Nil .and. lSave
	CheckSeque()
Endif

IF lSave .And. (!__lNoErro .Or. !__lD1D2D3)
	If IsInCallStack("GFEA065") .Or. IsInCallStack("GFEA066")
		Return Nil
	Else
		If lShowFinal
			FINAL(STR0126) //AJUSTAR PARAMETRO MV_DOCSEQ
		Else
			Return Nil //No conseguiu pegar o MV_DOCSEQ
		EndIf
	EndIf
Endif

IF lFProxNum == Nil
	lFProxNum := ExistBlock("FPROXNUM")
Endif

//Ŀ
// Tenta travar 1000 vezes os registros                         
//
While nTentativas < 1000 .And. lFalhou
	lFalhou:=!(Reclock("SX6",.F.))
	nTentativas++
End

//Ŀ
// Verifica se conseguiu travar os registros.                   
//
dbSelectArea("SX6")
If lFalhou .and. lSave
	If IsTelNet()
		VTAlert(cTexto+cNumSeq, STR0130) //"Prob. MV_DOCSEQ"
	Else
		MsgAlert(cTexto+cNumSeq)
	EndIf
ElseIF lSave
	cNumSeq := Soma1(Subs(GetMV("MV_DOCSEQ"),1,nTam))
	PutMV("MV_DOCSEQ",cNumSeq)
	IF lFProxNum
		ExecBlock("FPROXNUM",.f.,.f.,cNumSeq)
	Endif
	MsUnlock()
Else
	cNumSeq := Soma1(Substr(GETMV("MV_DOCSEQ"),1,nTam))
	MsUnlock()
Endif
RestArea(aArea)
Return cNumSeq


/*

Ŀ
Funo     _ProxNum   Autor  Fernando Joly Siquini  Data  20/08/99 
Ĵ
Descrio  Devolve o proximo numero sequencial de movimentacoes       
Ĵ
Sintaxe    _ProxNum(lSave)                                             
Ĵ
Parametro  lSave - Indica se grava SX6 ou nao                         
ٱ
Uso        Generico                                                   


*/
Static Function _ProxNum(lSave,lShowFinal)
Local cAliasNum      := Alias()
Local lFalhou
Local cTexto         := STR0125 //"O parametro MV_DOCSEQ nao foi conseguiu ser travado. O numero sequencial do movimento sera "
Local nTentativas    := 0
Local nTam           := TamSx3("D3_NUMSEQ")[1]
Local cNumSeq        := Replicate("0",nTam)
Local cLockKey       := 'MV_DOCSEQ_' +cEmpAnt //+cFilAnt
Local nTotTentativas := 120000 //- numero de tentativa para pegar o SX6
Local nWaitTime      := 275 //- tempo em milesegundos

//- valida se  diferente as empresas
If !( __cEmpFilOld == cEmpAnt+cFilAnt )
	__lChkNum    := .F.//- RESETA A CHEQUESEQ
	__cEmpFilOld := cEmpAnt+cFilAnt
EndIF

IF lxProxNum == Nil
	lxProxNum := ExistBlock("XPROXNUM")
Endif
IF lxProxNum
	cNumSeq := ExecBlock("xProxNum",.f.,.f.)
	If ValType(cNumSeq) == "C"
		Return cNumSeq
	EndIf
Endif

If ValType(lShowFinal) != "L"
	lShowFinal := .T.
Endif

IF ValType(lSave) != "L"
	lSave := .t.
Endif

lFalhou := .T.

IF lSave
	__lNoErro := nil

	//- garante que no haja outro processo
	While nTentativas <= nTotTentativas
		If LockByName(cLockKey,.F.,.F.,.F.)
			lFalhou := .F.
			Exit
		EndIf
		nTentativas++
		Sleep(nWaitTime)//- segura 1 segundo
	EndDo

	//- indica que no foi possivel exclusividade da chave
	If lFalhou
		If IsTelNet()
			VTAlert(cTexto+cNumSeq, STR0130) //"Prob. MV_DOCSEQ"
		Else
			MsgAlert(cTexto+cNumSeq)
		EndIf
		If !Empty(cAliasNum)
			DbSelectArea(cAliasNum)
		EndIf

		Return nil
	EndIf

	//- VALIDA apenas uma vez na chamada
	IF !__lChkNum
		_CheckSeque()
		__lChkNum := .T.
	Endif

	cNumSeq := Soma1(Substr(GETMV("MV_DOCSEQ"),1,nTam))

	//- efetua a gravao do valor da chave
	PutMV("MV_DOCSEQ",cNumSeq)

	IF lFProxNum == Nil
		lFProxNum := ExistBlock("FPROXNUM")
	Endif
	IF lFProxNum
		ExecBlock("FPROXNUM",.f.,.f.,cNumSeq)
	Endif

	//- Libera a chave para uso
	UnLockByName(cLockKey,.F.,.F.,.F.)
Else
	//- pega o valor corrente, no podendo estar em CACHE
	cNumSeq := Soma1(Substr(GETMV("MV_DOCSEQ"),1,nTam))
Endif

If !Empty(cAliasNum)
	DbSelectArea(cAliasNum)
EndIf

Return cNumSeq

/*

Ŀ
Funo    CheckSeque Autor Wilson Godoy / Rodrigo  Data  19/10/00 
Ĵ
Descrio  Testa se parametro dos numeros sequenciais nao esta com    
           algum valor incorreto.                                     
Ĵ
Sintaxe    CheckSeque()                                               
Ĵ
Uso        Generico                                                   
ٱ


*/
Static __lFWInCS := Nil
Function CheckSeque()
Local cNext
Local cNum,cGreat := Space(Len(Criavar("D1_NUMSEQ")))
Local cText
Local cAlias := Alias()
Local aAreaSD1
Local aAreaSD2
Local aAreaSD3
Local lRet := .T.
Local nTam:=TamSx3("D3_NUMSEQ")[1]
Local cNumSeq:= Replicate("0",nTam)
Local lMvDocSeq 

If __lFWInCS == Nil
	__lFWInCS := FwIsInCallStack("FWCheckSeque")
EndIf
If __lFWInCS
	Ma215Check()
	__lFWInCS := Nil
EndIf

If lxProxNum == Nil
	lxProxNum := ExistBlock("XPROXNUM")
EndIf

If __lD1D2D3 == Nil
	__lD1D2D3 := .F.
EndIf

If lxProxNum
	__lNoErro := .t.
	lRet := .F.
EndIf

If lRet

	__lD1D2D3 := (Select('SD1')>0) .And. (Select('SD2')>0) .And. (Select('SD3')>0)

	If SELECT('SD1')<= 0
		DbSelectArea('SD1')
		__lD1D2D3 := Select('SD1')> 0
	EndIf

	__lD1D2D3 := __lD1D2D3 .and. Select('SD2')> 0
	If !__lD1D2D3
		DbSelectArea('SD2')
		__lD1D2D3 := Select('SD2')> 0
	EndIf

	__lD1D2D3 := __lD1D2D3 .and. Select('SD3')> 0
	If !__lD1D2D3
		DbSelectArea('SD3')
		__lD1D2D3 := Select('SD3')> 0
	EndIf

	If __lD1D2D3
		dbSelectArea("SD1")
		aAreaSD1 := GetArea()
		dbSetOrder(4)
		dbSeek(xFilial("SD1")+"zzzzzz",.T.)
		dbSkip(-1)
		If D1_FILIAL == xFilial("SD1")
			cNum := D1_NUMSEQ
		Else
			cNum := Space(Len(D1_NUMSEQ))
		EndIf
		If cNum > cGreat
			cGreat := cNum
		EndIf
		RestArea(aAreaSD1)

		dbSelectArea("SD2")
		aAreaSD2 := GetArea()
		dbSetOrder(4)
		dbSeek(xFilial("SD2")+"zzzzzz",.T.)
		dbSkip(-1)
		If D2_FILIAL == xFilial("SD2")
			cNum := D2_NUMSEQ
		Else
			cNum := Space(Len(D2_NUMSEQ))
		EndIf
		If cNum > cGreat
			cGreat := cNum
		EndIf
		RestArea(aAreaSD2)

		dbSelectArea("SD3")
		aAreaSD3 := GetArea()
		dbSetOrder(4)
		dbSeek(xFilial("SD3")+"zzzzzz",.T.)
		dbSkip(-1)
		If D3_FILIAL == xFilial("SD3")
			cNum := D3_NUMSEQ
		Else
			cNum := Space(Len(D3_NUMSEQ))
		EndIf
		If cNum > cGreat
			cGreat := cNum
		EndIf
		RestArea(aAreaSD3)

		If nModulo <> 99
			If  valtype(lMvDocSeq:= getmv('MV_DOCSEQ')) == 'L' .and. !lMVDOCSEQ 
				Final ('MV_DOCSEQ '+OemToAnsi(STR0274)+' '+cFilAnt)
			EndIf
			cNext := ProxNum(.f.)
		EndIf
		
		If cGreat >= cNext
			cText := STR0128+cGreat+"." //"Problema no conteudo do parametro MV_DOCSEQ. O valor correto deveria ser: " + cNext
			cNumSeq := Soma1(Subs(cGreat,1,nTam))
			PutMV("MV_DOCSEQ",cNumSeq)

			__lNoErro := .T.
		Else
			__lNoErro := .T.
		EndIf
	EndIf
EndIf

If !Empty(cAlias)
	dbSelectArea(cAlias)
EndIf
Return Nil

/*

Ŀ
Funo    _CheckSeque Autor Wilson Godoy / Rodrigo  Data  19/10/00 
Ĵ
Descrio  Testa se parametro dos numeros sequenciais nao esta com    
           algum valor incorreto.                                     
Ĵ
Sintaxe    _CheckSeque()                                               
Ĵ
Uso        Generico                                                   
ٱ


*/
Static Function _CheckSeque()
Local cGreat  := Space(Len(Criavar("D1_NUMSEQ")))
Local cText
Local cAlias  := Alias()
Local nTam    := TamSx3("D3_NUMSEQ")[1]
Local cNumSeq := Replicate("0",nTam)
Local cQuery   as Character
Local aBindSeq as array

Iif(lxProxNum == Nil,lxProxNum := ExistBlock("XPROXNUM"),lxProxNum)

If lxProxNum
	__lNoErro := .t.
	Return
EndIf

//- ENCONTRA O MAIS NUMSEQ ENTRE AS TABELAS
cQuery := "SELECT MAX(NUMSEQ) NUMSEQ FROM ("
//- busca o maior do SD1
cQuery += " SELECT MAX(D1_NUMSEQ) NUMSEQ FROM "
cQuery += RetSqlName("SD1")
cQuery += " WHERE D1_FILIAL = ? "
cQuery += " AND D_E_L_E_T_ = ? "
cQuery += " UNION ALL "
//- busca o maior do SD2
cQuery += " SELECT MAX(D2_NUMSEQ) NUMSEQ FROM "
cQuery += RetSqlName("SD2")
cQuery += " WHERE D2_FILIAL = ? "
cQuery += " AND D_E_L_E_T_ = ? "
cQuery += " UNION ALL "
//- busca o maior do SD3
cQuery += " SELECT MAX(D3_NUMSEQ) NUMSEQ FROM "
cQuery += RetSqlName("SD3")
cQuery += " WHERE D3_FILIAL = ? "
cQuery += " AND D_E_L_E_T_ = ? "
cQuery += ") MAIOR"
cQuery := ChangeQuery(cQuery)

aBindSeq := {}

AAdd(aBindSeq,FWxFilial('SD1'))
AAdd(aBindSeq,' ')
AAdd(aBindSeq,FWxFilial('SD2'))
AAdd(aBindSeq,' ')
AAdd(aBindSeq,FWxFilial('SD3'))
AAdd(aBindSeq,' ')

dbUseArea( .T., "TOPCONN", TcGenQry2(,,cQuery,aBindSeq), "_QPROXSEQ", .T., .T. )

If _QPROXSEQ->(!Eof())
	cGreat := _QPROXSEQ->NUMSEQ
EndIf

_QPROXSEQ->(dbCloseArea())

aSize(aBindSeq,0)
aBindSeq := nil

cNumSeq := Soma1(Substr(GETMV("MV_DOCSEQ"),1,nTam))

//- valida se o gravado nas tabelas  maior que a chave do MV_DOCSEQ
If cGreat >= cNumSeq
	cText := STR0128+cGreat+"." //"Problema no conteudo do parametro MV_DOCSEQ. O valor correto deveria ser: " + cNext
	cNumSeq := Soma1(Substr(cGreat,1,nTam))
	PutMV("MV_DOCSEQ",cNumSeq)
EndIf

__lNoErro := .T.

If !Empty(cAlias)
	dbSelectArea(cAlias)
EndIf

Return Nil

/*


ͻ
Programa  HelpAutomaAutor  Fernando J. Siquini  Data   27/01/2004 
͹
Desc.     Nao exibe o HELP quando estiver executando Rotina Automatica
͹
Uso        Modulos de Materiais                                       
ͼ

*/
Function HelpAutoma(cParam1, nParam2, cParam3)

Local lAutoma := Type('l240Auto') == 'L' .And. l240Auto .Or. ;
	Type('l241Auto') == 'L' .And. l241Auto .Or. ;
	Type('l250Auto') == 'L' .And. l250Auto .Or. ;
	Type('l140Auto') == 'L' .And. l140Auto .Or. ;
	Type('lAutoma261') == 'L' .And. lAutoma261 .Or. ;
	Type('l680Auto') == 'L' .And. l680Auto .Or. ;
	Type('l681Auto') == 'L' .And. l681Auto .or. ;
	Type('l242Auto') == 'L' .and. l242Auto

Default cParam1    := ' '
Default nParam2    := 1
Default cParam3    := ''

If !lAutoma .And. !Empty(cParam3)
	Help(cParam1, nParam2, cParam3)
EndIf

Return Nil

/*

Ŀ
Funo    MsFreeObj    Autor Marcelo Iuspa         Data  20/05/04 
Ĵ
Descrio  Destroi Dialog/Panel/ScrollBox ou o seu conteudo           
Ĵ
Parametros oObjeto        - Objeto a ser destruido/liberado           
           lFreeChildren  - Se True destroi apenas objetos internos   
Ĵ
Retorno    Nil                                                        
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function MsFreeObj(oObjeto,lFreeChildren)
Local   lRet		  := .T.
Default lFreeChildren := .F.

If lRet
	If oObjeto <> Nil
		If lFreeChildren
			oObjeto:FreeChildren()
		Else
			oObjeto:Free()
		EndIf
	EndIf
EndIf
Return

/*

Ŀ
Funo    ChkGetFix  Autor Rodrigo de A Sartorio   Data 14/08/04  
Ĵ
Descrio  Checa validacoes e obrigat de gets fixos vinculados ao SX3 
Ĵ
Parametros aCampos - Array com dados para checagem                    
           [1] Nome do Campo [2] Variavel do Get [3] Conteudo do Get  
           lChecaVld - Indica se checa validacao do campo no SX3      
           lChecaObr - Indica se checa obrigatoriedade do campo no SX3
Ĵ
 Uso       MatA241                                                    
ٱ


*/
Function ChkGetFix(aCampos,lChecaVld,lChecaObr)
Local nx:=0
Local lRet:=.T.
Local aArea:=GetArea()

DEFAULT aCampos:={}
DEFAULT lChecaVld:=.T.
DEFAULT lChecaObr:=.T.

// Valida o conteudo dos gets
// Estrutura do array
// [1] Campo
// [2] Variavel
// [3] Conteudo
For nx:=1 to Len(aCampos)
	// Checa validacao do campo
	If lChecaVld .And. !CheckSX3(aCampos[nx,1],aCampos[nx,3])
		lRet:=.F.
	EndIf
	// Checa se campo eh obrigatorio
	If lRet .And. lChecaObr .And. (X3Obrigat(aCampos[nx,1]) .And. Empty(aCampos[nx,3]))
		HELP("  ",1,"OBRIGAT",,RetTitle(aCampos[nx,1])+Space(30),3,0)
		lRet := .F.
	EndIf
	// Abandona laco
	If !lRet
		Exit
	EndIf
Next nx
RestArea(aArea)
RETURN lRet

/*


ͻ
Funcao    ChkSD5ProcAutor  Microsiga            Data   02/04/05   
͹
Desc.      Verifica se o registro atual do SD5 eh referente a uma     
           Requisicao para Apropriacao Indireta (RE3)                 
           !!! ATENCAO !!! DEVE ESTAR POSICIONADO NO REGISTRO DO SD5! 
͹
Uso        AP                                                         
ͼ

*/
Function ChkSD5Proc()

Local aAreaAnt   := {}
Local aAreaSD3   := {}
Local cSeekSD3   := ''
Local cLocProc   := GetMvNNR('MV_LOCPROC','99')
Local lRet       := .F.

If SD5->D5_LOCAL == cLocProc
	aAreaAnt   := GetArea()
	aAreaSD3   := SD3->(GetArea())
	dbSelectArea('SD3')
	dbSetOrder(4) //-- D3_FILIAL+D3_NUMSEQ+D3_CHAVE+D3_COD
	If MsSeek(cSeekSD3:=xFilial('SD3')+SD5->D5_NUMSEQ, .F.)
		Do While !Eof() .And. cSeekSD3 == D3_FILIAL+D3_NUMSEQ
			If Empty(D3_ESTORNO) .And. (D3_LOCAL==cLocProc) .And. (D3_COD==SD5->D5_PRODUTO) .And. (SubStr(D3_CF, 2, 2)=='E3')
				lRet := .T.
				Exit
			EndIf
			dbSkip()
		EndDo
	EndIf
	RestArea(aAreaSD3)
	RestArea(aAreaAnt)
EndIf

Return lRet

/*/{Protheus.doc} IsProdMod
	Identifica se produto eh calculado como MOD.
	Caso haja alteracao deve ser revisado a A330ISMOD()

	@type  Function
   @author Rodrigo de Almeida Sartorio
   @since 20/03/06
   @version 1.0
   @param cCod, caracter, Codigo do produto a ser pesquisado
	@param lRecalc, logical, obsoleto
   @return lRet, Logical, Verdadeiro se o produto  de mo de obra
   @example
   (examples)
   @see (links_or_references)
/*/
Function IsProdMOD(cCod,lRecalc)
Local lRet     :=.F.
Local _cAlias  := Alias()
Local cKeySeek := cEmpAnt+cFilAnt+cCod
Default lRecalc:=.F.

If Substr(cCod,1,3) == "MOD"
	lRet:=.T.
Else
	If __oProdMOD == nil
		__oProdMOD := JsonObject():New()
	EndIf
	If (lRet := __oProdMOD[cKeySeek]) == nil
		if __lSeekMOD == nil .or. __cEmpOld <> cEmpAnt	.or. __cFilOld <> cFilAnt
			__cEmpOld  := cEmpAnt //- guarda a empresa
			__cFilOld  := cFilAnt //- guarda a filial
			__cQryMod  := nil     //- Reseta a query
			__lSeekMOD := EstGetMV("MV_PRODMOD",.F.,.T.)
		Endif

		If __lSeekMOD
			If __cQryMod == nil
				__cQryMod := "SELECT COUNT(1) TOTMOD FROM "
				__cQryMod += RetSqlName("SB1")
				__cQryMod += " WHERE B1_FILIAL = ?"
				__cQryMod += " AND B1_COD = ?"
				__cQryMod += " AND B1_CCCUSTO <> ?"
				__cQryMod += " AND D_E_L_E_T_ = ?"
				__cQryMod := ChangeQuery(__cQryMod)
			EndIf
			DbUseArea(.T., "TOPCONN", TcGenQry2(Nil, Nil, __cQryMod, {FWxFilial('SB1'),cCod,Space(Len(SB1->B1_CCCUSTO)),Space(1)}), 'QISMOD', .T., .T.)

			lRet := QISMOD->TOTMOD > 0

			__oProdMOD[cKeySeek] := lRet

			QISMOD->(dbCloseArea())

		EndIf
	EndIf
EndIf
If !Empty(_cAlias)
	DbSelectArea(_cAlias)
EndIf
Return lRet

/*

Ŀ
Funo	 APrModRec      Autor Rodrigo de A Sartorio Data  21/03/06 
Ĵ
Descrio  Retorna codigo do produto a ser pesquisado no cadastro de    
           produtos                                                     
Ĵ
Parametros cRecurso  = Recurso posicionado a ser pesquisado             
Ĵ
Uso		  Mata680,Mata681                                              
ٱ


*/
Function APrModRec(cRecurso)
LOCAL cRet      := ""
LOCAL cCusto    := ""
LOCAL cGrupo    := ""
LOCAL lTemIndice:= .F.
LOCAL aArea     := GetArea()
SH1->(dbSetOrder(1))

If ExistBlock("MTAREMOD")
	cRet := ExecBlock("MTAREMOD",.F.,.F.,{cRecurso})
EndIf

// Certifica-se de que o recurso esta posicionado
If SH1->(MsSeek(xFilial("SH1")+cRecurso)) .And. Empty(cRet)
	// Obtem os dados do recurso
	cCusto:=SH1->H1_CCUSTO
	cGrupo:=SH1->H1_GCCUSTO
	cRet  :="MOD"+Alltrim(cCusto)
	// Checa codigo de produto
	SB1->(dbSetOrder(1))
	If !SB1->(MsSeek(xFilial("SB1")+cRet))
		dbSelectArea("SIX")
		dbSeek("SB1")
		While ("SB1" == INDICE) .and. !Eof()
			cSixChave := AllTrim(CHAVE)
			If SIX->ORDEM == "8" .And. cSixChave == "B1_FILIAL+B1_CCCUSTO+B1_GCCUSTO"
				lTemIndice:=.T.
				Exit
			EndIf
			dbSkip()
		End
		If lTemIndice
			SB1->(dbSetOrder(8))
			// Checa codigo de produto
			If SB1->(MsSeek(xFilial("SB1")+cCusto+cGrupo))
				cRet:=SB1->B1_COD
			EndIf
		EndIf
	EndIf
EndIf
RestArea(aArea)
Return cRet

/*


Ŀ
Funo    AvalMovDiv  Autor  Marcos V. Ferreira    Data  24/07/06  
Ĵ
Descrio  Funcao utilizada para validar as rotinas de exclusao e      
			  estorno de movimentos SD1/SD2/SD3, aonde o produto em ques- 
			  tao esteja atualmente utilizando controle de rastreabilidade
			  ou enderecamento, mas no momento da criacao do movimento a  
			  ser estornado / excluido o produto nao estava utilizando    
			  esses controles. Validacao utilizada para evitar divergencia
			  de saldos entre as tabelas SB2/SB8/SBF.                     
Ĵ
Parametros cProduto  = Codigo do Produto                               
           cLocal    = Armazem do Movimento                            
           cLoteCtl  = Numero do Lote                                  
           cNumLote  = Numero do SubLote                               
           cTes      = Codigo da Tes                                   
           cTM       = Codigo do Movimento Interno                     
Ĵ
 Uso       EST/PCP/FAT/COM	                                           
ٱ


*/
Function AvalMovDiv(cProduto,cLocal,cLoteCtl,cNumLote,cNumSeq,cTes,cTM)
Local lRet      := .F.
Local lContinua := .T.
Local lQtdZero  := .F.
Local cTrbSD5   := ''
Local aAreaAnt  := GetArea()
Local aAreaSD5  := SD5->(GetArea())
Local aAreaSDA  := SDA->(GetArea())
Local aAreaSF4  := SF4->(GetArea())
Local cQuery    := ''
Local cAliasSD5 := 'SD5'


Default cTes    := ""
Default cTM     := ""


//Ŀ
// Verifica se TES atualiza estoque                |
//
If !Empty(cTes)
	dbSelectArea("SF4")
	dbSetOrder(1)
	dbSeek(xFilial("SF4")+cTes)
	//-- Verifica se atualiza estoque
	If !(SF4->F4_ESTOQUE == "S")
		lContinua := .F.
	EndIf
	//-- Verifica se utiliza quantidade zerada
	If SF4->F4_QTDZERO == "1"
		lQtdZero := .T.
	EndIf
EndIf
//Ŀ
// Verifica se a TM permite quantidade zerada      |
//
If !Empty(cTM)
	dbSelectArea("SF5")
	dbSetOrder(1)
	dbSeek(xFilial("SF5")+cTM)
	//-- Verifica se utiliza quantidade zerada
	If SF5->F5_QTDZERO == "1" .And. QtdComp(SD3->D3_QUANT) == QtdComp(0)
		lQtdZero := .T.
	EndIf
EndIf

If lContinua
	//Ŀ
	// Avalia movimentos com controle de Rastreabilidade                        |
	//
	If Rastro(cProduto)

		If Empty(cLoteCtl) .And. Empty(cNumLote)
			If !lQtdZero
				lRet := .T.
				HELP("  ",1,"PRODCHG")
			EndIf
		Else
			//Ŀ
			// Avalia se o movimento possui registro SD5   |
			//
			cTrbSD5 := CriaTrab(,.F.)

			cAliasSD5 := GetNextAlias()
			cQuery := "SELECT D5_FILIAL, D5_NUMSEQ FROM " + RetSqlName("SD5")+" SD5 "
			cQuery +=    "WHERE "
			cQuery +=      "D5_FILIAL = '"  + xFilial("SD5") + "' AND "
			cQuery +=      "D5_PRODUTO = '" + cProduto       + "' AND "
			cQuery +=      "D5_LOCAL = '"   + cLocal         + "' AND "
			cQuery +=      "D_E_L_E_T_ = ' ' "
			cQuery +=    "ORDER BY D5_FILIAL,D5_PRODUTO,D5_LOCAL,D5_NUMSEQ "
			cQuery := ChangeQuery(cQuery)
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSD5)

			If (cAliasSD5)->(!Eof())
				If cNumSeq < (cAliasSD5)->D5_NUMSEQ
					lRet := .T.
				EndIf
			Else
				lRet := .T.
			EndIf


		EndIf


	EndIf

	//Ŀ
	// Avalia movimentos com controle de Enderecamento                          |
	//
	If Localiza(cProduto)

		//Ŀ
		// Avalia se o movimento possui registro SDA   |
		//
		dbSelectArea('SDA')
		dbSetOrder(1) //DA_FILIAL+DA_PRODUTO+DA_LOCAL+DA_NUMSEQ
		If MsSeek(xFilial('SDA')+cProduto+cLocal)
			lRet := cNumSeq < SDA->DA_NUMSEQ
		Else
			If !lQtdZero    // permitir estorno para qtde 0 e tm configurado.
				lRet := .T.
			EndIf
		EndIf

		//Ŀ
		// Avalia se o movimento possui registro SDB   |
		//
		If lRet
			dbSelectArea('SDB')
			dbSetOrder(1) //DB_FILIAL+DB_PRODUTO+DB_LOCAL+DB_NUMSEQ
			If MsSeek(xFilial('SDB')+cProduto+cLocal)
				lRet := cNumSeq < SDB->DB_NUMSEQ
			Else
				if IsIncallStack('MATA103') .or. IsIncallStack('MATA140')  // tratamento para permitir excluir ou extornar classificao da nota cujo produto mudou para localiz = s depois
					lRet := .F.              // de entrada a nota.
				Else
					lRet := .T.
				EndIf
			EndIf
		EndIf


	EndIf

	If !Empty(cTrbSD5)
		RetIndex('SD5')
		Ferase(cTrbSD5+OrdBagExt())
	EndIf

EndIf

If !Empty(cQuery)
	dbSelectArea(cAliasSD5)
	(cAliasSD5)->(dbCloseArea())
EndIf

RestArea(aAreaSF4)
RestArea(aAreaSDA)
RestArea(aAreaSD5)
RestArea(aAreaAnt)
Return lRet
/*


Ŀ
Funao    CriaLote2  Autor  Fernando Joly Siquini  Data  08.01.07 
Ĵ
Descriao  Cria Lote/Sub-lote para um produto                         
Ĵ
Parametros 01 ExpC01 = Alias de origem (de onde a funcao e' chamada)  
           02 ExpC02 = Produto                                        
           03 ExpC03 = Local                                          
           04 ExpC04 = Lote                                           
           05 ExpC05 = SubLote                                        
           06 ExpC06 = Lote do Fornecedor                             
           07 ExpC07 = Cliente                                        
           08 ExpC08 = Loja                                           
           09 ExpC09 = Tipo do Movimento                              
           10 ExpC10 = Origem do Lancamento                           
           11 ExpC11 = Chave do SB8                                   
           12 ExpC12 = Numero Sequencial                              
           13 ExpC13 = Documento                                      
           14 ExpC14 = Serie do Documento                             
           15 ExpC15 = Ordem de Producao                              
           16 ExpN01 = Quantidade                                     
           17 ExpN02 = Quantidade 2a. UM                              
           18 ExpD01 = Data de Criacao do Lote                        
           19 ExpD02 = Data de Validade do Lote                       
           20 ExpL01 = Indica se cria lote para implantacao de saldos 
           21 ExpN03 = Potencia do Lote a ser criado                  
Ĵ
 Uso       Generico                                                   
ٱ

*/
Static Function CriaLote2(cAlias,cProduto,cLocal,cLoteCtl,cNumLote,cLoteFor,cCliFor,cLoja,cTm,cOrigLan,cChave,cNumSeq,cDoc,cSerie,cOp,nQuant,nQuant2UM,dData,dDtValid,lCrialote,nPotencia,cLotePrd,cSLotePrd,dDataFabric,cNumDesp,lAgregaOri)

Local aAreaAnt   := GetArea()
Local aAreaSB1	  := {}
Local lCriaSB8   := .T.
Local lGeraAuto  := Empty(cLoteCtl) //identifica gerao de numerao automtica
Local lAlteraSB8 := .F. // indica se havera ou nao atualizacao dos campos de origem do lote quando saldo estiver zerado na SB8 e estornado na SD5

If lFiCrialo == Nil
	lFiCrialo := ExistBlock('FICRIALO') //-- A verificacao sera executada somente uma vez
EndIf

lMTGRVLOT := iif( lMTGRVLOT == NIL, ExistBlock('MTGRVLOT'), lMTGRVLOT)

//Ŀ
// Preenche parametros nao recebidos pela funcao         
//
Default cLoteFor   := ''
Default nPotencia  := 0
Default nQuant2UM  := ConvUM(cProduto, nQuant, 0, 2)
Default dData      := dDataBase
Default lCriaLote  := .F.
Default cLotePrd   := ''
Default cSLotePrd  := ''
Default dDataFabric:= dDataBase
Default cNumDesp   := ''
Default lAgregaOri := .F.

cLocal := Padr(cLocal, TamSX3("B2_LOCAL")[1])

If Rastro(cProduto, 'S')
	//Ŀ
	// Descobre o Sub-lote 
	//
	cNumLote := If(cNumLote==Nil .Or. Empty(cNumLote), NextLote(cProduto, 'S'), cNumLote)
Else
	//Ŀ
	// SEMPRE Deixa o Sub-lote em branco 
	//
	cNumLote := Space(Len(SB8->B8_NUMLOTE))
EndIf

//Ŀ
// Descobre o Lote 
//
cLoteCtl := If(Empty(cLoteCtl), NextLote(cProduto, 'L', cNumLote), cLoteCtl)

Reclock(cAlias, .F.)
Replace &(Substr(cAlias,2,2)+'_LOTECTL') With cLoteCtl, ;
	&(Substr(cAlias,2,2)+'_NUMLOTE') With cNumLote
MsUnlock()
//Atualizacao do lote na etiqueta do produto - SIGAACD
If lGeraAuto .And. cAlias == "SD1" .And. UsaCB0("01")
	CBAtuLote(cLoteCtl,cNumLote,dDtValid)
EndIf

dbSelectArea('SB8')
dbSetOrder(3) //-- B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL+B8_NUMLOTE+DTOS(B8_DTVALID)
If dbSeek(xFilial('SB8')+cProduto+cLocal+cLoteCtl+cNumLote, .F.)
	lCriaSB8 := .F.

	dDtValid := SB8->B8_DTVALID
	//Ŀ
	//Caso o lote esteja zerado, verificar se houve estorno do documento que o originou. 
	//Em caso positivo, os dados de origem do lote serao atualizados.                    
	//
	If QtdComp(B8_SALDO) == QtdComp(0)
		EstOriSD5(cProduto, cLocal, cLoteCtl, cNumLote, @lAlteraSB8)
	EndIf
EndIf

If lCriaSB8
	dbSelectArea('SB1')
	dbSetOrder(1)
	aAreaSB1 := GetArea()
	If MsSeek(xFilial('SB1')+cProduto, .F.)
		//Ŀ
		// Calcula a data de validade 
		//
		If !(ValType(dDtValid) == 'D') .Or. Empty(dDtValid)
			dDtValid := dData + SB1->B1_PRVALID
		EndIf
		//Ŀ
		// Descobre a POTENCIA do lote 
		//
		If nPotencia == 0
			nPotencia := SB1->B1_POTENCI
		EndIf
	EndIf
	RestArea(aAreaSB1)
EndIf

RecLock('SB8', lCriaSB8)
If lCriaSB8
	Replace	B8_FILIAL  with xFilial('SB8'), ;
		B8_NUMLOTE with cNumLote, ;
		B8_PRODUTO with cProduto, ;
		B8_LOCAL   with cLocal, ;
		B8_DATA    with dData, ;
		B8_DTVALID with dDtValid, ;
		B8_SALDO   with nQuant, ;
		B8_SALDO2  with nQuant2UM, ;
		B8_ORIGLAN with cOrigLan, ;
		B8_LOTEFOR with cLoteFor,;
		B8_DOC     with cDoc, ;
		B8_SERIE   with cSerie, ;
		B8_CLIFOR  with cCliFor, ;
		B8_LOJA    with cLoja, ;
		B8_QTDORI  with nQuant, ;
		B8_QTDORI2 with nQuant2UM, ;
		B8_LOTECTL with cLoteCtl, ;
		B8_POTENCI with nPotencia

		Replace B8_DFABRIC With dDataFabric

	If cAlias == 'SD1' .And. !(cPaisLoc=='BRA')
		Replace B8_NUMDESP With (cAlias)->D1_NUMDESP
		Replace B8_ORIGEM  With (cAlias)->D1_ORIGEM
		Replace B8_ITEM With (cAlias)->D1_ITEM

	ElseIf cAlias=='SD3' .And. (cPaisLoc <> "BRA")
		Replace B8_NUMDESP With cNumDesp
	EndIf
Else
	Replace B8_SALDO with B8_SALDO + nQuant, ;
	B8_SALDO2  with B8_SALDO2  + nQuant2UM

	If lAgregaOri
		Replace B8_QTDORI with B8_QTDORI + nQuant
	EndIf

	If cTm == '499'
		Replace B8_DTVALID with dDtValid
	EndIf

	If lAlteraSB8
		//Ŀ
		//O documento que deu origem ao lote foi estornado, portanto as informacoes devem ser 
		//atualizadas com os dados do novo documento que esta sendo gerado .                  
		//
		Replace B8_DATA	   with dData, ;
				B8_DTVALID with dDtValid, ;
				B8_ORIGLAN with cOrigLan, ;
				B8_LOTEFOR with cLoteFor,;
				B8_DOC     with cDoc, ;
				B8_SERIE   with cSerie, ;
				B8_CLIFOR  with cCliFor, ;
				B8_LOJA    with cLoja, ;
				B8_QTDORI  with nQuant, ;
				B8_QTDORI2 with nQuant2UM, ;
				B8_POTENCI with nPotencia
			Replace B8_DFABRIC With dDataFabric
	EndIf
EndIf
MsUnlock()

If lMTGRVLOT
	ExecBlock('MTGRVLOT', .F., .F.)
EndIf

If (!(cAlias=='SD5') .And. !lCrialote)
	GravaSD5(cAlias, ;
		cProduto, ;
		cLocal, ;
		cLoteCtl, ;
		cNumLote, ;
		cNumSeq, ;
		cDoc, ;
		cSerie, ;
		cOp, ;
		cTm, ;
		cCliFor, ;
		cLoja, ;
		cLoteFor, ;
		nQuant, ;
		nQuant2UM, ;
		dData, ;
		dDtValid, ;
		nPotencia, ;
		cLotePrd, ;
		cSLotePrd)
EndIf

If lCriaSB8 .And. cAlias == "SD3" .And. Type("aLotPrdAut") == "A"
	aAdd(aLotPrdAut,{	cOp,;
						cProduto,;
						cLocal,;
						cNumLote,;
						cLoteCtl})
EndIf

If !(aAreaAnt[1]=='SB8')
	RestArea(aAreaAnt)
EndIf

//Ŀ
// Ponto de entrada no final da CriaLote 
//
If lFiCrialo
	ExecBlock('FICRIALO', .F., .F.)
Endif

Return NIL

/*


Ŀ
Funcao    EstOriSD5  Autor Emerson Rony Oliveira   Data  04/11/08  
Ĵ
Descricao  Verifica se o documento que originou o lote UNICO do produto
           foi estornado ou nao. (MV_LOTEUNI = .T.)                    
Ĵ
Parametros ExpC1 = Codigo do Produto                                   
           ExpC2 = Local                                               
           ExpC3 = Numero do lote                                      
           ExpC4 = Numero do sub-lote                                  
           ExpL1 = Variavel de retorno indicando se houve estorno      
Ĵ
Retorno	  A variavel lAlteraSB8 indicara se houve ou nao o estorno do 
           documento de origem do lote unico (.T. / .F.)               
Ĵ
 Uso       CriaLote2()                                                 
ٱ


*/
Function EstOriSD5(cProduto, cLocal, cLoteCtl, cNumLote, lAlteraSB8)
Local aArea      := GetArea()
Local aAreaSD5   := SD5->(GetArea())
Local cAliasSD5  := "SD5"
Local cQuery     := ""

dbSelectArea("SD5")
dbSetOrder(2) // D5_FILIAL+D5_PRODUTO+D5_LOCAL+D5_LOTECTL+D5_NUMLOTE+D5_NUMSEQ

cAliasSD5 := "ESTORISD5"

cQuery := "SELECT * "
cQuery += "FROM "+RetSqlName("SD5")+" SD5 "
cQuery += "WHERE SD5.D5_FILIAL='"+xFilial("SD5")+"' AND "
cQuery += "SD5.D5_PRODUTO='"+cProduto+"' AND "
cQuery += "SD5.D5_LOCAL='"+cLocal+"' AND "
cQuery += "SD5.D5_LOTECTL='"+cLoteCtl+"' AND "
cQuery += "SD5.D5_NUMLOTE='"+cNumLote+"' AND "
cQuery += "SD5.D5_DOC='"+SB8->B8_DOC+"' AND "
cQuery += "SD5.D5_SERIE='"+SB8->B8_SERIE+"' AND "
cQuery += "SD5.D5_ESTORNO='S' AND "
cQuery += "SD5.D_E_L_E_T_=' ' "
cQuery += "ORDER BY "+SqlOrder(SD5->(IndexKey()))

cQuery := ChangeQuery(cQuery)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSD5)


dbSelectArea(cAliasSD5)
While !Eof() .And. D5_FILIAL  == xFilial("SD5") .And. D5_PRODUTO == cProduto .And. D5_LOCAL == cLocal .And.;
	  D5_LOTECTL == cLoteCtl .And. D5_NUMLOTE == cNumLote
	If D5_DOC == SB8->B8_DOC .And. D5_SERIE == SB8->B8_SERIE .And. D5_ESTORNO == 'S'
		lAlteraSB8 := .T.
		Exit
	EndIf
	dbSkip()
EndDo

dbSelectArea(cAliasSD5)
dbCloseArea()


RestArea(aAreaSD5)
RestArea(aArea)
Return Nil

/*


Ŀ
Funo    B2AtuUnif  Autor  Microsiga S/A          Data  31/10/07 
Ĵ
Descrio  Atualiza o saldo atual do SB2 (VATU) Unificado             
Ĵ
Parametros ExpC1 = Codigo do Produto                                  
Parametros ExpL2 = Atualizar Saldo do Fechamento                      
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function B2AtuUnif(cProduto)
//Variveis para controle de filiais que sero utilizadas
//com custo unificado por empresa e Gesto de Empresas 
Static __cFilCond := ""
Static __aLisFil
Static __cCompAnt

//Ŀ
// MV_CUSMED  - Parametro utilizado para verificar se devera    |
//|              utilizar o custo ON-LINE.                       
//| MV_AGCUSTO - Parametro utilizado para verificar se devera    |
//|              aglutinar o custo sem a utilizacao do MV_CUSMED |
//
Local lCstOnLine
//Ŀ
//MV_CUSFIL - Parametro utilizado para verificar se o sistema   |
//|utiliza custo unificado por:                                  |
//|      F = Custo Unificado por Filial                          |
//|      E = Custo Unificado por Empresa                         |
//|      A = Custo Unificado por Armazem                         |
//
Local cMV_CUSFIL
Local lCusFil
Local lCusEmp
Local cCompany

Local aCMUnif   := {0,0,0,0,0}
Local cQuery    := ''
//Ŀ
// Moedas para calculo do custo medio - Sempre processa moeda 1 |
//
Local cMoedaCM
Local nX

//Ambiente com sigamat de Gesto de Empresas
Local lUsaGesEmp := .F.

Default cProduto  := ''

aAreaAnt  := GetArea()

lCstOnLine:= ( AllTrim(EstGetMv("MV_CUSMED",.F.,"M"))=="O" .Or. EstGetMv("MV_AGCUSTO",.F.,.F.) )
If lCstOnLine

	cMV_CUSFIL:= AllTrim(EstGetMv('MV_CUSFIL',.F.,"A"))
	lCusFil   := cMV_CUSFIL == "F"
	lCusEmp   := cMV_CUSFIL == "E"
	If (lCusFil .Or. lCusEmp)

		aAreaSB2  := SB2->(GetArea())

		cMoedaCM  := EstGetMv('MV_MOEDACM',.F.,"2345")

		If lCusEmp
			lUsaGesEmp := 'E' $ FWSM0Layout() .And. Len(FWAllCompany()) > 1
			If lUsaGesEmp
				cCompany := FWCompany()
				If __aLisFil == NIL .Or. cCompany <> __cCompAnt
					__aLisFil := FWAllFilial(cCompany,,,.F.)
					__cFilCond:= ""
				EndIf
			EndIf
		EndIf

		//Ŀ
		// Retorna o custo medio unificado do produto                
		//
		aCMUnif := PegaCMUnif(cProduto,,__aLisFil)

		//Ŀ
		// Montagem da query para atualizacao de valores no SB2      
		//
		cQuery := "UPDATE " + RetSqlName("SB2") + " SET "
		cQuery += " B2_VATU1 =  (B2_QATU * " + Alltrim(Str(aCMUnif[1])) +") "
		cQuery += If("2" $ cMoedaCM,", B2_VATU2 =  (B2_QATU * " + Alltrim(Str(aCMUnif[2])) +") ","")
		cQuery += If("3" $ cMoedaCM,", B2_VATU3 =  (B2_QATU * " + Alltrim(Str(aCMUnif[3])) +") ","")
		cQuery += If("4" $ cMoedaCM,", B2_VATU4 =  (B2_QATU * " + Alltrim(Str(aCMUnif[4])) +") ","")
		cQuery += If("5" $ cMoedaCM,", B2_VATU5 =  (B2_QATU * " + Alltrim(Str(aCMUnif[5])) +") ","")

		// Tratamento para nunca zerar os campos B2_CM'X' (custo medio historico)
		If aCMUnif[1] <> 0
			cQuery += ", B2_CM1 = " + Alltrim(Str(aCMUnif[1])) + " "
		EndIf
		If aCMUnif[2] <> 0
			cQuery += If("2" $ cMoedaCM,", B2_CM2 = " + Alltrim(Str(aCMUnif[2])) + " ","")
		EndIf
		If aCMUnif[3] <> 0
			cQuery += If("3" $ cMoedaCM,", B2_CM3 = " + Alltrim(Str(aCMUnif[3])) + " ","")
		EndIf
		If aCMUnif[4] <> 0
			cQuery += If("4" $ cMoedaCM,", B2_CM4 = " + Alltrim(Str(aCMUnif[4])) + " ","")
		EndIf
		If aCMUnif[5] <> 0
			cQuery += If("5" $ cMoedaCM,", B2_CM5 = " + Alltrim(Str(aCMUnif[5])) + " ","")
		EndIf
		cQuery += "WHERE "
		If lCusFil
			cQuery += " B2_FILIAL  = '" + xFilial("SB2") + "' AND "
		Else
			If lUsaGesEmp
				If Empty(__cFilCond)
					For nX := 1 to Len(__aLisFil)	
						__cFilCond += "'" + __aLisFil[nX] + "',"
					Next
					__cCompAnt:= cCompany
				EndIf
				cQuery += " B2_FILIAL IN (" + Substr(__cFilCond,1, Len(__cFilCond) - 1 ) + ") AND "
			EndIf
		EndIf
		cQuery += " B2_COD = '" +  cProduto + "' AND "
		cQuery += " D_E_L_E_T_ = ' '"

		//Ŀ
		// Execucao da query para atualizacao de valores no SB2 
		//
		TcSqlExec(cQuery)

		dbSelectArea("SB2")
		dbGoto(Recno()) //-- Reposiciona na tabela/registro atual somente para atualizar gravacoes pendentes

		RestArea(aAreaSB2)
	EndIf
EndIf
RestArea(aAreaAnt)

Return

/*


Ŀ
Funao    PegaCMUnif Autor  Microsiga S/A          Data  31/10/07 
Ĵ
Descrio  Retorna array com os saldos unificados                     
Ĵ
Parametros ExpC1 = Codigo do Produto                                  
           ExpA2 = Array com o custo medio por armazem                
           ExpL3 = Atualizar Saldo de Fechamento                      
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function PegaCMUnif(cProduto,aCM,aFilProc)
Local aAreaAnt  := GetArea()
Local aAreaSB2  := SB2->(GetArea())
Local aCMUnif   := {0,0,0,0,0}
Local lPadrao   := .F.

Local lCstOnLine

Local cMV_CUSFIL
Local lCusFil
Local lCusEmp
Local cQuery    := ''
Local cAliasTop := ''
Local nLen
Local cMD5
Local nPosPrepared
Local aInsParam
Local aTam
//Ŀ
// Moedas para calculo do custo medio - Sempre processa moeda 1 |
//
Local cMoedaCM

Default aCM      := {0,0,0,0,0}
Default cProduto := ''
Default aFilProc := {}

__lCusaVLib 	:= If(__lCusaVLib == NIL,FWLibVersion() >= "20211116",__lCusaVLib)

//Ŀ
// MV_CUSMED  - Parametro utilizado para verificar se devera    |
//|              utilizar o custo ON-LINE.                       
//| MV_AGCUSTO - Parametro utilizado para verificar se devera    |
//|              aglutinar o custo sem a utilizacao do MV_CUSMED |
//
lCstOnLine:= ( AllTrim(EstGetMv("MV_CUSMED",.F.,"M"))=="O" .Or. EstGetMv("MV_AGCUSTO",.F.,.F.) )
//Ŀ
//MV_CUSFIL - Parametro utilizado para verificar se o sistema   |
//|utiliza custo unificado por:                                  |
//|      F = Custo Unificado por Filial                          |
//|      E = Custo Unificado por Empresa                         |
//|      A = Custo Unificado por Armazem                         |
//
cMV_CUSFIL:= AllTrim(EstGetMv('MV_CUSFIL',.F.,"A"))
lCusFil := cMV_CUSFIL == "F"
lCusEmp := cMV_CUSFIL == "E"

If lCstOnLine .And. (lCusFil .Or. lCusEmp)

	//Ŀ
	// Moedas para calculo do custo medio - Sempre processa moeda 1 |
	//
	cMoedaCM  := EstGetMv('MV_MOEDACM',.F.,"2345")

	dbSelectArea("SB2")
	dbGoto(Recno()) //-- Reposiciona na tabela/registro atual somente para atualizar gravacoes pendentes

	//Ŀ
	// Define a string da query a ser processada                                               
	//	
	aInsParam :={}
	cQuery := "SELECT"
		cQuery += " SUM(B2_VATU1) TOTVLR1, "
		cQuery += If("2" $ cMoedaCM," SUM(B2_VATU2) TOTVLR2, ","")
		cQuery += If("3" $ cMoedaCM," SUM(B2_VATU3) TOTVLR3, ","")
		cQuery += If("4" $ cMoedaCM," SUM(B2_VATU4) TOTVLR4, ","")
		cQuery += If("5" $ cMoedaCM," SUM(B2_VATU5) TOTVLR5, ","")
		cQuery += " SUM(B2_QATU) TOTQTDE "
	cQuery += "FROM "
	aAdd(aInsParam,RetSqlName("SB2"))
	cQuery += "? SB2 "
	cQuery += "WHERE "
	If lCusFil
		aAdd(aInsParam,xFilial("SB2"))
		cQuery += "SB2.B2_FILIAL = ? AND "
	Elseif lCusEmp .And. !Empty(aFilProc)
		aAdd(aInsParam,aFilProc)
		cQuery += "SB2.B2_FILIAL IN (?) AND "
	EndIf
	aAdd(aInsParam,cProduto)
	cQuery += "SB2.B2_COD = ? AND "
	cQuery += "SB2.D_E_L_E_T_ = ' '"
	cQuery += "GROUP BY "
	cQuery += IIf(lCusFil,"B2_FILIAL,B2_COD","B2_COD")

	//Ŀ
	// Compatibiliza a query com o banco de dados                                      
	//
	nLen := Len(aInsParam)
	cMD5 := MD5(cQuery)
	If (nPosPrepared := Ascan(__aPrepared,{|x| x[2] == cMD5})) == 0
		cQuery := ChangeQuery(cQuery)
		Aadd(__aPrepared,{IIf(__lCusaVLib,FwExecStatement():New(cQuery),FWPreparedStatement():New(cQuery)),cMD5})
		nPosPrepared := Len(__aPrepared)
	Endif
	__aPrepared[nPosPrepared][1]:SetUnsafe(1, aInsParam[1])
	If lCusFil
		__aPrepared[nPosPrepared][1]:SetString(2, aInsParam[2])
	Elseif !Empty(aFilProc)
		__aPrepared[nPosPrepared][1]:SetIn(2, aInsParam[2])
	EndIf
	__aPrepared[nPosPrepared][1]:SetString(nLen, aInsParam[nLen])

	//Ŀ
	// Define o alias para a query                                                     
	//
	cAliasTop  := GetNextAlias()

	//Ŀ
	// Verifica se o alias esta em uso                                                 
	//
	If Select( cAliasTop ) > 0
		dbSelectArea( cAliasTop )
		dbCloseArea()
	EndIf

	//Ŀ
	// Cria o alias executando a query                                                 
	//

	If __lCusaVLib
		__aPrepared[nPosPrepared][1]:OpenAlias(cAliasTop)
		DbSelectArea(cAliasTop)
	Else
		cQuery := __aPrepared[nPosPrepared][1]:getFixQuery()
		dbUseArea( .T., 'TOPCONN', TCGENQRY(,,cQuery), cAliasTop , .F., .T.)
	EndIf

	//Ŀ
	// Compatibiliza os campos de acordo com a TopField                                
	//
	aTam := ESTTamSX3("B2_VATU1", @_aTamSX3)
	TcSetField(cAliasTop,"TOTVLR1","N",aTam[1],aTam[2])
	If "2" $ cMoedaCM
		aTam := ESTTamSX3("B2_VATU2", @_aTamSX3)
		TcSetField(cAliasTop,"TOTVLR2","N",aTam[1],aTam[2])
	EndIf
	If "3" $ cMoedaCM
		aTam := ESTTamSX3("B2_VATU3", @_aTamSX3)
		TcSetField(cAliasTop,"TOTVLR3","N",aTam[1],aTam[2])
	EndIf
	If "4" $ cMoedaCM
		aTam := ESTTamSX3("B2_VATU4", @_aTamSX3)
		TcSetField(cAliasTop,"TOTVLR4","N",aTam[1],aTam[2])
	EndIf
	If "5" $ cMoedaCM
		aTam := ESTTamSX3("B2_VATU5", @_aTamSX3)
		TcSetField(cAliasTop,"TOTVLR5","N",aTam[1],aTam[2])
	EndIf
	aTam := ESTTamSX3("B2_QATU", @_aTamSX3)
	TcSetField(cAliasTop,"TOTQTDE","N",aTam[1],aTam[2])

	aCMUnif := {	CusRound(TOTVLR1 / IIf(TOTQTDE == 0,1,TOTQTDE),1),;
						IIf("2" $ cMoedaCM,CusRound(TOTVLR2 / IIf(TOTQTDE == 0,1,TOTQTDE),2),0),;
						IIf("3" $ cMoedaCM,CusRound(TOTVLR3 / IIf(TOTQTDE == 0,1,TOTQTDE),3),0),;
						IIf("4" $ cMoedaCM,CusRound(TOTVLR4 / IIf(TOTQTDE == 0,1,TOTQTDE),4),0),;
						IIf("5" $ cMoedaCM,CusRound(TOTVLR5 / IIf(TOTQTDE == 0,1,TOTQTDE),5),0) }


	//Ŀ
	// Verifica se o alias esta em uso                                                 
	//
	If Select( cAliasTop ) > 0
		dbSelectArea( cAliasTop )
		dbCloseArea()
	EndIf
Else

	lPadrao := .T.

EndIf

RestArea(aAreaSB2)
RestArea(aAreaAnt)
Return IIf(lPadrao,aCM,aCMUnif)

/*/


Ŀ
Funcao    VerIDProc  Autor  Marcelo Pimentel       Data 06.12.2007
Ĵ
Descrio Identifica a sequencia de controle do fonte ADVPL com a     
          stored procedure, qualquer alteracao que envolva diretamente
          a stored procedure a variavel sera incrementada.            
          Procedure MAT052                                            
Ĵ
   DATA    Programador   Manutencao Efetuada                         
ٱ


/*/
Static Function VerIDProc()
Return EngSPS19Signature('19')

/*/


Ŀ
Funcao    CalcQtdReq  Autor  Andre Anjos		      Data 29.10.2008
Ĵ
Descrio Calcula a quantidade que sera requisitada de um empenho      
Ĵ
Uso   	 PerdaLinOk												   
ٱ


/*/
Function CalcQtdReq(cOP,nQtdProd,cComp,cLocal,cLoteCtl,cNumLote,cLocaliz,cNumSeri,cProdTot,cLocRas,lAbate)
Local aArea 	:= GetArea()
Local nIndice 	:= 0
Local nRet 		:= 0
Local cBxProp 	:= SuperGetMV("MV_BXPROP",.F.,"S")
LOCAL cReqAut 	:= SuperGetMV("MV_REQAUT",.F.,"A")
Local cFiltro 	:= ""

Default cProdTot := "P"
Default cLoteCtl := CriaVar("D4_LOTECTL",.F.)
Default cNumLote := CriaVar("D4_NUMLOTE",.F.)
Default cLocaliz := CriaVar("DC_LOCALIZ",.F.)
Default cNumSeri := CriaVar("DC_NUMSERI",.F.)
Default lAbate   := .T.

If cReqAut == "A"
	//Ŀ
	// Calcula o indice de baixa de empenhos   
	//
	dbSelectArea("SC2")
	dbSetOrder(1)
	dbSeek(xFilial("SC2")+cOP)
	If cBxProp == "S"
		If cProdTot == "T" .And. SuperGetMV("MV_BXSD4TL",.F.,.T.)
			nIndice := 1
		Else
			nIndice := Min(1,nQtdProd/SC2->C2_QUANT)
		EndIf
	EndIf

	//Ŀ
	// Calcula o total a ser requisitado do produto   
	//
	dbSelectArea("SD4")
	dbSetOrder(2)
	dbSeek(xFilial("SD4")+cOP+cComp+cLocal)
	While !EOF() .And. SD4->(D4_FILIAL+D4_OP+D4_COD+D4_LOCAL) == xFilial("SD4")+cOP+cComp+cLocal
		If !Empty(SD4->D4_QUANT) .And. SD4->D4_LOCAL == cLocal
			nRet += Min(nIndice * SD4->D4_QTDEORI,SD4->D4_QUANT)
		EndIf
		SD4->(dbSkip())
	End

	If lAbate
		//Ŀ
		// Abate do lote informado na perda as requisicoes           
		//| para producao que podem ser feitas em outros lotes        |
		//
		If cLocRas == "R" .And. !Empty(cLoteCtl+cNumLote)
			dbSelectArea("SD4")
			dbSetOrder(2)
			dbSeek(xFilial("SD4")+cOP+cComp+cLocal)
			While !EOF() .And. SD4->(D4_FILIAL+D4_OP+D4_COD+D4_LOCAL) == xFilial("SD4")+cOP+cComp+cLocal
				If !Empty(SD4->D4_QUANT) .And. SD4->D4_LOCAL == cLocal .And. ;
					SD4->(D4_LOTECTL+If(Rastro(D4_COD,"S"),D4_NUMLOTE,"")) # cLoteCtl+If(Rastro(D4_COD,"S"),cNumLote,"")

					nRet -= SD4->D4_QUANT
				EndIf
				SD4->(dbSkip())
			End
			If nRet < 0
				nRet := 0
			EndIf
		EndIf

		//Ŀ
		// Abate do endereco informado na perda as requisicoes           
		//| para producao que podem ser feitas em outros enderecos        |
		//
		If cLocRas == "L" .And. !Empty(cLocaliz+cNumSeri)
			cFiltro := "DC_FILIAL == '" +xFilial("SDC") +"' .And. DC_PRODUTO == '" +cComp +"' .And. DC_LOCAL == '" +cLocal +"' .And. "
			cFiltro += "DC_OP == '" +cOP +"' .And. !Empty(DC_QUANT)"
			dbSelectArea("SDC")
			SDC->(dbSetFilter({|| &cFiltro}, cFiltro))
			SDC->(dbGoTop())
			While !EOF()
				If SDC->(DC_LOTECTL+If(Rastro(cComp,"S"),DC_NUMLOTE,"")+DC_LOCALIZ+DC_NUMSERI) # cLoteCtl+If(Rastro(cComp,"S"),cNumLote,"")+cLocaliz+cNumSeri
					nRet -= SDC->DC_QUANT
				EndIf
				SDC->(dbSkip())
			End
			SDC->(dbClearFilter())
			If nRet < 0
				nRet := 0
			EndIf
		EndIf
	EndIf

	RestArea(aArea)
EndIf

Return nRet

/*


ͻ
Programa  RetLocalizAutor  Vendas CRM           Data   22/12/08   
͹
Desc.     Retorna a localizacao e numero de serie do produto devolvido
          de acordo com a NF de saida.                                
͹
Uso       Generico                                                    
ͼ


*/
Static Function RetLocaliz(cLocaliz,cNumSerie)

Local aArea		:= GetArea()
Local aAreaSD2	:= SD2->(GetArea())
Local aRecnoD2	:= {}
Local nPos		:= 0

If	(cPaisLoc == "BRA") .AND. !Empty(SD1->D1_NFORI)

	aRecnoD2 := Lj720RecD2()

	If (nPos := aScan(aRecnoD2,{|x|AllTrim(x[1]+x[2]+x[3])==AllTrim(SD1->(D1_NFORI+D1_SERIORI+D1_ITEMORI))})) > 0

		SD2->(DbGoTo(aRecnoD2[nPos][4]))

		cLocaliz	:= SD2->D2_LOCALIZ
		cNumSerie	:= SD2->D2_NUMSERI

	EndIf

EndIf

RestArea(aAreaSD2)
RestArea(aArea)

Return Nil

/*


Ŀ
Funo    AtuCPTRT   Autor Microsiga S/A           Data  03/02/09 
Ĵ
Descrio  Atualiza o CUSTO EM PARTES no arquivo TOTALIZADOR          
Ĵ
Sintaxe    AtuCPTRT(EXPL1,EXPA1,EXPN1,EXPC1)                          
Ĵ
Parametros ExpL1 = Variavel logica que indica se utiliza o custo em   
                   partes ou nao                                      
           ExpA1 = Array com os custos a serem atualizados            
           ExpN1 = Multiplicador do movimento                         
           ExpC1 = Arquivo totalizador                                
           ExpA2 = Array com os custos unitario Historicos            
Ĵ
 Uso       MATA330                                                    
ٱ


*/
Function AtuCPTRT(lCstPart,aRetPartes,nMultiplic,_cCampoBack,aCMHist)
LOCAL _cCampo     :=""
LOCAL _cCampoTot  :=""
LOCAL _cCampoUnit :="TRB_CP"
LOCAL _nLoop0     :=0
LOCAL _nLoop1     :=0
LOCAL _nValorAtu  :=0
LOCAL nPosicao    :=0
Local lUtilProp   := .F.
Local aHistParte
Local lPropCP

DEFAULT lCstPart   := .F.
DEFAULT _cCampoBack:= "TRB_VF"
DEFAULT aCMHist    := {}

If lCstPart

	cMoeda330C := IIF(cMoeda330C == Nil,SuperGetMv('MV_MOEDACM',.F.,"2345"),cMoeda330C)
	aHistParte := aClone(aRetPartes)
	lPropCP := SuperGetMv("MV_PROPCP",.F.,.F.)

	//Ŀ
	// Grava informacao do custo em partes no SB2           
	//
	For _nLoop0:=1 to Len(aRetPartes)/5
		For _nLoop1:=1 to 5
			_cCampo  := _cCampoBack+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0)
			nPosicao :=FieldPos(_cCampo)
			If _nLoop1 # 1 .And. !(Str(_nLoop1,1,0) $ cMoeda330C)
				_nValorAtu  := 0
			Else
				_nValorAtu  :=FIELDGET(nPosicao)
			EndIf
			If nPosicao > 0
				FIELDPUT(nPosicao,_nValorAtu+(	aRetPartes[_nLoop1+If(_nLoop0==1,0,(_nLoop0-1)*5)]*nMultiplic))
			EndIf
		Next _nLoop1
	Next _nLoop0
	//Ŀ
	// Grava informacao do custo em partes UNITARIO no TRT  
	//
	If Alias() == "TRT" .And. QtdComp(TRT->TRB_QFIM) > QtdComp(0)
		aFill(aHistParte,0)
		For _nLoop0:=1 to Len(aRetPartes)/5
			For _nLoop1:=1 to 5
				If &("TRT->TRB_VFIM"+StrZero(_nLoop1,1,0)) > 0
					_cCampo     := _cCampoUnit+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0)
					_cCampoTot  := _cCampoBack+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0)
					nPosicao    :=FieldPos(_cCampoTot)
					If _nLoop1 # 1 .And. !(Str(_nLoop1,1,0) $ cMoeda330C)
						_nValorAtu := 0
					Else
						_nValorAtu :=FIELDGET(nPosicao)
					EndIf
					If nPosicao > 0
						If lPropCP
							aHistParte[_nLoop1+((_nLoop0-1)*5)] := FIELDGET(FieldPos(_cCampo))
							If Len(aCMHist) > 0 .And. (_nValorAtu/TRT->TRB_QFIM) < 0 .And. (_nLoop0 <> Len(aRetPartes)/5)
								lUtilProp := .T.
							EndIf
						EndIf
						FIELDPUT(FieldPos(_cCampo),_nValorAtu/TRT->TRB_QFIM)
					EndIf
				EndIf
			Next _nLoop1
		Next _nLoop0
		//Ŀ
		// Grava o custo unitario em partes utilizando o calculo 
		// de proporcao para unitarios negativos                 
		//
        If lUtilProp
			For _nLoop0:=1 to Len(aRetPartes)/5
				For _nLoop1:=1 to 5
					_cCampo     := _cCampoUnit+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0)
					_cCampoTot  := _cCampoBack+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0)
					nPosicao    := FieldPos(_cCampoTot)
					If _nLoop1 # 1 .And. !(Str(_nLoop1,1,0) $ cMoeda330C)
						_nValorAtu  := 0
					Else
						_nValorAtu  := (aHistParte[_nLoop1+((_nLoop0-1)*5)]/aCMHist[_nLoop1]) * &("TRT->TRB_CM"+StrZero(_nLoop1,1,0))
					EndIf
					If nPosicao > 0
						FIELDPUT(FieldPos(_cCampo),_nValorAtu)
					EndIf
				Next _nLoop1
			Next _nLoop0
        EndIf
	EndIf
	aSize(aHistParte,0)
EndIf
RETURN

/*


Ŀ
Funo    AtuSldMov  Autor Microsiga S/A           Data  03/02/09 
Ĵ
Descrio  Atualiza o saldo do movimento por lote/localizacao.        
Ĵ
Sintaxe    AtuSldMov()                                                
Ĵ
Parametros                                                            
Ĵ
 Uso       MOVLOTE                                                    
ٱ


*/
Static Function AtuSldMov(cProduto,cLocal,nQuant,nQuant2UM,cLoteCtl,cNumLote,cLocaliz,cNumSerie,lBxEmpB8,lConsVenc,dData,cDoc,cSerie,cOp,cTm,cCliFor,cLoja,cLoteFor,cLotePrd,cSubLotePrd,nQuantPMax,aLogMov,nQtdSD5,nQtdSDB,lNumSerDev,cTipoNf,cAlias,cNumSeq,lEstorno,cEstFis,cServico,cTarefa,cAtividade,cAnomalia,cEstDest,cEndDest,cHrInicio,cAtuEst,cCarga,cUnitiza,cOrdTar,cOrdAti,cRHumano,cRFisico,cIdDCF,lEmpPrev,cIdMovto)
Local aAreaAnt := GetArea()
Local aAreaSBF := SBF->(GetArea())
Local aAreaSDB := SDB->(GetArea())
Local aAreaSB8 := SB8->(GetArea())
Local aAreaSD5 := SD5->(GetArea())
Local aArray   := {}
Local aTravas  := {}
Local i        := 0
Local z        := 0
Local nQtdPSDB := 0
Local nQtdPSD5 := 0
Local nRecnoSDB:= 0
Local lPotencLote := .F.

Default nQuantPMax := 0
Default nQtdSD5    := 0
Default nQtdSDB    := 0
Default aLogMov    := {}
Default lNumSerDev := .F.
Default lEstorno   := .F.
Default lEmpPrev   := .F.
Default cTipoNf    := ''
Default cAlias     := ''
Default cNumSeq    := ''
Default cIdMovto   := ''

TLogMov(@aLogMov,'206',STR0200,nQuant,cLoteCtl,cNumLote,nQuant,cLocaliz,cNumSerie) //"Iniciando Baixa pela SLDPORLOTE"
aArray:=SldPorLote(cProduto,cLocal,nQuant,nQuant2UM,cLoteCtl,cNumLote,cLocaliz,cNumSerie,@aTravas,NIL,NIL,NIL,NIL,NIL,dData,,,.T.)
nQtdPSDB  := 0
nQtdPSD5  := 0
nQuantPMax:= 0
lPotencLote := PotencLote(cProduto)
For i:=1 to Len(aArray)
	// Caso utilize registros da Rastreabilidade tira saldo e/ou empenho no SB8
	dbSelectArea("SB8")
	If Rastro(cProduto)
		If Len(aArray[i,10]) > 0
			For z:=1 to Len(aArray[i,10])
				dbGoto(aArray[i,10,z,1])
				Reclock("SB8",.F.)
				GravaSD5(cAlias,cProduto,cLocal,SB8->B8_LOTECTL,SB8->B8_NUMLOTE,cNumSeq,cDoc,cSerie,cOp,cTm,cCliFor,cLoja,cLoteFor,aArray[i,10,z,2],aArray[i,10,z,3],dData,SB8->B8_DTVALID,SB8->B8_POTENCI,cLotePrd,cSubLotePrd,'S')
				TLogMov(@aLogMov,'207',STR0173,aArray[i,10,z,2],SB8->B8_LOTECTL,SB8->B8_NUMLOTE) //"Atualizao do Registro SD5/SB8"
				nQtdPSD5 += aArray[i,10,z,2]
				nQtdSD5  += aArray[i,10,z,2]
				If lPotencLote .And. (!lBxEmpB8 .Or. (lBxEmpB8 .And. Empty(cLoteCtl+cNumLote))) .And. !Empty(cOp)
					nQuantPMax+=A250PotMax(cProduto,SB8->B8_POTENCI,Min(SB8->B8_SALDO,aArray[i,10,z,2]))
				EndIf
				Replace SB8->B8_SALDO  With SB8->B8_SALDO  - Min(SB8->B8_SALDO ,aArray[i,10,z,2])
				Replace SB8->B8_SALDO2 With SB8->B8_SALDO2 - Min(SB8->B8_SALDO2,aArray[i,10,z,3])
				If (lBxEmpB8 .And. QtdComp(SB8SALDO(.T.,,,,,lEmpPrev,,,.T.)) >= QtdComp(0) .And. !Empty(cLoteCtl))
					GravaB8Emp("-",aArray[i,10,z,2],"F",NIL, If( Empty(aArray[i,10,z,3]),NIL,aArray[i,10,z,3]))
				EndIf
				SB8->(MsUnlock())
			Next z
		Else
			TLogMov(@aLogMov,'208',STR0179) //"Nao foi Encontrado saldo por Lote na SLDPORLOTE"
		EndIf
	EndIf
	// Caso utilize registros da Localizacao Fisica tira saldo e/ou empenho no SBF
	If Localiza(cProduto)
		If aArray[i,9] > 0
			dbSelectArea("SBF")
			dbGoto(aArray[i,9])
			RecLock("SBF")
			nRecnoSDB := 0
			CriaSDB(cProduto,cLocal,aArray[i,5],aArray[i,3],If(lNumSerDev,aArray[i,4],cNumSerie),cDoc,cSerie,cCliFor,cLoja,cTipoNf,IIf(cAlias=='SD2','SC6',cAlias),dData,aArray[i,1],aArray[i,2],cNumSeq,cTm,"M",StrZero(1,Len(SDB->DB_ITEM)),lEstorno,Nil,aArray[i,6],Nil,cEstFis,cServico,cTarefa,cAtividade,cAnomalia,cEstDest,cEndDest,cHrInicio,cAtuEst,cCarga,cUnitiza,cOrdTar,cOrdAti,cRHumano,cRFisico,,cIdDCF,@nRecnoSDB,cIdMovto,cOp)
			TLogMov(@aLogMov,'208',STR0176,aArray[i,5],aArray[i,1],aArray[i,2],aArray[i,5],aArray[i,3],aArray[i,4]) //"Atualizao do Saldo por Endereco (SBF/SDB)"
			nQtdPSDB += aArray[i,5]
			nQtdSDB  += aArray[i,5]
			//Ŀ
			//Soma saldo em estoque por localizacao fisica (SBF)     
			//
			If SBF->BF_EMPENHO >= aArray[i,5]
				GravaSBF("SDB",lBxEmpB8,,nRecnoSDB)
			Else
				GravaSBF("SDB",.F.,,nRecnoSDB)
			EndIf
			SBF->(MsUnLock())
		Else
			TLogMov(@aLogMov,'209',STR0180) //"Nao foi Encontrado saldo por Endereco na SLDPORLOTE"
		EndIf
	EndIf
Next i

TLogMov(@aLogMov,'210',STR0201,nQtdPSD5,cLoteCtl,cNumLote,nQtdPSDB,cLocaliz,cNumSerie) //"Termino da Baixa pela SLDPORLOTE"

//Ŀ
// Remove travas dos registros utilizados                  
//
MaDesTrava(aTravas)

RestArea(aAreaSB8)
RestArea(aAreaSD5)
RestArea(aAreaSBF)
RestArea(aAreaSDB)
RestArea(aAreaAnt)
Return Nil

/*


Ŀ
Funo    TLogMov    Autor Microsiga S/A           Data  03/02/09 
Ĵ
Descrio  Funcao utilizada para carrega o log de eventos da MOVLOTE  
Ĵ
Parametros                                                            
Ĵ
 Uso       MOVLOTE                                                    
ٱ


*/
Static Function TLogMov(aLogMov,cProcesso,cMensagem,nQtdLote,cLoteCtl,cNumlote,nQtdLoc,cLocaliz,cNumSerie,cAlias,cProduto,cLocal,cTm,cNumSeq,cOp,cDoc,cSerie,cItem,cCliFor,cLoja,cTipoLote,lEstorno,lBaixaEmp,lBxEmpB8,cPedido,cSeqLib,lLocaliz,lDistribui,cCF)
Local aAreaAnt:= {}
Local cLogMov := SuperGetMV('MV_LOGMOV',.F.,'')
Local lLogMov := AllTrim(SubStr(cLogMov,1,1))=='S'

If !lLogMov
	Return
EndIf

Default nQtdLote  := 0
Default nQtdLoc   := 0

Default cProcesso := ''
Default cLoteCtl  := ''
Default cNumlote  := ''
Default cLocaliz  := ''
Default cNumSerie := ''
Default cMensagem := ''
Default cAlias    := ''
Default cProduto  := ''
Default cLocal    := ''
Default cTm       := ''
Default cNumSeq   := ''
Default cOp       := ''
Default cDoc      := ''
Default cSerie    := ''
Default cItem     := ''
Default cCliFor   := ''
Default cLoja     := ''
Default cTipoLote := ''
Default cPedido   := ''
Default cSeqLib   := ''
Default cCF       := ''

Default lEstorno  := .F.
Default lBaixaEmp := .F.
Default lBxEmpB8  := .F.
Default lLocaliz  := .F.
Default lDistribui:= .F.

aAreaAnt:= GetArea()

If lLogMov
	If cProcesso == '100'
		aLogMov := {}
		aAdd(aLogMov,{ {cProcesso,	STR0202	+ cAlias						 + CRLF +;	//"Alias      -> "
									STR0145	+ cProduto			 			 + CRLF +;	//"Produto    -> "
									STR0146	+ cLocal 						 + CRLF +;  //"Local      -> "
									STR0147	+ AllTrim(Str(nQtdLote))	 	 + CRLF +;	//"Quantidade -> "
									STR0148	+ cTm  							 + CRLF +;	//"Tm/Tes     -> "
									STR0149	+ cNumSeq 						 + CRLF +;	//"NumSeq     -> "
									STR0150	+ cOp							 + CRLF +;	//"OP         -> "
									STR0151	+ cDoc 							 + CRLF +;	//"Documento  -> "
									STR0152	+ cSerie 						 + CRLF +;	//"Serie      -> "
									STR0153	+ cItem							 + CRLF +;	//"Item       -> "
									STR0154	+ cCliFor					 	 + CRLF +;	//"Cli/For    -> "
									STR0155	+ cLoja 						 + CRLF +;	//"Loja       -> "
									STR0156	+ cTipoLote						 + CRLF +;	//"Rastro     -> "
									STR0157	+ cLoteCtl 						 + CRLF +;	//"Lote       -> "
									STR0158	+ cNumLote 						 + CRLF +;	//"SubLote    -> "
									STR0159	+ IIf(lLocaliz ,STR0168,STR0169) + CRLF +;	//"Contr.Ender-> "
									STR0160	+ cLocaliz						 + CRLF +;	//"Endereco   -> "
									STR0161	+ cNumSerie 					 + CRLF +;	//"Nro.Serie  -> "
									STR0162	+ IIf(lEstorno  ,STR0168,STR0169)+ CRLF +;	//"lEstorno   -> "
									STR0163	+ IIf(lBaixaEmp ,STR0168,STR0169)+ CRLF +;	//"lBaixaEmp  -> "
									STR0164	+ IIf(lBxEmpB8  ,STR0168,STR0169)+ CRLF +;	//"lBxEmpB8   -> "
									STR0165	+ IIf(lDistribui,STR0168,STR0169)+ CRLF +;	//"lDistribui -> "
									STR0166	+ cPedido 						 + CRLF +;	//"Pedido     -> "
									STR0167	+ cSeqLib						 + CRLF +;	//"SeqLib     -> "
									STR0205 + cCF								}})		//"Tipo RE/DE -> "
	Else
		aAdd(aLogMov,{	{cProcesso	,cMensagem				},;
						{nQtdLote	,cLoteCtl	,cNumLote	},;
						{nQtdLoc	,cLocaliz	,cNumSerie	}})
	EndIf
Else
	aLogMov := {}
EndIf
RestArea(aAreaAnt)
Return Nil

/*


Ŀ
Funcao    CliForOrig Autor Emerson Rony Oliveira    Data   01.Fev.10
Ĵ
Descriao  Obtem o codigo e a loja do cliente/fornecedor com base no CGC
           Caso o Cli/For estejam bloqueados (campos _MSBLQL e _MSBLQD),
           a funcao tenta encontrar um registro desbloqueado.           
Ĵ
Parametros cAlias  = Indica o alias a ser pesquisado (SA1 ou SA2)       
           cCodigo = Retorna o codigo do cliente ou do fornecedor       
           cLoja   = Retorna a loja do cliente ou do fornecedor         
           lUsaFilTrf = Define se sera utilizado o metodo antigo de     
                        localizacao do cliente/fornecedor (CNPJ) ou se  
                        utilizara o metodo novo, atraves dos campos     
                        A1_FILTRF e A2_FILTRF (UPDEST39)                
                                                                        
           IMPORTANTE: O "Alias" enviado estara posicionado.            
Ĵ
Retorno   .T. ou .F.                                                    
Ĵ
Uso        MATA103->A103TrFil / MATA310->A310TOk                        
ٱ


*/
Function CliForOrig(cAlias, cCodigo, cLoja, lUsaFilTrf)
Local cSeek      := ""
Local lRet       := .T.
Local lBloqueado := .F.
Local lMsBlqL    := .F.
Local lMsBlqD    := .F.

Default lUsaFilTrf := .F. // .F. == indica funcionamento padrao da rotina -- atraves do CNPJ do cliente/fornecedor

If cAlias == 'SA1'
	lMsBlqL := (SA1->(FieldPos("A1_MSBLQL")) > 0)
	If lMsBlqL
		lBloqueado := .F.
		cSeek      := xFilial('SA1')+IIf(!lUsaFilTrf, SA1->A1_CGC, SA1->A1_FILTRF)
		While xFilial('SA1')+IIf(!lUsaFilTrf, SA1->A1_CGC, SA1->A1_FILTRF) == cSeek

			If lMsBlqL .And. SA1->A1_MSBLQL == '1' // Esta com bloqueio logico
				lBloqueado := .T.
				SA1->(dbSkip())
				Loop
			Else
				lBloqueado := .F.
			EndIf
			If !lBloqueado
				cCodigo := SA1->A1_COD
				cLoja   := SA1->A1_LOJA
				Exit
			EndIf
			SA1->(dbSkip())
		EndDo
		lRet := !lBloqueado
	Else
		lRet    := .T.
		cCodigo := SA1->A1_COD
		cLoja   := SA1->A1_LOJA
	EndIf
ElseIf cAlias == 'SA2'
	lMsBlqL := (SA2->(FieldPos("A2_MSBLQL")) > 0)
	lMsBlqD := (SA2->(FieldPos("A2_MSBLQD")) > 0)
	If lMsBlqL .Or. lMsBlqD
		lBloqueado := .F.
		cSeek      := xFilial('SA2')+IIf(!lUsaFilTrf, SA2->A2_CGC, SA2->A2_FILTRF)
		While xFilial('SA2')+IIf(!lUsaFilTrf, SA2->A2_CGC, SA2->A2_FILTRF) == cSeek
			If lMsBlqD .And. (!Empty(SA2->A2_MSBLQD) .And. SA2->A2_MSBLQD < dDataBase) // Esta com bloqueio temporal
				lBloqueado := .T.
				SA2->(dbSkip())
				Loop
			Else
				lBloqueado := .F.
			EndIf
			If lMsBlqL .And. SA2->A2_MSBLQL == '1' // Esta com bloqueio logico
				lBloqueado := .T.
				SA2->(dbSkip())
				Loop
			Else
				lBloqueado := .F.
			EndIf
			If !lBloqueado
				cCodigo := SA2->A2_COD
				cLoja   := SA2->A2_LOJA
				Exit
			EndIf
			SA2->(dbSkip())
		EndDo
		lRet := !lBloqueado
	Else
		lRet    := .T.
		cCodigo := SA2->A2_COD
		cLoja   := SA2->A2_LOJA
	EndIf
EndIf

Return lRet

/*


Ŀ
Funcao    PesqMovTranAutor TOTVS S.A.               Data   22/08/14 
Ĵ
Descriao  Pesquisa o movimento interno gerado pelo processo de transito
Ĵ
Retorno    aRet                                                         
Ĵ
Uso        SIGACUSA.PRX                                                 
ٱ


*/
Static Function PesqMovTran(cAliasSQL)
Local aRet     := {.F.,0,0,0}
Local aAreaAnt := GetArea()

Default cAliasSQL := ""

If !Empty(cAliasSQL)
	If (cAliasSQL)->B6_TES < "501"
		SD1->(dbSetOrder(1)) //D1_FILIAL+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_COD+D1_ITEM
		If SD1->(MsSeek(xFilial("SD1")+(cAliasSQL)->B6_DOC+(cAliasSQL)->B6_SERIE+(cAliasSQL)->B6_CLIFOR+(cAliasSQL)->B6_LOJA+(cAliasSQL)->B6_PRODUTO))
			SD3->(dbSetOrder(13)) //D3_FILIAL+D3_IDENT+D3_COD
			If SD3->(MsSeek(xFilial('SD3')+SD1->D1_NUMSEQ+SD1->D1_COD))
				aRet := {.T.,SD3->D3_QUANT,SD3->D3_CUSTO1,SD3->D3_CUSFF1}
			EndIf
		EndIf
	Else
		SD2->(dbSetOrder(3)) //D2_FILIAL+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA+D2_COD+D2_ITEM
		If SD2->(MsSeek(xFilial("SD2")+(cAliasSQL)->B6_DOC+(cAliasSQL)->B6_SERIE+(cAliasSQL)->B6_CLIFOR+(cAliasSQL)->B6_LOJA+(cAliasSQL)->B6_PRODUTO))
			SD3->(dbSetOrder(13)) //D3_FILIAL+D3_IDENT+D3_COD
			If SD3->(MsSeek(xFilial('SD3')+SD2->D2_NUMSEQ+SD2->D2_COD))
				aRet := {.T.,SD3->D3_QUANT,SD3->D3_CUSTO1,SD3->D3_CUSFF1}
			EndIf
		EndIf
	EndIf
EndIf

RestArea(aAreaAnt)
Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} IsProdProt(cCod)
Funo que indica se um produto  prottipo a partir de seu cdigo.
@author antenor.silva
@since 25/10/2013
@version 1.0
@return NIL
/*/
//-------------------------------------------------------------------
Function IsProdProt(cCod)
Local lRet	:=	.F.

SB5->(dbSetOrder(1)) //B5_FILIAL+B5_COD
If SB5->(dbSeek(xFilial('SB5')+cCod)) .And. SB5->B5_PROTOTI
	lRet := .T.
EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} RetDataFab(dDataFab,cProduto, cLoteCtl, cNumLote, dDtValid)
	Esta funo tem por objetivo obter a data de fabricao do lote
	presente na Tabela SB8 - Saldos por lote, a partir do ndice 5 da tabela.
	O parmetro dDataFab  passado por referncia pela funo MovLote, e a mesma
	 carregada pelo contedo do campo B8_DFABRIC da tabela SB8, caso pr-exista
	saldo por lote para a chave em questo.
	Em caso de falha na busca, a data de fabricao  preenchida com o valor
	Default "  /  /  "

@author TOTVS
@since 20/03/2014
@version 1.0
@param
	dDataFab - Data de fabricao do lote ( passada por referencia para ser
				carregada a partir desta funo)
	cProduto - Cdigo do Produto
	cLoteCtl - Nmero do Lote
	cNumLote - Nmero do Sub-Lote
	dDtValid - Data de validade do Lote

@return
	lRet - Flag que indica sucesso ou fracasso no processo de obteno da
	data de fabricao do lote.
	.T. = sucesso
	.F. = falha
/*/
//-------------------------------------------------------------------

Function RetDataFab(dDataFab,cProduto, cLoteCtl, cNumLote, dDtValid)

Local aArea 	 	:= GetArea()
Local lRet 		:= .F.
Local cAlias   	:= "SB8"
DEFAULT dDataFab  := CTOD("  /  /  ")

DbSelectArea(cAlias)
(cAlias)->(DbSetOrder(5)) // FILIAL + PRODUTO + LOTE + SUB-LOTE + DATA VALIDADE

If (cAlias)->(DbSeek(xFilial("SB8")+cProduto+cLoteCtl+cNumLote+DTOS(dDtValid)))
	dDataFab := SB8->B8_DFABRIC
	lRet := .T.
Endif

RestArea(aArea)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} ListOpc(cProduto,mOpc,cOpc,nExibeAll)
Funo que interpreta os opcionais concatenados, e retorna um array com as descries dos grupos e dos itens opcionais.
@author Lucas Konrad Frana
@since 09/09/2014
@param cProduto - Cdigo do produto. Utilizado quando existir o mOpc
@param mOpc - Valor do memo dos opcionais, que ser transformado em um array.
@param cOpc - String concatenada com os opcionais, no formato GGGIIII/ (Grupo, Item)
@param nExibeAll - Utilizado quando existir o mOpc, indicar se sero considerados todos os opcionais (2), ou somente
        o opcional do produto passado por parmetro.
@version 1.0
@return aOpc
/*/
//-------------------------------------------------------------------
Function ListOpc(cProduto,mOpc,cOpc,nExibeAll)
   Local aOpc    := { }
   //Funo migrada para PCPXFUN
   aOpc := aClone(ListOpcPcp(cProduto,mOpc,cOpc,nExibeAll))
Return aOpc

//-------------------------------------------------------------------
/*/{Protheus.doc} VisualOpc(cProduto,mOpc,cOpc,nExibeAll)
Funo que abre uma janela popup para visualizao dos opcionais.
@author Lucas Konrad Frana
@since 09/09/2014
@param cProduto - Cdigo do produto. Utilizado quando existir o mOpc
@param mOpc - Valor do memo dos opcionais, que ser transformado em um array.
@param cOpc - String concatenada com os opcionais, no formato GGGIIII/ (Grupo, Item)
@param nExibeAll - Utilizado quando existir o mOpc, indicar se sero considerados todos os opcionais (2), ou somente
        o opcional do produto passado por parmetro.
@version 1.0
@return .T.
/*/
//-------------------------------------------------------------------
Function VisualOpc(cProduto,mOpc,cOpc,nExibeAll)
  	//Funo migrada para PCPXFUN
	VisOpcPcp(cProduto,mOpc,cOpc,nExibeAll)
Return .T.


//-------------------------------------------------------------------
/*/{Protheus.doc} SIGACUSA_V
Verifica a data da ltima alterao do SIGACUS (DEVER SER RETIRADA APS A DIVISO DESTE FONTE ENTRE OS MDULOS)

@author jose.eulalio
@since 08/05/2014
@version P12
@return nRet
/*/
//-------------------------------------------------------------------
Function SIGACUSA_V
Local nRet := 20140508
Return nRet

/*

Ŀ
Funcao     LMovSBD   Autor  Materiais               Data   08/01/14 
Ĵ
Descriao  Percorre SDB validando se existe um registro do mesmo NUMSEQ 
           e Lote apenas para producoes                                 
Ĵ
Retorno    lRet                                                         
Ĵ
Uso        LOGMOV                                                       
ٱ

*/
Static Function LMovSBD(cProduto,cLocal,cNumSeq,cLoteCtl)

Local aAreaSDB := SDB->(GetArea())
Local cSeek    := ""
Local lRet     := .F.

dbSelectArea('SDB')
dbSetOrder(1)
If dbSeek(cSeek := xFilial("SDB")+cProduto+cLocal+cNumSeq, .F.)
	Do While SDB->(!Eof()) .And. SDB->(DB_FILIAL+DB_PRODUTO+DB_LOCAL+DB_NUMSEQ) == cSeek
		If SDB->DB_LOTECTL == cLoteCtl
			lRet := .T.
			Exit
		EndIf
		SDB->(dbSkip())
	EndDo
EndIf

RestArea(aAreaSDB)

Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} CusRound
Funo para arredondar ou no o custo das movimentaes

@author Bruno.Schmidt
@since 11/12/2017
@version P12
@return nCusto
/*/
//-------------------------------------------------------------------
Function CusRound(nCalc,nMoe)
Local nCusto	:= 0
Local lRound	:= EstGetMV("MV_CMROUND",.F.,.F.)
Local cChave
Local cNameField
Local nCM1Dec	:= 0

STATIC oJTMB2_CM

default nMoe := 1

IF oJTMB2_CM == NIL
	oJTMB2_CM := JsonObject():New()
	oJTMB2_CM:fromJson("{}")
ENDIF

cNameField := 'B2_CM'+cValToChar(nMoe)
cChave := cFilAnt+cNameField

nCM1Dec := oJTMB2_CM[cChave]
IF nCM1Dec == NIL
	nCM1Dec := TamSx3(cNameField)[2]
	oJTMB2_CM[cChave] := nCM1Dec
ENDIF

IF lRound
	nCusto := Round(nCalc,nCM1Dec)
Else
	nCusto := NoRound(nCalc,nCM1Dec)
EndIf

Return nCusto

//-------------------------------------------------------------------
/*/{Protheus.doc} VldQtdPerd
Funo para validao do saldo da perda

@author Michele Girardi
@since 09/01/2018
@version P12
/*/
//-------------------------------------------------------------------
 Static Function VldQtdPerd(cRotOrig, nSaldo, nQtdTot, cCodProd, cLocal, cLotCtl, cLote ,cEnd, cSerie)
 //-------------------------------------------------------------------
 Local lRet := .T.

 //Validar somente para a perda do MATA250
 IF cRotOrig != 'MATA250'
 	lRet := .F.
 EndIf

 //Se controlar lote, endereo ou srie deve possuir saldo em estoque
 If lRet
 	If !Empty(cLotCtl) .Or. ;
 		!Empty(cLote) .Or. ;
 		!Empty(cEnd) .Or. ;
 		!Empty(cSerie)
 		lRet := .F.
 	EndIf
 EndIf

 //Se o produto informado para perda for diferente do produto da OP deve possuir saldo em estoque
 //Se o local informado para perda for diferente do produto da OP deve possuir saldo em estoque
 //Se a quantidade informada na perda para o PA for maior que a produzida deve possuir saldo em estoque
 If lRet
 	IF cRotOrig == 'MATA250'
 		If M->D3_COD != cCodProd .Or. M->D3_QUANT < nQtdTot .Or. M->D3_local != cLocal
 			lRet := .F.
 		EndIf
 	EndIF
 EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} LOGCRITMP
Funo para cria o LOG de Ocorrncias caso houver
@author Adriano.Vieira
@since 05/04/2018
@version 1.0
/*/
//-------------------------------------------------------------------
Function LOGCRITMP(cEmpJob,cFilJob)
Local aCampos 	:= {}
Local cInvRes		:= ''
Local aArea		:= GetArea()

// Seta job para nao consumir licensas
RpcSetType(3)

// Seta job para empresa filial desejadas
RPCSetEnv(cEmpJob,cFilJob,,,'EST')

cInvRes 	:= 'LOGMOVMT'

//-- Criao da Tabela de Dados de Registros de Log
AADD(aCampos ,{"LOG_FILIAL"	,"C",2						,0})
AADD(aCampos ,{"LOG_COD"		,"C",Len(SB1->B1_COD)	,0})
AADD(aCampos ,{"LOG_LOCAL"	,"C",Len(SB1->B1_LOCPAD)	,0})
AADD(aCampos ,{"LOG_DATA"	,"D",8						,0})
AADD(aCampos ,{"LOG_STATUS"	,"N",2						,0})

If !MsFile(cInvRes,,"TOPCONN")
	//--Cria tabela temporria no banco de dados
	DBCreate(cInvRes,aCampos,"TOPCONN")
	dbUseArea( .T.,"TOPCONN", cInvRes, "LOGMOVMT", .T., .F. )

	cNameIdx := FileNoExt(cInvRes)

	INDEX ON LOG_FILIAL+LOG_COD+LOG_LOCAL+DTOS(LOG_DATA) TAG &(cNameIdx+"1") TO &(cNameIdx)
	dbClearIndex()
	dbSetIndex( cNameIdx )
EndIf

RpcClearEnv()

restArea(aArea)
Return

/*/{Protheus.doc} MaxSD2Emis
// Obtem a maior data de emissao de um documento de saida, desde que o produto tenha movimentado estoque
@author reynaldo
@since 07/08/2018
@version 1.0
@return date, data selecionada
@param cProduto, characters, descricao
@param cLocal, characters, descricao
@param cNumSeq, characters, descricao
@param dEmissao, date, descricao
@param lGetLast, logical, descricao
@type function
/*/
Static Function MaxSD2Emis(cProduto, cArmazem, cNumSeq, dEmissao, lGetLast)

Local cAliasSD2 := ""
Local cQuery	:= ""
Local cQryField	:= ""
Local cQryFrom	:= ""
Local cQryOrder	:= ""
Local cDBMS		:= ""
Local dUltSaida	:= stod("")
Local cAliasOld	:= ""

DEFAULT lGetLast := .F.

If lGetLast

	cAliasOld	:= Alias()
	cDBMS		:= TCGetDB()
	cAliasSD2	:= GetNextAlias()

	cQryField := ""

	cQryFrom += " FROM " + RetSQLName("SD2") +" SD2 "
	cQryFrom += " LEFT JOIN " + RetSQLName("SF4") +" SF4 ON SF4.F4_FILIAL = '" + xFilial("SF4") + "' "
	cQryFrom += " AND SF4.F4_CODIGO = SD2.D2_TES "
	cQryFrom += " AND SF4.F4_ESTOQUE = 'S' "
	cQryFrom += " AND SF4.D_E_L_E_T_= ' ' "
	cQryFrom += " WHERE SD2.D2_FILIAL = '" + xFilial("SD2") + "' "
	cQryFrom += " AND SD2.D2_COD = '" + cProduto + "' "
	cQryFrom += " AND SD2.D2_LOCAL = '" + cArmazem + "' "
	cQryFrom += " AND SD2.D2_ORIGLAN <> 'LF' "
	cQryFrom += " AND SD2.D2_NUMSEQ <> ' "+cNumSeq+"' "
	cQryFrom += " AND SD2.D_E_L_E_T_ = ' ' "

	cQryOrder := " ORDER BY SD2.D2_EMISSAO DESC "

	cQuery := ""
	cQuery += "SELECT "
	cQuery += cQryField

	If cDBMS == 'MYSQL' .OR. cDBMS == 'POSTGRES'
		cQryField := " SD2.D2_EMISSAO EMISSAO "
		cQuery := "SELECT "+ cQryField + cQryFrom + cQryOrder + " LIMIT 1 "

	ElseIf cDBMS == 'ORACLE'
		cQryField := " SD2.D2_EMISSAO EMISSAO "
		cQuery := "SELECT EMISSAO FROM ( SELECT " + cQryField + cQryFrom + cQryOrder + " ) WHERE ROWNUM < 2 "

	ElseIf cDBMS == 'DB2'
		cQryField := " SD2.D2_EMISSAO EMISSAO "
		cQuery := "SELECT "+ cQryField + cQryFrom + cQryOrder + "FETCH FIRST 1 ROWS ONLY"

	ElseIf cDBMS == 'MSSQL'
		cQryField := " SD2.D2_EMISSAO EMISSAO "
		cQuery := "SELECT TOP 1 "+ cQryField + cQryFrom +  cQryOrder

	Else
		cQryField := " MAX(SD2.D2_EMISSAO) EMISSAO "
		cQuery := "SELECT " + cQryField + cQryFrom
	EndIf

	cQuery := ChangeQuery(cQuery)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSD2,.T.,.T.)
	dUltSaida := STOD((cAliasSD2)->EMISSAO)
	(cAliasSD2)->(dbCloseArea())

	If ! Empty(cAliasOld)
		dbSelectArea(cAliasOld)
	EndIf

Else
	dUltSaida := dDatabase
EndIf

Return dUltSaida

/*/{Protheus.doc} ClrCachOpc
Limpa o array aOpcCache de escopo Static

@author lucas.franca
@since 04/01/2019
@version 1.0
@return Nil
@type function
/*/
Function ClrCachOpc()
	aOpcCache := {}
Return


/*/{Protheus.doc} SldEmpLE
Busca saldo do empenho por lote e endereo

@author michele.girardi
@since 27/02/2019
@version 1.0
@return Nil
@type function
/*/
Function SldEmpLE(cProduto, cLocalOrig, cLoteCtl, cNumLote)
Local aAreaSD4	:=	SD4->( GetArea() )

cNumOP := cOrdemP
nQuant := 0

dbSelectArea("SD4")
SD4->(dbSetOrder(2))
SD4->(dbSeek(cSeek:=xFilial("SD4")+cNumOP+cProduto+cLocalOrig))
Do While !Eof() .And. cSeek == SD4->(D4_FILIAL+D4_OP+D4_COD+D4_LOCAL)
	If SD4->(D4_LOTECTL+If(Rastro(D4_COD,"S"),D4_NUMLOTE,"")) == (cLoteCtl+If(Rastro(cProduto,"S"),cNumLote,""))
		//--Verifica a existencia de relacionamento no SDC
		dbSelectArea("SDC")
		SDC->(dbSetOrder(2))
		SDC->(dbSeek(cSeek2:=xFilial("SDC")+SD4->(D4_COD+D4_LOCAL+D4_OP+D4_TRT+D4_LOTECTL+D4_NUMLOTE)))
		While !SDC->(EOF()) .And. cSeek2 == SDC->(DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL+DC_NUMLOTE)
			If  cSeek2 == SDC->(DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL+DC_NUMLOTE)
				nQuant += SDC->DC_QUANT
			EndIf
			SDC->(dbSkip())
		End
	EndIf
	SD4->(dbSkip())
EndDo

RestArea(aAreaSD4)

Return nQuant

/*/{Protheus.doc} SldEmpLO
Busca saldo do empenho por lote e sublote

@author michele.girardi
@since 27/02/2019
@version 1.0
@return Nil
@type function
/*/
Function SldEmpLS(cProduto, cLocalOrig, cLoteCtl, cNumLote, dDtMvt)

Local aAreaB8  := SB8->(GetArea())
Local cAliasLS := ""
Local cNumOP   := ""
Local cQuery   := ""
Local nQuant   := 0
Local nSaldoB8 := 0

cNumOP  := cOrdemP

//Se a Data de incio do lote for MAIOR que a data do movimento - o lote ainda no est disponvel e deve retornar zero.
cQuery := " SELECT SB8.* "
cQuery += "   FROM " +RetSqlName("SB8")+" SB8 "
cQuery += "  WHERE SB8.B8_FILIAL  = '"+xFilial("SB8")+"' "
cQuery += "    AND SB8.B8_PRODUTO = '"+cProduto+"' "
cQuery += "    AND SB8.B8_LOCAL   = '"+cLocalOrig+"' "
cQuery += "    AND SB8.B8_SALDO   > 0 "
cQuery += "    AND SB8.D_E_L_E_T_ = ' '  "

If !Empty(cLoteCtl)
	cQuery += " AND SB8.B8_LOTECTL = '"+cLoteCtl+"' "
EndIf 

cQuery := ChangeQuery(cQuery)

cAliasLS := GetNextAlias()

dbUseArea( .T., 'TOPCONN', TcGenQry(,,cQuery), cAliasLS, .T., .F. )

If !(cAliasLS)->(Eof())
	dDtIni :=  STOD((cAliasLS)->B8_DATA)

	If dDtIni <= dDtMvt
		nSaldoB8 := (cAliasLS)->B8_SALDO
	EndIf
EndIf 

(cAliasLS)->(dbCloseArea())

SB8->(RestArea(aAreaB8))

If nSaldoB8 <= 0
   Return nQuant
EndIf

dbSelectArea("SD4")
SD4->(dbSetOrder(2))
SD4->(dbSeek(cSeek:=xFilial("SD4")+cNumOP+cProduto+cLocalOrig))
Do While !Eof() .And. cSeek == SD4->(D4_FILIAL+D4_OP+D4_COD+D4_LOCAL)
	If SD4->(D4_LOTECTL+If(Rastro(D4_COD,"S"),D4_NUMLOTE,"")) == (cLoteCtl+If(Rastro(cProduto,"S"),cNumLote,""))
		nQuant += SD4->D4_QUANT
	EndIf

	SD4->(dbSkip())
EndDo

Return nQuant

/*/{Protheus.doc} CustEF
	tratamento complementar a funcao RetCustEnt() para retornar os dados do documento de Compra,
	considerando que o item de documento corrente faz parte do documento de recebimetno
   @type  Function
   @author Reynaldo Miyashita
   @since 07/08/2019
   @version 1.0
	@param aNFCompra, Array, Contem os dados do documento desejado
   @return aCusEF, Array, Contem os dados dos impostos do documento de Compra(Simples Faturamento)
/*/
Static Function CustEF(aNFCompra)
Local aArea    := {}
Local aAreaSD1 := {}
Local aAreaDHQ := {}
Local aCusEF   := {}
Local cIdEF	   := ""

DEFAULT aNFCompra := {}

	aArea := GetArea() // salvar a area corrente

	If Empty(aNFCompra)
		// posiciona a DHQ do documento de recebimento pra encontrar na SD1 o documento de simples faturamento(COMPRA) atravs do ID Entrega Futura
		dbSelectArea("DHQ")
		aAreaDHQ := DHQ->(GetArea())
		dbSetOrder(1) // DHQ_FILIAL+DHQ_DOC+DHQ_SERIE+DHQ_FORNEC+DHQ_LOJA+DHQ_ITEM
		If dbSeek(xFilial("DHQ")+SD1->(D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_ITEM))
			cIdEF := DHQ->DHQ_IDENT

			dbSetOrder(2) // DHQ_FILIAL+DHQ_IDENT+DHQ_TIPO+DHQ_DOC+DHQ_SERIE+DHQ_ITEM
			If dbSeek(xFilial("DHQ")+cIdEF+"1")
				aNFCompra := {DHQ->DHQ_DOC,DHQ->DHQ_SERIE,DHQ->DHQ_FORNEC,DHQ->DHQ_LOJA,DHQ->DHQ_ITEM}
			EndIf
		EndIf
		RestArea(aAreaDHQ)
	EndIf

	If !Empty(aNFCompra)
		// posiciona a DHQ pra buscar na SD1 o documento de simples faturamento(COMPRA)
		dbSelectArea("DHQ")
		aAreaDHQ := DHQ->(GetArea())
		dbSetOrder(1) // DHQ_FILIAL+DHQ_DOC+DHQ_SERIE+DHQ_FORNEC+DHQ_LOJA+DHQ_ITEM
		If dbSeek(xFilial("DHQ")+aNFCompra[1]+aNFCompra[2]+aNFCompra[3]+aNFCompra[4]+aNFCompra[5])
			// Posiciona SD1 no registro da nota origem (simples faturamento) e guarda no array aCusEF os valores deste item para utilizar no custo
			dbSelectArea("SD1")
			aAreaSD1 := SD1->(GetArea())
			dbSetOrder(1) //D1_FILIAL+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_COD+D1_ITEM
			If dbSeek(xFilial("SD1")+DHQ->(DHQ_DOC+DHQ_SERIE+DHQ_FORNEC+DHQ_LOJA+DHQ_COD+DHQ_ITEM))
				aAdd(aCusEF,{SD1->D1_FILIAL,SD1->D1_DOC,SD1->D1_SERIE,SD1->D1_FORNECE,SD1->D1_LOJA,SD1->D1_COD,SD1->D1_ITEM,SD1->D1_QUANT, SD1->D1_TOTAL, SD1->D1_VALIMP1, SD1->D1_VALIMP2,SD1->D1_VALIMP3,SD1->D1_VALIMP4,SD1->D1_VALIMP5,SD1->D1_VALIMP6,SD1->D1_VALIPI})
			EndIf
			RestArea(aAreaSD1)
		EndIf
		RestArea(aAreaDHQ)

	EndIf

RestArea(aArea) // retorno para area corrente
Return aCusEF

/*/{Protheus.doc} AgregaOri
	Indica se na manuteno do registro de lote na SB8 dever ser agregado o saldo ao campo B8_QRDORI.
	Funo utilizada nos itens da Nota de Entrada (SD1) na MATA103
	@type  Function
	@author SQUAD Entradas
	@since 21/11/2019
	@version P12.1.25
	@param aItensOri, Array, Array de controle de itens para no realizar a mesma consulta na SB8 para um item j consultado
	@param cFilSD1, Caracter, Filial do item a ser consultado
	@param cProduto, Caracter, Produto a ser consultado
	@param cLocal, Caracter, Armazm a ser consultado
	@param dValid, Date, Data de Validade do Lote a ser consultado
	@param cLote, Caracter, Lote a ser consultado
	@param cLote, cNumLote, SubLote a ser consultado. Dever sempre receber um valor, nem que seja somente uma string em branco
	@return lRet, Boolean, indica se na manuteno do registro do lote na SB8 dever ser agregado o valor no campo B8_QTDORI
	@example
		lAgregaOri = AgregaOri(@aItens, FWxFilial("SB8"), "COD000000000001", "01", StoD('20191121'), "L01       ", "      ")
/*/
Function AgregaOri(aItensOri, cFilSD1, cProduto, cLocal, dValid, cLote, cNumLote)

	Local lRet := .F.
	Local cChave := cFilSD1 + cProduto + cLocal + DtoS(dValid) + cLote + cNumLote
	Local aArea := GetArea()
	Local nPos := Ascan(aItensOri, {|x| x[1] == cChave })

	If nPos == 0

		SB8->(dbSetOrder(1))

		If SB8->(dbSeek(cChave))

			lRet := .F.

		Else

			lRet := .T.

		EndIf

		Aadd(aItensOri, {cChave, lRet})

	Else

		lRet := aItensOri[nPos][2]

	EndIf

	RestArea(aArea)

Return lRet



/*/{Protheus.doc} GeraQuality
	qualidade.
	@type  Function
	@author mauricio.joao
	@since 24/07/2020
	@version 1.0
	@param param_name, param_type, param_descr
	@return lRet, logical, retorno se enviou para o qualidade.
	/*/
Function GeraQuality()
Local aAreaSD3  := {}
Local aEnvCele 	:= {}
Local cLocCQ 	:= GetMvNNR('MV_CQ','98')
Local lMA260NFQ := NIL
Local lQtdRep   := If(GetMv("MV_QTRFREP")=="S",.T.,.F.)
Local lQualyCQ 	:= .F.
Local lRet 		:= .T.

//-- Inclui o Produto Destino no CQ
If AllTrim(cLocCQ) == AllTrim(SD3->D3_LOCAL) //.And. AllTrim(cLocCQ) # AllTrim(aCols[n,nPosLOCOri])

	fGeraCQ0('SD3', SD3->D3_COD, 'TR', SD3->D3_LOCAL)

	//Ŀ
	// Atualiza o CQ do modulo SigaQuality                   
	//
	SB1->(dbSetOrder(1))
	lQualyCQ := SB1->(dbSeek(xFilial("SB1")+SD3->D3_COD)) .And. RetFldProd(SB1->B1_COD,"B1_TIPOCQ") == "Q"

	If lQualyCQ

	lMA260NFQ := If(lMA260NFQ== Nil,ExistBlock("MA260NFQ"),lMA260NFQ)

		//-------------------------------------------//
		If lMA260NFQ
			lQualyCQ := Execblock("MA260NFQ",.F.,.F.)
			lQualyCQ := If(ValType(lQualyCQ)#"L",.T.,lQualyCQ)
		Else
			aAreaSD3 := SD3->(GetArea())
			If !a260NFOrig(SD3->D3_COD, SB1->B1_LOCPAD, SD3->D3_LOTECTL, SD3->D3_NUMLOTE, .T.,SD3->D3_LOCAL,)
				If Aviso(STR0246,STR0247+ AllTrim(SD3->D3_COD) + STR0248,{STR0249,STR0250}) == 1 // 'Siga Quality'###'Envia o Produto '###' somente para CQ Materiais?'###'Sim'###'Aborta'
					lQualyCQ := .F.
				Else
					Return(.F.)
				EndIf
			EndIf
			RESTAREA(aAreaSD3)
		EndIf

		If lQualyCQ
			If Alias() == 'SWN'
				cForNFO := SWN->WN_FORNECE
				cLojNFO := SWN->WN_LOJA
				cDocNFO := SWN->WN_DOC
				cSerNFO := SWN->WN_SERIE
				cTipNFO := SWN->WN_TIPO_NF
				nQtdOri := SWN->WN_QUANT
				cItemNF := StrZero(Val(SWN->WN_ITEM),2)
				nPreco  := SWN->WN_VALOR

				SD1->(dbSetOrder(1))
				If SD1->(dbSeek(xFilial('SD1')+cDocNFO+cSerNFO+cForNFO+cLojNFO+cCodEIC))
					cPedNFO := SD1->D1_PEDIDO
					cIPCNFO := SD1->D1_ITEMPC
					cDocEnt := SD1->D1_LOTEFOR
					dNotFis := SD1->D1_EMISSAO
				EndIf
			Else
				cForNFO := SD1->D1_FORNECE
				cLojNFO := SD1->D1_LOJA
				cPedNFO := SD1->D1_PEDIDO
				cDocNFO := SD1->D1_DOC
				cSerNFO := SD1->D1_SERIE
				cTipNFO := SD1->D1_TIPO
				cIPCNFO := SD1->D1_ITEMPC
				nQtdOri := SD1->D1_QUANT
				cItemNF := SD1->D1_ITEM
				cDocEnt := SD1->D1_LOTEFOR
				dNotFis := SD1->D1_EMISSAO
				nPreco  := SD1->D1_VUNIT
			EndIf

			// Atualizando SD7, referente dados da NF original - Geovani - 06/04/2022
			Reclock('SD7', .F.)
				SD7->D7_DOC     := cDocNFO
				SD7->D7_SERIE   := cSerNFO
				SD7->D7_FORNECE := cForNFO
				SD7->D7_LOJA    := cLojNFO
			MsUnlock('SD7')
		//-------------------------------------------//

			nAtraso    := 0
			nSC7OrdAnt := SC7->(IndexOrd())
			nSC7RecAnt := SC7->(Recno())
			SC7->(dbSetOrder(1))
			If SC7->(dbSeek(xFilial('SC7')+cPedNFO+cIPCNFO, .F.))
				nAtraso := SD3->D3_DTVALID-SC7->C7_DATPRF
			EndIf

			SC7->(dbSetOrder(nSC7OrdAnt))
			SC7->(dbGoto(nSC7RecAnt))
			//Ŀ
			//Posiciona o Registro do SD5, para envio do LOTECTL+NUMLOTE a  
			// qAtuMatQie().												 
			//
			cLotCtlQie := ''
			cNumLotQie := ''
			If Rastro(SD3->D3_COD,"L") .Or. Rastro(SD3->D3_COD,"S")
				aAreaSD5 := SD5->(GetArea())
				SD5->(dbSetOrder(3))
				If SD5->(dbSeek(xFilial('SD5')+SD3->D3_NUMSEQ+SD3->D3_COD+SD3->D3_LOCAL+SD3->D3_LOTECTL,.F.))
					cLotCtlQie := SD5->D5_LOTECTL
					cNumLotQie := SD5->D5_NUMLOTE
				EndIf
				SD5->(dbSetOrder(aAreaSD5[2]))
				SD5->(dbGoto(aAreaSD5[3]))
			EndIf

			//Ŀ
			// Passa LOTECTL+NUMLOTE p/ser gravado nos campos de Lote do QIE
			//
			nSC7OrdAnt := SC7->(IndexOrd())
			nSC7RecAnt := SC7->(Recno())
			SC7->(dbSetOrder(1))
			If SC7->(dbSeek(xFilial('SC7')+cPedNFO+cIPCNFO, .F.))
				nAtraso := SD3->D3_DTVALID-SC7->C7_DATPRF
			Else
				nAtraso := 0
			EndIf

			SC7->(dbSetOrder(nSC7OrdAnt))
			SC7->(dbGoto(nSC7RecAnt))
			//Ŀ
			// Grava os dados referentes ao Inspecao de Entradas (SIGAQIE)  
			//

			//Grava a quantidade original do item rejeitado
			If !lQtdRep
				cItemNF := ''
				cDocEnt := SD3->D3_DOC
				dNotFis := SD3->D3_EMISSAO
				nPreco  := SD3->D3_CUSTO1
			EndIf

			aEnvCele := {cDocNFO				,; //Numero da Nota Fiscal
				cSerNFO							,; //Serie da Nota Fiscal
				cTipNFO 						,; //Tipo da Nota Fiscal
				dNotFis							,; //Data de Emissao da Nota Fiscal
				SD3->D3_EMISSAO					,; //Data de Entrada da Nota Fiscal
				"TR"							,; //Tipo de Documento
				cItemNF							,; //Item da Nota Fiscal
				Space(TamSX3("D1_REMITO")[1])	,; //Numero do Remito (Localizacoes)
				cPedNFO							,; //Numero do Pedido de Compra
				Space(TamSX3("D1_ITEMPC")[1])	,; //Item do Pedido de Compra
				cForNFO							,; //Codigo Fornecedor/Cliente
				cLojNFO							,; //Loja Fornecedor/Cliente
				cDocEnt							,; //Numero do Lote do Fornecedor
				Space(6)						,; //Codigo do Solicitante
				SD3->D3_COD						,; //Codigo do Produto
				SD3->D3_LOCAL					,; //Local Origem
				cLotCtlQie						,; //Numero do Lote
				cNumLotQie						,; //Sequencia do Sub-Lote
				SD3->D3_NUMSEQ					,; //Numero Sequencial
				SD7->D7_NUMERO					,; //Numero do CQ
				SD3->D3_QUANT					,; //Quantidade
				nPreco							,; //Preco
				nAtraso							,; //Dias de atraso
				" "								,; //TES
				AllTrim(FunName())				,; //Origem
				" "								,; //Origem TXT
				PadR(nQtdOri,15)}				   //Tamanho do lote original

			//Ŀ
			// Realiza a integracao Materiais x Inspecao de Entradas		 
			//
			aRecCele := qAtuMatQie(aEnvCele,1)

			//Ŀ
			// Liberao Automatica (FREE-PASS) - Parametrizada no SigaQIE  
			//
			If aRecCele[1] == 'C' .or. aRecCele[1] =='L'
				//-- Liberar totalmente a movimentao no SD7 com Free-Pass
				aMov := {}
				aAdd(aMov, {})
				aAdd(aMov[Len(aMov)], 1)
				aAdd(aMov[Len(aMov)], SD7->D7_SALDO)
				aAdd(aMov[Len(aMov)], SD7->D7_LOCDEST)
				aAdd(aMov[Len(aMov)], SD7->D7_DATA)
				aAdd(aMov[Len(aMov)], '')
				aAdd(aMov[Len(aMov)], '')
				aAdd(aMov[Len(aMov)], aRecCele[2])
				aAdd(aMov[Len(aMov)], SD7->D7_QTSEGUM)
				fGravaCQ(SD7->D7_PRODUTO, SD7->D7_NUMERO, .F., aMov, PegaCMD3())
			EndIf
		EndIf
	EndIf
EndIf

Return lRet

/*/{Protheus.doc} EstGetMv
	Faz cache da SX6 neste fonte, conforme parametros pesquisados.
	Similar a supergetmv().

	MANTER a funo como STATIC para no causar impacto em outros fontes.

	@type  Function
	@author Reynaldo Miyashita
	@since 28/07/2020
	@version 1.0
	@param cParametro, caracter, Parametro a ser pesquisado
	@param lHelp, logico, .T. deve apresentar mensagem
	@param cDefault, caracter, Conteudo padro, caso no encontre
	@param cFil, caracter, Codigo da Filial
	@return xResultado, indefinido, conteudo o parametro
	@example
	(examples)
	@see (links_or_references)
/*/
Static Function EstGetMv( cParametro , lHelp , cDefault , cFil )

Local cSvFilAnt  := cFilAnt
Local xResultado := NIL
Local cPesquisa

Static _EstGetMV

IF PCount() == 0.00

	IF _EstGetMV <> NIL
		_EstGetMV:fromJson("{}")
   EndIf
	_EstGetMV := NIL

Else

	DEFAULT cFil := cFilAnt

	If _EstGetMV == NIL
		_EstGetMV := JsonObject():New()
	EndIf

	cFilAnt	:= cFil

	cPesquisa := cFilAnt+cParametro
	xResultado := _EstGetMV[cPesquisa]
	IF xResultado == NIL
		xResultado := SuperGetMv( cParametro , lHelp , cDefault )
		_EstGetMV[cPesquisa] := xResultado
	EndIF

	cFilAnt := cSvFilAnt
EndIF

Return( xResultado )

/*/{Protheus.doc} ESTTamSX3
	Faz cache do resultado da funcao TamSX3() para as fun?es do
	fonte MATA330 melhorando assim o tempo de execu?o.
	Assim evitando o alto consumo na	funcao TAMSX3().
	@type  Function
	@author reynaldo
	@since 26/02/2021
	@version 1.0
	@param cCampo, caracter, Nome do campo a ser pesquisado
	@param aTamSX3, array, Array statico declarado no fonte onde ocorre a chamada desta funcao.
/*/
Function ESTTamSX3(cCampo, aTamSX3 )
Local xResultado := NIL
Local cPesquisa

DEFAULT cCampo := ""

IF cCampo == ""

	IF aTamSX3 <> NIL
		aTamSX3:fromJson("{}")
   EndIf
	aTamSX3 := NIL

	// devido a ter uma variavel estatica que faz uso no sigacusa,
	// foi aplicado este tratamento para garantir que seja resetado tambem junto a
	// variavel estatica do mata330
	IF _aTamSX3 <> NIL
		_aTamSX3:fromJson("{}")
   EndIf
	_aTamSX3 := NIL

Else

	If aTamSX3 == NIL
		aTamSX3 := JsonObject():New()
	EndIf

	cPesquisa := cEmpAnt+cCampo
	xResultado := aTamSX3[cPesquisa]
	IF xResultado == NIL
		xResultado := TamSX3( cCampo )
		aTamSX3[cPesquisa] := xResultado
	EndIF

EndIF

Return( xResultado )

/*


Ŀ
Funo CargaLtD    Autor Ana Paula dos Santos      Data  06/05/21 
Ĵ
Descrio  Preenche o lote e data destino                             
ٱ


*/
Function CargaLtD()

Local lRet:=.T.
LOCAL lLtPrd:=GetNewPar("MV_LTPRD",.T.)
Local cLoteCtl := ' '

//Se o campo 'BC_LOTDEST' no existir - retorna
If !(SBC->(FieldPos('BC_LOTDEST')) > 0)
   Return lRet
EndIf

//Se o item destino no controla lote no carrega nada
If !Rastro(SBC->BC_CODDEST)
	Return lRet
EndIf

//Se parametro MV_LTPRD = T carrega lote destino igual lote origem;
//seno ir gerar lote automtico
IF Empty(SBC->BC_LOTDEST)
	If lLtPrd .And. Rastro(SBC->BC_PRODUTO)
		SBC->BC_LOTDEST:=SBC->BC_LOTECTL
	Else
		cLoteCtl := If(Empty(cLoteCtl),NextLote(SBC->BC_CODDEST,"L"),cLoteCtl)
		cLoteCtl := If(Empty(cLoteCtl),"AUTO"+cLoteCtl,cLoteCtl)
		SBC->BC_LOTDEST:=cLoteCtl
	EndIF
EndIf

//A data de validade destino ser sempre carregada conforme a data de validade origem
If SBC->(FieldPos('BC_DTVLDES')) > 0
	IF Empty(SBC->BC_DTVLDES)
		If Rastro(SBC->BC_PRODUTO)
			SBC->BC_DTVLDES:=SBC->BC_DTVALID
		Else
			SBC->BC_DTVLDES:=DATE()
		EndIf
	EndIf
EndIf

Return lRet

/*/{Protheus.doc} SetEmpenho
	Seta Empenho da variavel static __lEmpenho
	@type  Function
	@author maiara.cunhago
	@since 28/06/2023
	@version v1.0
	@param lEmpenho, logico, Empenho
	@return nil, nil, nil.
	/*/
Function SetEmpenho(lEmpenho)
	
__lEmpenho := lEmpenho

Return nil
