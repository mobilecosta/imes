#INCLUDE "TBICONN.CH"
#INCLUDE "FILEIO.CH"
#INCLUDE "FWEVENTVIEWCONSTS.CH"
#INCLUDE "Fwlibversion.ch"
#INCLUDE "MATA330.CH"
#INCLUDE "PROTHEUS.CH"

#DEFINE USADO CHR(0)+CHR(0)+CHR(1)
#DEFINE _RMCONS "1A"

#Define SB2_MOD '1'
#Define SB2_GRV '2'
#Define SB2_OBR '3'
#Define SB2_ALL SB2_MOD+SB2_GRV+SB2_OBR

#DEFINE DEF_SPS_FROM_RPO                "1"
#DEFINE DEF_SPS_NOT_INSTALLED           "2"

Static lMA330D1 :=.F.
Static lMA330D2 :=.F.
Static lMA330D3 :=.F.
Static lMA330CP :=.F.
Static lMA330TRF:=.F.
Static lM330DSDA:=.F.
Static lCstPart :=.F.
Static lIntCusTMS := .F.
Static aRegraCP
Static nProdProp
Static cAliasTemp := ""
// Array com filiais a serem processadas na contabilizacao
Static a330RegCTB := {}
// Moedas para calculo do custo medio - Sempre processa moeda 1
Static cMoeda330C
// Nomes das tabelas "temporárias"
Static cNomTRA
Static cNomTRB
Static cNomTRBSG1
Static cNomTRC
Static cNomTRD
Static cNomTRT
Static cNomTRX
Static cNomTR2
Static __MV_PCOINTE // Cache por filial sobre conteudo do parametro MV_PCOINTE
Static cFilBack
Static dIniBack

Static _A330MOD

Static _MV_M330THR // cache da 1a filial sobre o conteudo do parametro _MV_M330THR

Static _aTamSX3
Static _oItem

Static __lLibVer := Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MATA330  ³ Autor ³ Bregantim / Stiefano  ³ Data ³ 01/10/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Recalculo do Custo MEDIO / FIFO / LIFO.                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpL1 = Indicacao da variavel de processamento em batch    ³±±
±±³          ³ ExpA2 = Lista com as filiais a serem consideradas (Batch)  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MATA330(lBat,aListaFil,lSemParte,aParAuto,oJour,lOnbord,cUserNameJ, l331x330)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Salva a Integridade dos dados de Entrada                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LOCAL aLogsPart := {}
LOCAL aLogsRep  := {}
LOCAL aLogDec   := {}
LOCAL lDigita,lAglutina
LOCAL oSay,oSay2
LOCAL oBtn1,oBtn2
LOCAL oDlg
LOCAL lExistProc
LOCAL lEnviron:= FindFunction("ACVERVLD")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variaveis utilizadas no calculo do custo de transporte       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LOCAL nRateioFrota  :=1
LOCAL nRateioVeiculo:=1
LOCAL nRateioViagem :=1

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variaveis utilizadas para validar a utilizacao de procedures ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PRIVATE cSPMAT004 := GetSPName("MAT004","19")
PRIVATE cSPMAT007 := GetSPName("MAT007","19")
PRIVATE cSPMAT009 := GetSPName("MAT009","19")
PRIVATE cSPMAT013 := GetSPName("MAT013","19")
PRIVATE cSPMAT016 := GetSPName("MAT016","19")
PRIVATE cSPMAT052 := GetSPName("MAT052","19")
PRIVATE cSPMAT054 := GetSPName("MAT054","19")
PRIVATE cSPMAT060 := GetSPName("MAT060","19")

lExistProc := ExistProc(cSPMAT004,VerIDProc()) .And. ;
				  ExistProc(cSPMAT007,VerIDProc()) .And. ;
				  ExistProc(cSPMAT009,VerIDProc()) .And. ;
				  ExistProc(cSPMAT016,VerIDProc()) .And. ;
				  ExistProc(cSPMAT052,VerIDProc()) .And. ;
				  ExistProc(cSPMAT054,VerIDProc()) .And. ;
				  ExistProc(cSPMAT060,VerIDProc())

PRIVATE lUsaFilTrf 	:= UsaFilTrf()
PRIVATE aAuto330	:= aClone(aParAuto)
PRIVATE aLotesAchados := {}
PRIVATE lJourney
Private OJOURNEYLOG
// Verifica as chaves do appserver.ini
If !A330LogProfiler( !IIF(lBat == NIL, .F., lBat) .and. !IsBlind() )
	Return
EndIf

// atualiza o nome das tabelas auxiliares do recalculo de custo
DefNomTrb()

cMoeda330C := SuperGetMv('MV_MOEDACM',.F.,"2345")

If __lLibVer == Nil
	__lLibVer := FWLibVersion() >= "20211116"
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Identifica se usa custo em partes ou nao                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DEFAULT lSemParte := .F.

//Variavel de controle se esta processando pelo onboard de jornada de fechamento
Default  lOnbord  := .F.
Default	 cUserNameJ := ""
Default  l331x330 := .F.	

/* INSTALA PROCEDURE CTB250 */
M330Proced()

// Array com filiais a serem processadas na contabilizacao
a330RegCTB := {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Checa versao dos fontes relacionados. NAO REMOVER!!!         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If M330JCTB_V() < 20141209
	Final(OemToAnsi(STR0142))
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica a permissao do programa em relacao aos modulos      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If AMIIn(4,12,44)
	lMA330D1   := (ExistBlock("MA330D1"))
	lMA330D2   := (ExistBlock("MA330D2"))
	lMA330D3   := (ExistBlock("MA330D3"))
	lMA330CP   := (ExistBlock("MA330CP"))
	lMA330TRF  := (ExistBlock("MA330TRF"))
	lA330Seq   := (ExistBlock("MA330SEQ",,.T.))
	lA330TRB   := (ExistBlock("MA330TRB",,.T.))
	lM330DSDA  := (ExistBlock("M330DSDA"))
	lBat       := If(lBat == NIL, .F., lBat)
	aRegraCP   := {}
	nProdProp  := SuperGetMV("MV_PRODPR0",.F.,1)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Preenche array com as regras do custo em partes.             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lMA330CP
		aRegraCP:=ExecBlock("MA330CP",.F.,.F.)
		If ValType(aRegraCP) # "A"
			aRegraCP:={}
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se os campos do custo em partes estao Ok            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Len(aRegraCP) > 0
		lCstPart:=MA330AvlCp(aRegracp,aLogsPart)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
		// Telemetria - Uso da classe FwCustomMetrics                   //
		// Metrica - setAverageMetric                                   //
		// Grava se este ambiente esta configurado com custo em partes  //
		//?ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
		If FWLibVersion() >= "20210628"
			FWCustomMetrics():setAverageMetric(	"MATA330"/*cSubRoutine*/,;
												"estoque-protheus_total-acessos-custo-partes_total" /*cIdMetric*/,;
												1 /*nValue*/,;
												/*dDateSend*/,;
												/*nLapTime*/,;
												"SIGACUSA"/*cRotina*/)
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Caso definido por parametro desliga custo em partes          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lCstPart .And. lSemParte
		lCstPart:=.F.
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Pega a variavel que identifica se o calculo do custo e' :    ³
	//³               O = On-Line                                    ³
	//³               M = Mensal                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	PRIVATE cCusMed := SuperGetMv("MV_CUSMED",.F.,"M")
	PRIVATE dInicio := SuperGetMv("MV_ULMES",.F.,SToD("19961231"))+1
	PRIVATE lLancToOn
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Variavel que define o tamanho dos array que guardarao os cus-³
	//³ tos.                                                         |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	PRIVATE nTamArrCus := 5
	PRIVATE cCadastro  := OemToAnsi(STR0007) //"Recalculo do Custo Medio"

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Calculo das data validas usadas no sistema (outros modulos)   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	PRIVATE cMes, cMesMat
	PRIVATE cLoteAnt,dDataAnt,cDocAnt

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Variaveis para controle de sequencias                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	PRIVATE nSeqFIFO := 0

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Variavel utilizada para gravar o grupo de perguntas - MTA330  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	PRIVATE a330ParamZX:=Array(21)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³MV_CUSFIL - Parametro utilizado para verificar se o sistema   |
	//|utiliza custo unificado por:                                  |
	//|      F = Custo Unificado por Filial                          |
	//|      E = Custo Unificado por Empresa                         |
	//|      A = Custo Unificado por Armazem                         |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	PRIVATE lCusFil    := AllTrim(SuperGetMV('MV_CUSFIL' ,.F.,"A")) == "F"
	PRIVATE lCusEmp    := AllTrim(SuperGetMv('MV_CUSFIL' ,.F.,"A")) == "E"
	PRIVATE lD3Servico := AllTrim(SuperGetMv('MV_D3SERVI',.F.,"N")) == "S"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³MV_CUSREP - Parametro utilizado para habilitar o calculo do   ³
	//³            Custo de Reposicao.                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	PRIVATE lCusRep    := SuperGetMv("MV_CUSREP",.F.,.F.)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Variavel global para controle da numeracao SEQCALC            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	PRIVATE cSeqEmp := CriaTrab(Nil,.F.)
	PutGlbValue(cSeqEmp,'000000')
	GlbUnLock()

	//- Variavel de controle para sequenciamento dos registros na tabela TRC
	Private cKeyRegCT := CriaTrab(Nil,.F.)
	//- inicializa a chave
	PutGlbVars(cKeyRegCT,0)

	//- Objeto para Bulk
	Private oBulk
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Carrega as perguntas selecionadas                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ dInicio  - Data Inicial para processamento                   ³
	//³ mv_par01 - Data limite para processamento                    ³
	//³ mv_par02 - Se mostra e permite digitar lancamentos contabeis ³
	//³ mv_par03 - Se deve aglutinar os lancamentos contabeis        ³
	//³ mv_par04 - Se deve atualizar os valores dos movimentos       ³
	//³ mv_par05 - Porcentual a ser adicionado ao custo medio da MOD ³
	//³ mv_par06 - 1 - centro de custo contabil  2 - extracontabil   ³
	//³ mv_par07 - Contas contabeis a serem inibidas - conta inicial ³
	//³ mv_par08 - Contas contabeis a serem inibidas - conta final   ³
	//³ mv_par09 - Deleta movimentos de Estorno, 1 = Sim  2 = Nao    ³
	//³ mv_par10 - Contabilizacao On line                            ³
	//³ mv_par11 - Gera estrutura p/movimentos                       ³
	//³ mv_par12 - Contabiliza ? 1 = Consumo 2 = Producao 3 = Ambas  ³
	//³ mv_par13 - Calcula MO  ? 1 = Sim     2 = Nao                 ³
	//³ mv_par14 - Metodo Apropriacao 1 = Sequencial                 ³
	//³                               2 = Mensal                     ³
	//³                               3 = Diaria                     ³
	//³ mv_par15 - Recalcula Niveis   1 = Sim 2 = Nao                ³
	//³ mv_par16 - Mostra Seq Calculo 1 = Nao Mostrar                ³
	//³                               2 = Custo Medio                ³
	//³                               3 = Custo FIFO                 ³
	//³ mv_par17 - Seq Proces  FIFO   1 = Data + Sequen 2 = Cus Medio³
	//³ mv_par18 - Proc Internos Valorizados   1 = Antes 2 = Depois  ³
	//³ mv_par19 - Recalcula custos de transporte 1 = Sim 2 = Nao    ³
	//³ mv_par20 - Calculo de Custo por  1 = Todas Filiais           ³
	//³                                  2 = Filial Corrente         ³
	//³                                  3 = Selec. Filiais          ³
	//³ mv_par21 - Calcular Custo em Partes ? 1 = Sim  2 = Nao       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Salvar variaveis existentes no array A330ParamZX[]           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	lJourney := lOnbord
	If lEnviron
		If !lJourney
			OJOURNEYLOG:= acJourneyLog():New()
		Else
			OJOURNEYLOG:= oJour
			iIf (Empty(cUserName), cUserName:= cUserNameJ, cUserName)
		EndIf
		OJOURNEYLOG:envValid(lJourney)
	else
		Help(" ",1,"NOTATU",,STR0245,02,01)
		Return Nil
	EndIf
	// Mesma funcionalidade do ProcLogIni
	oJourneyLog:logIni()
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Inicializa o log de processamento   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If oJourneyLog:nCondition == 1
		oJourneyLog:idMovD3X()
		oJourneyLog:setThreadId( Strzero(ThreadID(),15))
	elseIF oJourneyLog:nCondition == 4 .or. oJourneyLog:nCondition == 2
		oJourneyLog:idMovCV8()
	EndIF

	MTA330Perg(.F.)

	If !lBat .And. !IsBlind()
		If SuperGetmv("MV_CUSTEXC",.F.,"N") == "N"
			cMens := OemToAnsi(STR0001)+chr(13)		//"Esta rotina ser  executada em modo"
			cMens += OemToAnsi(STR0002)+chr(13)		//"compartilhado , conforme indicado"
			cMens += OemToAnsi(STR0003)+chr(13)		//"pelo parƒmetro MV_CUSTEXC."
			cMens += OemToAnsi(STR0004)+chr(13)		//"As movimenta‡”es que ocorrerem durante"
			cMens += OemToAnsi(STR0005)+chr(13)		//"o processo podem influir no c lculo."
			If !MsgYesNo(cMens,OemToAnsi(STR0006)) 		//"ATEN€O"
				Return
			EndIf
		EndIf

		If lExistProc .And. lCusEmp .And. !SuperGetMV("MV_THRSEQ",.F.,.F.)
			cMens := OemToAnsi(STR0196)+chr(13)
			cMens += OemToAnsi(STR0197)+chr(13)
			cMens += OemToAnsi(STR0198)+chr(13)
			cMens += OemToAnsi(STR0199)+chr(13)
			If !MsgYesNo(cMens,OemToAnsi(STR0006)) 		//"ATEN€O"
				Return
			EndIf
		Endif

		If lExistProc  // insere 1 linha no TRB para não trazer a tela de sequencia em branco na primeira execução
					   // com procedures.....o TRB será zerado no inicio.
			TcSqlExec("insert into " + cNomTRB + " (TRB_CHAVE) values ('Header') ")
		EndiF
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Colocado o Return porque se o usuario clicasse no botao de     ³
		//| cancelar ele nao retornava ao menu, ele continuava o processo. |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !MTA330Perg(.T.)
			Return .F.
		EndIf
	Else
		MTA330Perg(.F.)
	EndIf

	lDigita   := !lBat .And. !IsBlind() .And. a330ParamZX[02] == 1
	lAglutina := IIf(a330ParamZX[03] == 1,.T.,.F.)
	lLanctoOn := IIf(a330ParamZX[10] == 1,.T.,.F.)
	lDigita   := IIf(lLanctoOn == .F.,.F.,lDigita)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Tratamento para nao quebrar o Log da CV8 em SubProcesso      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Type("__SubProc") == "C"
		__SubProc := ""
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se os campos do Custo de Reposicao estao Ok         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lCusRep
		 lCusRep := MA330AvRep(aLogsRep)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Identificacao da variavel cOpcoes                            ³
	//³                                                              ³
	//³  1a posicao - 1 Deve calcular o custo da MOD                 ³
	//³  2a posicao - 1 Calcula o custo com apropriacao sequencial   ³
	//³  3a posicao - 1 Calcula o custo com apropriacao mensal       ³
	//³  4a posicao - 1 Calcula o custo com apropriacao diaria       ³
	//³  Obs.: 0 sempre identifica que nao deve executar rotina      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lBat
		If IsBlind()
			If MTA330TOk()
				BatchProcess(OemToAnsi(STR0007),OemToAnsi(STR0008)+OemToAnsi(STR0009)+OemToAnsi(STR0010)+DTOC(dInicio),"MTA330",{ || Processa({|lEnd| MA330Process(aListaFil,lBat,@lEnd,,,,lExistProc, l331x330)},OemToAnsi(STR0007),OemToAnsi(STR0011),.F.)})
			EndIf
		Else
			DEFINE MSDIALOG oDlg FROM  96,9 TO 320,612 TITLE OemToAnsi(STR0007) PIXEL	//"Rec lculo do Custo M‚dio"
			@ 11,6 TO 90,287 LABEL "" OF oDlg  PIXEL
			@ 16, 15 SAY OemToAnsi(STR0008) SIZE 268, 8 OF oDlg PIXEL					//"Este programa permite que o custo m‚dio seja recalculado de trˆs formas diferentes, atendendo"
			@ 26, 15 SAY OemToAnsi(STR0009) SIZE 268, 8 OF oDlg PIXEL					//"qualquer exigˆncia legal."
			@ 36, 15 SAY OemToAnsi(STR0010) + DTOC(dInicio) SIZE 268, 8 OF oDlg PIXEL	//"Data Inicial de Processamento : "
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Avisa o usuario sobre campos faltantes com divergencias      ³
			//³ em decimais                                                  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If M330AvlDec(aLogDec)
				@ 48, 15 SAY oSay VAR OemToAnsi(STR0032) SIZE 268, 8 OF oDlg PIXEL 	//"Existem campos com decimais divergentes, poderao ocorrer diferencas de arredondamento"
				oSay:SetColor(CLR_HRED,GetSysColor(15))
				@ 092,480 BTNBMP oBtn1 RESOURCE "BMPPERG" SIZE 25,25 DESIGN ACTION M330ShowDc(aLogDec) OF oDlg
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Avisa o usuario sobre campos faltantes para calculo com      ³
			//³ custo em partes                                              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Len(aRegraCP) > 0 .And. !lCstPart
				@ 61,015 SAY oSay2 VAR OemToAnsi(STR0028) SIZE 268, 8 OF oDlg PIXEL 	//"Custo em partes nao sera considerado pois algum(ns) campos(s) nao foi(ram) criado(s)"
				oSay2:SetColor(CLR_HRED,GetSysColor(15))
				@ 119,480 BTNBMP oBtn2 RESOURCE "BMPPERG" SIZE 25,25 DESIGN ACTION MA330LPart(aLogsPart) OF oDlg
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Avisa o usuario sobre campos faltantes para calculo do       ³
			//³ custo de reposicao                                           ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Len(aLogsRep) > 0 .And. !lCusRep
				@ 75,015 SAY oSay2 VAR OemToAnsi(STR0164) SIZE 268, 8 OF oDlg PIXEL 	//"Custo de Reposição nao sera considerado pois algum(ns) campos(s) nao foi(ram) criado(s)"
				oSay2:SetColor(CLR_HRED,GetSysColor(15))
				@ 148,480 BTNBMP oBtn2 RESOURCE "BMPPERG" SIZE 25,25 DESIGN ACTION MA330LRep(aLogsRep) OF oDlg
			EndIf

			DEFINE SBUTTON FROM 93, 163 TYPE 15 ACTION ProcLogView(,'MATA330') ENABLE OF oDlg
			DEFINE SBUTTON FROM 93, 193 TYPE 5  ACTION MTA330Perg(.T.) ENABLE OF oDlg
			DEFINE SBUTTON FROM 93, 223 TYPE 1  ACTION If(MTA330TOk(),(Processa({|lEnd| MA330Process(aListaFil,lBat,@lEnd,nRateioFrota,nRateioVeiculo,nRateioViagem,lExistProc, l331x330)},OemToAnsi(STR0007),OemToAnsi(STR0011),.F.),oDlg:End()),) ENABLE OF oDlg
			DEFINE SBUTTON FROM 93, 253 TYPE 2  ACTION oDlg:End() ENABLE OF oDlg
			ACTIVATE MSDIALOG oDlg CENTERED
		EndIf
	Else
		If MTA330TOk()
			MA330Process(aListaFil,lBat,NIL,nRateioFrota,nRateioVeiculo,nRateioViagem,lExistProc, l331x330)
		Endif
	EndIf
EndIf

ESTTamSX3('', @_aTamSX3)

If __MV_PCOINTE <> NIL
	__MV_PCOINTE:fromJson("{}")
EndIf

Return


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MA330Process³ Autor ³ Bregantim / Stiefano  ³ Data ³01/10/97³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Processa o recalculo do custo medio.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Lista com as filiais a serem consideradas (Batch)  ³±±
±±³          ³ ExpL2 = Indicacao da variavel de processamento em batch    ³±±
±±³          ³ ExpL3 = Variavel que controla interrupcao do processo      ³±±
±±³          ³ ExpN4 = Rateio por Frota                                   ³±±
±±³          ³ ExpN5 = Rateio por Veiculo                                 ³±±
±±³          ³ ExpN6 = Rateio por Viagem                                  ³±±
±±³          ³ ExpL7 = Variavel que verifica a utilizacao de procedures   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function MA330Process(aListaFil,lBatch,lEnd,nRateioFrota,nRateioVeiculo,nRateioViagem,lExistProc, l331x330)
LOCAL nTotRegs	:=0
LOCAL cOrigens
LOCAL cAliasTMP :=""
LOCAL cDbType		:= TCGetDB()
LOCAL lContinua	:=.T.
Local lfinish  	:= .F.
LOCAL lProcessa :=.T.
LOCAL cTempo	:="",nTempoFim:=0,nTempo := 0,nTempoIni:=Seconds()
LOCAL lMA330Fim :=ExistBlock("MA330FIM")
LOCAL nX,nY     := 0
LOCAL aAuxFil   := {}
LOCAL nColigada := GetNewPar("MV_RMCOLIG",0)
Local cThreadID
//-- Variavel usada para verificar se o disparo da funcao IntegDef() pode ser feita manualmente
LOCAL lIntegDef  :=  FWHasEAI("MATA330",.T.,,.T.)
LOCAL lM330JCM  := !Empty(SuperGetMv("MV_M330JCM" ,.F.,""))
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ variaveis utilizadas em ambiente Top                           |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LOCAL aTam		 := {}
LOCAL aProcNam	 := {cSPMAT004,cSPMAT016} // vetor contendo os nomes das procedures MAT004 e MAT016
LOCAL cQuery	 := ""
LOCAL cListaFil  := ""
LOCAL nHdl       := 0
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ variaveis da procedure com multiplas threads                   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LOCAL cJobAux    := ""
LOCAL cJobFile   := ""
LOCAL aJobAux    := {}
LOCAL aDataProc  := {}
LOCAL nRetry_0   := 0
LOCAL nRetry_1   := 0
LOCAL nMoeda	 := 0
LOCAL cStartPath := GetSrvProfString("Startpath","")
LOCAL lSeq500    := SuperGetMv("MV_SEQ500",.F.,.T.)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variaveis utilizadas para processamento de calculo por empresa |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LOCAL aFilsCalc  := {}
LOCAL nForFilial := 0
LOCAL cC2UlMes := Dtos(SuperGetMv("MV_ULMES",.F.,"19961231"))
LOCAL aNmArqTmp:={}
LOCAL lWmsNew	:= SuperGetMv("MV_WMSNEW",.F.,.F.)
LOCAL lProdMOD	:= SuperGetMV("MV_PRODMOD",.F.,.T.)
LOCAL nTotFil := 0
LOCAL aSelFil := {}
LOCAL nPosFil := 0
LOCAL aBkpFils:={}
LOCAL nI
LOCAL cFiltTRB
LOCAL cIDThread
LOCAL cSemaforo
Local nTotPrdMO
Local cIDEvent:= ""
Local cMessage:= ""
Local cTitle  := ""
Local cSubstr := If(TCGetDB() $ "ORACLE/POSTGRES/DB2/400/INFORMIX","SUBSTR","SUBSTRING")
Local cConcat := If(TCGetDB() $ "ORACLE/POSTGRES/DB2/400/INFORMIX","||","+")
Local cSubRotina := ""
Local lCtbFila   :=  If(SuperGetMV("MV_CTBJOB",.F.,"2")==1,.T.,.F.)
Local nFilial  as numeric
Local aCpos   := {}
Local cCpos   := ""
Local nCpo    := 0
Local cQry    := ''
Local nIndex  := 0
Local cLogTit := ''
Local cLogMes := ''
Local nTotal  := 0

DEFAULT lExistProc := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ MV_CUSTEXC - Define se abertura de arquivos sera executada de     |
//|              forma Exclusiva ou Compartilhada.                    |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PRIVATE l330ArqExcl := IIf(SuperGetMv("MV_CUSTEXC",.F.,"S")!="N",.T.,.F.)
PRIVATE lBat        := lBatch
PRIVATE lCusFIFO    := .F.
PRIVATE lCusLIFO    := .F.
PRIVATE lMATA330    := .T.
PRIVATE oSx1Mta331	:= JsonObject():new()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Envia mensagem de aviso no inicio da rotina ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
MEnviaMail("046", {cUserName, SubStr(cNumEmp,1,2), SubStr(cNumEmp,3,2), DtoC(Date()), Time()})

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ EventViewer						  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cIDEvent:= "046"
cTitle	:= 	STR0241 // Inicio de processamento do custo
cMessage+=  CRLF+STR0222+cUserName +CRLF // Usuário // Min
EventInsert( FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cIDEvent, FW_EV_LEVEL_INFO, "",cTitle, cMessage, .T. )
cTitle	:= " "
cMessage+= " "

cFilBack := cFilAnt
dIniBack := dInicio 

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Quando utilizado custo por empresa (MV_CUSFIL = 'E')    |
//| sempre processar todas as filiais.                      |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lCusEmp .And. !(a330ParamZX[20] == 1)
	Help(" ",1,"A330EMPR")
	// Forca o processamento de todas as Filiais
	a330ParamZX[20] := 1
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Caso definido por parametro desliga custo em partes          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lCstPart .And. (a330ParamZX[21] <> 1)
	lCstPart:=.F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Selecao de Filiais a serem processadas ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lBat .Or. IsBlind()
	If lJourney
		aFilsCalc := aListaFil
	Else 
		aFilsCalc:=Ma330FCalc(.F.,aListaFil)
	Endif
Else
	aFilsCalc:=Ma330FCalc(.T.,aListaFil)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Recalculo do Custo Medio por Filial ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(aFilsCalc) .And. M330331Lk(aFilsCalc, lJourney)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o log de processamento   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	M330PrcLog("INICIO")
	M330PrcLog("AMBIENTE")

	IF lJourney .and. oJourneyLog:processHasStarted(oJourneyLog:cIdParent, oJourneyLog:cIdChild, 'MATA330')
		OJOURNEYLOG:attStatus('PROCESSING', .T.)
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Carrega a lista de filiais a serem processadas                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cListaFil := A330Lista(aFilsCalc)

	// Desativa as triggers da MsUnLock (Integracao RM x Protheus)
	If nColigada > 0
		A330LckGlb("cPMS_SB2")
		PutGlbValue("cPMS_SB2","1")
		A330ULckGlb("cPMS_SB2")
	EndIf

	lDigita   := !lBat .And. !IsBlind() .And. a330ParamZX[02] == 1
	lAglutina := IIf(a330ParamZX[03] == 1,.T.,.F.)
	lLanctoOn := IIf(a330ParamZX[10] == 1,.T.,.F.)
	lDigita   := IIf(lLanctoOn == .F.,.F.,lDigita)
	lCusFIFO  := SuperGetMV("MV_CUSFIFO",.F.,.F.)
	lCusLIFO  := SuperGetMv('MV_CUSLIFO',.F.,.F.)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Identificacao da variavel cOpcoes                            ³
	//³                                                              ³
	//³  1a posicao - 1 Deve calcular o custo da MOD                 ³
	//³  2a posicao - 1 Calcula o custo com apropriacao sequencial   ³
	//³  3a posicao - 1 Calcula o custo com apropriacao mensal       ³
	//³  4a posicao - 1 Calcula o custo com apropriacao diaria       ³
	//³  Obs.: 0 sempre identifica que nao deve executar rotina      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cOPcoes := IIF(a330ParamZX[13]== 1,"1000","0000")
	cOpcoes := Subs(cOPcoes,1,a330ParamZX[14])+"1"+"0000"
	cOPcoes := Subs(cOpcoes,1,4)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atraves do parametro MV_CUSTEXC, verifica se a abertura de   ³
	//³ arquivos e' exclusiva ou compartilhada.                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If l330ArqExcl
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Abre todos os arquivos de forma exclusiva                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		ChkFile("CT1",.T.)
		ChkFile("CT2",.T.)
		ChkFile("CT5",.T.)
		ChkFile("CTT",.T.)
		ChkFile("CQ1",.T.)
		ChkFile("CQ3",.T.)

		If MntInUse()
			ChkFile("STL",.T.)
		EndIf
		If ! (	MA280FLock("SD3") .And. MA280FLock("SD1") .And. MA280FLock("SB2") .And. ;
				MA280FLock("SC2") .And. MA280FLock("SF4") .And. MA280FLock("SF5") .And.;
				MA280FLock("SM2") .And. MA280FLock("SB9") .And. MA280Flock("SBD") .And.;
				MA280Flock("SD8")) .And. MA280FLock("SF8") .And.;
				MA280FLock("CT1") .And.MA280FLock("CT2") .And. ;
				MA280FLock("CQ3") .And. MA280Flock("CT5") .And. ;
				MA280FLock("CQ1") .And. MA280Flock("CTT") .And.;
				If(MntInUse(),MA280Flock("STL"),)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Fecha todos os arquivos e reabre-os de forma compartilhada   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbCloseAll()
			OpenFile(SubStr(cNumEmp,1,2))
			Return .T.
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Abre indices dos arquivos que foram abertos de forma exclusivo ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		OpenIndx("SD3")
		OpenIndx("SD1")
		OpenIndx("SB2")
		OpenIndx("SB9")
		OpenIndx("SC2")
		OpenIndx("SF4")
		OpenIndx("SF5")

		OpenIndx("SM2")
		OpenIndx("SBD")
		OpenIndx("SD8")
		OpenIndx("SF8")
		If MntInUse()
			OpenIndx("STL")
		EndIf
	EndIf

	If Subs(cOpcoes,1,1) == "1"
		dbSelectArea("SB2")           // saldos em estoque
		nTotRegs += LastRec()

		dbSelectArea("SB9")           // saldos iniciais
		nTotRegs += LastRec()

		dbSelectArea("SD3")           // movimentacoes internas (producao/requisicao/devolucao)
		nTotRegs += LastRec()
	EndIf

	If "1"$SubStr(cOpcoes,2,3)
		dbSelectArea("SB2")           // saldos em estoque
		nTotRegs += LastRec()

		dbSelectArea("SB9")           // saldos iniciais
		nTotRegs += LastRec()

		dbSelectArea("SC2")			  // ordem de producao
		nTotRegs += LastRec()

		dbSelectArea("AF9")			  // tarefas do projeto
		nTotRegs += LastRec()

		If SubStr(cOpcoes,3,1) == "1"
			nTotRegs += LastRec()
		EndIf

		dbSelectArea("SD1")           // itens das notas fiscais de entrada
		nTotRegs += LastRec()
		nTotRegs += LastRec()

		If SubStr(cOpcoes,4,1) == "1"
			nTotRegs += LastRec()
		EndIf

		dbSelectArea("SD2")           // itens das notas fiscais de saida
		nTotRegs += LastRec()
		nTotRegs += LastRec()

		If SubStr(cOpcoes,4,1) == "1"
			nTotRegs += LastRec()
		EndIf

		dbSelectArea("SD3")           // movimentacoes internas (producao/requisicao/devolucao)
		nTotRegs += LastRec()

		If SubStr(cOpcoes,3,1) == "1"
			nTotRegs += LastRec()
		EndIf
	EndIf
	If MntInUse()
		dbSelectArea("STL")				// Integracao com Manutencao de Ativos
	EndIf
	If !lBat
		ProcRegua(nTotRegs,16,4)
	EndIf

	/*
	* Inicia o cache de lista de produtos do tipo MO - Mão de obra
	* da filial corrente
	*/
	A330ISMOD()

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Validacao para o calendario contabil                    |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	For nForFilial := 1 to Len(aFilsCalc)
		If aFilsCalc[nForFilial,1]
			// Altera filial corrente
			cFilAnt:=aFilsCalc[nForFilial,2]
			dInicio := SuperGetMv("MV_ULMES",.F.,SToD("19961231"))+1

			//-- Verifica Calendario Contabil
			If A330VldCal(dInicio,a330ParamZX[01])
				Return .T.
			EndIf
		EndIf
	Next nForFilial

	// Atualizacao automatica do parametro MV_DBLQMOV para uso no MATA280
	For nForFilial := 1 to Len(aFilsCalc)
		If aFilsCalc[nForFilial,1]
			// Altera filial corrente
			cFilAnt:=aFilsCalc[nForFilial,2]
			If SuperGetMv("MV_CMDBLQV",.F.,.F.)
				// Altera parametro com a data do recalculo
				PutMV("MV_DBLQMOV",a330ParamZX[01])
			EndIf
		EndIf
	Next nForFilial

	// Restaura filial original apos processamento
	cFilAnt := cFilBack
	dInicio := dIniBack

	cThreadID := Strzero(ThreadID(),15)
	//-- Cria arquivos de trabalho do recalculo de custos
	A330CrTabs(aFilsCalc,,cThreadID)
	// Exclui os movimentos da thread atual, pois seria de uma thread passada
	TcSqlExec("DELETE FROM " +cNomTRB +" WHERE TRB_THREAD = '"+cThreadID+"' ")

	If 'TR2' $ cNomTR2
		//Inicializa os dados da TR2 com a SB2
		A330TR2Ini(aFilsCalc)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Apagando lancamentos contabeis                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nForFilial := 1 to Len(aFilsCalc)
		If aFilsCalc[nForFilial,1]
			// Altera filial corrente
			cFilAnt:=aFilsCalc[nForFilial,2]
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se vai abrir o arquivo para lancamentos contabeis   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If "1"$SubStr(cOpcoes,2,3) .And. a330ParamZX[10] < 3
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Apaga os lancamentos contabeis relacionados                  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cOrigens := "MATA241/MATA240/MATA250/MATA260/MATA261/MATA330/MTA460C/MTA520C/CNA200C/MATA685/"
				If a330ParamZX[12] != 2
					cOrigens += "MTA330C/"
				EndIf
				If a330ParamZX[12] != 1
					cOrigens += "MTA330P/"
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o log de processamento			    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

				// mesma funcionalidade do proclogini
				oJourneyLog:logIni()
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o log de processamento			    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If  oJourneyLog:nCondition == 1
					oJourneyLog:idMovD3X()
				elseIF oJourneyLog:nCondition == 4  .or. oJourneyLog:nCondition == 2
					oJourneyLog:idMovCV8()
				EndIf

				M330PrcLog("INICIO")

				M330PrcLog("MENSAGEM",OemToAnsi(I18N(STR0106,{cFilAnt})),OemToAnsi(I18N(STR0106,{cValToChar(cFilAnt)}))) //"Apagando Lançamentos Contabeis do Periodo na filial: #1[D MG 01]" ## "Apagando Lançamentos Contabeis do Periodo na filial: #1[D MG 01]"

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Apaga os Lançamentos Contabeis			    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cA100Apaga(cOrigens,a330ParamZX[01],lCtbFila)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Utiliza reprocessamento contabil            |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aAdd(aAuxFil,cFilAnt)
			EndIf
		EndIf
	Next nForFilial
	// Restaura filial original apos processamento
	cFilAnt:=cFilBack

	//
	// Realiza o calculo do custo da Mao de Obra das filiais selecionadas
	//
	If !lBat .And. !IsBlind()
		IncProc(OemToAnsi(STR0154)) //"Acertando o Custo da Mao de Obra"
	EndIf
	A330CalcMod(a330ParamZX, aFilsCalc, cOpcoes, dInicio, cMoeda330C)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Reprocessamento Contabil para CA100APAGA()           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(aAuxFil)

		// mesma funcionalidade do proclogini
		oJourneyLog:logIni()
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o log de processamento			    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If oJourneyLog:nCondition == 1
			oJourneyLog:idMovD3X()
		elseIF oJourneyLog:nCondition == 4 .or. oJourneyLog:nCondition == 2
			oJourneyLog:idMovCV8()
		EndIf
		A330Reproc(aAuxFil,dInicio,a330ParamZX[01],,"CA100APAGA")

		// Ponto de Entrada para Consultar o Saldo Contábil apos o Reprocessamento
		If ExistBlock("MA330CTB")
			ExecBlock("MA330CTB",.F.,.F.,{aAuxFil})
		EndIf
	EndIf

	For nX := 1 to Len(aFilsCalc)
		If aFilsCalc[nX,1]
			// Altera filial corrente
			cFilAnt := aFilsCalc[nX,2]
			dInicio := SuperGetMv("MV_ULMES",.F.,SToD("19961231"))+1

			// gera log com os conteudos dos parametros(SX6) a serem utilizados
			A330Param()

			nTotPrdMO := ListaMOD("2")
			M330PrcLog("MENSAGEM",I18N(STR0219,{cValToChar(nTotPrdMO)}) +STR0067+cFilAnt,I18N(STR0219,{cValToChar(nTotPrdMO)})) //"Encontrado #1[2]# registros de produto do tipo mão de obra" ## "Encontrado #1[2]# registros de produto do tipo mão de obra"

			//-- Inclui filial na tabela temporaria TRD utilizada na stored procedures
			RecLock("TRD",.T.)
			TRD->TRD_FILIAL	:= aFilsCalc[nX,2]
			TRD->TRD_CGC	:= aFilsCalc[nX,4]
			TRD->TRD_INSC   := aFilsCalc[nX,6]  // Tratamento para diferenciar as filiais quando usado o sigamat com mesmo cnpj em duas filiais
			TRD->(MsUnlock())

			//-- Quando custo FIFO/LIFO, cria arquivo de trabalho para processar log da baixa por filial
			If lCusFIFO .Or. lCusLIFO
				cAliasTMP := STRTRAN(alltrim("TMP"+cEmpAnt+(aFilsCalc[nX][2]))," ","_")
				oTabTemp := FWTemporaryTable():New(cAliasTMP,{{"T_CONTEUDO","C",98,0}})
				aAdd(aNmArqTmp,{oTabTemp,cAliasTMP})
				oTabTemp:Create()
			EndIf

			//-- Apaga movimentos de estorno
			If a330ParamZX[09] == 1 .Or. lCusFIFO .Or. lCusLIFO
				If ExistProc(cSPMAT013,VerIDProc())
					TCSpExec(xProcedures(cSPMAT013),	cFilAnt,;							      // 01. Filial a processar
																SuperGetMv("MV_RASTRO",.F.,"N")	,;	// 02. Parametro MV_RASTRO
																SuperGetMv("MV_LOCALIZ",.F.,"N") ,;	// 03. Parametro MV_LOCALIZ
																DToS(dInicio)					      ,;	// 04. Data inicial do processamento
																DToS(a330ParamZX[01])			   ,;	// 05. Data final do processamento
																IIF(lWmsNew,'1','0')			      ,; // 06. Parametro MV_WMSNEW
																SuperGetMv("MV_ARQPROD",.F.,"SB1"))	// 07. Parametro MV_ARQPROD
				Else
					BeginSQL Alias "DELSD3"
						SELECT R_E_C_N_O_ RECSD3
						FROM %Table:SD3%
						WHERE D3_FILIAL = %xFilial:SD3% AND
							D3_EMISSAO BETWEEN %Exp:DToS(dInicio)% AND %Exp:DToS(a330ParamZX[01])% AND
							D3_ESTORNO = 'S' AND
							%NotDel%
					EndSQL
					While !DELSD3->(EOF())
						SD3->(dbGoTo(DELSD3->RECSD3))
						MA330DelD3()

						DELSD3->(dbSkip())
					End
					DELSD3->(dbCloseArea())
				EndIf
			EndIf

			//-- Gera estrutura pela movimentação e ajusta niveis nas ordens de produção (C2_NIVEL)
			If !(lContinua := MA330NivCD(dInicio,a330ParamZX[01],,cFilBack))
				Exit
			EndIf
		EndIf
	Next nX

	If lContinua
		// Restaura filial original apos processamento
		cFilAnt := cFilBack
		dInicio := dIniBack

		If lCusEmp
			MA330NivCD(dInicio,a330ParamZX[01],.T.,cFilBack) //terceiro parametro indica somente o acerto de niveis (OP)
		Else

			For nX := 1 to Len(aFilsCalc)
				If aFilsCalc[nX,1]
					// Altera filial corrente
					cFilAnt := aFilsCalc[nX,2]
					dInicio := SuperGetMv("MV_ULMES",.F.,SToD("19961231"))+1
					MA330NivCD(dInicio,a330ParamZX[01],.T.,cFilBack) //terceiro parametro indica somente o acerto de niveis (OP)
				EndIf
			Next nX
			cFilAnt := cFilBack
			dInicio := dIniBack
		EndIf
	EndIf
	If lContinua .And. lProcessa
		If lExistProc
			aTam:=TamSX3("D3_DOC")
			cSubRotina := "PROCEDURE"

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Movimentacao do Cursor                                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lBat .And. !IsBlind()
				IncProc(OemToAnsi(STR0109+STR0107)) //"Procedures: " + "Geração do Arquivo de Trabalho - (0) Iniciando "
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o log de processamento			    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			M330PrcLog("MENSAGEM",OemToAnsi(STR0109+STR0107),OemToAnsi(STR0109+STR0107),'3') //"Procedures: " + "Geração do Arquivo de Trabalho - (0) Iniciando "
			cIDThread := cValToChar(ThreadID())
			cSemaforo := "M330JPRC_"+cIDThread+"_"+CEMPANT
			A330JobManual("1",cSemaforo , "M330JPRCCONNECT" )

			// define qtas filiais foram selecionadas
			nTotFil := 0
			For nForFilial := 1 to Len(aFilsCalc)
				If aFilsCalc[nForFilial,1]
					nTotFil := nTotFil+1
				EndIF
			Next nForFilial

			// separa as filiais em grupos de 30 ou de 100
			aSelFil := {{}}
			nPosFil := 1
			For nForFilial := 1 to Len(aFilsCalc)
				If aFilsCalc[nForFilial,1]
					If nTotFil >=100
						aAdd(aSelFil[nPosFil],aFilsCalc[nForFilial])
						If Len(aSelFil[nPosFil]) = 100
							aAdd(aSelFil,{})
							nPosFil++
						EndIf
					Else
						aAdd(aSelFil[nPosFil],aFilsCalc[nForFilial])
						If Len(aSelFil[nPosFil]) = 30
							aAdd(aSelFil,{})
							nPosFil++
						EndIf
					EndIf
				EndIf
			Next nForFilial

			aBkpFils :=Aclone(aFilsCalc)
			nPosFil :=0
			WHILE nPosFil < LEN(aSelFil)

				nPosFil++
				aFilsCalc:=Aclone(aSelFil[nPosFil])

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Gera arquivo de trabalho com os movimento as serem processados            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				For nForFilial := 1 to Len(aFilsCalc)
					//-- Adiciona posição da filial no array de parâmetros da procedure
					aAdd(aDataProc,{})

					If !aFilsCalc[nForFilial,1]
						Loop
					EndIf

					// Altera filial corrente
					cFilAnt := aFilsCalc[nForFilial,2]
					dInicio := SuperGetMv("MV_ULMES",.F.,SToD("19961231"))+1

					// Verifica se utiliza Custo FIFO/LIFO
					lCusFIFO := SuperGetMv("MV_CUSFIFO",.F.,.F.)
					lCusLIFO := SuperGetMv("MV_CUSLIFO",.F.,.F.)

					// Informacoes do semaforo
					cJobFile:= cStartPath + "P"+cEmpAnt + cFilAnt+".SP"

					// Adiciona o nome do arquivo de Job no array aJobAux
					aAdd(aJobAux,{cFilAnt,cJobFile})

					// Inicializa variavel global de controle de thread
					cJobAux:="P"+cEmpAnt+cFilAnt
					A330LckGlb(cJobAux)
					PutGlbValue(cJobAux,"0")
					A330ULckGlb(cJobAux)

					If !SuperGetMV('MV_A330GRV',.F.,.T.)
						cQuery := "UPDATE "
						cQuery += cNomTR2
						cQuery += " SET "
						cQuery += " B2_QFIM   = 0, B2_VFIM1  = 0,"
						cQuery += " B2_VFIM2  = 0, B2_VFIM3  = 0,"
						cQuery += " B2_VFIM4  = 0, B2_VFIM5  = 0,"
						cQuery += " B2_CMFIM1 = 0, B2_CMFIM2 = 0,"
						cQuery += " B2_CMFIM3 = 0, B2_CMFIM4 = 0,"
						cQuery += " B2_CMFIM5 = 0 "
						cQuery += " WHERE  B2_FILIAL = '"+xFilial("SB2")+"' AND "
						cQuery += " D_E_L_E_T_ = ' ' AND EXISTS "
						cQuery += " (SELECT B1_COD FROM "+RetSqlName("SB1")
						cQuery += " WHERE B1_FILIAL = '"+xFilial("SB1")+"' AND "
						cQuery += " B1_COD = B2_COD AND "
						cQuery += " B1_FILIAL = B2_FILIAL AND "
						cQuery += " B1_CCCUSTO = '"+SPACE(TamSx3('B1_CCCUSTO')[1])+"' AND "
						If cDbType $ "ORACLE/POSTGRES/DB2/INFORMIX"
							cQuery += "SUBSTR"
						Else
							cQuery +=  "SUBSTRING"
						EndiF
						cQuery +=  "(B1_COD, 1, 3) <> 'MOD' AND "
						cQuery +=  " D_E_L_E_T_ = ' ' )"

						TcSqlExec(cQuery)

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³A tabela eh fechada para restaurar o buffer da aplicacao³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						SB2->(DbGoTo(SB2->(Recno()))) //Força refresh do cache

						TcRefresh(cNomTR2)						
					EndIf

					if cMoeda330C == NIL
						cMoeda330C := SuperGetMv('MV_MOEDACM',.F.,"2345")
					EndIf

					// Dados para chamada da procedure
					aDataProc[nForFilial] := {	SuperGetMv("MV_NIVALT",.F.,"N"),; 	// 01. Parametro MV_NIVALT
														GetMvNNR( 'MV_LOCPROC' , '99' ),;                    // 02. Parametro MV_LOCPROC
									DtoS(a330ParamZX[01]),;							// 03. Data final do processamento
									a330ParamZX[09],;								// 04. Deleta movimentos de Estorno
									a330ParamZX[11],;								// 05. Gera estrutura p/movimentos
									a330ParamZX[14],;								// 06. Metodo Apropriacao 1 = Sequencial / 2 = Mensal / 3 = Diaria
														If(lCusFIFO .Or. lCusLIFO, '1' , '0' ) ,;            // 07. Parametro MV_CUSFIFO ou MV_CUSFIFO
									SuperGetMv("MV_RASTRO",.F.,"N"),;				// 08. Parametro MV_RASTRO
									SuperGetMv("MV_LOCALIZ",.F.,"N"),;				// 09. Parametro MV_LOCALIZ
														GetMvNNR( 'MV_CQ' , '98' ),;                         // 10. Parametro MV_CQ
									DtoS(dInicio),;									// 11. Data de inicio do processamento
									aTam[1],;										// 12. Tamanho do campo D3_DOC
									cOpcoes,;										// 13. Identificacao da variavel cOpcoes
														IIf(lCusFil, '1' ,If(lCusEmp, '2' , '0' )),;         // 14. 0 = Custo por Armazem / 1 = Custo por Filial / 2 = Custo por Empresa
									nProdProp,;										// 15. Parametro MV_PRODPR0
									Dtos(dDataBase),;								// 16. Data Base do sistema
														If(SuperGetMV( 'MV_NEGESTR' ,.F.,.F.), '1' , '0' ),; // 17. Parametro MV_NEGESTR
									SM0->(Recno()),;								// 18. Numero do recno da tabela SM0
									a330ParamZX[18],;								// 19. Processa Mov. Internos Valorizados  1 = Antes / 2 = Depois
									cPaisLoc,;										// 20. Codigo do Pais
									0,;												// 21. Codigo da Filial (Convertida para valor numerico) [OBSOLETO]
														SuperGetMv( 'MV_PRODMNT' ,.F.,"MANUTENCAO"),;        // 22. Codigo do produto MANUTENCAO, utilizado para desconsidera-lo na procedure
									cMoeda330C,;									// 23. Parametro MV_MOEDACM
														If(lD3Servico, '1' , '0' ),;                         // 24. Parametro MV_D3SERVI
														If(IntDL(), '1' , '0' ),;                            // 25. Indica se existe integracao com WMS
														If(lCusRep, '1' , '0' ),;                            // 26. Indica se deve calcular o custo de reposicao
									a330ParamZX[15],;								// 27. Recalcula niveis da estrutura (1 - sim / 0 - nao)
														IIF(lUsaFilTrf, '1' , '0' ),;                        // 28. Indica a forma de localizacao das notas de transferencia ( 1 = A1_FILTRF e A2_FILTRF / 0 = A1_CGC e A2_CGC )
														IIF(lSeq500, '1' , '0' ) ,;                          // 29. Indica se utiliza o parametro MV_SEQ500
									DTOS(SuperGetMV("MV_ULMES",.F.,"19961231")),;	// 30. Conteudo do parametro MV_ULMES
														IIF(lWmsNew, '1' , '0' ),;                           // 31. Conteudo do parametro MV_WMSNEW
														IIF(lProdMOD, '1' , '0' ),;                          // 32. Conteudo do parametro MV_PRODMOD
									SuperGetMv("MV_SEQREBE",.F.,"290"),;			// 33. Conteudo do parametro MV_SEQREBE
									SuperGetMv("MV_M330JCM" ,.F.,""),;				// 34. Conteudo do parametro MV_M330JCM
														If(SuperGetMV( 'MV_PROCQE6' ,.F.,.F.), '1' , '0' ),; // 35. Conteudo do parametro MV_PROCQE6
									IIf(lCusEmp,Space(Len(cFilAnt )),cFilBack),;							 // 36. Filial que esta processando o recalculo
									IIf('SB2' $ cNomTR2, 'SB2', 'TR2')}                                      // 37. Nome físico do Alias SB2

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Dispara thread para Stored Procedure        ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					while ! IPCGO( cSemaforo,cEmpAnt,cFilAnt,aProcNam,aDataProc[nForFilial],cJobFile,cFilBack)
						for nI := 1 to 2
							sleep(1000)
						Next nI
					End

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o log de processamento			    ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					M330PrcLog("MENSAGEM",OemToAnsi(I18N(STR0109+STR0136,{cFilAnt})),I18N(STR0136,{cFilAnt})+chr(10)+MontProc(aProcNam[1], aDataProc[nForFilial]) ) //"Procedures: Geração do Arquivo de Trabalho - Thread da Filial #1[D MG 01- (0) Iniciando "

				Next nForFilial

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Controle de Seguranca para MULTI-THREAD                                   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				For nForFilial := 1 to Len(aFilsCalc)
					If !aFilsCalc[nForFilial,1]
						Loop
					EndIf

					// Altera filial corrente
					cFilAnt := aFilsCalc[nForFilial,2]

					nPos := ASCAN(aJobAux,{|x| x[1] == cFilAnt})

					// Informacoes do semaforo
					cJobFile:= aJobAux[nPos,2]

					// Inicializa variavel global de controle de thread
					cJobAux:="P"+cEmpAnt+cFilAnt

					nRetry_0 := 0
					nRetry_1 := 0

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Analise das Threads em Execucao                              ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					While .T.
						Do Case
						// TRATAMENTO PARA ERRO DE SUBIDA DE THREAD
						Case GetGlbValue(cJobAux) == '0'
							If nRetry_0 > 50
								Conout(Replicate("-",65))
								Conout("MATA330: "+STR0133 + " " + StrZero(nForFilial,3) ) //"MATA330: Não foi possivel realizar a subida da thread"
								Conout(Replicate("-",65))
								Final(STR0133) //"Não foi possivel realizar a subida da thread"
							Else
								nRetry_0 ++
							EndIf
						// TRATAMENTO PARA ERRO DE CONEXAO
						Case GetGlbValue(cJobAux) == '1'
							If FCreate(cJobFile) # -1
								If nRetry_1 > 5
									Conout(Replicate("-",65))
									Conout(STR0139) 			//"MATA330: Erro de conexao na thread de procedures"
									Conout(STR0127 + cJobAux )	//"Thread numero : "
									Conout(STR0128)				//"Numero de tentativas excedidas"
									Conout(Replicate("-",65))
									Final(STR0139) //"MATA330: Erro de conexao na thread de procedures"
								Else
									// Inicializa variavel global de controle de Job
									A330LckGlb(cJobAux)
									If GetGlbValue(cJobAux) == '1'
										PutGlbValue(cJobAux, "0" )
										A330ULckGlb(cJobAux)
									else
										A330ULckGlb(cJobAux)
										Loop
									EndIf

									// Reiniciar thread de contabilizacao
									Conout(Replicate("-",65))
									Conout(STR0139) 					//"MATA330: Erro de conexao na thread de procedures"
									Conout(STR0129+StrZero(nRetry_1,2))	//"Tentativa numero: "
									Conout(STR0130+cJobAux )			//"Reiniciando a thread : "
									Conout(Replicate("-",65))
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Dispara thread para Stored Procedure        ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									//StartJob("M330JPRC",GetEnvServer(),lCusEmp .Or. lThrSeq,cEmpAnt,cFilAnt,aProcNam,aDataProc[nForFilial],cJobFile)
								EndIf
								nRetry_1 ++
							EndIf
						// TRATAMENTO PARA ERRO DE APLICACAO
						Case GetGlbValue(cJobAux) == '2'
							If (nRetry_1 := FCreate(cJobFile)) # -1
								Sleep(5000)
								If GetGlbValue(cJobAux) # '2'	//-- Tratamento para falso positivo: quando thread muda entre as consultas
									FClose(nRetry_1)
									FErase(cJobAux)
									Loop
								EndIf
								Conout(Replicate("-",65))
								Conout(STR0140) 			//"MATA330: Erro de aplicacao na thread de procedures"
								Conout(STR0127+cJobAux)		//"Thread numero : "
								Conout(Replicate("-",65))
								Final(STR0140) 				//"MATA330: Erro de aplicacao na thread de procedures"
							EndIf
						// THREAD PROCESSADA CORRETAMENTE
						Case GetGlbValue(cJobAux) == '3'
							If File(cJobFile)
								nHdl := FOpen( cJobFile, FO_READ+FO_EXCLUSIVE )
								If nHdl > -1
									FClose(nHdl)
									If File(cJobFile )
										fErase(cJobFile )
									EndIf
								EndIf
							EndIf
							// Limpa variavel global de controle de thread
							ClearGlbValue(cJobAux)
							Exit
						// THREAD PROCESSADA COM ERRO NA CHAMADA DO PROCESSO
						Case GetGlbValue(cJobAux) == '4'
							cIDThread := cValToChar(ThreadID())
							cSemaforo := "M330JPRC_"+cIDThread+"_"+CEMPANT
							A330JobManual("2",cSemaforo , "M330JPRCCONNECT" )
							Final(STR0020) //'Erro na chamada do processo'
							Return Nil
						// THREAD PROCESSADA POREM REPROCESSAMENTO COM ERRO
						Case GetGlbValue(cJobAux) == '5'
							cIDThread := cValToChar(ThreadID())
							cSemaforo := "M330JPRC_"+cIDThread+"_"+CEMPANT
							A330JobManual("2",cSemaforo , "M330JPRCCONNECT" )
							Final(STR0021) //'Reprocessamento com Erro'
							Return Nil
						// PROCEDURE INSTALADA INCORRETAMENTE
						Case GetGlbValue(cJobAux) == '6'
							cIDThread := cValToChar(ThreadID())
							cSemaforo := "M330JPRC_"+cIDThread+"_"+CEMPANT
							A330JobManual("2",cSemaforo , "M330JPRCCONNECT" )
							Final(STR0265) //O parâmetro MV_A330SB2 foi alterado. Reinstale a procedure 19. 
						EndCase
						Sleep(500)
					End
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o log de processamento			    ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					M330PrcLog("MENSAGEM",OemToAnsi(I18N(STR0109+STR0137,{cFilAnt})),OemToAnsi(I18N(STR0137,{cFilAnt})) ) //"Procedures: Geração do Arquivo de Trabalho - Thread da Filial #1[D MG 01- (1) Termino "
				Next nForFilial

				For nForFilial := 1 to Len(aDataProc)
					aDataProc[nForFilial] := ASIZE(aDataProc[nForFilial], 0 )
				Next nForFilial

				// limpa array
				ASIZE(aDataProc, 0 )

			END
			aFilsCalc := aClone(aBkpFils)

			For nForFilial := 1 to Len(aBkpFils)
				aBkpFils[nForFilial] := ASIZE(aBkpFils[nForFilial], 0 )
			Next nForFilial

			// limpa array
			ASIZE(aBkpFils, 0 )

			// Restaura filial original apos processamento
			cFilAnt := cFilBack
			dInicio := dIniBack

			cIDThread := cValToChar(ThreadID())
			cSemaforo := "M330JPRC_"+cIDThread+"_"+CEMPANT
			A330JobManual("2",cSemaforo , "M330JPRCCONNECT" )

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o log de processamento			    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			M330PrcLog("MENSAGEM",OemToAnsi(STR0109+STR0108),OemToAnsi(STR0109+STR0108)+CountTRB(aFilsCalc), '4') //"Procedures: "+"Geração do Arquivo de Trabalho - (1) Termino "
			TRB->(dbSetOrder(If(lM330JCM,1,10)))

		EndIf

		If !lExistProc
			cSubRotina := "ADVPL"

			TRB->(dbSetOrder(If(lM330JCM,1,10)))

			M330PrcLog("MENSAGEM",OemToAnsi(STR0107),OemToAnsi(STR0107), '3') // "Geração do Arquivo de Trabalho - (0) Iniciando "
			For nForFilial := 1 to Len(aFilsCalc)
				If aFilsCalc[nForFilial,1]
					// Altera filial corrente
					cFilAnt := aFilsCalc[nForFilial,2]
					dInicio := SuperGetMv("MV_ULMES",.F.,SToD("19961231"))+1

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Grava arquivo de trabalho                                    ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If (lContinua := A330GrvTRB(aFilsCalc,lExistProc))
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Processa arquivo dos apontamentos                            ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If lContinua .And. nProdProp == 1
							A330PrcPR0()
						EndIf
					Else
						Exit
					EndIf
				EndIf
			Next nForFilial
			// Restaura filial original apos processamento
			cFilAnt := cFilBack
			dInicio := dIniBack

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o log de processamento			    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			M330PrcLog("MENSAGEM",OemToAnsi(STR0108),OemToAnsi(STR0108)+CountTRB(aFilsCalc), '4') //"Geração do Arquivo de Trabalho - (1) Termino "

		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
		// Telemetria - Uso da classe FwCustomMetrics                   //
		// Metrica - setAverageMetric                                   //
		// Grava se utiliza ou nao stored procedure para o processamento//
		// do recalculo do custo medio.                                 //
		//?ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
		If FWLibVersion() >= "20210628"
			FWCustomMetrics():setAverageMetric(	cSubRotina/*cSubRoutine*/,;
												"estoque/custos-protheus_recalculo-do-custo-medio-stored-procedures_count" /*cIdMetric*/,;
												1 /*nValue*/,;
												/*dDateSend*/,;
												/*nLapTime*/,;
												"MATA330"/*cRotina*/)
		EndIf

	EndIf

	If lContinua
		// Atualiza o numero da thread corrente dos registros a qual se refere as filiais selecionadas
		For nFilial := 1 to Len(aFilsCalc)
			If aFilsCalc[nFilial,1]
				TcSqlExec("UPDATE " +cNomTRB +" SET TRB_THREAD = '"+cThreadID+"' WHERE TRB_FILIAL = '"+aFilsCalc[nFilial,2]+"'")
			EndIf
		Next nFilial

		M330PrcLog("MENSAGEM",OemToAnsi(STR0178),OemToAnsi(STR0178)+JOBCMCount(cThreadID), '4') //"Analise dos registros para JOBCM"

		//-- Aplica filtro das filiais a serem processadas nas tabelas TRB (cenário de dois recalculos em execução)
		cFiltTRB := "TRB_THREAD = " + '"' + cThreadID + '"'
		TRB->(dbSetFilter({|| &cFiltTRB},cFiltTRB))
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³	Amarra notas de transferencia entre filiais                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lProcessa
			A330PrcTrf(aFilsCalc,lExistProc,cThreadID)
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se deve sequenciar os movimento de ordem 300        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lProcessa
			A330Seq300()
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Chama ponto de entrada para manipular arquivo de trabalho    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lProcessa .And. lA330TRB
			ExecBlock("MA330TRB",.F.,.F.)
			//- fazemos a garantia de que nada esteja com lock em aberto
			MsUnLockAll()
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			// Telemetria - Uso da classe FwCustomMetrics                    //
			// Metrica - setAverageMetric                                    //
			// Grava se utiliza ou nao utilizam a ordenação customizada no   //
			// recálculo do custo médio(através do ponto de entrada MA330TRB)//
			//?ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			If FWLibVersion() >= "20210628"
				FWCustomMetrics():setAverageMetric(	"MA330TRB"/*cSubRoutine*/,;
													"estoque/custos-protheus_recalculo-do-custo-medio-ordenacao-customizada_count" /*cIdMetric*/,;
													1 /*nValue*/,;
													/*dDateSend*/,;
													/*nLapTime*/,;
													"MATA330"/*cRotina*/)
			EndIf
		EndIf

		//Cria a SB2/TR2 com base nos registros deletados da SB2 e as movimentações da TRB
		A330CriaB2(aFilsCalc)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Recalcula o Custo                                            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		A330Recalc(nRateioFrota,nRateioVeiculo,nRateioViagem,aFilsCalc,lExistProc)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Calculo do Custo Unificado por Empresa / Filial              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lCusFil .Or. lCusEmp
			If lCusEmp
				cQuery := "DELETE FROM " +cNomTRT +" WHERE TRB_QFIM=0 AND TRB_QFIM2 = 0 AND TRB_VFIM1=0 AND "
				cQuery += " TRB_VFIM2=0 AND TRB_VFIM3=0 AND TRB_VFIM4=0 AND TRB_VFIM5=0 AND TRB_CM1=0 AND TRB_CM2=0 AND "
				cQuery += " TRB_CM3=0 AND TRB_CM4=0 AND TRB_CM5=0 AND TRB_QTDMOD=0 AND TRB_TOTCM1=0 AND TRB_TOTCM2=0 AND "
				cQuery += " TRB_TOTCM3=0 AND TRB_TOTCM4=0 AND TRB_TOTCM5=0 AND TRB_RNOAUX=0"
				TcSqlExec( cQuery )
			EndIf
			A330CMUnif(aFilsCalc,lExistproc)
		EndIf

		//Grava SB2 com base na TR2
		If 'TR2' $ cNomTR2
			If !lBat .And. !IsBlind()
				FWMsgRun(,{|oObj| A330B2Fim(aFilsCalc, oObj)}, STR0266, STR0267)
			Else 
				A330B2Fim(aFilsCalc)
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza os novos campos de custo unitario para fechamento   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		A330AtuCM(aFilsCalc)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Processa Log se Tiver Problemas na Baixa dos Lotes "SBD".    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lCusFIFO .Or. lCusLIFO
			For nX:= 1 to Len(aFilsCalc)
				If aFilsCalc[nX,1]
					cAliasTMP:= STRTRAN(alltrim("TMP"+cEmpAnt+(aFilsCalc[nX][2]))," ","_")
					nHandler := MsFCreate("LOGDIF"+cEmpAnt+(aFilsCalc[nX][2])+".TXT")
					If fError() # 0 .Or. nHandler < 0
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Atualiza o log de processamento com o erro  ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						M330PrcLog("ERRO","GPM350HAND",Ap5GetHelp("GPM350HAND"))
						Return NIL
					EndIf

					dbSelectArea( cAliasTMP )
					dbGoTop()
					While !Eof()
						fWrite( nHandler , T_CONTEUDO + CHR(13) + CHR(10) )
						dbSkip()
					EndDo
					Fclose( nHandler )

					dbSelectArea( "SB1" )
				EndIf
			Next nX
		EndIf
	Else
		Aviso("",OemToAnsi(STR0026), {"Ok"}) //"Cancelado pelo usuário"
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gera os lancamentos contabeis                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lContinua
		A330Contab(NIL,cNomTRC,NIL,aFilsCalc)
	EndIf

	//-- Fecha alias que foram usados temporariamente
	TRA->(dbCloseArea())
	TRB->(dbCloseArea())
	TRC->(dbCloseArea())
	TRD->(dbCloseArea())
	TRT->(dbCloseArea())
	TRX->(dbCloseArea())
	If a330ParamZX[11] == 1
		SG1->(dbCloseArea())
	EndIf

	//-- Fecha tabelas temporárias das divergências FIFO
	If (lCusFIFO .Or. lCusLIFO)
		For nY := 1 To Len(aNmArqTmp)
			If SELECT(aNmArqTmp[nY,2]) # 0
				aNmArqTmp[nY,1]:Delete()
			EndIf
		Next nY
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Fecha todos os arquivos e reabre-os de forma compartilhada,  ³
	//³ se o parametro MV_CUSTEXC estiver p/ abertura exclusiva.     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nTempoFim:=Seconds()
	dbSelectArea("SB1")
	dbSetOrder(1)
	If l330ArqExcl
		dbCloseAll()
		OpenFile(SubStr(cNumEmp,1,2))
	EndIf

	If lContinua
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Envia mensagem de aviso apos termino da rotina               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nTempoFim < nTempoIni
			nTempo := (nTempoFim+86399) - nTempoIni
		Else
			nTempo := nTempoFim - nTempoIni
		EndIf
		cTempo:=StrZero((nTempo)/60,5,0)
		MEnviaMail("023",{cUserName,SubStr(cNumEmp,1,2),SubStr(cNumEmp,3,2),cTempo})
	EndIf

	If lContinua
		//-- Atualiza saldos atuais da OP na SC2
		If SuperGetMv("MV_UPC2ATU",.F.,.F.)
			For nForFilial := 1 to Len(aFilsCalc)
				If !aFilsCalc[nForFilial,1]
					Loop
				EndIf

				cFilAnt := aFilsCalc[nForFilial,2]
				dInicio := SuperGetMv("MV_ULMES",.F.,SToD("19961231"))+1

				For nMoeda := 1 To 5
					If nMoeda # 1 .And. !(Str(nMoeda,1,0) $ cMoeda330C)
						Loop
					EndIf
					cQuery := "UPDATE " +RetSqlName("SC2") + " SET "
					//-- Atualiza VATU com VINI mais requisicoes menos devolucoes posteriores ao ultimo fechamento
					cQuery += "C2_VATU"+Str(nMoeda,1,0) +" = (C2_VINI"+Str(nMoeda,1,0) +" + "
					cQuery += 	"(SELECT "+MatIsnull()+"(SUM(CASE WHEN D3_TM > '500' THEN -D3_CUSTO"+Str(nMoeda,1,0) +" ELSE D3_CUSTO"+Str(nMoeda,1,0) +" END),0) "
					cQuery += 	"FROM " +RetSqlName("SD3") +" WHERE D_E_L_E_T_ = ' ' AND D3_FILIAL = '" +xFilial("SD3") +"' AND D3_ESTORNO <> 'S' AND "
					cQuery += 	"D3_OP = C2_NUM" +cConcat +"C2_ITEM" +cConcat +"C2_SEQUEN" +cConcat +"C2_ITEMGRD AND "
					cQuery += 	"D3_EMISSAO > '"+cC2UlMes+"' AND " +cSubstr +"(D3_CF,1,2) <> 'PR' AND " +cSubstr +"(D3_CF,3,1) <> '9') ), "
					//-- Atualiza APRATU com APRINI mais producoes posteriores ao ultimo fechamento
					cQuery += "C2_APRATU"+Str(nMoeda,1,0) +" = (C2_APRINI"+Str(nMoeda,1,0) +" + "
					cQuery += 	"(SELECT "+MatIsnull()+"(SUM(D3_CUSTO"+Str(nMoeda,1,0) +"),0) "
					cQuery += 	"FROM " +RetSqlName("SD3") +" WHERE D_E_L_E_T_ = ' ' AND D3_FILIAL = '" +xFilial("SD3") +"' AND D3_ESTORNO <> 'S' AND "
					cQuery += 	"D3_OP = C2_NUM" +cConcat +"C2_ITEM" +cConcat +"C2_SEQUEN" +cConcat +"C2_ITEMGRD AND "
					cQuery += 	"D3_EMISSAO > '"+cC2UlMes+"' AND " +cSubstr +"(D3_CF,1,2) = 'PR') )"
					cQuery += "WHERE D_E_L_E_T_ = ' ' AND C2_FILIAL = '" +xFilial('SC2') +"' AND (C2_DATRF = ' ' OR C2_DATRF > '" +cC2UlMes +"')"
					A330SQLExec(cQuery,"A330EMV" + STR0067+cFilAnt, STR0226 ) //" filial" //"Erro na Atualização de saldos atuais da OP na SC2: "
				Next nMoeda
			Next nForFilial
			cFilAnt := cFilBack
			dInicio := dIniBack
		EndIf
	ENDIF

	// limpa o cache com os produtos de mao de obra
	A330ISMOD()

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ P.E. utilizado para executar rotinas apos o recalculo.       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lMA330Fim
		ExecBlock("MA330FIM",.F.,.F.)
	EndIf

	// Limpa variavel global de controle
	If nColigada > 0
		ClearGlbValue("cPMS_SB2")
	EndIf

	If lContinua .and. lJourney .and.!l331x330
		M330Analysis(aFilsCalc)
	Endif

	If lContinua
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o log de processamento   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		M330PrcLog("FIM")
		lfinish := .T.

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ EventViewer						  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cIDEvent:= "023"
		cTitle:= 	STR0220 // "Termino de processamento do custo "
		cMessage:=	STR0221+cTempo+ STR0223 + CRLF // "Tempo de Execução: "
		cMessage+=  STR0222+cUserName +CRLF // Usuário // Min
		EventInsert( FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cIDEvent, FW_EV_LEVEL_INFO, "",cTitle, cMessage, .T. ) // "Termino de gração com Tempo"
		If Valtype(oJourneyLog) == 'O'
			cIdJourney := oJourneyLog:cIdParent
			If lJourney
				oJourneyLog:updateD3YPositi('MATA330')
				oJourneyLog:attStatus('FINISHED', .F.)
			Endif
		Endif
	EndIf
EndIf

// Desbloqueio de filiais bloqueadas
M330331ULk(aFilsCalc, lJourney)

//Envia mensagem para EAI
If lIntegDef
	MAEnvInteg(cListaFil)
EndIf

if lContinua .and. l331x330 .And. lfinish
	M330startC(aListaFil , cIdJourney, cfilant, FWGrpCompany(), @oJourneyLog)
EndIf 

if lfinish
	oJourneyLog:Destroy()
	FreeObj(oJourneyLog)
EndIf 

Return NIL


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ A330HEAD ³ Autor ³ Marcos Bregantim      ³ Data ³ 13/09/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Simula HEADPROVA testando lLanctoOn (Lancto. On-Line)      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MA330HEad(xPar1,xPar2,xPar3,xPar4)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Numero do lote para lancamentos contabeis          ³±±
±±³          ³ ExpC2 = Nome da Rotina de Origem dos lancamentos contabeis ³±±
±±³          ³ ExpC3 = Nome do Usuario Corrente                           ³±±
±±³          ³ ExpC4 = Nome do Arquivo de Contra-Prova                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function A330HEAD(xPar1,xPar2,xPar3,xPar4,aPar5)
Local nRet := 0
xPar2 := IIf(a330ParamZX[12]==3,"MATA330",IIf(a330ParamZX[12]==1,"MTA330C","MTA330P"))
If lLanctoOn
	nRet := HEADPROVA(xPar1,xPar2,xPar3,@xPar4,nil,aPar5)
EndIf
Return (nRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ A330RODA ³ Autor ³ Marcos Bregantim      ³ Data ³ 13/09/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Simula RODAPROVA testando lLanctoOn (Lancto. On-Line)      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³  A330RODA(xPar1,xPar2)                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Endereco do arquivo de contra-prova                ³±±
±±³          ³ ExpN2 = Total dos lancamentos contabeis                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function A330RODA(xPar1,xPar2,xPar3)
Local lRet:=.F.
If lLanctoOn
	lRet := RodaProva(xPar1,xPar2,xPar3)
EndIf
Return (lRet)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MA330DelD3³ Autor ³ Marcos Bregantim      ³ Data ³ 26/07/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Apaga movimentos de estorno no SD3                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MA330DelD3(Void)                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function MA330DelD3()
Local aArea    := GetArea()
Local cSeek    := ""
Local cCompara := ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Remove registros estornados dos arquivos relacionados        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Rastro(SD3->D3_COD)
	dbSelectArea("SD5")
	dbSetOrder(3)
	cSeek:=xFilial("SD5")+SD3->D3_NUMSEQ+SD3->D3_COD+SD3->D3_LOCAL+SD3->D3_LOTECTL+IF(Rastro(SD3->D3_COD,"S"),SD3->D3_NUMLOTE,"")
	cCompara:="D5_FILIAL+D5_NUMSEQ+D5_PRODUTO+D5_LOCAL+D5_LOTECTL"+IF(Rastro(SD3->D3_COD,"S"),"+D5_NUMLOTE","")
	dbSeek(cSeek)
	While !Eof() .And. cSeek == &(cCompara)
		If D5_ESTORNO == "S"
			RecLock("SD5",.F.,.T.)
			dbDelete()
			SD5->(MsUnlock())
		EndIf
		dbSkip()
	End
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Remove registros estornados dos arquivos relacionados        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Localiza(SD3->D3_COD)
	dbSelectArea("SDB")
	dbSetOrder(1)
	cSeek:=xFilial("SDB")+SD3->D3_COD+SD3->D3_LOCAL+SD3->D3_NUMSEQ+SD3->D3_DOC
	cCompara:="DB_FILIAL+DB_PRODUTO+DB_LOCAL+DB_NUMSEQ+DB_DOC"
	dbSeek(cSeek)
	While !Eof() .And. cSeek == &(cCompara)
		If DB_ESTORNO == "S"
			RecLock("SDB",.F.,.T.)
			dbDelete()
			SDB->(MsUnlock())
		EndIf
		dbSkip()
	EndDo
	If lM330DSDA
		dbSelectArea("SDA")
		dbSetOrder(1)
		cSeek:=xFilial("SDA")+SD3->D3_COD+SD3->D3_LOCAL+SD3->D3_NUMSEQ+SD3->D3_DOC
		cCompara:="DA_FILIAL+DA_PRODUTO+DA_LOCAL+DA_NUMSEQ+DA_DOC"
		dbSeek(cSeek)
		While !Eof() .And. cSeek == &(cCompara)
			If SDA->DA_ORIGEM =="SD3" .And. SDA->DA_QTDORI == SDA->DA_SALDO .And. SD3->D3_TM <= "500" .And. SubStr(SD3->D3_CF,1,2) == "DE"
		 		RecLock("SDA",.F.,.T.)
		 		dbDelete()
				SDA->(MsUnlock())
			EndIf
			dbSkip()
	  	EndDo
	EndIf
EndIf

RestArea(aArea)
aSize(aArea,0)
aArea := nil

RecLock("SD3",.F.,.T.)
dbDelete()
SD3->(MsUnlock())
dbSkip()
Return NIL

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GRAVASEQ  ³ Autor ³ BREGANTIN             ³ Data ³ 23/01/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava Sequencia de Calculo                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias da Sequencia de Calculo                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GravaSeq(cArq)
Local cAlias    := Alias()
Local cNewSeq

//- Garante que apenas um pegue o ID
A330LckGlb(cSeqEmp)

// Monta a sequencia de Calculo para Thread
cNewSeq := Soma1(GetGlbValue(cSeqEmp))
//- envia a nova sequencia para o servidor
PutGlbValue(cSeqEmp,cNewSeq)
//- Libera a chave em uso
A330ULckGlb(cSeqEmp)

dbSelectArea(cArq)
RecLock(cArq,.F.)
If cArq == "SD1"
	SD1->D1_SEQCALC := dTos(dInicio)+cNewSeq
ElseIf cArq == "SD2"
	SD2->D2_SEQCALC := dTos(dInicio)+cNewSeq
ElseIf cArq == "SD3"
	SD3->D3_SEQCALC := dTos(dInicio)+cNewSeq
EndIf
(cArq)->(MsUnlock())

DbSelectArea(cAlias)
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ A330DET  ³ Autor ³ Marcos Bregantim      ³ Data ³ 13/09/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Cria em array lancamentos contabil testando lLanctoOn       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³A330DET(cSeqCalc,cLanctoPad,cRotinaCall,cAliasOri,lAvalLcto)³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Sequencia de calculo                               ³±±
±±³          ³ ExpC2 = Codigo do Lancamento Padrao                        ³±±
±±³          ³ ExpC3 = Rotina Chamadora                                   ³±±
±±³          ³ ExpC4 = Alias                                              ³±±
±±³          ³ ExpL5 = Avalia se usa 666/668 para Req/Dev de Consumo      ³±±
±±³          ³ ExpA6 = Perguntas da rotina MATA330 (quando thread de job) ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function A330Det(cSeqCalc,cLanctoPad,cRotinaCall,cAliasOri,lAvalLcto,a330ParLoc,nRecSGS)
Local cAlias  		:= Alias(), lCCusto := .F.
Local l667669 		:= cLanctoPad$"667#669"
Local lPcoInte
Local lRet	  		:= .F.
Local lLanctoOn 	:= .F.
Local xResultado
Local lConsuDate 	:= .F. 

Default a330ParLoc := a330ParamZX //-- herda variavel private

If __MV_PCOINTE == Nil
	__MV_PCOINTE := JsonObject():New()
EndIf

If __MV_PCOINTE <> Nil
	xResultado := __MV_PCOINTE[cFilAnt]
	IF xResultado == NIL
		xResultado := SuperGetMV("MV_PCOINTE",.F.,"2")
		__MV_PCOINTE[cFilAnt] := xResultado
	EndIF
	lPcoInte := (xResultado=="1")
EndIf

lLanctoOn   := IIf(a330ParLoc[10] == 1,.T.,.F.)
cRotinaCall := IIF(a330ParLoc[12]==3,"MATA330",IIf(a330ParLoc[12]==1,"MTA330C","MTA330P"))
cAliasOri   := IIF(cAliasOri==NIL,"SD3",cAliasOri)
lAvalLcto   := IIF(lAvalLcto==NIL,.F.,lAvalLcto)
nRecSGS     := IIF(nRecSGS==NIL,0,nRecSGS)

If cAliasOri == "SD3"
	dbSelectArea("SD3")
	If lLanctoOn
		If Empty(SD3->D3_OP) .And. Subs(SD3->D3_CF,2,2)$"E0#E3#E5#E6#E8"
			lCCusto := .T.
		Else
			If a330ParLoc[12] == 1 .And. Subs(SD3->D3_CF,2,2)$"E0#E3#E5#E6#E8" .And.;
			Alltrim(Subs(SD3->D3_OP,7,5)) == "OS001"
				lCCusto := .T.
			EndIf
		EndIf
		If ( a330ParLoc[12] == 1 .And. lCCusto .And. !l667669)
			// Adiciona na lista para geracao de lancamento contabil
			GravaRegCT(cFilAnt,cAliasOri,(cAliasOri)->(Recno()),cSeqCalc,cLanctoPad,cRotinaCall,.F.,SB1->(Recno()),SF4->(Recno()),nRecSGS)
		ElseIf 	a330ParLoc[12] == 2 .And. ((!lCCusto .And. !l667669) .Or. (lCCusto .And. l667669) .Or. lAvalLcto ) .And. ;
				Alltrim(Subs(SD3->D3_OP,7,5)) != "OS001"  // Incluido para integracao com MNT
			If l667669
				lRet := .T. // Verificar se precisa checar lancamentos 667/669
			EndIf
			// Adiciona na lista para geracao de lancamento contabil
			GravaRegCT(cFilAnt,cAliasOri,(cAliasOri)->(Recno()),cSeqCalc,cLanctoPad,cRotinaCall,lAvalLcto,SB1->(Recno()),SF4->(Recno()),nRecSGS)
		ElseIf a330ParLoc[12] == 3 .And. !l667669
			// Adiciona na lista para geracao de lancamento contabil
			GravaRegCT(cFilAnt,cAliasOri,(cAliasOri)->(Recno()),cSeqCalc,cLanctoPad,cRotinaCall,.F.,SB1->(Recno()),SF4->(Recno()),nRecSGS)
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Integracao com o PCO processo 314 item 02      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lPcoInte .And. cLanctoPad $ "666/67A/670/672/668/67B/679/680" .And. (Funname()=="MATA330" .Or. (Funname()=="MATA331" .And. lJourney))
			PcoDetLan("000314","02","MATA330")
		EndIf
	ElseIf a330ParLoc[10] != 3 .And. !Empty(SD3->D3_DTLANC)
		
		lConsuDate := Subs(SD3->D3_CF,2,2)$"E0#E3#E5#E6#E8" .AND. (Empty(SD3->D3_OP) .OR. Alltrim(Subs(SD3->D3_OP,7,5)) == "OS001")
		
		If a330ParLoc[12] == 3 .OR. (lConsuDate .and. a330ParLoc[12] == 1) .OR. (!lConsuDate .and. a330ParLoc[12] == 2)
			RecLock("SD3",.F.)
			SD3->D3_DTLANC := cTod('')
			SD3->(MsUnLock())
		Endif
	EndIf
ElseIf a330ParLoc[12] != 1
	If lLanctoOn
		// Adiciona na lista para geracao de lancamento contabil
		GravaRegCT(cFilAnt,cAliasOri,(cAliasOri)->(Recno()),cSeqCalc,cLanctoPad,cRotinaCall,.F.,SB1->(Recno()),SF4->(Recno()),nRecSGS)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Integracao com o PCO processo 314 item 01 e 03 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If  lPcoInte .And. cLanctoPad $ "641/682/681/678" .And. (Funname()=="MATA330" .Or. (Funname()=="MATA331" .And. lJourney))
			If cAliasOri=="SD1" .And. cLanctoPad $ "641/682/681"
				PcoDetLan("000314","01","MATA330")
			ElseIf cAliasOri=="SD2" .And. cLanctoPad $ "678"
				PcoDetLan("000314","03","MATA330")
			EndIf
		EndIf
	EndIf
EndIf
dbSelectArea(cAlias)
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A330GrvTRB³ Autor ³ Bregantim / Stiefano  ³ Data ³ 15/10/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava arquivo de trabalho por nivel da estrutura           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A330GrvTRB(ExpC1,ExpC2,ExpA1)                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Variavel com nome do arquivo de trabalho p/ custo  ³±±
±±³          ³ unificado                                                  ³±±
±±³          ³ ExpC2 = Variavel com nome do indice  de trabalho p/ custo  ³±±
±±³          ³ unificado                                                  ³±±
±±³          ³ ExpA3 = Array com o controle para processamento por empresa³±±
±±³          ³ ExpL4 = Variavel que verifica a utilizacao de procedures   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function A330GrvTRB(aFilsCalc,lExistProc)
Local nRegRE5   :=0
Local nRegRE6   :=0

Local cSeekSD1  := ""

Local aTransf	:= {}
Local aRegsRE5	:= {{}}
Local aRegsRE6  := {{}}

Local lRet 		:= .T.
Local lAptmPMS	:= .F.
Local lAuxEofSD3:= .F.
Local lDocCQ	:= .F.
Local lAtuNiv   := .F.

Local cLocalCQ  := GetMvNNR('MV_CQ','98')
Local lRemInt   := SuperGetMv("MV_REMINT",.F.,.F.)
Local cProdMNT  := SuperGetMv("MV_PRODMNT",.F.,"MANUTENCAO")
Local cSeqRetBen:= SuperGetMv("MV_SEQREBE",.F.,"290")
Local lIntMNT   := MTA330IsMNT()
Local lAjCamb   := cPaisLoc == "BOL"

Local nAchou
Local lEofSD3
Local i
Local lUsaD2DIG    := UsaD2DTDIG()

DEFAULT lExistProc := .F.

// Ordem Calculo
// 080 -> LOCALIZACOES - Movimento de Ajuste Cambial (Bolivia)           - Arquivo SD3
// 095 -> LOCALIZACOES - Remitos de entrada por compra                   - Arquivo SCM
// 100 -> Compras                                                        - Arquivo SD1
// 110 -> Movimentacoes do CQ                                            - Arquivo SD3
// 120 -> Entrada de beneficiamento efetuado fora e Req. para OP (RE5)   - PERIODO ANTERIOR - Arquivo SD1/SD3
// 145 -> LOCALIZACOES - Devolucao Compras                               - Arquivo SCM
// 150 -> Devolucao Compras                                              - Arquivo SD2
// 195 -> LOCALIZACOES - Devolucao de Vendas Mes Anterior                - Arquivo SCN
// 200 -> Devolucao Vendas Periodo Anterior                              - Arquivo SD1
// 250 -> Remessa Beneficiamento "Eu Benef."                             - Arquivo SD1
// 280 -> Retorno Beneficiamento "Fora"                                  - PERIODO ANTERIOR - Arquivo SD1
// 290 -> Retorno Beneficiamento "Eu Benef."                             - Arquivo SD2 [MV_SEQREBE = '290']
// 300 -> Movimentacoes Internas (menos req. p/ consumo e transferencia) - Arquivo SD3
// 300 -> Movimentacoes Internas de transferencia                  w     - Arquivo SD3
// 300 -> Saida para transferencia entre filiais                   w     - Arquivo SD2
// 300 -> Entrada de transferencia entre filiais                   w     - Arquivo SD1
// 300 -> Remessa Beneficiamento "Fora" de Produtos sem estrutura  x     - Arquivo SD2
// 300 -> Retorno Beneficiamento "Fora" de Produtos sem estrutura  y     - Arquivo SD1
// 300 -> Remessa Beneficiamento "Fora" de Produtos com estrutura  x     - Arquivo SD1
// 300 -> Retorno Beneficiamento "Fora" de Produtos com estrutura  y     - Arquivo SD2
// 300 -> Entrada de beneficiamento efetuado fora e Req. para OP (RE5)   - Arquivo SD1/SD3
// 301 -> Requisicoes para Consumo										 - Arquivo SD3
// 302 -> Retorno Beneficiamento "Eu Benef."                             - Arquivo SD2 [MV_SEQREBE = '302']
// 480 -> Apontamento de Projetos ( SIGAPMS )
// 495 -> LOCALIZACOES - Remitos de saida Vendas "SCN"
// 500 -> Vendas "SD2"													 - Arquivo SD2
// 500 -> Devolucoes Vendas do periodo                                   - Arquivo SD1
// 545 -> LOCALIZACOES - Devolucao de Vendas do Mes "SCN"
// 600 -> Reavaliacao de Custo (REA/DEA)                                 - Arquivo SD3
// 610 -> Movimento de acerto do custo de reposicao                      - Arquivo SD3

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Pega valores do inicio do periodo para serem reprocessados   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
A330Inicia(lExistProc)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Processa as compras                                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza o log de processamento			                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
M330PrcLog("MENSAGEM",OemToAnsi(STR0081) +STR0067+cFilAnt,OemToAnsi(STR0081)) //"Gerando Arquivo de Trabalho - SD1"

dbSelectArea("SD1")
dbSetOrder(6)
dbSeek(xFilial("SD1")+dTos(dInicio),.T.)
If !lBat
	ProcRegua(LastRec())
EndIf
While !Eof() .And. SD1->D1_FILIAL == xFilial("SD1") .And. SD1->D1_DTDIGIT <= a330ParamZX[01]
	lEofSD3:=.T.
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Movimentacao do Cursor                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lBat .And. !IsBlind()
		IncProc(OemToAnsi(STR0081)) //"Gerando Arquivo de Trabalho - SD1"
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Desconsiderar notas de entrada tipo 10 quando o cliente uti_ |
	//| lizar o conceito de remito interno com importacao (SIGAEIC)  |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRemInt
	  	If !Empty(SD1->D1_CONHEC) .And. SD1->D1_TIPO_NF $ '5' .And. SD1->D1_TIPODOC $ '10'
			DbSkip()
			Loop
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Desconsiderar notas de remito e notas geradas pelo EIC       ³
	//| com excecao da nota de FOB.									 |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(SD1->D1_REMITO) .Or. (cPaisLoc # "BRA" .And. SD1->D1_TIPO_NF $ '6789AB')
		DbSkip()
		Loop
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Nao processar lancamentos dos Livros Fiscais                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SD1->D1_ORIGLAN == "LF"
		dbSkip()
		Loop
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ LOCALIZACOES - Ignora NF de Entrada com REMITO               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cPaisLoc # "BRA"
		If !Empty(D1_REMITO)
			dbSkip()
			Loop
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Tratamento de integracao com o SIGAMNT                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lIntMNT .And. AllTrim(cProdMNT) == AllTrim(SD1->D1_COD)
		dbSkip()
		Loop
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se existe apontamento do SD1 a um Projeto           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	AFN->(dbSetOrder(2))
	lAptmPMS := AFN->(dbSeek(xFilial("AFN")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_ITEM) .And. !(AFN->AFN_ESTOQU == '2'))

	//dbSelectArea("SF4")
	SF4->(dbSetOrder(1))
	SF4->(MsSeek(xFilial("SF4")+SD1->D1_TES))

	dbSelectArea("SD1")
	If (!Empty(D1_OP) .Or. lAptmPMS) .And. SF4->F4_ESTOQUE == "S" .And. !(SF4->F4_PODER3$"RS")

		dbSelectArea("SD3")
		// Se houve requisicao para OP por Liberacao de CQ
		If cLocalCQ == SD1->D1_LOCAL
			// Se houve requisicao para OP de um documento de entrada direto ou por Liberacao de CQ
			dbSetOrder(14) // D3_FILIAL+D3_COD+D3_IDENT
			dbSeek(xFilial("SD3")+SD1->D1_COD+SD1->D1_NUMSEQ)
			While !Eof() .And. SD3->D3_COD == SD1->D1_COD .AND. SD3->D3_IDENT == SD1->D1_NUMSEQ
				If Alltrim(SD3->D3_CF) == "RE5"
					If SD3->D3_OP == SD1->D1_OP
						Exit
					EndIf
				EndIf
				dbSkip()
			EndDo

			dbSelectArea("SD1")
			lEofSD3 := IIF(SD1->D1_OP # SD3->D3_OP .Or. SD1->D1_NUMSEQ # SD3->D3_IDENT .Or. SD3->(Eof()),.T.,.F.)

		// Se houve requisicao para OP de um documento de entrada direto
		Else
			dbSetOrder(4)
			dbSeek(xFilial("SD3")+SD1->D1_NUMSEQ)
			While !Eof() .And. Alltrim(SD3->D3_CF) # "RE5" .And. SD3->D3_NUMSEQ == SD1->D1_NUMSEQ .And. SD3->D3_COD != SD1->D1_COD .And. SD3->D3_OP != SD1->D1_OP
				dbSkip()
			EndDo

			dbSelectArea("SD1")
			lEofSD3 := IIF(SD1->D1_OP # SD3->D3_OP .Or. SD1->D1_NUMSEQ # SD3->D3_NUMSEQ .Or. SD3->(Eof()),.T.,.F.)

		EndIf

		If !lEofSD3
			For i:=1 to Len(aRegsRE5)
				nAchou:=ASCAN(aRegsRE5[i],{|x| x == SD3->D3_NUMSEQ})
				If nAchou > 0
					Exit
				EndIf
			Next i
			// Coloca registro do RE5 no array de movimentos processados
			If nAchou == 0
				If Len(aRegsRE5[Len(aRegsRE5)]) > 4095
					AADD(aRegsRE5,{})
				EndIf
				AADD(aRegsRE5[Len(aRegsRE5)],SD3->D3_NUMSEQ)
			EndIf
		EndIf
	EndIf
	dbSelectArea("SD1")
	If SF4->F4_ESTOQUE == "S"
		If D1_TIPO != "D"
			If SF4->F4_PODER3 == "D"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava Retorno Beneficiamento ( FORA ).                ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				lAtuNiv := .F.
				If A330Period("D",@lAtuNiv)
					A330TRB(aFilsCalc,"SD1","300",If(!lEofSD3,SD3->(Recno()),NIL),,,,lAtuNiv)
					If !lEofSD3
						dbSelectArea("SD3")
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Grava Movimentacoes Internas.                         ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						A330TRB(aFilsCalc,"SD3","300",SD1->(Recno()),TRB->(Recno()))
						dbSelectArea("SD1")
					EndIf
				Else
					A330TRB(aFilsCalc,"SD1","280",If(!lEofSD3,SD3->(Recno()),NIL))
					If !lEofSD3
						dbSelectArea("SD3")
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Grava Movimentacoes Internas.                         ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						A330TRB(aFilsCalc,"SD3","280",SD1->(Recno()),TRB->(Recno()))
						dbSelectArea("SD1")
					EndIf
				EndIf
			ElseIf SF4->F4_PODER3 == "R"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava Remessa de Beneficiamento ( EU BENEF. ).        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				A330TRB(aFilsCalc,"SD1","250")
			Else
				If lAptmPMS
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Grava Notas Fiscais de Compras.                       ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					dbSelectArea("AFN")
					dbSetOrder(2)
					If MsSeek(xFilial("AFN")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_ITEM)
						While !Eof() .And. xFilial("AFN")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_ITEM==;
								AFN->(AFN_FILIAL+AFN_DOC+AFN_SERIE+AFN_FORNEC+AFN_LOJA+AFN_ITEM)
							dbSelectArea("SD3")
							dbSetOrder(4)
							dbSeek(xFilial("SD3")+SD1->D1_NUMSEQ)
							While !Eof() .And. Alltrim(SD3->D3_CF) # "RE5" .And. SD3->D3_NUMSEQ == SD1->D1_NUMSEQ
								dbSkip()
							EndDo
							lAuxEofSD3 := IIF(SD3->D3_NUMSEQ # SD1->D1_NUMSEQ,.T.,.F.)
							If !lAuxEofSD3
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Grava Notas Fiscais de Compras.                       ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If !IsRemito(1,'SD1->D1_TIPODOC')
									A330TRB(aFilsCalc,"SD1",If(!lEofSD3,"300","100"),If(!lEofSD3,SD3->(Recno()),NIL))
								Else
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Grava Remitos de Compras.                             ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									A330TRB(aFilsCalc,"SD1",If(!lEofSD3,"300","095"),If(!lEofSD3,SD3->(Recno()),NIL))
								EndIf
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Grava Movimentacoes Internas.                         ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								A330TRB(aFilsCalc,"SD3","300",SD1->(Recno()),TRB->(Recno()))
								dbSelectArea("SD1")
							EndIf
							dbSelectArea("AFN")
							dbSkip()
						End
					EndIf
				Else
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Grava Notas Fiscais de Compras.                       ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !IsRemito(1,'SD1->D1_TIPODOC')
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ NfeComplFF - utilizada para analisar se foi gerada 'RE6'   |
						//| para notas de complemento, somente utilizada c/ custo Fifo.|
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If (lCusFifo .Or. lCusLifo) .And. NfeComplFF("SD1",(lCusFifo .Or. lCusLifo),2)
							dbSelectArea("SD3")
							dbSetOrder(4)
							dbSeek(xFilial("SD3")+SD1->D1_NUMSEQ)
							While !Eof() .And. Alltrim(SD3->D3_CF) # "RE6" .And. SD3->D3_NUMSEQ == SD1->D1_NUMSEQ .And. SD3->D3_COD != SD1->D1_COD
								dbSkip()
							EndDo
							lAuxEofSD3 := IIF(SD1->D1_NUMSEQ # SD3->D3_NUMSEQ .Or. SD3->(Eof()),.T.,.F.)
							If !lAuxEofSD3
								For i:=1 to Len(aRegsRE6)
									nAchou:=ASCAN(aRegsRE6[i],{|x| x == SD3->D3_NUMSEQ})
									If nAchou > 0
										Exit
									EndIf
								Next i
								// Coloca registro do RE6 no array de movimentos processados
								If nAchou == 0
									If Len(aRegsRE6[Len(aRegsRE6)]) > 4095
										AADD(aRegsRE6,{})
									EndIf
									AADD(aRegsRE6[Len(aRegsRE6)],SD3->D3_NUMSEQ)
								Else
									lAuxEofSD3 := .T.
								EndIf
							EndIf

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Grava Notas Fiscais de Complemento                    ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							dbSelectArea("SD1")
							A330TRB(aFilsCalc,"SD1",If(!lAuxEofSD3,"300","100"),If(!lAuxEofSD3,SD3->(Recno()),NIL),If(!lAuxEofSD3,IIf(TRB->(Recno())==1,TRB->(Recno())+1,TRB->(Recno())+2),NIL))

							If !lAuxEofSD3
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Grava Movimentacoes Internas.                         ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								dbSelectArea("SD3")
								A330TRB(aFilsCalc,"SD3","300",SD1->(Recno()),TRB->(Recno()))
							EndIf

						Else
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Grava Notas Fiscais de Compras.                       ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							A330TRB(aFilsCalc,"SD1",If(!lEofSD3,"300","100"),If(!lEofSD3,SD3->(Recno()),NIL))
						EndIf
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Grava Remitos de Compras.                             ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					Else
						A330TRB(aFilsCalc,"SD1",If(!lEofSD3,"300","095"),If(!lEofSD3,SD3->(Recno()),NIL))
					EndIf
					If !lEofSD3
						dbSelectArea("SD3")
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Grava Movimentacoes Internas.                         ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						A330TRB(aFilsCalc,"SD3","300",SD1->(Recno()),TRB->(Recno()))
					EndIf
					dbSelectArea("SD1")
				EndIf
			EndIf
		Elseif D1_TIPO == "D" .And. A330Period("V")
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava Notas Fiscais de Devolucoes de Compras.(Remitos)³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If IsRemito(1,'SD1->D1_TIPODOC')
				A330TRB(aFilsCalc,"SD1","545",,If(!lEofSD3,SD3->(Recno()),NIL))
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava Notas Fiscais de Devolucoes de Vendas  (Notas F)³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				A330TRB(aFilsCalc,"SD1","500",,If(!lEofSD3,SD3->(Recno()),NIL))
			EndIf
		Elseif D1_TIPO == "D" .And. !A330Period("V")
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava Devolucoes de Vendas Mes Anterior.(Remitos)     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If IsRemito(1,'SD1->D1_TIPODOC')
				A330TRB(aFilsCalc,"SD1","195",,If(!lEofSD3,SD3->(Recno()),NIL))
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava Devolucoes de Vendas Mes Anterior.(Nota fiscal) ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				A330TRB(aFilsCalc,"SD1","200",,If(!lEofSD3,SD3->(Recno()),NIL))
			EndIf
		EndIf
	EndIf
	dbSelectArea("SD1")
	dbSkip()
EndDo

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Devolve ordem principal do arquivo                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SD1")
dbSetorder(1)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Processa as Vendas, Devolucoes, Beneficiamento               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza o log de processamento			    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
M330PrcLog("MENSAGEM",OemToAnsi(STR0082) +STR0067+cFilAnt,OemToAnsi(STR0082)) //"Gerando Arquivo de Trabalho - SD2"

dbSelectArea("SD2")
dbSetOrder( IIf( lUsaD2DIG, 19, 5 ) )
dbSeek(xFilial("SD2")+dTos(dInicio),.T.)
If !lBat
	ProcRegua(LastRec())
EndIf
While !Eof() .And. D2_FILIAL == xFilial("SD2") .And. IIf(lUsaD2DIG, D2_DTDIGIT, D2_EMISSAO) <= a330ParamZX[01]
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Movimentacao do Cursor                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lBat .And. !IsBlind()
		IncProc(OemToAnsi(STR0082)) //"Gerando Arquivo de Trabalho - SD2"
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Nao processar lancamentos dos Livros Fiscais                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If D2_ORIGLAN == "LF"
		dbSkip()
		Loop
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Tratamento de integracao com o SIGAMNT                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lIntMNT .And. AllTrim(cProdMNT) == AllTrim(SD2->D2_COD)
		dbSkip()
		Loop
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ LOCALIZACOES - Ignora NF de Saida com REMITO que nao eh de   ³
	//³                consigacao (D2_TPDCENV # "1").                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cPaisLoc # "BRA"
		If !Empty(D2_REMITO) .And. !(D2_TPDCENV $ _RMCONS)
			dbSkip()
			Loop
		EndIf
	EndIf

	//dbSelectArea("SF4")
	SF4->(dbSetOrder(1))
	SF4->(MsSeek(xFilial("SF4")+SD2->D2_TES))
	dbSelectArea("SD2")
	If SF4->F4_ESTOQUE == "S"
		If D2_TIPO != "D"
			If SF4->F4_PODER3 == "R"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava Remessa Beneficiamento ( FORA ).                ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				lAtuNiv := A330Period()
				A330TRB(aFilsCalc,"SD2","300",,,,,lAtuNiv)
			ElseIf SF4->F4_PODER3 == "D"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava Retorno Beneficiamento ( EU BENEF. ).           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				A330TRB(aFilsCalc,"SD2",cSeqRetBen) //cSeqRetBen 290 ou 302 de acordo com o parâmetro MV_SEQREBE
			Else
				If IsRemito(1,'SD2->D2_TIPODOC')
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Grava Remitos de  Vendas.                             ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					A330TRB(aFilsCalc,"SD2","495")
				Else
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Grava Notas Fiscais Vendas.                           ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					A330TRB(aFilsCalc,"SD2","500")
				EndIf
			EndIf
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava remitos de Dev. Compras                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If IsRemito(1,'SD2->D2_TIPODOC')
				A330TRB(aFilsCalc,"SD2","145")
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava Notas Fiscais de Dev. Compras                   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava Notas Fiscais de Dev. Compras                   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				SD1->(dbSetOrder(1))
				cSeekSD1:=SD2->D2_NFORI+SD2->D2_SERIORI+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEMORI
				SD1->(dbSeek(xFilial("SD1")+cSeekSD1))
				A330TRB(aFilsCalc,"SD2","150")
			EndIf
		EndIf
	EndIf
	dbSelectArea("SD2")
	dbSkip()
EndDo

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Devolve ordem principal dos arquivos                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SD2")
dbSetOrder(1)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Processa as movimentacoes internas                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza o log de processamento			    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
M330PrcLog("MENSAGEM",OemToAnsi(STR0083) +STR0067+cFilAnt,OemToAnsi(STR0083)) //"Gerando Arquivo de Trabalho - SD3"

dbSelectArea("SD3")
dbSetOrder(6)
dbSeek(xFilial("SD3")+dTos(dInicio),.T.)
If !lBat
	ProcRegua(LastRec())
EndIf
While !Eof() .And. D3_FILIAL == xFilial("SD3") .And. D3_EMISSAO  <= a330ParamZX[01]
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Movimentacao do Cursor                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lBat .And. !IsBlind()
		IncProc(OemToAnsi(STR0083)) //"Gerando Arquivo de Trabalho - SD3"
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Valida movimentos de WMS                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !D3Valido("SD3")
		SD3->(DbSkip())
		Loop
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Tratamento de integracao com o SIGAMNT                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lIntMNT .And. AllTrim(cProdMNT) == AllTrim(SD3->D3_COD)
		dbSkip()
		Loop
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Filtra RE5. ja processada no while do SD1                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Alltrim(SD3->D3_CF) $ "RE5/DE5"
		nRegRE5:=Recno()
		// Coloca registro do RE5 no array de movimentos processados
		For i:=1 to Len(aRegsRE5)
			nAchou:=ASCAN(aRegsRE5[i],{|x| x == SD3->D3_NUMSEQ})
			If nAchou > 0
				Exit
			EndIf
		Next i
		// Grava sequencia do RE5
		If nAchou == 0
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava Movimentacoes Internas.                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SD1->(dbSetOrder(4))
			If SD1->(dbSeek(xFilial("SD1")+SD3->D3_IDENT))
				A330TRB(aFilsCalc,"SD3","300",SD1->(Recno()))
			Else
				A330TRB(aFilsCalc,"SD3","300")
			EndIf
			SD1->(dbSetOrder(1))
			SD3->(dbGoto(nRegRE5))
		EndIf
		dbSkip()
		Loop
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava Movimentacoes Internas.                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Alltrim(SD3->D3_CF) $ "RE8/DE8" // Integracao com SIGAEIC
		A330TRB(aFilsCalc,"SD3","100")
	ElseIf !Empty(SD3->D3_PROJPMS)
		A330TRB(aFilsCalc,"SD3","480")
	ElseIf Alltrim(SD3->D3_CF) $ "RE0" .And. Empty(SD3->D3_OP) // Requisicoes p/ Consumo
		A330TRB(aFilsCalc,"SD3","301")
	ElseIf Alltrim(SD3->D3_CF) $ "RE4/DE4" .And. SD3->D3_ESTORNO == "S"
		nAchou:=ASCAN(aTransf,{|x| x[1] == SD3->D3_NUMSEQ .And. x[2] == SD3->D3_CF .And. x[3] == SD3->D3_COD})
		If nAchou > 0
			A330TRB(aFilsCalc,"SD3","300",nil,nil,"2")
		Else
			AADD(aTransf,{SD3->D3_NUMSEQ,SD3->D3_CF,SD3->D3_COD})
			A330TRB(aFilsCalc,"SD3","300",nil,nil,"1")
		EndIf
	ElseIf Alltrim(SD3->D3_CF) $ "RE6/DE6"
		nRegRE6:=Recno()
		// Coloca registro do RE6 no array de movimentos processados
		For i:=1 to Len(aRegsRE6)
			nAchou:=ASCAN(aRegsRE6[i],{|x| x == SD3->D3_NUMSEQ})
			If nAchou > 0
				Exit
			EndIf
		Next i
		// Grava sequencia do RE6
		If nAchou == 0
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ lDocCQ - Verifica se o movimento e relacionado a movimentacao|
			//|          de CQ originada de NF.                              |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			lDocCQ := A330DocCQ(SD3->D3_COD,SD3->D3_DOC,SD3->D3_NUMSEQ)

			If SD3->D3_LOCAL == cLocalCQ .And. lDocCQ
				A330TRB(aFilsCalc,"SD3","110")
			Else
				If A330MovCQ(SD3->D3_NUMSEQ, cLocalCQ, SD3->D3_COD, SD3->D3_QUANT) .And. lDocCQ
					A330TRB(aFilsCalc,"SD3","110")
				Else
					If lCusRep .And. SD3->D3_STATUS == 'RP'
						A330TRB(aFilsCalc,"SD3","610")
					ElseIf lAjCamb .And. SD3->D3_STATUS == 'AC'
						A330TRB(aFilsCalc,"SD3","080")
					Else
						A330TRB(aFilsCalc,"SD3","300")
					EndIf
				EndIf
			EndIf
			SD1->(dbSetOrder(1))
			SD3->(dbGoto(nRegRE6))
		EndIf
		dbSkip()
		Loop
	ElseIf Alltrim(SD3->D3_CF) $ "REA/DEA"
		A330TRB(aFilsCalc,"SD3","600")
	Else
		A330TRB(aFilsCalc,"SD3","300",,,,iIf(alltrim(SD3->D3_CF) == 'DE0' .and. !Empty(SD3->D3_OP),.f.,.t.))
	EndIf
	dbSelectArea("SD3")
	dbSkip()
EndDo
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Devolve a ordem original do arquivo                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SD3")
dbSetOrder(1)

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ A330TRB  ³ Autor ³Bregantim / Stiefano   ³ Data ³ 15/10/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava arquivo de trabalho por nivel da estrutura           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A330TRB(aFilsCalc,cAlias,cOrdem,nRecRE5,nRecTrb,cPosTrans) ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array com o controle para processamento por empresa³±±
±±³          ³ ExpC2 = Alias origem para gravacao no arquivo de trabalho  ³±±
±±³          ³ ExpC3 = Ordem a ser gravada no arquivo de trabalho         ³±±
±±³          ³ ExpN4 = Registro do SD1 relacionado ao movimento RE5       ³±±
±±³          ³ ExpN5 = Registro original do arquivo de trabalho           ³±±
±±³          ³ ExpC6 = Posicao para processar transferencia estornada     ³±±
±±³          ³ ExpC8 = Atualiza o nivel das notas de remessa/dev de rem   ³±±
±±³          ³ que foram enviados em um armazém e retornado em outro      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function A330TRB(aFilsCalc,cAlias,cOrdem,nRecRE5,nRecTRB,cPosTrans,lbypass,lAtuNiv)
Local nRecNo    := 0
Local nQuant    := 0
Local nOldRec   := 0
Local cRetFil   := ""
Local cProduto  := ""
Local dData     := ""
Local cChave    := ""
Local cOP       := ""
Local cCF       := ""
Local cSeq      := ""
Local dDtOrig   := ""
Local cTES      := ""
Local cTipo		:= ""
Local cTipoNF   := ""
Local cNivSD3   := " "
Local cNivSD3Bkp:= " "
Local cNivel    := "  "
Local cSeqPro   := Space(Len(TRB->TRB_SEQPRO))
Local cDoc      := Space(6)
Local cSerie    := Space(3)
Local cOldOrdem := cOrdem
Local cLocCQ	:= GetMvNNR('MV_CQ','98')
Local lSeekTrx  := .F.
Local lUsaD2DIG := UsaD2DTDIG()
Local lSeq500   := SuperGetMv("MV_SEQ500",.F.,.T.)
Local cItem		:= Space(tamsx3('D1_ITEM')[1])
Local aBackArea := {}
Local cProdMod := ""
Local cNewNiv   := ""

Default cPosTrans := "0"
Default lbypass   := .t.
Default lAtuNiv   := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Ordem para processamento do N¡vel do SD3                                            |
//| "1" - RE6 / DE6                                                                     |
//| "1" - RE6 / DE6 na rotina A330Estru para as transferencias do CQ                    |
//| "5" - PR0 / PR1                                                                     |
//| "5" - RE1 / DE1                                                                     |
//| "5" - RE4 / DE4 na rotina A330Estru                                                 |
//| "5" - RE5 / DE5 no caso de tratamento de poder de terceiros                         |
//| "5" - RE7 / DE7 na rotina A330Estru                                                 |
//| "7" - RE3 / DE3                                                                     |
//| "9" - RE0 / DE0                                                                     |
//| "9" - RE2 / DE2                                                                     |
//| E' calculado n¡vel para RE5 e DE5 somente no caso de devolucao de poder de          |
//| terceiros . O PI deve ter o custo processado no momento da producao da OP           |
//| informada no SD1.                                                                   |
//| Caso contrario estas sao processadas junto da NF de retorno de beneficiamento (SD1) |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Chama ponto de entrada para mudar sequencia do calculo       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lA330Seq
	cOrdem:=ExecBlock("MA330SEQ",.F.,.F.,{cOrdem,cAlias})
	If Valtype(cOrdem) != "C" .Or. Empty(cOrdem)
		cOrdem:=cOldOrdem
	EndIf
EndIf

nRecRE5 := IIF(nRecRE5 == NIL,0,nRecRE5)
nRecTRB := IIF(nRecTRB == NIL,0,nRecTRB)

If cAlias == "SD1"
	If cPaisLoc <> "BRA"
		cRetFil  := M330TrFil("SD1",SD1->D1_TES,aFilsCalc,SD1->D1_ESPECIE,SD1->D1_TIPODOC)
	Else
		cRetFil  := M330TrFil("SD1",SD1->D1_TES,aFilsCalc)
	EndIf
	nRecNo   := SD1->(RecNo())
	cProduto := SD1->D1_COD
	cLocal   := SD1->D1_LOCAL
	dData    := SD1->D1_DTDIGIT
	cSeq     := SD1->D1_NUMSEQ
	cSeqPro  := IIF(a330ParamZX[14]==1,SD1->D1_NUMSEQ,cSeqPro)
	dDtOrig  := SD1->D1_DTDIGIT
	nQuant   := SD1->D1_QUANT
	cTES     := SD1->D1_TES
	cDoc     := SD1->D1_DOC
	cItem    := SD1->D1_ITEM
	cSerie   := SD1->D1_SERIE
	cOP      := SD1->D1_OP
	cTipoNF  := SD1->D1_TIPO

	If cOrdem # "300"
		If cOrdem=="500" .And. lSeq500
			cChave:= SD1->D1_NUMSEQ+SD1->D1_FORNECE+DTOS(dData)+SD1->D1_DOC+SD1->D1_SERIE
		Else
			cChave:= SD1->D1_FORNECE+DTOS(dData)+SD1->D1_NUMSEQ+SD1->D1_DOC+SD1->D1_SERIE
		EndIf
	Else
		cNewNiv := "y"
		If lAtuNiv
			cNewNiv := "w"
		EndIf
		cChave  := CriaVar("D3_OP",.F.)+"E"+DTOS(dData)+SD1->D1_NUMSEQ+"9"+cNewNiv

		//-- Acerta os niveis do SD1 quando gerou RE5 de produto com estrutura
		SF4->(MsSeek(xFilial("SF4")+SD1->D1_TES))
		If (SF4->F4_ESTOQUE == "S" .And. SF4->F4_PODER3 == "D")
			SG1->(DBSETORDER(1))
			If SG1->(MsSeek(Iif(a330ParamZX[11] == 1,IIf(lCusEmp,Space(Len(cFilBack )),cFilBack),'')+A320Filial(a330ParamZX[11] == 1)+cProduto))
				cNivel := StrZero(100-IIf(Val(SG1->G1_NIV)==0,1,Val(SG1->G1_NIV)),2)
			EndIf
			If !Empty(SD1->D1_OP) .And. SC2->(MsSeek(xFilial("SC2")+SD1->D1_OP))
				cNivel  := SC2->C2_NIVEL
				cNivSD3 := "5"
				SD3->(MsGoto(nRecRE5))
				cChave := SD3->D3_OP+SUBSTR(SD3->D3_CF,2,1)+DTOS(SD3->D3_EMISSAO)+SD3->D3_NUMSEQ+IIF(Alltrim(SD3->D3_CF)$"DE4/DE6/DE7","9","0")+"y"
			Else
				cNivSD3 := "5"
				cNivel += cNewNiv
			EndIf
		EndIf
	EndIf
ElseIf cAlias == "SD2"
	cNewNiv := "x"
	If cPaisLoc <> "BRA"
		cRetFil  := M330TrFil("SD2",SD2->D2_TES,aFilsCalc,SD2->D2_ESPECIE,SD2->D2_TIPODOC)
	Else
		cRetFil  := M330TrFil("SD2",SD2->D2_TES,aFilsCalc)
	EndIf
	nRecNo   := SD2->(RecNo())
	cProduto := SD2->D2_COD
	cLocal   := SD2->D2_LOCAL
	dData    := IIf(lUsaD2DIG, SD2->D2_DTDIGIT, SD2->D2_EMISSAO)
	cSeq     := SD2->D2_NUMSEQ
	cSeqPro  := IIF(a330ParamZX[14]==1,SD2->D2_NUMSEQ,cSeqPro)
	dDtOrig  := IIf(lUsaD2DIG, SD2->D2_DTDIGIT, SD2->D2_EMISSAO)
	nQuant   := SD2->D2_QUANT
	cTES     := SD2->D2_TES
	cDoc     := SD2->D2_DOC
	cItem    := SD2->D2_ITEM
	cSerie   := SD2->D2_SERIE
	If cOrdem # "300"
		If cOrdem=="500" .And. lSeq500
			cChave:= SD2->D2_NUMSEQ+SD2->D2_CLIENTE+DTOS(dData)+SD2->D2_DOC+SD2->D2_SERIE
		Else
			cChave:= SD2->D2_CLIENTE+DTOS(dData)+SD2->D2_NUMSEQ+SD2->D2_DOC+SD2->D2_SERIE
		EndIf
	Else
		If lAtuNiv
			cNewNiv := "w"
		EndIf
		cChave:= CriaVar("D3_OP",.F.)+"E"+DTOS(dData)+SD2->D2_NUMSEQ+"9"+cNewNiv
	EndIf

	//-- Acerta os niveis do SD2 de REMESSA de produto com estrutura
	If cOrdem == "300" .Or. !Empty(cRetFil)
		SF4->(MsSeek(xFilial("SF4")+SD2->D2_TES))
		If (SF4->F4_ESTOQUE == "S" .And. SF4->F4_PODER3 == "R") .Or. !Empty(cRetFil)
			SG1->(DBSETORDER(1))
			If SG1->(MsSeek(Iif(a330ParamZX[11] == 1,IIf(lCusEmp,Space(Len(cFilAnt )),cFilBack),'')+A320Filial(a330ParamZX[11] == 1)+cProduto))
				cNivel := StrZero(100-IIf(Val(SG1->G1_NIV)==0,1,Val(SG1->G1_NIV)),2)
			EndIf
			cNivSD3 := "5"
			cNivel += cNewNiv
		EndIf
	EndIf
ElseIf cAlias == "SD3"
	nRecNo   := SD3->(RecNo())
	cProduto := SD3->D3_COD
	cLocal   := SD3->D3_LOCAL
	dData    := SD3->D3_EMISSAO
	If nRecRE5 > 0
		nOldRec:= SD1->(Recno())
		SD1->(dbGoto(nRecRE5))
		If cOrdem # "300"
			cChave:= SD1->D1_FORNECE+DTOS(dData)+SD1->D1_NUMSEQ+SD1->D1_DOC+SD1->D1_SERIE+"z"
		Else
			cChave:= CriaVar("D3_OP",.F.)+"E"+DTOS(dData)+SD1->D1_NUMSEQ+"9"+"z"
		EndIf
		SD1->(dbGoto(nOldRec))
	Else
		cChave:= SD3->D3_OP+SUBSTR(SD3->D3_CF,2,1)+DTOS(dData)+SD3->D3_NUMSEQ+cPosTrans+IIF(Alltrim(D3_CF)$"DE4/DE6/DE7","9","0")
	EndIf
	cOP      := SD3->D3_OP
	cCF      := Alltrim(SD3->D3_CF)
	cSeq     := SD3->D3_NUMSEQ
	cSeqPro  := IIf(a330ParamZX[14]==1,SD3->D3_NUMSEQ,cSeqPro)
	dDtOrig  := SD3->D3_EMISSAO
	nQuant   := SD3->D3_QUANT
	cDoc     := SD3->D3_DOC
	cItem    := SD3->D3_ITEM
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ No caso das producoes grava arquivo de apontamentos p/ ratear³
	//³ custo no caso de apontamentos em locais diferentes           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cCF $ "PR0/PR1" .And. SD3->D3_ESTORNO # "S"
		lSeekTrx := TRX->(dbSeek(cFilAnt+IIF(a330ParamZX[14]!=3,DTOS(a330ParamZX[01]),DTOS(dData))+cOP+cProduto+cLocal))
		// Caso ja tenha achado apontamento, nao cria registro novo
		Reclock("TRX",!lSeekTrx)
		If !lSeekTrx
			Replace TRX->TRX_DATA    With IIF(a330ParamZX[14]!=3,a330ParamZX[01],dData)
			Replace TRX->TRX_COD     With cProduto
			Replace TRX->TRX_OP      With cOP
			Replace TRX->TRX_LOCAL   With cLocal
			Replace TRX->TRX_FILIAL  With cFilAnt
		EndIf
		Replace TRX->TRX_QUANT   With TRX->TRX_QUANT + nQuant
		Replace TRX->TRX_QPERDA  With TRX->TRX_QPERDA + SD3->D3_PERDA
		TRX->(MsUnlock())
	EndIf
    If lbypass
		If !Empty(SD3->D3_OP) .And. Subs(SD3->D3_CF,2,2) != "E3" .And. If(SD3->D3_CF == "RE5",cOrdem == "300",.T.)
			If SC2->(MsSeek(xFilial("SC2")+SD3->D3_OP))
				cNivel  := SC2->C2_NIVEL
				cNivSD3 := "5"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Quando for RE5 somente alterar a chave quando a nota de    |
				//| de entrada ('SD1') estiver com a TES configurada com 	   |
				//| F4_ESTOQUE ='S' e F4_PODER3 == 'D'.						   |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If SD3->D3_CF == "RE5" .And. cOrdem == "300"
					SD1->(MsGoto(nRecRE5))
					SF4->(MsSeek(xFilial("SF4")+SD1->D1_TES))
					If SF4->F4_ESTOQUE == "S" .And. SF4->F4_PODER3 == "D"
						cChave := SD3->D3_OP+SUBSTR(SD3->D3_CF,2,1)+DTOS(SD3->D3_EMISSAO)+SD3->D3_NUMSEQ+IIF(Alltrim(SD3->D3_CF)$"DE4/DE6/DE7","9","0")+"z"
					Else
						cNivel  := ''
						cNivSD3 := ''
					EndIf
				EndIf
			EndIf
		ElseIf SubStr(SD3->D3_CF,2,2) $ "E4/E7" .Or. (SubStr(SD3->D3_CF,2) == "E6" .And. SD3->D3_LOCAL == cLocCQ)
			A330Estru(cLocCQ,@cNivel,@cNivSD3,@cTipo,@cCF)
			cNivSD3Bkp := cNivSD3
		ElseIf Subs(SD3->D3_CF,2,2) != "E3" .And. cOrdem # "280"
			cNivSD3 := "9"
		ElseIf cOrdem # "280"
			cNivSD3 := "7"
		EndIf

		If SD3->D3_CF $ "DE4/DE7/DE6"
			//-- Busca cf, nivel, nivsd e tipo do movimento de origem (RE)
			TRB->(dbSetOrder(2))
			TRB->(MsSeek(cFilAnt+"SD3"+SD3->D3_NUMSEQ))
			While !TRB->(EOF()) .And. cFilAnt+"SD3"+SD3->D3_NUMSEQ == TRB->(TRB_FILIAL+TRB_ALIAS+TRB->TRB_SEQ)
				If TRB->TRB_DTORIG == SD3->D3_EMISSAO .And. SubStr(TRB->TRB_CF,1,1) == "R" .And. (SD3->D3_CF == "DE7" .Or. (TRB->TRB_CF <> "RE5" .AND. TRB->TRB_QUANT == SD3->D3_QUANT))
					cCF		:= Subs(cCF,1,1)+Subs(TRB->TRB_CF,2,2)
					cNivel  := TRB->TRB_NIVEL
					cNivSD3 := TRB->TRB_NIVSD3
					cTipo   := TRB->TRB_TIPO
					Exit
				EndIf
				TRB->(dbSkip())
			EndDo
			//-- Corrige CF no caso de troca (MV_PROCQE6)
			If cCF <> SD3->D3_CF
				RecLock("SD3",.F.)
				Replace SD3->D3_CF With cCF
				SD3->(MsUnLock())
			EndIf
			cNivSD3Bkp := cNivSD3
		EndIf

		If (SubStr(SD3->D3_CF,2) == "E6") .And. SD3->D3_LOCAL <> cLocCQ
			cNivSD3 := If(a330ParamZX[18]==1,"1","9")

			//-- Verifica se é entrada de liberacao de CQ, neste caso, não mexe no cNivSD3
			cNumSeq := SD3->D3_NUMSEQ
			aBackArea := SD3->(GetArea())
			SD3->(dbSetOrder(4))
			SD3->(MsSeek(xFilial("SD3")+cNumSeq))
			While !SD3->(Eof()) .And. xFilial("SD3")+cNumSeq == SD3->(D3_FILIAL+D3_NUMSEQ)
				If SD3->D3_LOCAL == cLocCQ
					cNivSD3 := cNivSD3Bkp
					Exit
				EndIf
				SD3->(dbSkip())
			End
			SD3->(RestArea(aBackArea))
			aSize(aBackArea,0)
			aBackArea := nil
		EndIf

		//-- Reordena entradas de CQ conforme movimento origem
		A330NivCQ(cLocCQ,@cOrdem,@cNivel,@cNivSD3,@cChave,lSeq500)
	EndIf
EndIf

If Empty(cNivel) .and. lbypass
	SG1->(DBSETORDER(1))
	If SG1->(MsSeek(Iif(a330ParamZX[11] == 1,IIf(lCusEmp,Space(Len(cFilBack )),cFilBack),'')+A320Filial(a330ParamZX[11] == 1)+cProduto))
		cNivel := StrZero(100-IIf(Val(SG1->G1_NIV)==0,1,Val(SG1->G1_NIV)),2)
	EndIf
EndIf

// Se 1 é produto de mão de obra
cProdMod := IIF(A330ISMOD(cProduto), "1", "0")

RecLock("TRB",.T.)
Replace TRB->TRB_FILTRA  With cRetFil
Replace TRB->TRB_USATRA  With If(!Empty(cRetFil),"S","")
Replace TRB->TRB_ALIAS   With cAlias
Replace TRB->TRB_RECNO   With nRecNo
Replace TRB->TRB_ORDEM   With cOrdem
Replace TRB->TRB_NIVEL   With cNivel
Replace TRB->TRB_NIVSD3  With cNivSD3
Replace TRB->TRB_COD     With cProduto
Replace TRB->TRB_LOCAL   With cLocal
Replace TRB->TRB_DTBASE  With IIF(a330ParamZX[14]!=3,a330ParamZX[01],dData)
Replace TRB->TRB_CHAVE   With cChave
Replace TRB->TRB_OP      With cOP
Replace TRB->TRB_CF      With cCF
Replace TRB->TRB_SEQ     With cSeq
Replace TRB->TRB_SEQPRO  With cSeqPro
Replace TRB->TRB_DTORIG  With dDtOrig
Replace TRB->TRB_RECSD1  With nRecRE5
Replace TRB->TRB_TES     With cTES
Replace TRB->TRB_DOC     With cDoc
Replace TRB->TRB_SERIE   With cSerie
Replace TRB->TRB_RECTRB  With nRecTRB
Replace TRB->TRB_TIPO    With cTipo
Replace TRB->TRB_TIPONF  With cTipoNF
Replace TRB->TRB_FILIAL  With cFilAnt
Replace TRB->TRB_QUANT   With nQuant
Replace TRB->TRB_ITEM    With cItem
Replace TRB->TRB_MOD     With cProdMod

TRB->(MsUnlock())

dbSelectArea(cAlias)
Return NIL

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A330Recalc³ Autor ³ Bregantim / Stiefano  ³ Data ³ 15/10/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Recalcula o custo m‚dio                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A330Recalc()                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array com os nomes dos indices de Trabalho         ³±±
±±³          ³ ExpN2 = Rateio por Frota                                   ³±±
±±³          ³ ExpN3 = Rateio por Veiculo                                 ³±±
±±³          ³ ExpN4 = Rateio por Viagem                                  ³±±
±±³          ³ ExpA5 = Array contendo as Filiais para Recalcular          ³±±
±±³          ³ ExpL6 = Variavel que verifica a utilizacao de procedures   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function A330Recalc(nRateioFrota,nRateioVeiculo,nRateioViagem,aFilsCalc,lExistProc)

LOCAL aCM[nTamArrCus]		,aCusto[nTamArrCus]		,aAprInd[nTamArrCus]
LOCAL aAprDir[nTamArrCus]	,aApropria[nTamArrCus]	,aCMRep[nTamArrCus]
LOCAL aApropFF[nTamArrCus]	,aCustoFF[nTamArrCus]	,aCMFF[nTamArrCus]
LOCAL aCMSD1Rep[nTamArrCus] ,aAprRep[nTamArrCus]	,aCustoRep[nTamArrCus]
LOCAL aCMSD3Rep[nTamArrCus]
LOCAL nX,j,cApropri,lPassou,aEnvCus

LOCAL lMA330P3   := ExistBlock("MA330P3")
LOCAL lMA330C3   := ExistBlock("MA330C3")
LOCAL lM330CD2   := ExistBlock("M330CD2")
LOCAL lM330CD1   := ExistBlock("M330CD1")

LOCAL nRecOrig   := 0
LOCAL nCountNf   := 0
LOCAL nCountSF8  := 0
LOCAL nQuantOriD7:= 0
LOCAL nPropPR0   := 1
LOCAL nPropPR0Rp := 1
LOCAL i			 := 0

LOCAL aRetPUnit  := {}
LOCAL aRet       := {}
LOCAL aRetPartes := {}
LOCAL aRetAPAtu  := {}
LOCAL aCMSD1     := {}
LOCAL aCMSD3     := {}
LOCAL aImpCusto  := {}
LOCAL aBackCusto := {}
LOCAL aCMPartes  := {}
LOCAL aNFsCompl  := {{}}

LOCAL cNumSeqOrig:= ""
LOCAL cSeekSD1   := ""
LOCAL cSeekSD3   := ""
LOCAL cSeekTRX   := ""
LOCAL cWhileTRX  := ""
LOCAL cNumImport := ""
LOCAL cNfAnt     := ""
LOCAL cChaveSD3  := ""
LOCAL cSeekD7    := ""

LOCAL lReqAut
LOCAL lseq300
LOCAL cLocalCQ   := GetMvNNR('MV_CQ','98')
LOCAL lM330PR1	 := SuperGetMv('MV_M330PR1',.F.,.F.)
LOCAL cLocProc   := GetMvNNR('MV_LOCPROC','99')
LOCAL lAjNfCompl := SuperGetMV("MV_AJUSNFC",.F.,.F.)
LOCAL lHabCon330 := SuperGetMV('MV_M330CON',.F.,.F.)
LOCAL cDepTran   := SuperGetMV("MV_DEPTRAN",.F.,"")
LOCAL lUltSD7    := .F.
LOCAL lTransito  := .F.
LOCAL lVer67A    := .F.
LOCAL lVer67B    := .F.
LOCAL lFirstSD1  := .F.
LOCAL lFirstSD2  := .F.
LOCAL lFirstSD3  := .F.
LOCAL lOPEncParc := .F.

LOCAL bBloco     := { |nV,nX| Trim(nV)+STR(nX,1) }
LOCAL nDec       := Set(3,8)
LOCAL nPartes    := Len(aRegraCP)+1
LOCAL nOrderFIFO := If(a330ParamZX[17]==1,5,3)
LOCAL nTamDoc    := TamSX3("D3_DOC")[1]
LOCAL aRetCPUs	 := Nil
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ MV_M330JCM - Habilita o calculo do custo por threads para as ordens escolhidas (100/300/500) |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LOCAL lM330JCM1   := "1" $ SuperGetMv("MV_M330JCM" ,.F.,"") .And. a330ParamZX[14]==2 .And. !l330ArqExcl
LOCAL lM330JCM3   := "3" $ SuperGetMv("MV_M330JCM" ,.F.,"") .And. a330ParamZX[14]==2 .And. !l330ArqExcl
LOCAL lM330JCM5   := "5" $ SuperGetMv("MV_M330JCM" ,.F.,"") .And. a330ParamZX[14]==2 .And. !l330ArqExcl
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Integracao com Modulo de Manutencao de Ativos (Parceiros)      |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LOCAL lIntMntAt := AllTrim(SuperGetMv("MV_NGMNTES",.F.,"N")) = "S"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ A330CDEV - Ponto de Entrada utilizado para contabilizar os   |
//| lancamentos de devolucao de compras LP 678                   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LOCAL lA330CDEV := ExistBlock("A330CDEV")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variaveis utilizadas para processamento de calculo por empresa |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LOCAL nForFilial:=0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³	aListaTrf :													   |
//|     [nX,1] Filial origem        [nX,2] Filial destino          |
//|     [nX,3] Documento            [nX,4] Serie                   |
//|     [nX,5] Codigo do produto    [nX,6] Quantidade              |
//|     [nX,7] Custo unitario       [nX,8] Custo Movimento         |
//|     [nX,9] Custo em partes      [nX,10] Custo e reposição      |
//|     [nX,11] Item do documento     								    |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//LOCAL aListaTrf :={}
Local oListaTRF := JsonObject():New()
Local cKeyListaTRF
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variavel utilizada para identificar lancamento padrao 667/669  |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LOCAL lLct667669	:=.F.
LOCAL aRegsRE5		:= {}
Local aAcumPR0		:= {0,0,0,0,0}
Local nOPAnt		:= ''
Local cLocTran		:= GetMvNNR('MV_LOCTRAN','95')
Local cKeySD3TRB	:= ""
Local lDvCom		:= .F.
Local cItem			:= 0
Local nQtdOri		:= 0
Local cUMOrig		:= ""
Local oJobCMCall  as Object

Local oQryRecDE4 as Object
Local nSD3RecDE4 as numeric

DEFAULT lExistProc := .F.

oJobCMCall := JsonObject():New()
oJobCMCall:fromJson("{}")

if cMoeda330C == NIL
	cMoeda330C := SuperGetMv('MV_MOEDACM',.F.,"2345")
EndIf

If cPaisLoc # "BRA"
	//Definidas como privates para compatibilidade com a RetCUsent nas saidas por devolucao de compra
	PRIVATE	nTaxa	:=	0
	PRIVATE	nMoedaNf:=	1
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Processa pela sequencia FIFO/LIFO 	                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lCusFifo .Or. lCusLIFO
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica a sequencia das notas originais e coloca as notas ³
	//³complementares na sequencia, para que o custo seja agregado³
	//³corretamente.                                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SD1")
	dbSetOrder(1)
	dbSelectArea("SF8")
	dbSetOrder(3)
	dbSelectArea("TRB")
	dbSetOrder(4)
	For nForFilial := 1 to Len(aFilsCalc)
		If aFilsCalc[nForFilial,1]
			// Altera filial corrente
			cFilAnt:=aFilsCalc[nForFilial,2]
			dbSeek(cFilAnt+"SD1")
			cNfAnt:=""
			nCountNf:=0
			While !Eof() .And. TRB->TRB_FILIAL+TRB->TRB_ALIAS == cFilAnt+"SD1"
				If TRB->TRB_TIPONF $ "CIP"
					lSeek:=.F.
					dbSelectArea("SD1")
					dbGoto(TRB->TRB_RECNO)
					If cNfAnt != SD1->D1_DOC+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA
						nCountNf:= 0
						cNfAnt  := SD1->D1_DOC+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA
					EndIf
					nCountNf++
					cSeekSD1:=xFilial("SD1")+SD1->D1_NFORI+SD1->D1_SERIORI+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD+SD1->D1_ITEMORI
					cSeekSF8:=xFilial("SF8")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA
					cComplSF8:=SD1->D1_COD
					cItem := SD1->D1_ITEM
					// Pesquisa no SD1 pela NF Original da NF de despesa
					lSeek:=dbSeek(cSeekSD1)
					If !lSeek
						// Pesquisa no SD1 pela NF de despesa e verifica quais as NFs amarradas
						dbSelectArea("SF8")
						dbSeek(cSeekSF8)
						nCountSF8:=0
						While !Eof() .And. nCountSF8 < nCountNf .And. ;
								F8_FILIAL+F8_NFDIFRE+F8_SEDIFRE+F8_TRANSP+F8_LOJTRAN == cSeekSF8
							cSeekSD1:=xFilial("SD1")+SF8->F8_NFORIG+SF8->F8_SERORIG+SF8->F8_FORNECE+SF8->F8_LOJA+cComplSF8
							SD1->(dbsetorder(1))
							SD1->(dbSeek(cSeekSD1))
							While !Eof() .and. SD1->(D1_FILIAL+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_COD) == cSeekSD1
								If SD1->D1_ITEM == cItem
									lSeek := .t.
									nCountSF8++
									exit
								else
									If Len(aNFsCompl[Len(aNFsCompl)]) > 0 .and. aScanx(aNFsCompl, { |x| x[1,3] == SD1->D1_NUMSEQ}) = 0
										lSeek := .t.
										nCountSF8++
										exit
									EndIf
								EndIf
								SD1->(Dbskip())
							End
							dbSelectArea("SF8")
							dbSkip()
						End
					EndIf
					If lSeek
						If Len(aNFsCompl[Len(aNFsCompl)]) > 4095
							AADD(aNFsCompl,{})
						EndIf
						AADD(aNFsCompl[Len(aNFsCompl)],{TRB->(Recno()),SD1->D1_DTDIGIT,SD1->D1_NUMSEQ})
					EndIf
					dbSelectArea("TRB")
				EndIf
				dbSkip()
			EndDo

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica a sequencia dos movimentos de importacao          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SD1")
			dbSetOrder(4)
			dbSelectArea("SD3")
			dbSetOrder(4)
			dbSelectArea("SWN")
			dbSetOrder(2)
			dbSelectArea("TRB")
			dbSetOrder(2)
			dbSeek(cFilAnt+"SD3")
			Do While !Eof() .And. TRB_FILIAL+TRB->TRB_ALIAS == cFilAnt+"SD3"
				dbSelectArea("SD3")
				dbGoto(TRB->TRB_RECNO)
				If Substr(SD3->D3_CF,3,1) == "8" .And. QtdComp(SD3->D3_QUANT) == QtdComp(0)
					// Verifica se Utiliza NF de Importacao
					dbSelectArea("SD1")
					If dbSeek(xFilial("SD1")+SD3->D3_NUMSEQ) .And. (D1_DTDIGIT >= dInicio .And. D1_DTDIGIT <= a330ParamZX[01])
						dbSelectArea("SWN")
						dbSetOrder(2)
						dbSeek(xFilial("SWN")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA)
						cNumImport:=""
						Do While !Eof() .And. Empty(cNumImport) .And. ;
								WN_FILIAL+WN_DOC+WN_SERIE+WN_FORNECE+WN_LOJA == ;
								xFilial("SWN")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA
							If QtdComp(WN_QUANT) == QtdComp(0) .And. ;
									SD3->D3_COD == SWN->WN_PRODUTO .And. ;
									SD1->D1_FORNECE+SD1->D1_LOJA == SWN->WN_FORNECE+SWN->WN_LOJA
								cNumImport:=SWN->WN_HAWB
							EndIf
							dbSkip()
						EndDo
						If !Empty(cNumImport)
							dbSetOrder(3)
							dbSeek(xFilial("SWN")+cNumImport)
							Do While !Eof() .And. WN_FILIAL+WN_HAWB == xFilial("SWN")+cNumImport
								If QtdComp(WN_QUANT) # QtdComp(0) .And. SD3->D3_COD == SWN->WN_PRODUTO
									dbSelectArea("SD1")
									dbSetOrder(1)
									If dbSeek(xFilial("SD1")+SWN->WN_DOC+SWN->WN_SERIE+SWN->WN_FORNECE+SWN->WN_LOJA)
										dbSelectArea("SD3")
										If dbSeek(xFilial("SD3")+SD1->D1_NUMSEQ)
											If Len(aNFsCompl[Len(aNFsCompl)]) > 4095
												AADD(aNFsCompl,{})
											EndIf
											AADD(aNFsCompl[Len(aNFsCompl)],{TRB->(Recno()),SD3->D3_EMISSAO,SD3->D3_NUMSEQ})
										EndIf
									EndIf
								EndIf
								dbSelectArea("SWN")
								dbSkip()
							EndDo
						EndIf
					EndIf
				EndIf
				dbSelectArea("TRB")
				dbSkip()
			EndDo
		EndIf
	Next nForFilial
	// Restaura filial original apos processamento
	cFilAnt:=cFilBack

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Muda a sequencia para respeitar NFs Originais              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nx:=1 to Len(aNFsCompl)
		For j:=1 to Len(aNFsCompl[nx])
			dbGoto(aNFsCompl[nx,j,1])
			Reclock("TRB",.F.)
			Replace TRB_DTORIG With aNFsCompl[nx,j,2]
			Replace TRB_SEQ    With aNFsCompl[nx,j,3]
			TRB->(MsUnlock())
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Ajusta a requisicao valorizada gerada pelo custo Fifo      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lAjNfCompl .And. (lCusFIFO .Or. lCusLIFO) .And. TRB->TRB_RECTRB > 0
				MsGoto(TRB->TRB_RECTRB)
				If TRB->TRB_CF == "RE6"
					Reclock("TRB",.F.)
					Replace TRB_DTORIG With aNFsCompl[nx,j,2]
					Replace TRB_SEQ    With aNFsCompl[nx,j,3]
					TRB->(MsUnlock())
				EndIf
			EndIf
		Next j
	Next nx
	aSize(aNFsCompl,0)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Monta tela para mudar sequencia de acordo com necessidade ³
	//³ do usuario.                                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lBat .And. !IsBlind() .And. a330ParamZX[16] == 3
		M330LogCus(aFilsCalc,nOrderFIFO,.F.)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o log de processamento			    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	M330PrcLog("MENSAGEM",OemToAnsi(I18N(STR0084,{Alltrim(cMoeda330C)})),OemToAnsi(I18N(STR0084,{Alltrim(cMoeda330C)})) ) //"Recalculo do custo FIFO/LIFO na(s) moeda(s) 1#1[2345]# - (0) Iniciando"

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Processa arquivo de trabalho pela ordem desejada           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("TRB")
	dbSetOrder(nOrderFIFO)
	dbGotop()
	If !lBat .And. !IsBlind()
		ProcRegua(LastRec(),16,4)
	EndIf

	aRegsRE5 := {}

	While !Eof()

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Movimentacao do Cursor                                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lBat .And. !IsBlind()
			IncProc(OemToAnsi(STR0097))	//"Recalculando os Custos dos Movimentos FIFO/LIFO"
		EndIf
		// Altera filial corrente
		cFilAnt:=TRB->TRB_FILIAL

		If TRB->TRB_ALIAS == "SD1"

			dbSelectArea("SD1")
			dbGoto(TRB->TRB_RECNO)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Posiciona no SB1 para formulas de lancamento contabil        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SB1")
			MsSeek(xFilial("SB1")+SD1->D1_COD)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Posiciona no SF4 - TES                                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			//dbSelectArea("SF4")
			SF4->(dbSetOrder(1))
			MsSeek(xFilial("SF4")+SD1->D1_TES)
			dbSelectArea("SD1")

			//Entrada para OP, independente de poder de terceiros
			If TRB->TRB_RECSD1 > 0 .And. a330ParamZX[04] == 1
				Aadd(aRegsRE5,{TRB->TRB_RECNO, TRB->TRB_RECSD1})
			EndIf

			If SF4->F4_PODER3 == "D"
				If TRB->TRB_RECSD1 > 0
					SD3->(dbGoto(TRB->TRB_RECSD1))
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Nao considerar o custo de uma entrada por devolucao ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If SD1->D1_TIPO == "D" .And. SF4->F4_DEVZERO == "2"
					aRet := {{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0}}
				Else
					// Se nao for transferencia de filiais obtem custo pelo tipo de movimento
					If !A330RecTrf(aRet,oListaTrf,.T.,lCstPart,aRegraCP)
						aRet := A330PegaSB6("SD1",.T.,"330")
					EndIf
				EndIf
				aCMFF   := aRet[2]
				aCMSD1  := ACLONE(aRet[2])
				aRet    := GravaCusD1(NIL,"D",aCMFF,"330")
				aCustoFF:= aRet[2]
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Acerta custo no SD3 caso necessario - Custo de RE5           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If TRB->TRB_RECSD1 > 0 .And. a330ParamZX[04] == 1
					GravaCusD3(NIL,.T.,aCMFF,"330")
					SD3->(MsUnlock())
				EndIf
				dbSelectArea("SD1")

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o saldo final (VFIM) com os dados do SD1            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				B2FimComD1(NIL,aCustoFF,.T.)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Ponto de Entrada MA330D1                                     ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lMA330D1
					ExecBlock("MA330D1",.F.,.F.)
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Acerta custo de CQ - Controle de Qualidade                   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If SD1->D1_LOCAL == cLocalCQ .And.!Empty(SD1->D1_NUMCQ) .And. !(SD1->D1_TIPO $ "I|C|P")
					cSeekD7:=SD1->D1_NUMCQ+SD1->D1_COD+SD1->D1_LOCAL
					dbSelectArea("SD7")
					dbSetOrder(1)
					dbSeek(xFilial("SD7")+cSeekD7,.F.)
					While !Eof() .And. xFilial("SD7")+cSeekD7==D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL
						If D7_TIPO # 0 .And. D7_TIPO # 5 .And. D7_TIPO # 8
							aCMFF := PegaCMD1(.T.)
							dbSelectArea("SD3")
							dbSetOrder(2)
							dbSeek(cSeekSD3:=xFilial("SD3")+PadR(SD7->D7_NUMERO,nTamDoc)+SD7->D7_PRODUTO)
							While !Eof() .And. cSeekSD3 == D3_FILIAL+D3_DOC+D3_COD
								If (D3_NUMSEQ == SD7->D7_NUMSEQ) .And. QtdComp(SD3->D3_QUANT) # QtdComp(0)
									For nx:=1 to Len(aCM)
										aCMSD1[nx]:=aCMFF[nx]*SD3->D3_QUANT
									Next nx
									aRet:=GravaCusD3(NIL,.T.,aCMSD1,"330")
									SD3->(MsUnlock())
								EndIf
								dbSkip()
							End
						EndIf
						dbSelectArea("SD7")
						dbSkip()
					EndDo
				EndIf
				dbSelectArea("SD1")

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o SBD FIFO/LIFO com os dados do SD1                 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				GravaSBD("SD1",aCustoFF,"D")

				dbSelectArea("TRB")
				dbSetOrder(nOrderFIFO)
				dbSkip()
				Loop
			EndIf

			If D1_TIPO != "D"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava o campo de custo FIFO/LIFO no arquivo SD1.             ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

				// Se nao for transferencia de filiais obtem custo pelo tipo de movimento
				If !A330RecTrf(aRet,oListaTrf,.T.,lCstPart,aRegraCP)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Tratamento para Fifo caso NF seja complementar (IPI/ICM/Despesa/Preco)³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If D1_TIPO $ "CIP"
						aCustoFF := {D1_CUSTO,D1_CUSTO2,D1_CUSTO3,D1_CUSTO4,D1_CUSTO5}
					Else
						aCustoFF := {D1_CUSTO/D1_QUANT,D1_CUSTO2/D1_QUANT,D1_CUSTO3/D1_QUANT,D1_CUSTO4/D1_QUANT,D1_CUSTO5/D1_QUANT}
					EndIf

					GravaCusD1(NIL,D1_TIPO,aCustoFF,"330")

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Acerta custo no SD3 caso necessario - Custo de RE5           ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If TRB->TRB_RECSD1 > 0
						SD3->(dbGoto(TRB->TRB_RECSD1))
						If a330ParamZX[04] == 1
							aRet:=GravaCusD3(NIL,.T.,aCustoFF,"330")
							SD3->(MsUnlock())
						EndIf
					EndIf

				Else
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Grava o custo de transferencia corrigido no SD1              |
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aCustoFF := ACLONE(aRet[2])
					aCMSD1	 := ACLONE(aRet[2])
					Reclock("SD1",.F.)
					For nx:=1 to Len(aCustoFF)
						If lCusFIFO .Or. lCusLIFO
							If SF4->F4_TRFICST == '1'
								If nx == 1
									aCustoFF[nx] := aCustoFF[nx]+SD1->D1_ICMSRET
								Else
									aCustoFF[nx] := aCustoFF[nx]+xMoeda(SD1->D1_ICMSRET,1,nx,SD1->D1_DTDIGIT)
								EndIf
							EndIf
							Fieldput(Fieldpos("D1_CUSFF"+Str(nx,1,0)),aCustoFF[nx])
						EndIf
						Fieldput(Fieldpos("D1_CUSTO"+If(nx == 1,"",Str(nx,1,0))),aCustoFF[nx])
					Next nx
					SD1->(MsUnlock())


					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Grava o custo de movimentos de Documento em trânsito provenientes de Trans. Fil.   |
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

					M330DocTran(NIL,aCustoFF,lCstPart,aRegraCP,aCMPartes,lIntCusTMS,lCusRep,aCMRep,lCusFil,lCusEmp,aRetPartes,cLocTran)

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Acerta custo no SD3 caso necessario - Custo de RE5           ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If TRB->TRB_RECSD1 > 0
						SD3->(dbGoto(TRB->TRB_RECSD1))
						If a330ParamZX[04] == 1
							aRet:=GravaCusD3(NIL,.T.,aCMSD1,"330")
							SD3->(MsUnlock())
						EndIf
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Acerta custo de CQ - Controle de Qualidade                   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If SD1->D1_LOCAL == cLocalCQ .And.!Empty(SD1->D1_NUMCQ) .And. !(SD1->D1_TIPO $ "I|C|P")
						cSeekD7:=SD1->D1_NUMCQ+SD1->D1_COD+SD1->D1_LOCAL
						dbSelectArea("SD7")
						dbSetOrder(1)
						dbSeek(xFilial("SD7")+cSeekD7,.F.)
						While !Eof() .And. xFilial("SD7")+cSeekD7==D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL
							If D7_TIPO # 0 .And. D7_TIPO # 5 .And. D7_TIPO # 8
								aCMFF  := PegaCMD1(.T.)
								aCMSD1 := ACLONE(aCMFF)
								dbSelectArea("SD3")
								dbSetOrder(2)
								dbSeek(cSeekSD3:=xFilial("SD3")+PadR(SD7->D7_NUMERO,nTamDoc)+SD7->D7_PRODUTO)
								While !Eof() .And. cSeekSD3 == D3_FILIAL+D3_DOC+D3_COD
									If (D3_NUMSEQ == SD7->D7_NUMSEQ) .And. QtdComp(SD3->D3_QUANT) # QtdComp(0)
										For nx:=1 to Len(aCMFF)
											aCMSD1[nx]:=aCMFF[nx]*SD3->D3_QUANT
										Next nx
										aRet:=GravaCusD3(NIL,.T.,aCMSD1,"330")
										SD3->(MsUnlock())
									EndIf
									dbSkip()
								EndDo
							EndIf
							dbSelectArea("SD7")
							dbSkip()
						EndDo
					EndIf
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o saldo final (VFIM) com os dados do SD1.           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				B2FimComD1(NIL,NIL,(lCusFIFO .Or. lCusLIFO))

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Ponto de Entrada MA330D1                                     ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lMA330D1
					ExecBlock("MA330D1",.F.,.F.)
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o SBD FIFO/LIFO com os dados do SD1                 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				GravaSBD("SD1")

				If SF4->F4_PODER3 == "R"
					A330GravaSB6("SD1",aCusto,,.T.)
				EndIf

				SD1->(MsUnlock())
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Pega os custos medios finais                                 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Nao considerar o custo de uma entrada por devolucao ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If SD1->D1_TIPO == "D" .And. SF4->F4_DEVZERO == "2"
					aRet := {{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0}}
				Else
					aRet := PegaCmDev(.F.,SD1->D1_NFORI,SD1->D1_SERIORI,SD1->D1_COD,SD1->D1_LOCAL,SD1->D1_QUANT,.T.,"330",,.T.,,,,SD1->D1_ITEMORI,,IF(cPaisLoc<>"BRA",AllTrim(SD1->D1_ESPECIE)=="NCC",.F.))
				EndIf
				aCMFF := aRet[2]

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava o custo da nota fiscal de devolucao                    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aRet     := GravaCusD1(NIL,SD1->D1_TIPO,aCMFF,"330")
				aCustoFF := aRet[2]

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Acerta custo no SD3 caso necessario - Custo de RE5           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If TRB->TRB_RECSD1 > 0
					SD3->(dbGoto(TRB->TRB_RECSD1))
					If a330ParamZX[04] == 1
						aRet:=GravaCusD3(NIL,.T.,aCMFF,"330")
						SD3->(MsUnlock())
					EndIf
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o saldo final (VFIM) com os dados do SD1            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				B2FimComD1(NIL,aCustoFF,.T.)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Ponto de Entrada MA330D1                                     ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lMA330D1
					ExecBlock("MA330D1",.F.,.F.)
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o SBD FIFO/LIFO com os dados do SD1                 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				GravaSBD("SD1",aCustoFF,"D")

				If SF4->F4_PODER3 == "R"
					A330GravaSB6("SD1",{SD1->D1_CUSTO,SD1->D1_CUSTO2,SD1->D1_CUSTO3,SD1->D1_CUSTO4,SD1->D1_CUSTO5},,.T.)
				EndIf

				SD1->(MsUnlock())
			EndIf
		ElseIf TRB->TRB_ALIAS == "SD3"
			dbSelectArea("SD3")
			dbGoto(TRB->TRB_RECNO)
			If SD3->D3_ESTORNO == "S" .And. a330ParamZX[04] == 1
				RecLock("SD3",.F.)
				Replace D3_CUSFF1 With 0
				Replace D3_CUSFF2 With 0
				Replace D3_CUSFF3 With 0
				Replace D3_CUSFF4 With 0
				Replace D3_CUSFF5 With 0
				SD3->(MsUnlock())
				dbSelectArea("TRB")
				dbSkip()
				Loop
			EndIf

			// --Valida movimentos de WMS
			If !Empty(D3_SERVIC) .And. !D3Valido("SD3")
				dbSelectArea("TRB")
				dbSkip()
				Loop
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Posiciona no SB1 para formulas de lancamento contabil        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SB1")
			MsSeek(xFilial("SB1")+SD3->D3_COD)
			dbSelectArea("SD3")
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Processa as movimentacoes internas                           ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			lPassou := .F.
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ lTransito - Variavel utilizada para verificar se o movimento e   |
			//| referente a um remito de transferencia entre filiais utilizando  |
			//| o almoxarifado de TRANSITO definido pelo parametro MV_DEPTRAN    ³
			//| (Somente utilizado por paises localizados)						 |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			lTransito := cPaisLoc <> "BRA" .And. Alltrim(D3_CF)=="DE4" .And. cDepTran==D3_LOCAL .And. !Empty(D3_DOC) .And. !Empty(D3_ITEM)

			AFILL(aCMFF,0)
			AFILL(aCustoFF,0)
			AFILL(aApropFF,0)

			dbSelectArea("SF5")
			dbSeek(xFilial("SF5")+SD3->D3_TM)
			dbSelectArea("SD3")
			If Alltrim(D3_CF) $ "PR0/PR1"  // Producoes

				dbSelectArea("SC2")
				If dbSeek(xFilial("SC2")+SD3->D3_OP)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Pega o custo final (VFIM) desta OP                           ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aRet        := PegaC2Fim("330",.T.)
					aApropFF    := aRet[2]

					RecLock("SC2",.F.)
					Replace C2_VFIMFF1 With 0
					Replace C2_VFIMFF2 With 0
					Replace C2_VFIMFF3 With 0
					Replace C2_VFIMFF4 With 0
					Replace C2_VFIMFF5 With 0
					SC2->(MsUnlock())
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza movimento do Pai                                    ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If a330ParamZX[04] == 1
						RecLock("SD3",.F.)
						Replace D3_CUSFF1 With aApropFF[01]
						Replace D3_CUSFF2 With If("2" $ cMoeda330C,aApropFF[02],0)
						Replace D3_CUSFF3 With If("3" $ cMoeda330C,aApropFF[03],0)
						Replace D3_CUSFF4 With If("4" $ cMoeda330C,aApropFF[04],0)
						Replace D3_CUSFF5 With If("5" $ cMoeda330C,aApropFF[05],0)
						SD3->(MsUnlock())
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o saldo final (VFIM) com os dados do SD3            ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Nao calcula produtos "MAO DE OBRA"                           ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !A330ISMOD(SD3->D3_COD,.T.)
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ A330QtdPR0 - Verifica se existe quantidade produzida "PR0"    |
						//| para esta ordem de producao para verificar se deve valorizar  |
						//| o custo para movimentos com D3_QUANT igual a zero.			  |
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If A330QtdPR0(SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN,SC2->C2_PRODUTO)
							B2FimComD3(NIL,NIL,aApropFF,.T.)
						EndIf
						If lMA330D3
							ExecBlock("MA330D3",.F.,.F.)
						EndIf
					EndIf

					GravaSBD("SD3",aApropFF)

					dbSelectArea("SC2")
					aCustoFF[01] := aApropFF[01] + C2_APFIFF1
					If "2" $ cMoeda330C
						aCustoFF[02] := aApropFF[02] + C2_APFIFF2
					EndIf
					If "3" $ cMoeda330C
						aCustoFF[03] := aApropFF[03] + C2_APFIFF3
					EndIf
					If "4" $ cMoeda330C
						aCustoFF[04] := aApropFF[04] + C2_APFIFF4
					EndIf
					If "5" $ cMoeda330C
						aCustoFF[05] := aApropFF[05] + C2_APFIFF5
					EndIf
					RecLock("SC2",.F.)
					Replace C2_APFIFF1 With aCustoFF[01]
					If "2" $ cMoeda330C
						Replace C2_APFIFF2 With aCustoFF[02]
					EndIf
					If "3" $ cMoeda330C
						Replace C2_APFIFF3 With aCustoFF[03]
					EndIf
					If "4" $ cMoeda330C
						Replace C2_APFIFF4 With aCustoFF[04]
					EndIf
					If "5" $ cMoeda330C
						Replace C2_APFIFF5 With aCustoFF[05]
					EndIf
					SC2->(MsUnlock())
				Else
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o log de processamento com o erro  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					M330PrcLog("ERRO","A650NOP",Ap5GetHelp("A650NOP")+" - OP: "+SD3->D3_OP)
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Zera os valores dos arrays para novo lote de movimentos      ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				AFILL(aCMFF,0)
				AFILL(aCustoFF,0)
				AFILL(aApropFF,0)
			ElseIf Alltrim(D3_CF) == "RE4" .Or. lTransito // Transferencias

				If oQryRecDE4 == NIL
					// processa pela sequencia FIFO
					cQuery := ""
					cQuery += "SELECT R_E_C_N_O_ FROM "+RetSqlName("SD3")+" SD3 "
					cQuery += "WHERE SD3.D3_FILIAL = ? " // '"+xFilial("SD3")+"' "
					cQuery += "AND SD3.D3_COD  = ? " // '" +SD3->D3_COD+ "' "
					cQuery += "AND SD3.D3_LOCAL = ? " // '" +SD3->D3_LOCAL+ "' "
					cQuery += "AND SD3.D3_NUMSEQ = ? " // '" +SD3->D3_NUMSEQ+ "' "
					cQuery += "AND SD3.D3_CF = ? " // 'DE4' "
					cQuery += "AND SD3.D3_DOC = ? " // '" +SD3->D3_DOC+ "' "
					cQuery += "and SD3.D3_UM  = ? " // '" +SD3->D3_UM+ "' "
					cQuery += "and SD3.D3_EMISSAO  = ? " // '" +dtos(SD3->D3_EMISSAO)+ "' "
					cQuery += "and SD3.D3_ESTORNO  = ? " // ' ' "
					cQuery += "and SD3.D_E_L_E_T_  = ? " // ' ' "
					cQuery := ChangeQuery(cQuery)
					//nSD3RecDE4 := MpSysExecScalar(cQuery,"R_E_C_N_O_")

					If __lLibVer
						oQryRecDE4 := FwExecStatement():New(cQuery)
					Else
						oQryRecDE4 := FWPreparedStatement():New(cQuery)
					EndIf
				ENDIF
				oQryRecDE4:SetString(1,xFilial("SD3"))
				oQryRecDE4:SetString(2,SD3->D3_COD)
				oQryRecDE4:SetString(3,SD3->D3_LOCAL)
				oQryRecDE4:SetString(4,D3_NUMSEQ)
				oQryRecDE4:SetString(5,'DE4')
				oQryRecDE4:SetString(6,SD3->D3_DOC)
				oQryRecDE4:SetString(7,SD3->D3_UM)
				oQryRecDE4:SetString(8,dtos(SD3->D3_EMISSAO))
				oQryRecDE4:SetString(9,' ')
				oQryRecDE4:SetString(10,' ')

				If __lLibVer
					nSD3RecDE4 := oQryRecDE4:ExecScalar('R_E_C_N_O_')
				Else
					cQuery := oQryRecDE4:GetFixQuery()
					nSD3RecDE4 := MpSysExecScalar(cQuery, 'R_E_C_N_O_')
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Pega os custos medios finais                                 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Na Funcao () Esta Tratando CUSTO FIFO / LIFO                 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aRet  := PegaCMFim(D3_COD,D3_LOCAL,,,"SD3","330",,.T.,,,,,,lTransito)
				aCMFF := aRet[2]

				If Alltrim(D3_CF) == "RE4" // Transferencia
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Grava o custo da movimentacao                                ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If a330ParamZX[04] == 1
						aRet     := GravaCusD3(NIL,,aCMFF,"330")
						aCustoFF := aRet[2]
						SD3->(MsUnlock())
					EndIf

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o saldo final (VFIM) com os dados do SD3            ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Nao calcula produtos "MAO DE OBRA"                           ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !A330ISMOD(SD3->D3_COD,.T.)
						B2FimComD3(NIL,NIL,aCustoFF,.T.,,,,,nSD3RecDE4==0)
						If lMA330D3
							ExecBlock("MA330D3",.F.,.F.)
						EndIf
					EndIf
				EndIf
				cChaveSD3 := SD3->(D3_COD+D3_TM+D3_CF+D3_LOCAL+D3_OP)
				If !lTransito
					// Verificar este SKIP
					dbSelectArea("TRB")
					nRecOrig:=Recno()
					cNumSeqOrig:=TRB_SEQ
					DbSelectArea("SD3")
					SD3->(DbSetOrder(6)) //D3_FILIAL+DTOS(D3_EMISSAO)+D3_NUMSEQ+D3_CHAVE+D3_COD

					if nSD3RecDE4 == 0
						If SD3->(MsSeek(xFilial("SD3") + DtoS(TRB->TRB_DTORIG) + TRB->TRB_SEQ))
							cKeySD3TRB := SD3->D3_FILIAL + DTOS(SD3->D3_EMISSAO) + SD3->D3_NUMSEQ
							While SD3->D3_FILIAL + DTOS(SD3->D3_EMISSAO) + SD3->D3_NUMSEQ == cKeySD3TRB
								If SD3->D3_CF == "DE4"
									Exit
								EndIf
								SD3->(DbSkip())
							EndDo
						EndIf
					else
						SD3->(MsGoto(nSD3RecDE4)) //D3_FILIAL+DTOS(D3_EMISSAO)+D3_NUMSEQ+D3_CHAVE+D3_COD
					endif
				EndIf

				If SubStr(D3_CF,3,1) == "4" .And. IIf(lTransito,.T.,D3_NUMSEQ == cNumSeqOrig) // Transferencias
					dbSelectArea("SB2")
					dbSetOrder(1)
					MsSeek(xFilial("SB2")+SD3->D3_COD+SD3->D3_LOCAL)
					
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Grava o custo da movimentacao                                ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If a330ParamZX[04] == 1
						aRet     := GravaCusD3(NIL,,aCMFF,"330")
						aCustoFF := aRet[2]
						SD3->(MsUnlock())
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o SBD FIFO / LIFO  com os dados do SD3              ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					GravaSBD("SD3",aCustoFF)

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o saldo final (VFIM) com os dados do SD3            ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Nao calcula produtos "MAO DE OBRA"                           ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !A330ISMOD(SD3->D3_COD,.T.)
						B2FimComD3(NIL,NIL,aCustoFF,.T.,,,,,nSD3RecDE4==0)
						If lMA330D3
							ExecBlock("MA330D3",.F.,.F.)
						EndIf
					EndIf
					
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Corrige o custo do CQ caso tenha sido originado por RE4      ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If SD3->D3_LOCAL == cLocalCQ
						aCM        := {SD3->D3_CUSFF1,SD3->D3_CUSFF2,SD3->D3_CUSFF3,SD3->D3_CUSFF4,SD3->D3_CUSFF5}
						aCMSD3     := ACLONE(aCM)
						dbSelectArea("SD7")
						dbSetOrder(3) //-- D7_FILIAL+D7_PRODUTO+D7_NUMSEQ+D7_NUMERO
						If dbSeek(xFilial("SD7")+SD3->D3_COD+SD3->D3_NUMSEQ)
							lUltSD7    := .F.
							cSeekD7    := D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL
							nQuantOriD7:= D7_SALDO
							dbSetOrder(2) //-- D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL+D7_NUMSEQ+STR(D7_TIPO)
							dbSeek(cSeekD7)
						EndIf
						While !Eof() .And. cSeekD7 == D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL
							If Empty(D7_ESTORNO) .And. D7_TIPO # 0 .And. D7_TIPO # 5 .And. D7_TIPO # 8
								dbSkip()
								If cSeekD7 # D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL
									lUltSD7    := .T.
								EndIf
								dbSkip(-1)
								dbSelectArea("SD3")
								dbSetOrder(4) //- D3_FILIAL+D3_NUMSEQ+D3_CHAVE+D3_COD
								If dbSeek(xFilial("SD3")+SD7->D7_NUMSEQ) .And. PadR(SD7->D7_NUMERO,nTamDoc) == SD3->D3_DOC .And. QtdComp(SD3->D3_QUANT) # QtdComp(0)
									While !Eof() .And. xFilial("SD3")+SD7->D7_NUMSEQ == D3_FILIAL+D3_NUMSEQ
										Reclock("SD3",.F.)
										Replace D3_CUSFF1 With If(lUltSD7,aCMSD3[1],aCm[1]*(SD3->D3_QUANT/nQuantOriD7))
										If "2" $ cMoeda330C
											Replace D3_CUSFF2 With If(lUltSD7,aCMSD3[2],aCm[2]*(SD3->D3_QUANT/nQuantOriD7))
										EndIf
										If "3" $ cMoeda330C
											Replace D3_CUSFF3 With If(lUltSD7,aCMSD3[3],aCm[3]*(SD3->D3_QUANT/nQuantOriD7))
										EndIf
										If "4" $ cMoeda330C
											Replace D3_CUSFF4 With If(lUltSD7,aCMSD3[4],aCm[4]*(SD3->D3_QUANT/nQuantOriD7))
										EndIf
										If "5" $ cMoeda330C
											Replace D3_CUSFF5 With If(lUltSD7,aCMSD3[5],aCm[5]*(SD3->D3_QUANT/nQuantOriD7))
										EndIf
										SD3->(MsUnlock())
										//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
										//³ So processa uma vez para nao comprometer saldo               ³
										//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
										If !lUltSD7 .And. SD3->D3_LOCAL == SD7->D7_LOCAL
											For nx:=1 to 5
												// Verifica se moeda devera ser considerada
												If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
													Loop
												EndIf
												aCMSD3[nx]-=&(Eval(bBloco,"D3_CUSFF",nX))
											Next nx
										EndIf
										dbSkip()
									End
								EndIf
							EndIf
							dbSelectArea("SD7")
							dbSkip()
						EndDo
					EndIf
				Else
					dbSelectArea("TRB")
					dbGoto(nRecOrig)
				EndIf
			ElseIf Alltrim(D3_CF) == "RE7"      // Transferencias Multiplas
				A330ProcRE7(.T.)
			ElseIf Alltrim(D3_CF) != "DE7" .And. Alltrim(D3_CF) != "DE4"   // RE0,1,2,3 e suas DE's respectivas
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³     Pega o tipo de apropriacao do material                   ³
				//³==============================================================³
				//³ 0 = Requisicao Manual de material Direto                     ³
				//³ 1 = Requisicao Automatica de material Direto                 ³
				//³ 2 = Requisicao Automatica de material Indireto               ³
				//³ 3 = Requisicao Manual de material Indireto                   ³
				//³ 4 = Transferencias em geral                                  ³
				//³ 5 = Apropriacao direta de entrada na Op                      ³
				//³ 9 = Requisicao para OP sem agregar custo para a mesma        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cApropri := SubStr(D3_CF,3,1)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Pega os custos medios finais                                 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !(cApropri $ "568")
					aRet      := PegaCMFim(D3_COD,If(SD3->D3_CF <> "DE3",D3_LOCAL,cLocProc),,,"SD3","330",,.T.)
					aCMFF     := aRet[2]
					If a330ParamZX[04] == 1
						aRet      := GravaCusD3(NIL,,aCMFF,"330")
						aCustoFF  := aRet[2]
						dbSelectArea("SD3")
						SD3->(MsUnlock())
					EndIf
				Else
					aCMFF     := {D3_CUSTO1,D3_CUSTO2,D3_CUSTO3,D3_CUSTO4,D3_CUSTO5}
					aCustoFF  := aCMFF
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o SBD FIFO / LIFO com os dados do SD3               ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If Alltrim(SD3->D3_CF) $ "DE6/DE8"
						GravaSBD("SD3",aCustoFF)
					Else
						aCMFF:=BaixaSBD("SD3",,TRB->TRB_RECTRB > 0,SubStr(AllTrim(SD3->D3_CF),2,2) == "E6",,,cLocalCQ)
						For i:=1 to 5
							// Verifica se moeda devera ser considerada
							If i # 1 .And. !(Str(i,1,0) $ cMoeda330C)
								Loop
							EndIf
							aCustoFF[i]:=aCMFF[1,i]
						Next i
					EndIf
					dbSelectArea("SD3")
					RecLock("SD3",.F.)
					Replace D3_CUSFF1 	  With aCustoFF[01]
					If "2" $ cMoeda330C
						Replace D3_CUSFF2 With aCustoFF[02]
					EndIf
					If "3" $ cMoeda330C
						Replace D3_CUSFF3 With aCustoFF[03]
					EndIf
					If "4" $ cMoeda330C
						Replace D3_CUSFF4 With aCustoFF[04]
					EndIf
					If "5" $ cMoeda330C
						Replace D3_CUSFF5 With aCustoFF[05]
					EndIf
					SD3->(MsUnlock())
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o saldo final (VFIM) com os dados do SD3            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Nao calcula produtos "MAO DE OBRA"                           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !A330ISMOD(SD3->D3_COD,.T.)
					B2FimComD3(NIL,NIL,aCustoFF,.T.)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Ponto de Entrada MA330D3                                     ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lMA330D3
						ExecBlock("MA330D3",.F.,.F.)
					EndIf
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica se o movimento e' referente a requisicao manual     ³
				//³ de material indireto para atualizar o saldo final (VFIM)     ³
				//³ do processo com os dados do SD3                              ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If cApropri == "3"
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o saldo final (VFIM) com os dados do SD3            ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Nao calcula produtos "MAO DE OBRA"                           ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !A330ISMOD(SD3->D3_COD,.T.)
						B2FimComD3(NIL,cLocProc,aCustoFF,.T.)
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Ponto de Entrada MA330D3                                     ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If lMA330D3
							ExecBlock("MA330D3",.F.,.F.)
						EndIf
					EndIf
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza os saldos finais (VFIM) das OP's                    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !Empty(SD3->D3_OP) .And. cAproPri # "9"
					If SC2->(dbSeek(xFilial("SC2")+SD3->D3_OP))
						C2FimComD3(NIL,aCustoFF,.T.)
					Else
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Atualiza o log de processamento com o erro  ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						M330PrcLog("ERRO","A650NOP",Ap5GetHelp("A650NOP")+" - OP: "+SD3->D3_OP)
					EndIf
				EndIf
				dbSelectArea("SD3")
			EndIf

		ElseIf TRB->TRB_ALIAS == "SD2"

			dbSelectArea("SD2")
			dbGoto(TRB->TRB_RECNO)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Posiciona no SB1 para formulas de lancamento contabil        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SB1")
			MSSeek(xFilial("SB1")+SD2->D2_COD)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Posiciona no SF4 - TES                                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SF4")
			SF4->(dbSetOrder(1))
			SF4->(MsSeek(xFilial("SF4")+SD2->D2_TES))
			dbSelectArea("SD2")

			If SF4->F4_PODER3 == "D"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Retorna o Custo Fifo baseado nos lotes da tabela SBD		 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aRet := RetCusSBD()
				aCMFF := {aRet[1]/SD2->D2_QUANT,aRet[2]/SD2->D2_QUANT,aRet[3]/SD2->D2_QUANT,aRet[4]/SD2->D2_QUANT,aRet[5]/SD2->D2_QUANT}

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Realiza a gravacao do Custo Fifo na tabela SB6 				 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				A330PegaSB6("SD2",.T.,"330",lCstPart,nPartes)
				If lM330CD2
					aBackCusto :=ACLONE(aCMFF)
					aCMFF:=ExecBlock("M330CD2",.F.,.F.,{aCMFF,.T.})
					If Valtype(aCMFF) != "A"
						aCMFF:=ACLONE(aBackCusto)
					EndIf
				EndIf
				aRet    := GravaCusD2(NIL,"N",aCMFF,"330")   // para forcar a gravacao
				aCustoFF:= aRet[2]
				B2FimComD2(NIL,aCustoFF,(lCusFIFO .Or. lCusLIFO))
				SD2->(MsUnlock())

			Else

				If SD2->D2_TIPO != "D"
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Processa as vendas                                           ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aEnvCus := A330EnvCus()

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Pega os custos medios finais                                 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aRet  := PegaCMFim(SD2->D2_COD,SD2->D2_LOCAL,SD2->D2_TIPO,aEnvCus,"SD2","330",,.T.)
					aCMFF := aRet[2]

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Grava o custo da nota fiscal de saida                        ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lM330CD2
						aBackCusto :=ACLONE(aCMFF)
						aCMFF:=ExecBlock("M330CD2",.F.,.F.,{aCMFF,.T.})
						If Valtype(aCMFF) != "A"
							aCMFF:=ACLONE(aBackCusto)
						EndIf
					EndIf
					aRet     := GravaCusD2(NIL,SD2->D2_TIPO,aCMFF,"330")
					aCustoFF := aRet[2]

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o saldo final (VFIM) com os dados do SD2            ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					B2FimComD2(NIL,aCustoFF,.T.)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Ponto de Entrada MA330D2                                     ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lMA330D2
						ExecBlock("MA330D2",.F.,.F.)
					EndIf

					If SF4->F4_PODER3 == "R"
						A330GravaSB6("SD2",NIL,aCustoFF,.T.)
					EndIf

					SD2->(MsUnlock())
				Else
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Processa as devolucoes de compra                             ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aEnvCus := A330EnvCus()

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Pega os custos medios finais                                 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Na Funcao PegaCMFim() Esta Tratando CUSTO FIFO / LIFO        ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aRet  := PegaCMFim(SD2->D2_COD,SD2->D2_LOCAL,SD2->D2_TIPO,aEnvCus,"SD2","330",.T.,.T.,SD2->D2_QUANT == 0)
					aCMFF := aRet[2]

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Grava o custo da nota fiscal de saida                        ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lM330CD2
						aBackCusto :=ACLONE(aCMFF)
						aCMFF:=ExecBlock("M330CD2",.F.,.F.,{aCMFF,.T.})
						If Valtype(aCMFF) != "A"
							aCMFF:=ACLONE(aBackCusto)
						EndIf
					EndIf
					aRet     := GravaCusD2(NIL,SD2->D2_TIPO,aCMFF,"330")
					aCustoFF := aRet[2]

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o saldo final (VFIM) com os dados do SD2            ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					B2FimComD2(NIL,aCustoFF,.T.)

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Ponto de Entrada MA330D2                                     ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lMA330D2
						ExecBlock("MA330D2",.F.,.F.)
					EndIf

					If SF4->F4_PODER3 == "R"
						A330GravaSB6("SD2",NIL,aCustoFF,.T.)
					EndIf

					SD2->(MsUnlock())
				EndIf

			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Adiciona custos na lista de transferencia					 |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			 If !Empty(TRB->TRB_FILTRA)
			 	cKeyListaTRF := cFilAnt+TRB->TRB_FILTRA+SD2->D2_DOC+SD2->D2_SERIE +A330ConvIT(SD2->D2_ITEM,'SD1')
			 	oListaTRF[cKeyListaTRF] := {cFilAnt,TRB->TRB_FILTRA,SD2->D2_DOC,SD2->D2_SERIE,SD2->D2_COD,TRB->TRB_QUANT,aCMFF,aCustoFF,{},{},A330ConvIT(SD2->D2_ITEM,'SD1')}
			 	//AADD(aListaTrf,{cFilAnt,TRB->TRB_FILTRA,SD2->D2_DOC,SD2->D2_SERIE,SD2->D2_COD,TRB->TRB_QUANT,aCMFF,aCustoFF,{},{},SD2->D2_ITEM})
			 EndIf
		EndIf
		dbSelectArea("TRB")
		dbSetOrder(nOrderFIFO)
		dbSkip()
		// Restaura filial original
		cFilAnt:=cFilBack
	EndDo

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o log de processamento			    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	M330PrcLog("MENSAGEM",OemToAnsi(I18N(STR0098,{Alltrim(cMoeda330C)})),OemToAnsi(I18N(STR0098,{Alltrim(cMoeda330C)})) ) //"Recalculo do custo FIFO/LIFO na(s) moeda(s) 1#1[2345]# - (1) Termino"

EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta tela para mudar sequencia de acordo com necessidade ³
//³ do usuario.                                               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lBat .And. !IsBlind() .And. a330ParamZX[16] == 2
	M330LogCus(aFilsCalc)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Reinicia Lista de Transferencias                          |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//aListaTrf := {}
oListaTrf:fromJson("{}")

// Verifica se os LPs 67A e 67B estao configurados
If lLanctoOn
	lVer67A	:= VerPadrao("67A") // Movimento de Estoques - Rateio da Solicitacao ao Armazem
	lVer67B	:= VerPadrao("67B") // Movimento de Estoques - Rateio da Solicitacao ao Armazem - Estorno
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza o log de processamento			    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
M330PrcLog("MENSAGEM",OemToAnsi(I18N(STR0099,{Alltrim(cMoeda330C)}) ),OemToAnsi(I18N(STR0099,{Alltrim(cMoeda330C)})),'6' ) //"Recalculo do Custo Medio na(s) moeda(s) 1#1[2345]# - (0) Iniciando "

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Integracao com o PCO processo 314           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PcoIniLan("000314")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Processa pela sequencia CUSTO MEDIO                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("TRB")
dbSetOrder(3)
dbGotop()

If !lBat .And. !IsBlind()
	ProcRegua(LastRec(),16,4)
EndIf

While !Eof()

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Movimentacao do Cursor                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lBat .And. !IsBlind()
		IncProc(OemToAnsi(STR0101)) //"Recalculando o Custo Medio dos Movimentos"
	EndIf
	// Altera filial corrente
	cFilAnt:=TRB->TRB_FILIAL
	lReqAut	:= SuperGetMv('MV_REQAUT',.F.,"A") == 'A'
	lSeq300	:= SuperGetMv('MV_SEQ300',.F.,.F.)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Habilita Log via Conout para Analise                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lHabCon330
		Conout("ST | ORDEM: " + TRB->TRB_ORDEM + " | " + "ALIAS: " + TRB->TRB_ALIAS + " | " + "RECNO : " + STRZERO(TRB->(RECNO()),10) + " | PRODUTO: " + TRB->TRB_COD)
	EndIf

	If TRB->TRB_ALIAS == "SD1" .And. !(lM330JCM1 .And. TRB->TRB_ORDEM == '100')
		If !lFirstSD1
			M330PrcLog("MENSAGEM",STR0242 +cFilAnt,STR0242 +cFilAnt,'6A') //"Analise de entradas "
			lFirstSD1 := .T.
		EndIf

		dbSelectArea("SD1")
		dbGoto(TRB->TRB_RECNO)
		GravaSeq("SD1")

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posiciona no SB1 para formulas de lancamento contabil        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lLanctoOn
			dbSelectArea("SB1")
			MsSeek(xFilial("SB1")+SD1->D1_COD)
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posiciona no SF4 - TES                                       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SF4")
		MsSeek(xFilial("SF4")+SD1->D1_TES)
		dbSelectArea("SD1")

		If SF4->F4_PODER3 == "D"
			If TRB->TRB_RECSD1 > 0
				SD3->(dbGoto(TRB->TRB_RECSD1))
				If a330ParamZX[04] == 1
					GravaSeq("SD3")
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Nao considerar o custo de uma entrada por devolucao ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SD1->D1_TIPO == "D" .And. SF4->F4_DEVZERO == "2"
				aRet := {{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0}}
			Else
				// Se nao for transferencia de filiais obtem custo pelo tipo de movimento
				If !A330RecTrf(aRet,oListaTrf,.F.,lCstPart,aRegraCP)
					aRet := A330PegaSB6("SD1",.F.,"330",lCstPart,nPartes,lCusRep)
				EndIf
			EndIf
			aCM        := ACLONE(aRet[1])
			aCMSD1     := ACLONE(aRet[1])
			aRetPartes := ACLONE(aRet[3])
			If lCusRep
				aCMRep := ACLONE(aRet[4])
			EndIf
			aRet       := GravaCusD1(aCm,"D",NIL,"330",lCstPart,aRegraCP,ACLONE(aRetPartes),1,lIntCusTMS,lCusRep,ACLONE(aCMRep))
			aCusto     := ACLONE(aRet[1])
			aRetPartes := ACLONE(aRet[3])
			If lCusRep
				aCMRep := ACLONE(aRet[4])
			EndIf

			//Entrada para OP, independente de poder de terceiros
			If TRB->TRB_RECSD1 > 0 .And. a330ParamZX[04] == 1
				Aadd(aRegsRE5,{TRB->TRB_RECNO, TRB->TRB_RECSD1,aRetPartes})
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Acerta custo no SD3 caso necessario - Custo de RE5           ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If TRB->TRB_RECSD1 > 0 .And. a330ParamZX[04] == 1
				aRet:=GravaCusD3(aCM,.T.,NIL,"330",NIL,lCstPart,aRegraCP,aRetPartes,lIntCusTMS,1,lCusRep,aCMRep,.T.)
				SD3->(MsUnlock())
			EndIf
			dbSelectArea("SD1")

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o saldo final (VFIM) com os dados do SD1            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			B2FimComD1(aCusto,NIL,NIL,lCstPart,aRetPartes,lCusRep)
			TTFimComD1(aCusto,ACLONE(aRetPartes),,lCstPart)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Ponto de Entrada MA330D1                                     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lMA330D1
				ExecBlock("MA330D1",.F.,.F.)
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Acerta custo de CQ - Controle de Qualidade                   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SD1->D1_LOCAL == cLocalCQ .And.!Empty(SD1->D1_NUMCQ) .And. !(SD1->D1_TIPO $ "I|C|P")
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Calcula o Custo em Partes Unitario                       ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lCstPart
					dbSelectArea("SD1")
					aCMPartes := PegaCMPFim("D1_CP",lCstPart,nPartes,SD1->D1_QUANT)
				EndIf
				cSeekD7:=SD1->D1_NUMCQ+SD1->D1_COD+SD1->D1_LOCAL
				dbSelectArea("SD7")
				dbSetOrder(1)
				dbSeek(xFilial("SD7")+cSeekD7,.F.)
				While !Eof() .And. xFilial("SD7")+cSeekD7==D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL
					If D7_TIPO # 0 .And. D7_TIPO # 5 .And. D7_TIPO # 8
						aCM    := PegaCMD1()
						If lCusRep
							aCMRep := IIf(lCusRep,PegaCMD1(Nil,lCusRep),{0,0,0,0,0,})
						EndIf
						dbSelectArea("SD3")
						dbSetOrder(2)
						dbSeek(cSeekSD3:=xFilial("SD3")+PadR(SD7->D7_NUMERO,nTamDoc)+SD7->D7_PRODUTO)
						While !Eof() .And. cSeekSD3 == D3_FILIAL+D3_DOC+D3_COD
							If (D3_NUMSEQ == SD7->D7_NUMSEQ) .And. QtdComp(SD3->D3_QUANT) # QtdComp(0)
								For nx:=1 to Len(aCM)
									aCMSD1[nx]	:=aCM[nx]*SD3->D3_QUANT
									If lCusRep
										aCMSD1Rep[nX] := IIf(lCusRep,aCMRep[nx]*SD3->D3_QUANT,{0,0,0,0,0})
									EndIf
								Next nx
								aRet:=GravaCusD3(aCMSD1,.T.,NIL,"330",NIL,lCstPart,aRegraCP,aClone(aCMPartes),lIntCusTMS,SD3->D3_QUANT,lCusRep,aCMSD1Rep)
								SD3->(MsUnlock())
							EndIf
							dbSkip()
						End
					EndIf
					dbSelectArea("SD7")
					dbSkip()
				EndDo
			EndIf
			dbSelectArea("SD1")

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Gera o lancamento no arquivo de prova                        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			A330DET(SD1->D1_SEQCALC,"682","MATA330","SD1",,a330ParamZX)

			dbSelectArea("TRB")
			dbSetOrder(3)
			dbSkip()
			Loop
		EndIf

		If D1_TIPO != "D"

			// Se nao for transferencia de filiais obtem custo pelo tipo de movimento
			If !A330RecTrf(aRet,oListaTrf,.F.,lCstPart,aRegraCP)

				aCusto := {SD1->D1_CUSTO,SD1->D1_CUSTO2,SD1->D1_CUSTO3,SD1->D1_CUSTO4,SD1->D1_CUSTO5}

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza os campos de Custo de Reposicao                       ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lCusRep
					RecLock("SD1",.F.)
					SD1->D1_CUSRP1 := aCusto[1]
					SD1->D1_CUSRP2 := aCusto[2]
					SD1->D1_CUSRP3 := aCusto[3]
					SD1->D1_CUSRP4 := aCusto[4]
					SD1->D1_CUSRP5 := aCusto[5]
					SD1->(MsUnLock())
					If lCusRep
						aCMRep := aCusto
					EndIf
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ M330CD1 - Ponto de Entrada para manipulacao do Custo em Partes ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lM330CD1 .And. lCstPart
					aRetCPUs := ExecBlock("M330CD1",.F.,.F.,{lCstPart,aRegraCP,aCusto})
					If Valtype(aRetCPUs) == "A" .And. Len(aRetCPUs) > 0
						aRetPartes := aRetCPUs
					EndIf
				EndIf

				If lCstPart
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Grava o custo em partes no arquivo de movimento              ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

					// ATENCAO este trecho é de movimento da SD1 e é diferente do trecho abaixo de transferencia de filiais
					// os parametros aqui devem ser NIL na posição 6 ou o retorno do PE Acima é NIL caso não use e deve ser a qtde da SD1 na posição 7.
					aRetPartes:=GravaCusCP(lCstPart,aRegraCP,aCusto,"SD1",SD1->D1_COD,aRetCPUs, SD1->D1_QUANT,NIL,aCusto)
				EndIf


				 //Entrada para OP, independente de poder de terceiros
				 If TRB->TRB_RECSD1 > 0 .And. a330ParamZX[04] == 1
					Aadd(aRegsRE5,{TRB->TRB_RECNO, TRB->TRB_RECSD1,aRetPartes})
				 EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Acerta custo no SD3 caso necessario - Custo de RE5           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If TRB->TRB_RECSD1 > 0
					SD3->(dbGoto(TRB->TRB_RECSD1))
					If a330ParamZX[04] == 1
						GravaSeq("SD3")
						aRet:=GravaCusD3(aCusto,.T.,NIL,"330",NIL,lCstPart,aRegraCP,aRetPartes,lIntCusTMS,,lCusRep,aCMRep,.T.)
						SD3->(MsUnlock())
					EndIf
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Acerta custo de CQ - Controle de Qualidade                   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If SD1->D1_LOCAL == cLocalCQ .And. !Empty(SD1->D1_NUMCQ) .And. !(SD1->D1_TIPO $ "I|C|P")
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Calcula o Custo em Partes Unitario                       ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lCstPart
						dbSelectArea("SD1")
						aCMPartes := PegaCMPFim("D1_CP",lCstPart,nPartes,SD1->D1_QUANT)
					EndIf
					cSeekD7:=SD1->D1_NUMCQ+SD1->D1_COD+SD1->D1_LOCAL
					dbSelectArea("SD7")
					dbSetOrder(1)
					dbSeek(xFilial("SD7")+cSeekD7,.F.)
					While !Eof() .And. xFilial("SD7")+cSeekD7==D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL
						If D7_TIPO # 0 .And. D7_TIPO # 5 .And. D7_TIPO # 8
							aCM    := PegaCMD1()
							aCMSD1 := ACLONE(aCM)
							If lCusRep
								aCMRep := IIf(lCusRep,PegaCMD1(Nil,lCusRep),{0,0,0,0,0,})
							EndIf
							dbSelectArea("SD3")
							dbSetOrder(2)
							dbSeek(cSeekSD3:=xFilial("SD3")+PadR(SD7->D7_NUMERO,nTamDoc)+SD7->D7_PRODUTO)
							While !Eof() .And. cSeekSD3 == D3_FILIAL+D3_DOC+D3_COD
								If (D3_NUMSEQ == SD7->D7_NUMSEQ) .And. QtdComp(SD3->D3_QUANT) # QtdComp(0)
									For nx:=1 to Len(aCM)
										aCMSD1[nx]	:=aCM[nx]*SD3->D3_QUANT
										If lCusRep
											aCMSD1Rep[nX] := IIf(lCusRep,aCMRep[nx]*SD3->D3_QUANT,{0,0,0,0,0})
										EndIf
									Next nx
									aRet:=GravaCusD3(aCMSD1,.T.,NIL,"330",NIL,lCstPart,aRegraCP,aClone(aCMPartes),lIntCusTMS,SD3->D3_QUANT,lCusRep,aCMSD1Rep)
									SD3->(MsUnlock())
								EndIf
								dbSkip()
							End
						EndIf
						dbSelectArea("SD7")
						dbSkip()
					EndDo
				EndIf
				dbSelectArea("SD1")

			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava o custo de transferencia corrigido no SD1              |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aCusto    := ACLONE(aRet[1])
				aRetPartes:= ACLONE(aRet[3])
				If lCusRep
					aCMRep:= ACLONE(aRet[4])
				EndIf
				Reclock("SD1",.F.)
				For nx:=1 to Len(aCusto)
					If SF4->F4_TRFICST == '1'
						If nx == 1
							aCusto[nx] := aCusto[nx]+SD1->D1_ICMSRET
						Else
							aCusto[nx] := aCusto[nx]+xMoeda(SD1->D1_ICMSRET,1,nx,SD1->D1_DTDIGIT)
						EndIf
					EndIf
					Fieldput(Fieldpos("D1_CUSTO"+If(nx == 1,"",Str(nx,1,0))),aCusto[nx])
					If lCusRep
						Fieldput(Fieldpos("D1_CUSRP"+Str(nx,1,0)),aCMRep[nx])
					EndIf
				Next nx
				SD1->(MsUnlock())

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava o custo de movimentos de Documento em trânsito provenientes de Trans. Fil.   |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

				M330DocTran(aCusto,NIL,lCstPart,aRegraCP,aCMPartes,lIntCusTMS,lCusRep,aCMRep,lCusFil,lCusEmp,aRetPartes,cLocTran)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ M330CD1 - Ponto de Entrada para manipulacao do Custo em Partes ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lM330CD1 .And. lCstPart
					aRetCPUs := ExecBlock("M330CD1",.F.,.F.,{lCstPart,aRegraCP,aCusto})
					If Valtype(aRetCPUs) == "A" .And. Len(aRetCPUs) > 0
						aRetPartes := aRetCPUs
					EndIf
				EndIf

				If lCstPart
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Grava o custo em partes no arquivo de movimento              ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

					// ATENCAO Este trecho é diferente do trecho acima e os parametros devem ser aretpartes na posição 6
					// e fixo 1 na posição 7, cenario de tratamento para transferencia de filiais.
					aRetPartes:=GravaCusCP(lCstPart,aRegraCP,aCusto,"SD1",SD1->D1_COD,aRetPartes,1,NIL,aCusto)
				EndIf


				//Entrada para OP, independente de poder de terceiros
				If TRB->TRB_RECSD1 > 0 .And. a330ParamZX[04] == 1
					Aadd(aRegsRE5,{TRB->TRB_RECNO, TRB->TRB_RECSD1,aRetPartes})
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Acerta custo no SD3 caso necessario - Custo de RE5           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If TRB->TRB_RECSD1 > 0
					SD3->(dbGoto(TRB->TRB_RECSD1))
					If a330ParamZX[04] == 1
						GravaSeq("SD3")
						aRet:=GravaCusD3(aCusto,.T.,NIL,"330",NIL,lCstPart,aRegraCP,aRetPartes,lIntCusTMS,,lCusRep,aCMRep)
						SD3->(MsUnlock())
					EndIf
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Acerta custo de CQ - Controle de Qualidade                   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If SD1->D1_LOCAL == cLocalCQ .And.!Empty(SD1->D1_NUMCQ) .And. !(SD1->D1_TIPO $ "I|C|P")
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Calcula o Custo em Partes Unitario                       ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lCstPart
						dbSelectArea("SD1")
						aCMPartes := PegaCMPFim("D1_CP",lCstPart,nPartes,SD1->D1_QUANT)
					EndIf
					cSeekD7:=SD1->D1_NUMCQ+SD1->D1_COD+SD1->D1_LOCAL
					dbSelectArea("SD7")
					dbSetOrder(1)
					dbSeek(xFilial("SD7")+cSeekD7,.F.)
					While !Eof() .And. xFilial("SD7")+cSeekD7==D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL
						If D7_TIPO # 0 .And. D7_TIPO # 5 .And. D7_TIPO # 8
							aCM    := PegaCMD1()
							aCMSD1 := ACLONE(aCM)
							If lCusRep
								aCMRep := IIf(lCusRep,PegaCMD1(Nil,lCusRep),{0,0,0,0,0,})
							EndIf
							dbSelectArea("SD3")
							dbSetOrder(2)
							dbSeek(cSeekSD3:=xFilial("SD3")+PadR(SD7->D7_NUMERO,nTamDoc)+SD7->D7_PRODUTO)
							While !Eof() .And. cSeekSD3 == D3_FILIAL+D3_DOC+D3_COD
								If (D3_NUMSEQ == SD7->D7_NUMSEQ) .And. QtdComp(SD3->D3_QUANT) # QtdComp(0)
									For nx:=1 to Len(aCM)
										aCMSD1[nx]	:=aCM[nx]*SD3->D3_QUANT
										If lCusRep
											aCMSD1Rep[nX] := IIf(lCusRep,aCMRep[nx]*SD3->D3_QUANT,{0,0,0,0,0})
										EndIf
									Next nx
									aRet:=GravaCusD3(aCMSD1,.T.,NIL,"330",NIL,lCstPart,aRegraCP,aClone(aCMPartes),lIntCusTMS,SD3->D3_QUANT,lCusRep,aCMSD1Rep)
									SD3->(MsUnlock())
								EndIf
								dbSkip()
							End
						EndIf
						dbSelectArea("SD7")
						dbSkip()
					EndDo
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o saldo final (VFIM) com os dados do SD1            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			B2FimComD1(NIL,NIL,NIL,lCstPart,aRetPartes,lCusRep)
			TTFimComD1(NIL,ACLONE(aRetPartes),,lCstPart)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Ponto de Entrada MA330D1                                     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lMA330D1
				ExecBlock("MA330D1",.F.,.F.)
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Acerta o Custo de Poder de Terceiros                         |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SF4->F4_PODER3 == "R"
				A330GravaSB6("SD1",aCusto,NIL,NIL,lCstPart,aRegraCP,ACLONE(aRetPartes))
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Gera o lancamento no arquivo de prova                        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			A330DET(SD1->D1_SEQCALC,"681","MATA330","SD1",,a330ParamZX)

			SD1->(MsUnlock())
		Else
			If TRB->TRB_RECTRB > 0
				SD3->(dbGoto(TRB->TRB_RECTRB))
				If a330ParamZX[04] == 1
					GravaSeq("SD3")
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Pega os custos medios finais                                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Nao considerar o custo de uma entrada por devolucao          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SD1->D1_TIPO == "D" .And. SF4->F4_DEVZERO == "2"
				aRet := {{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0}}
			Else
				aRet := PegaCmDev(.F.,SD1->D1_NFORI,SD1->D1_SERIORI,SD1->D1_COD,SD1->D1_LOCAL,SD1->D1_QUANT,.T.,"330",NIL,NIL,lCusFil .Or. lCusEmp,lCstPart,nPartes,SD1->D1_ITEMORI,lCusRep,IF(cPaisLoc <>"BRA",AllTrim(SD1->D1_ESPECIE)=="NCC",.F.))
			EndIf
			aCM       := ACLONE(aRet[1])
			aRetPartes:= ACLONE(aRet[3])
			If lCusRep
				aCMRep:= ACLONE(aRet[4])
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava o custo da nota fiscal de devolucao                    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aRet      := GravaCusD1(aCM,SD1->D1_TIPO,NIL,"330",lCstPart,aRegraCP,ACLONE(aRetPartes),SD1->D1_QUANT,lIntCusTMS,lCusRep,aCMRep)
			aCusto    := ACLONE(aRet[1])
			aRetPartes:= ACLONE(aRet[3])
			If lCusRep
				aCMRep    := ACLONE(aRet[4])
			EndIf

			//Entrada para OP, independente de poder de terceiros
			If TRB->TRB_RECSD1 > 0 .And. a330ParamZX[04] == 1
				Aadd(aRegsRE5,{TRB->TRB_RECNO, TRB->TRB_RECSD1,aRetPartes})
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Acerta custo no SD3 caso necessario - Custo de RE5           ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If TRB->TRB_RECTRB > 0 .And. a330ParamZX[04] == 1
				aRet:=GravaCusD3(aCM,.T.,NIL,"330",NIL,lCstPart,aRegraCP,aRetPartes,lIntCusTMS,1,lCusRep,aCMRep)
				SD3->(MsUnlock())
			EndIf
			dbSelectArea("SD1")

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o saldo final (VFIM) com os dados do SD1            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			B2FimComD1(aCusto,NIL,NIL,lCstPart,aRetPartes,lCusRep)
			TTFimComD1(aCusto,ACLONE(aRetPartes),,lCstPart)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Ponto de Entrada MA330D1                                     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lMA330D1
				ExecBlock("MA330D1",.F.,.F.)
			EndIf

			If SF4->F4_PODER3 == "R"
				A330GravaSB6("SD1",{SD1->D1_CUSTO,SD1->D1_CUSTO2,SD1->D1_CUSTO3,SD1->D1_CUSTO4,SD1->D1_CUSTO5},NIL,NIL,lCstPart,aRegraCP,NIL,lCusRep,aCMRep)
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Gera o lancamento no arquivo de prova                        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			A330DET(SD1->D1_SEQCALC,"641","MATA330","SD1",,a330ParamZX)

			SD1->(MsUnlock())
		EndIf


	ElseIf lM330JCM1 .And. TRB->TRB_ORDEM == '100'

		If !lFirstSD1
			M330PrcLog("MENSAGEM",STR0242+cFilAnt,STR0242+cFilAnt,'6A') //"Analise de entradas "
			lFirstSD1 := .T.
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Processamento por Threads para a Ordenacao 100   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		A330JobCM('100',aFilsCalc,lExistProc,oListaTrf,Strzero(ThreadID(),15),oJobCMCall)

	ElseIf TRB->TRB_ALIAS == "SD3" .And. !(lM330JCM3 .And. TRB->TRB_ORDEM == '300' .And. Empty(TRB->TRB_SEQPRO) .And. !Empty(TRB->TRB_NIVEL) .And. !Empty(TRB->TRB_NIVSD3) .And. !Empty(TRB->TRB_OP))

		If !lFirstSD3
			M330PrcLog("MENSAGEM",STR0243 +cFilAnt,STR0243 +cFilAnt,'6B') //"Analise de movimentos internos - "
			lFirstSD3 := .T.
		EndIf

		dbSelectArea("SD3")
		dbGoto(TRB->TRB_RECNO)
		If a330ParamZX[04] == 1
			GravaSeq("SD3")
		EndIf

		If SD3->D3_ESTORNO == "S" .And. a330ParamZX[04] == 1
			RecLock("SD3",.F.)
			Replace D3_CUSTO1 With 0
			Replace D3_CUSTO2 With 0
			Replace D3_CUSTO3 With 0
			Replace D3_CUSTO4 With 0
			Replace D3_CUSTO5 With 0
			If lCusRep
				Replace D3_CUSRP1 With 0
				Replace D3_CUSRP2 With 0
				Replace D3_CUSRP3 With 0
				Replace D3_CUSRP4 With 0
				Replace D3_CUSRP5 With 0
			EndIf
			SD3->(MsUnlock())
			dbSelectArea("TRB")
			dbSkip()
			Loop
		EndIf

		// Valida movimentos de WMS
		If !Empty(D3_SERVIC) .And. !D3Valido("SD3")
			dbSelectArea("TRB")
			dbSkip()
			Loop
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posiciona no SB1 para formulas de lancamento contabil        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lLanctoOn
			dbSelectArea("SB1")
			MsSeek(xFilial("SB1")+SD3->D3_COD)
		EndIf

		dbSelectArea("SD3")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Processa as movimentacoes internas                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		lPassou   := .F.
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ lTransito - Variavel utilizada para verificar se o movimento e   |
		//| referente a um remito de transferencia entre filiais utilizando  |
		//| o almoxarifado de TRANSITO definido pelo parametro MV_DEPTRAN    ³
		//| (Somente utilizado por paises localizados)						 |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		lTransito := cPaisLoc <> "BRA" .And. Alltrim(D3_CF)=="DE4" .And.;
			cDepTran==D3_LOCAL .And. !Empty(D3_DOC) .And. !Empty(D3_ITEM)
		AFILL(aCMRep    ,0)
		AFILL(aAprRep   ,0)
		AFILL(aCustoRep ,0)
		AFILL(aCM       ,0)
		AFILL(aCusto    ,0)
		AFILL(aApropria ,0)
		AFILL(aAprInd   ,0)
		AFILL(aAprDir   ,0)
		If lLanctoOn
			dbSelectArea("SF5")
			MsSeek(xFilial("SF5")+SD3->D3_TM)
		EndIf
		dbSelectArea("SD3")
		If Alltrim(D3_CF) $ "PR0/PR1" // Producoes
			dbSelectArea("SC2")
			If MsSeek(xFilial("SC2")+SD3->D3_OP)
				If SD3->D3_OP <> nOPAnt
					aAcumPR0   := {0,0,0,0,0}
					nOPAnt := SD3->D3_OP
				Endif
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Pega o custo final (VFIM) desta OP                           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aRet        := PegaC2Fim("330",.F.,lCstPart,nPartes,lCusRep)
				aApropria   := ACLONE(aRet[1])
				If lCusRep
					aAprRep     := ACLONE(aRet[4])
				EndIf
				If a330ParamZX[14] # 1 .And. nProdProp == 1
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Proporcionaliza custo do apontamento.                        ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					dbSelectArea("TRX")
					MsSeek(cFilAnt+DTOS(TRB->TRB_DTBASE)+TRB->TRB_OP+TRB->TRB_COD+TRB->TRB_LOCAL)
					// Usando o MV_SEQ300 com produção e requisição automatica, o custo das requisições devem ser descarregados
					// no proximo apontamento de produção (Manut feita Harley por Marcos Vinicius)
					If  lM330PR1 .And. lSeq300 .And. lReqAut .and. SD3->D3_PARCTOT=='P'
						nPropPR0 := 1
					Else
						nPropPR0 := (SD3->D3_QUANT+SD3->D3_PERDA)/((TRX->TRX_TOTAL+TRX_TPERDA)-TRX->TRX_QTDPRC)
					EndIf
					nPropPR0Rp := nPropPR0
					cSeekTRX:=cFilAnt+DTOS(TRB->TRB_DTBASE)+TRB->TRB_OP+TRB->TRB_COD
					cWhileTRX:="TRX_FILIAL+DTOS(TRX_DATA)+TRX_OP+TRX_COD"
					MsSeek(cSeekTRX)
					While !Eof() .And. cSeekTRX == &(cWhileTRX)
						Reclock("TRX",.F.)
						Replace TRX_QTDPRC With TRX_QTDPRC + (SD3->D3_QUANT+SD3->D3_PERDA)
						TRX->(MsUnlock())
						dbSkip()
					End
				ElseIf a330ParamZX[14] # 1 .And. ((nProdProp == 2 .And. SD3->D3_RATEIO > 0) .Or. nProdProp == 3)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Verifica valorizacao do apontamento quando todos componentes ³
					//³ ja foram requisitados                                        ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

					//Verifica se a ordem de produção foi encerrada parcialmente no período
					lOPEncParc := nProdProp == 3 .And. (!Empty(SC2->C2_DATRF) .And. SC2->C2_DATRF <= a330ParamZX[01]) .And. SC2->C2_QUJE > 0 .And. (SC2->C2_QUJE + SC2->C2_PERDA) < SC2->C2_QUANT

					If lOPEncParc
						lOPEncParc := TRX->(dbSeek(cFilAnt+DTOS(TRB->TRB_DTBASE)+SD3->D3_OP+SD3->D3_COD+SD3->D3_LOCAL))
					EndIf

					If SD3->D3_PARCTOT == "P"
						If QtdComp(SC2->C2_APRFIM1) > QtdComp(0) .And. !lOPEncParc
							nPropPR0 := 1-(SC2->C2_APRFIM1/(aApropria[1]+SC2->C2_APRFIM1))
							nPropPR0 := If(nProdProp==2,SD3->D3_RATEIO/100,(SD3->D3_QUANT + SD3->D3_PERDA )/ max(SC2->C2_QUANT,SC2->C2_QUJE)) / nPropPR0
						Else
							If !lOPEncParc
								nPropPR0 := If(nProdProp==2,SD3->D3_RATEIO/100,(SD3->D3_QUANT + SD3->D3_PERDA )/ max(SC2->C2_QUANT,SC2->C2_QUJE))
							Else
								nPropPR0 := (SD3->D3_QUANT + SD3->D3_PERDA) / ((TRX->TRX_QUANT + TRX->TRX_QPERDA) - (TRX->TRX_TOTAL + TRX->TRX_TPERDA))
							EndIf
						EndIf
						nPropPR0 := Min(1,nPropPR0)

						If lOPEncParc
							Reclock("TRX",.F.)
							Replace TRX_TOTAL With TRX_TOTAL + SD3->D3_QUANT
							Replace TRX_TPERDA With TRX_TPERDA + SD3->D3_PERDA
							TRX->(MsUnlock())
						EndIf
					Else
						nPropPR0 := 1
					EndIf
					If lCusRep
						If SD3->D3_PARCTOT == "P"
							If QtdComp(SC2->C2_APRFRP1) > QtdComp(0)
								nPropPR0Rp := 1-(SC2->C2_APRFRP1/(aAprRep[1]+SC2->C2_APRFRP1))
								nPropPR0Rp := If(nProdProp==2,SD3->D3_RATEIO/100,(SD3->D3_QUANT + SD3->D3_PERDA )/ max(SC2->C2_QUANT,SC2->C2_QUJE)) / nPropPR0Rp
							Else
								nPropPR0Rp := If(nProdProp==2,SD3->D3_RATEIO/100,(SD3->D3_QUANT + SD3->D3_PERDA )/ max(SC2->C2_QUANT,SC2->C2_QUJE))
							EndIf
							nPropPR0Rp := Min(1,nPropPR0Rp)
						Else
							nPropPR0Rp := 1
						EndIf

					EndIf
				EndIf

				For nx:=1 to Len(aApropria)
					aApropria[nx]:=aApropria[nx]*nPropPR0
				Next nx

				If lCusRep
					For nx:=1 to Len(aAprRep)
						aAprRep[nx]:=aAprRep[nx]*nPropPR0Rp
					Next nx
				EndIf

				RecLock("SC2",.F.)
				Replace C2_VFIM1     With C2_VFIM1 - aApropria[01]
				If "2" $ cMoeda330C
					Replace C2_VFIM2 With C2_VFIM2 - aApropria[02]
				EndIf
				If "3" $ cMoeda330C
					Replace C2_VFIM3 With C2_VFIM3 - aApropria[03]
				EndIf
				If "4" $ cMoeda330C
					Replace C2_VFIM4 With C2_VFIM4 - aApropria[04]
				EndIf
				If "5" $ cMoeda330C
					Replace C2_VFIM5 With C2_VFIM5 - aApropria[05]
				EndIf
				If lCusRep
					Replace C2_VFIMRP1     With C2_VFIMRP1 - aAprRep[01]
					If "2" $ cMoeda330C
						Replace C2_VFIMRP2 With C2_VFIMRP2 - aAprRep[02]
					EndIf
					If "3" $ cMoeda330C
						Replace C2_VFIMRP3 With C2_VFIMRP3 - aAprRep[03]
					EndIf
					If "4" $ cMoeda330C
						Replace C2_VFIMRP4 With C2_VFIMRP4 - aAprRep[04]
					EndIf
					If "5" $ cMoeda330C
						Replace C2_VFIMRP5 With C2_VFIMRP5 - aAprRep[05]
					EndIf
				EndIf
				SC2->(MsUnlock())

				If lCstPart
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Pega o custo final em partes desta OP                        ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aRetPartes:=PegaC2PFim(lCstPart,nPartes)
					For nx:=1 to Len(aRetPartes)
						aRetPartes[nx]:=aRetPartes[nx]*nPropPR0
					Next nx
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o custo final em partes desta OP                    ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					GravaC2CPF(aRetPartes,lCstPart,cMoeda330C)
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza movimento do Pai                                    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If a330ParamZX[04] == 1
					Reclock("SD3",.F.)
					Replace D3_CUSTO1 With aApropria[1]
					Replace D3_CUSTO2 With If("2" $ cMoeda330C,aApropria[2],0)
					Replace D3_CUSTO3 With If("3" $ cMoeda330C,aApropria[3],0)
					Replace D3_CUSTO4 With If("4" $ cMoeda330C,aApropria[4],0)
					Replace D3_CUSTO5 With If("5" $ cMoeda330C,aApropria[5],0)
					If lCusRep
						Replace D3_CUSRP1 With aAprRep[1]
						Replace D3_CUSRP2 With If("2" $ cMoeda330C,aAprRep[2],0)
						Replace D3_CUSRP3 With If("3" $ cMoeda330C,aAprRep[3],0)
						Replace D3_CUSRP4 With If("4" $ cMoeda330C,aAprRep[4],0)
						Replace D3_CUSRP5 With If("5" $ cMoeda330C,aAprRep[5],0)
					EndIf
					SD3->(MsUnlock())
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Integracao com o Modulo de Manutencao de Ativos              ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lIntMntAt
						NGCUSSTLMED(SD3->D3_NUMSEQ,SD3->D3_CUSTO1)
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Grava o custo em partes no arquivo de movimento              ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lCstPart
						aRetPartes:=GravaCusCP(lCstPart,aRegraCP,NIL,"SD3",SD3->D3_COD,aRetPartes,1,NIL,{SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5})
					EndIf
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o saldo final (VFIM) com os dados do SD3            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Nao calcula produtos "MAO DE OBRA"                           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !A330ISMOD(SD3->D3_COD,.T.)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ A330QtdPR0 - Verifica se existe quantidade produzida "PR0"    |
					//| para esta ordem de producao para verificar se deve valorizar  |
					//| o custo para movimentos com D3_QUANT igual a zero.			  |
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If A330QtdPR0(SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN,SC2->C2_PRODUTO)
						B2FimComD3(aApropria,NIL,NIL,NIL,lCusFil .Or. lCusEmp,lCstPart,aRetPartes,lCusRep,aClone(aAprRep))
						TTFimComD3(aApropria,ACLONE(aRetPartes),,,lCstPart)
					EndIf
					If lMA330D3
						ExecBlock("MA330D3",.F.,.F.)
					EndIf
				EndIf

				dbSelectArea("SC2")
				aCusto[01]     := aApropria[01] + C2_APRFIM1
				If "2" $ cMoeda330C
					aCusto[02] := aApropria[02] + C2_APRFIM2
				EndIf
				If "3" $ cMoeda330C
					aCusto[03] := aApropria[03] + C2_APRFIM3
				EndIf
				If "4" $ cMoeda330C
					aCusto[04] := aApropria[04] + C2_APRFIM4
				EndIf
				If "5" $ cMoeda330C
					aCusto[05] := aApropria[05] + C2_APRFIM5
				EndIf
				RecLock("SC2",.F.)
				Replace C2_APRFIM1     With aCusto[01]
				If "2" $ cMoeda330C
					Replace C2_APRFIM2 With aCusto[02]
				EndIf
				If "3" $ cMoeda330C
					Replace C2_APRFIM3 With aCusto[03]
				EndIf
				If "4" $ cMoeda330C
					Replace C2_APRFIM4 With aCusto[04]
				EndIf
				If "5" $ cMoeda330C
					Replace C2_APRFIM5 With aCusto[05]
				EndIf
				If lCusRep
					aCustoRep[01]     := aAprRep[01] + C2_APRFRP1
					If "2" $ cMoeda330C
						aCustoRep[02] := aAprRep[02] + C2_APRFRP2
					EndIf
					If "3" $ cMoeda330C
						aCustoRep[03] := aAprRep[03] + C2_APRFRP3
					EndIf
					If "4" $ cMoeda330C
						aCustoRep[04] := aAprRep[04] + C2_APRFRP4
					EndIf
					If "5" $ cMoeda330C
						aCustoRep[05] := aAprRep[05] + C2_APRFRP5
					EndIf
					RecLock("SC2",.F.)
					Replace C2_APRFRP1     With aCustoRep[01]
					If "2" $ cMoeda330C
						Replace C2_APRFRP2 With aCustoRep[02]
					EndIf
					If "3" $ cMoeda330C
						Replace C2_APRFRP3 With aCustoRep[03]
					EndIf
					If "4" $ cMoeda330C
						Replace C2_APRFRP4 With aCustoRep[04]
					EndIf
					If "5" $ cMoeda330C
						Replace C2_APRFRP5 With aCustoRep[05]
					EndIf
				EndIf
				SC2->(MsUnlock())

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Pega o custo final em partes desta OP                        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lCstPart
					aRetAPAtu:=PegaC2APF(lCstPart,nPartes)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o custo apropriado final em partes desta OP         ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					For nx:=1 to Len(aRetPartes)
						aRetPartes[nx]:=aRetPartes[nx]+aRetAPAtu[nx]
					Next nx
					GravaC2APF(aRetPartes,lCstPart,cMoeda330C)
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Gera o lancamento no arquivo de prova                        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				A330DET(SD3->D3_SEQCALC,"668","MATA330","SD3",,a330ParamZX)
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o log de processamento com o erro  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				M330PrcLog("ERRO","A650NOP",Ap5GetHelp("A650NOP")+" - OP: "+SD3->D3_OP)
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Zera os valores dos arrays para novo lote de movimentos      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			AFILL(aCM		,0)
			AFILL(aCusto	,0)
			AFILL(aApropria	,0)
			AFILL(aAprInd	,0)
		ElseIf Alltrim(D3_CF) == "RE4" .Or. lTransito // Transferencias

			If oQryRecDE4 == NIL
				// processa pela sequencia do custo médio
				cQuery := ""
				cQuery += "SELECT R_E_C_N_O_ FROM "+RetSqlName("SD3")+" SD3 "
				cQuery += "WHERE SD3.D3_FILIAL = ? " // '"+xFilial("SD3")+"' "
				cQuery += "AND SD3.D3_COD  = ? " // '" +SD3->D3_COD+ "' "
				cQuery += "AND SD3.D3_LOCAL = ? " // '" +SD3->D3_LOCAL+ "' "
				cQuery += "AND SD3.D3_NUMSEQ = ? " // '" +SD3->D3_NUMSEQ+ "' "
				cQuery += "AND SD3.D3_CF = ? " // 'DE4' "
				cQuery += "AND SD3.D3_DOC = ? " // '" +SD3->D3_DOC+ "' "
				cQuery += "and SD3.D3_UM  = ? " // '" +SD3->D3_UM+ "' "
				cQuery += "and SD3.D3_EMISSAO  = ? " // '" +dtos(SD3->D3_EMISSAO)+ "' "
				cQuery += "and SD3.D3_ESTORNO  = ? " // ' ' "
				cQuery += "and SD3.D_E_L_E_T_  = ? " // ' ' "
				cQuery := ChangeQuery(cQuery)
				If __lLibVer
					oQryRecDE4 := FwExecStatement():New(cQuery)
				Else
					oQryRecDE4 := FWPreparedStatement():New(cQuery)
				EndIf
			ENDIF
			oQryRecDE4:SetString(1,xFilial("SD3"))
			oQryRecDE4:SetString(2,SD3->D3_COD)
			oQryRecDE4:SetString(3,SD3->D3_LOCAL)
			oQryRecDE4:SetString(4,D3_NUMSEQ)
			oQryRecDE4:SetString(5,'DE4')
			oQryRecDE4:SetString(6,SD3->D3_DOC)
			oQryRecDE4:SetString(7,SD3->D3_UM)
			oQryRecDE4:SetString(8,dtos(SD3->D3_EMISSAO))
			oQryRecDE4:SetString(9,' ')
			oQryRecDE4:SetString(10,' ')

			If __lLibVer
				nSD3RecDE4 := oQryRecDE4:ExecScalar('R_E_C_N_O_')
			Else
				cQuery := oQryRecDE4:GetFixQuery()
				nSD3RecDE4 := MpSysExecScalar(cQuery, 'R_E_C_N_O_')
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Pega os custos medios finais                                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Quando a entrada foi gerada por um remito de consignacion, vou pegar ³
			//³o custo de saida do almoxarifado de origem. Bruno                    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aRet := Nil
			If lTransito
				SD2->(DbSetOrder(3))
				SD2->(DBSeek(xFilial("SD2")+SD3->D3_DOC))
				While !SD2->(Eof()) .And. SD2->D2_FILIAL+SD2->D2_DOC ==  xFilial("SD2")+SD3->D3_DOC
					If SD3->D3_ITEM == SD2->D2_ITEM .And. SD2->D2_COD == SD3->D3_COD .And. AllTrim(SD2->D2_ESPECIE) == "RTS"  //RTS - Remito de Transferencia de Saida
						aRet :={{SD2->D2_CUSTO1/SD2->D2_QUANT,SD2->D2_CUSTO2/SD2->D2_QUANT,SD2->D2_CUSTO3/SD2->D2_QUANT,SD2->D2_CUSTO4/SD2->D2_QUANT,SD2->D2_CUSTO5/SD2->D2_QUANT},{0,0,0,0,0},{0,0,0,0,0},IIf(lCusRep,{SD2->D2_CUSRP1/SD2->D2_QUANT,SD2->D2_CUSRP2/SD2->D2_QUANT,SD2->D2_CUSRP3/SD2->D2_QUANT,SD2->D2_CUSRP4/SD2->D2_QUANT,SD2->D2_CUSRP5/SD2->D2_QUANT},{0,0,0,0,0})}
						If lCusRep
							aCMRep   :=ACLONE(aRet[4])
						EndIf
						Exit
					EndIf
					SD2->(DbSkip())
					Loop
				EndDo
			EndIf

			If aRet == Nil
				If lCusFil .Or. lCusEmp
					aRet   := A330TTFim(D3_COD,D3_LOCAL,,,"SD3","330",NIL,NIL,lCstPart,nPartes,lCusEmp)
					aCMRep := {0,0,0,0,0}
				Else
					aRet  := PegaCMFim(D3_COD,D3_LOCAL,,,"SD3","330",NIL,NIL,lCstPart,nPartes,aRegraCP,lCusRep)
					If lCusRep
						aCMRep := ACLONE(aRet[4])
					EndIf
				EndIf
			EndIf
			aCM      :=ACLONE(aRet[1])
			aRetPUnit:=ACLONE(aRet[3])

			If Alltrim(D3_CF) == "RE4" // Transferencia

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava o custo da movimentacao                                ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If a330ParamZX[04] == 1
					aRet      := GravaCusD3(aCM,NIL,NIL,"330",NIL,lCstPart,aRegraCP,ACLONE(aRet[3]),lIntCusTMS,,lCusRep,ACLONE(aCMRep))
					aCusto    := ACLONE(aRet[1])
					aRetPartes:= ACLONE(aRet[3])
					If lCusRep
						aCMRep := ACLONE(aRet[4])
					EndIf
					SD3->(MsUnlock())
				Else
					aCusto := {SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5}
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o saldo final (VFIM) com os dados do SD3            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Nao calcula produtos "MAO DE OBRA"                           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !A330ISMOD(SD3->D3_COD,.T.)
					B2FimComD3(aCusto,NIL,NIL,NIL,lCusFil .Or. lCusEmp,lCstPart,aRetPartes,lCusRep,ACLONE(aCMRep),nSD3RecDE4==0)
					TTFimComD3(aCusto,ACLONE(aRetPartes),,,lCstPart)
					If lMA330D3
						ExecBlock("MA330D3",.F.,.F.)
					EndIf
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Gera o lancamento no arquivo de prova                        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				A330DET(SD3->D3_SEQCALC,"670","MATA330","SD3",,a330ParamZX)

			EndIf

			If !lTransito
				// Verificar este SKIP
				dbSelectArea("TRB")
				nRecOrig:=Recno()
				cNumSeqOrig:=TRB_SEQ
				nQtdOri:=TRB_QUANT
				cUMOrig:=SD3->D3_UM
				DbSelectArea("SD3")
				SD3->(DbSetOrder(6)) //D3_FILIAL+DTOS(D3_EMISSAO)+D3_NUMSEQ+D3_CHAVE+D3_COD
				if nSD3RecDE4 == 0
					If SD3->(MsSeek(xFilial("SD3") + DtoS(TRB->TRB_DTORIG) + TRB->TRB_SEQ))
						cKeySD3TRB := SD3->D3_FILIAL + DTOS(SD3->D3_EMISSAO) + SD3->D3_NUMSEQ
						While SD3->D3_FILIAL + DTOS(SD3->D3_EMISSAO) + SD3->D3_NUMSEQ == cKeySD3TRB
							If SD3->D3_CF == "DE4"
								Exit
							EndIf
							SD3->(DbSkip())
						EndDo
					EndIf
				else
					SD3->(MsGoto(nSD3RecDE4)) //D3_FILIAL+DTOS(D3_EMISSAO)+D3_NUMSEQ+D3_CHAVE+D3_COD
				endif
			EndIf

			If SubStr(D3_CF,3,1) == "4" .And. IIf(lTransito,.T.,D3_NUMSEQ == cNumSeqOrig) // Transferencias
				If a330ParamZX[04] == 1
					GravaSeq("SD3")
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Posiciona no SB1 para formulas de lancamento contabil        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lLanctoOn
					dbSelectArea("SB1")
					MsSeek(xFilial("SB1")+SD3->D3_COD)
				EndIf
				dbSelectArea("SB2")
				dbSetOrder(1)
				MsSeek(xFilial("SB2")+SD3->D3_COD+SD3->D3_LOCAL)
				
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava o custo da movimentacao                                ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If a330ParamZX[04] == 1
					If lTransito
						aRet := GravaCusD3(aCM,NIL,NIL,"330",NIL,lCstPart,aRegraCP,ACLONE(aRetPUnit),lIntCusTMS,,lCusRep,ACLONE(aCMRep))
					Else
						aRet := GravaCusD3(aRet[1],.T.,NIL,"330",NIL,lCstPart,aRegraCP,ACLONE(aRetPUnit),lIntCusTMS,Iif(lCstPart .and. SD3->D3_CF=="DE4",nQtdOri,Nil),lCusRep,ACLONE(aCMRep))
					EndIf
					aCusto     := ACLONE(aRet[1])
					aRetPartes := ACLONE(aRet[3])
					If lCusRep
						aCMRep := ACLONE(aRet[4])
					EndIf
					SD3->(MsUnlock())
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o saldo final (VFIM) com os dados do SD3            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Nao calcula produtos "MAO DE OBRA"                           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !A330ISMOD(SD3->D3_COD,.T.)
					B2FimComD3(aCusto,NIL,NIL,NIL,lCusFil .Or. lCusEmp,lCstPart,aRetPartes,lCusRep,ACLONE(aCMRep),nSD3RecDE4==0)
					TTFimComD3(aCusto,ACLONE(aRetPartes),,,lCstPart)
					If lMA330D3
						ExecBlock("MA330D3",.F.,.F.)
					EndIf
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Gera o lancamento no arquivo de prova                        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				A330DET(SD3->D3_SEQCALC,"672","MATA330","SD3",,a330ParamZX)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Corrige o custo do CQ caso tenha sido originado por RE4      ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If SD3->D3_LOCAL == cLocalCQ
					aCM        := {SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5}
					aCMSD3     := ACLONE(aCM)
					If lCusRep
						aCMRep    := {SD3->D3_CUSRP1,SD3->D3_CUSRP2,SD3->D3_CUSRP3,SD3->D3_CUSRP4,SD3->D3_CUSRP5}
						aCMSD3Rep := ACLONE(aCMRep)
					EndIf
					dbSelectArea("SD7")
					dbSetOrder(3) //-- D7_FILIAL+D7_PRODUTO+D7_NUMSEQ+D7_NUMERO
					If MsSeek(xFilial("SD7")+SD3->D3_COD+SD3->D3_NUMSEQ)
						lUltSD7    := .F.
						cSeekD7    := D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL
						nQuantOriD7:= D7_SALDO
						dbSetOrder(2) //-- D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL+D7_NUMSEQ+STR(D7_TIPO)
						MsSeek(cSeekD7)
					EndIf
					While !Eof() .And. cSeekD7 == D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL
						If Empty(D7_ESTORNO) .And. D7_TIPO # 0 .And. D7_TIPO # 5 .And. D7_TIPO # 8
							dbSkip()
							If cSeekD7 # D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL
								lUltSD7    := .T.
							EndIf
							dbSkip(-1)
							dbSelectArea("SD3")
							dbSetOrder(4) //-- D3_FILIAL+D3_NUMSEQ+D3_CHAVE+D3_COD
							If MsSeek(xFilial("SD3")+SD7->D7_NUMSEQ) .And. PadR(SD7->D7_NUMERO,nTamDoc) == SD3->D3_DOC .And. QtdComp(SD3->D3_QUANT) # QtdComp(0)
								While !Eof() .And. xFilial("SD3")+SD7->D7_NUMSEQ == D3_FILIAL+D3_NUMSEQ
									Reclock("SD3",.F.)
									Replace D3_CUSTO1 With If(lUltSD7,aCMSD3[1],aCm[1]*(SD3->D3_QUANT/nQuantOriD7))
									Replace D3_CUSTO2 With If("2" $ cMoeda330C,If(lUltSD7,aCMSD3[2],aCm[2]*(SD3->D3_QUANT/nQuantOriD7)),0)
									Replace D3_CUSTO3 With If("3" $ cMoeda330C,If(lUltSD7,aCMSD3[3],aCm[3]*(SD3->D3_QUANT/nQuantOriD7)),0)
									Replace D3_CUSTO4 With If("4" $ cMoeda330C,If(lUltSD7,aCMSD3[4],aCm[4]*(SD3->D3_QUANT/nQuantOriD7)),0)
									Replace D3_CUSTO5 With If("5" $ cMoeda330C,If(lUltSD7,aCMSD3[5],aCm[5]*(SD3->D3_QUANT/nQuantOriD7)),0)
									If lCusRep
										Replace D3_CUSRP1 With If(lUltSD7,aCMSD3Rep[1],aCMSD3Rep[1]*(SD3->D3_QUANT/nQuantOriD7))
										Replace D3_CUSRP2 With If("2" $ cMoeda330C,If(lUltSD7,aCMSD3Rep[2],aCm[2]*(SD3->D3_QUANT/nQuantOriD7)),0)
										Replace D3_CUSRP3 With If("3" $ cMoeda330C,If(lUltSD7,aCMSD3Rep[3],aCm[3]*(SD3->D3_QUANT/nQuantOriD7)),0)
										Replace D3_CUSRP4 With If("4" $ cMoeda330C,If(lUltSD7,aCMSD3Rep[4],aCm[4]*(SD3->D3_QUANT/nQuantOriD7)),0)
										Replace D3_CUSRP5 With If("5" $ cMoeda330C,If(lUltSD7,aCMSD3Rep[5],aCm[5]*(SD3->D3_QUANT/nQuantOriD7)),0)
									EndIf
									SD3->(MsUnlock())
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Integracao com o Modulo de Manutencao de Ativos              ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									If lIntMntAt
										NGCUSSTLMED(SD3->D3_NUMSEQ,SD3->D3_CUSTO1)
									EndIf
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ So processa uma vez para nao comprometer saldo               ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									If !lUltSD7 .And. SD3->D3_LOCAL == SD7->D7_LOCAL
										For nx:=1 to 5
											// Verifica se moeda devera ser considerada
											If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
												Loop
											EndIf
											aCMSD3[nx]-=&(Eval(bBloco,"D3_CUSTO",nX))
											If lCusRep
												aCMSD3Rep[nx]-=&(Eval(bBloco,"D3_CUSRP",nX))
											EndIf
										Next nx
									EndIf
									dbSkip()
								End
							EndIf
						EndIf
						dbSelectArea("SD7")
						dbSkip()
					EndDo
				EndIf
			Else
				dbSelectArea("TRB")
				dbGoto(nRecOrig)
			EndIf
		ElseIf Alltrim(D3_CF) == "RE7"      // Transferencias Multiplas
			A330ProcRE7(.F.,lCstPart,aRegraCP,lCusRep)
		ElseIf Alltrim(D3_CF) != "DE7" .And. Alltrim(D3_CF) != "DE4"   // RE0,1,2,3 e suas DE's respectivas
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³     Pega o tipo de apropriacao do material                   ³
			//³==============================================================³
			//³ 0 = Requisicao Manual de material Direto                     ³
			//³ 1 = Requisicao Automatica de material Direto                 ³
			//³ 2 = Requisicao Automatica de material Indireto               ³
			//³ 3 = Requisicao Manual de material Indireto                   ³
			//³ 4 = Transferencias em geral                                  ³
			//³ 5 = Apropriacao direta de entrada na Op                      ³
			//³ 9 = Requisicao para OP sem agregar custo para a mesma        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cApropri := SubStr(D3_CF,3,1)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Gera o lancamento no arquivo de prova                        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			lLct667669 := .F.
			If SubStr(SD3->D3_CF,3,1) != "2"
				If SD3->D3_TM <= "500"
					lLct667669 := A330DET(SD3->D3_SEQCALC,"669","MATA330","SD3",,a330ParamZX)
				Else
					lLct667669 := A330DET(SD3->D3_SEQCALC,"667","MATA330","SD3",,a330ParamZX)
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Pega os custos medios finais                                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !(cApropri $ "568A")
				If lCusFil .Or. lCusEmp
					aRet  := A330TTFim(D3_COD,If(SD3->D3_CF <> "DE3",D3_LOCAL,cLocProc),,,"SD3","330",NIL,NIL,lCstPart,nPartes,lCusEmp)
					aCMRep:= {0,0,0,0,0}
				Else
					aRet := PegaCMFim(D3_COD,If(SD3->D3_CF <> "DE3",D3_LOCAL,cLocProc),,,"SD3","330",NIL,NIL,lCstPart,nPartes,aRegraCP,lCusRep)
					If lCusRep
						aCMRep := ACLONE(aRet[4])
					EndIf
				EndIf
				aCM       := ACLONE(aRet[1])
				aRetPartes:= ACLONE(aRet[3])
				If a330ParamZX[04] == 1
					aRet      := GravaCusD3(aCM,NIL,NIL,"330",NIL,lCstPart,aRegraCP,ACLONE(aRetPartes),lIntCusTMS,,lCusRep,aCMRep)
					aCusto    := ACLONE(aRet[1])
					aRetPartes:= ACLONE(aRet[3])
					If lCusRep
						aCMRep    := ACLONE(aRet[4])
					EndIf
					dbSelectArea("SD3")
					SD3->(MsUnlock())
				Else
					aCusto := {D3_CUSTO1,D3_CUSTO2,D3_CUSTO3,D3_CUSTO4,D3_CUSTO5}
				EndIf
			Else

				//
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Procura movimento RE5 já processado pelo SD1 para recuperar o custo em partes. ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nAchou := 0
				If cApropri=="5"
					nAchou := Ascan(aRegsRE5,{|a| a[2]==TRB->TRB_RECNO})
					If nAchou > 0 .And. Len(aRegsRE5[nAchou])>=3
						aRetPartes := aRegsRE5[nAchou,3]
					Else
						nAchou := 0
					EndIf
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ A330CustoCQ - Recupera o custo original do movimento CQ            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If cApropri == "6" .And. A330CustoCQ(SD3->D3_DOC,SD3->D3_COD,cLocalCQ,SD3->D3_NUMSEQ,aCM,lCusRep,aCMRep,aRetPartes,nPartes,lCstPart)
					GravaCusD3(aCM,NIL,NIL,"330",NIL,lCstPart,aRegraCP,aRetPartes,lIntCusTMS,,lCusRep,ACLONE(aCMRep))
					aCM := {D3_CUSTO1,D3_CUSTO2,D3_CUSTO3,D3_CUSTO4,D3_CUSTO5}
				Else
					If cApropri == "A"
						If lCusFil .Or. lCusEmp
							TRT->(dbSeek(If(lCusEmp,Space(Len(cFilAnt)),cFilAnt)+SD3->D3_COD))
							If TRT->TRB_PRCREA == .F.
								aCM	:= A330AjCusto(1,.T.)
							Else
								aCM := A330AjCusto(1)
							EndIf
						Else
							aCM := A330AjCusto(1)
						EndIf
					Else
						aCM    := {D3_CUSTO1,D3_CUSTO2,D3_CUSTO3,D3_CUSTO4,D3_CUSTO5}
						If lCusRep
							aCMRep := A330AjCusto(2)
						Else
							aCMRep := {0,0,0,0,0}
						EndIf
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Grava o custo em partes no arquivo de movimento              ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lCstPart
						If nAchou > 0 //Ajusta o Custo em Partes com Base na RE5
							aRetPartes:=GravaCusCP(lCstPart,aRegraCP,aCM,"SD3",SD3->D3_COD,aRetPartes,1,NIL,ACLONE(aCM))
						Else //Ajusta o Custo em Partes com Base na Regra
							aRetPartes:=GravaCusCP(lCstPart,aRegraCP,aCM,"SD3",SD3->D3_COD,NIL,SD3->D3_QUANT,NIL,ACLONE(aCM))
						EndIf
					EndIf
				EndIf
				aCusto := ACLONE(aCM)
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Executa P.E. para alterar valor do array com o custo medio   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lMA330C3
				aBackCusto :=ACLONE(aCusto)
				aCusto:=ExecBlock("MA330C3",.F.,.F.,aCusto)
				If Valtype(aCusto) != "A"
					aCusto:=ACLONE(aBackCusto)
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Executa P.E. para alterar valor do array com o custo medio   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lMA330P3
				aBackCusto :=ACLONE(aRetPartes)
				aRetPartes :=ExecBlock("MA330P3",.F.,.F.,{aCusto,lCstPart,aRegraCP,ACLONE(aRetPartes)})
				If Valtype(aRetPartes) != "A"
					aRetPartes:=ACLONE(aBackCusto)
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o saldo final (VFIM) com os dados do SD3            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Nao calcula produtos "MAO DE OBRA"                           ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !A330ISMOD(SD3->D3_COD,.T.)
				B2FimComD3(aCusto,NIL,NIL,NIL,lCusFil .Or. lCusEmp,lCstPart,aRetPartes,lCusRep,ACLONE(aCMRep))
				TTFimComD3(aCusto,ACLONE(aRetPartes),,,lCstPart)
				If lMA330D3
					ExecBlock("MA330D3",.F.,.F.)
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se o movimento e' referente a requisicao manual     ³
			//³ de material indireto para atualizar o saldo final (VFIM)     ³
			//³ do processo com os dados do SD3                              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cApropri == "3"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o saldo final (VFIM) com os dados do SD3            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Nao calcula produtos "MAO DE OBRA"                           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !A330ISMOD(SD3->D3_COD,.T.)
					B2FimComD3(aCusto,cLocProc,NIL,NIL,lCusFil .Or. lCusEmp,lCstPart,aRetPartes,lCusRep,ACLONE(aCMRep))
					TTFimComD3(aCusto,ACLONE(aRetPartes),cLocProc,,lCstPart)
					If lMA330D3
						ExecBlock("MA330D3",.F.,.F.)
					EndIf
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza os saldos finais (VFIM) das OP's                    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !Empty(SD3->D3_OP) .And. cAproPri # "9"
				If SC2->(MsSeek(xFilial("SC2")+SD3->D3_OP))
					C2FimComD3(aCusto,NIL,NIL,lCstPart,aRetPartes,lCusRep,ACLONE(aCMRep))
				Else
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o log de processamento com o erro  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					M330PrcLog("ERRO","A650NOP",Ap5GetHelp("A650NOP")+" - OP: "+SD3->D3_OP)
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza os saldos finais (VFIM) das Tarefas                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !Empty(SD3->D3_PROJPMS)
				AF9FimComD3(aCusto)
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se o custo medio e' calculado On-Line               ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SubStr(SD3->D3_CF,3,1) != "2"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Gera o lancamento no arquivo de prova                        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If SD3->D3_TM <= "500"
					A330DET(SD3->D3_SEQCALC,"668","MATA330","SD3",lLct667669,a330ParamZX)

					// Verifica se existe rateio na SA para contabilizar
					If lVer67B .And. !Empty(SD3->D3_NUMSA) .And. !Empty(SD3->D3_ITEMSA)
						A330CtbRat(SD3->D3_NUMSA, SD3->D3_ITEMSA, SD3->D3_SEQCALC, "67B", lLct667669, a330ParamZX)
					EndIf

				Else
					A330DET(SD3->D3_SEQCALC,"666","MATA330","SD3",lLct667669,a330ParamZX)

					// Verifica se existe rateio na SA para contabilizar
					If lVer67A .And. !Empty(SD3->D3_NUMSA) .And. !Empty(SD3->D3_ITEMSA)
						A330CtbRat(SD3->D3_NUMSA, SD3->D3_ITEMSA, SD3->D3_SEQCALC, "67A", lLct667669, a330ParamZX)
					EndIf

				EndIf
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Gera o lancamento no arquivo de prova                        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If SD3->D3_TM <= "500"
					A330DET(SD3->D3_SEQCALC,"679","MATA330","SD3",lLct667669,a330ParamZX)
				Else
					A330DET(SD3->D3_SEQCALC,"680","MATA330","SD3",lLct667669,a330ParamZX)
				EndIf
			EndIf

			dbSelectArea("SD3")
			If D3_TM <= "500"
				If cApropri == "2"
					For nX := 1 To nTamArrCus
						// Verifica se moeda devera ser considerada
						If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
							Loop
						EndIf
						aAprInd[nX] := aAprInd[nX] - aCusto[nX]
					Next nX
				ElseIf cApropri != "3"
					For nX := 1 To nTamArrCus
						// Verifica se moeda devera ser considerada
						If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
							Loop
						EndIf
						aAprDir[nX] := aAprDir[nX] - aCusto[nX]
					Next nX
				EndIf
			Else
				If cApropri == "2"
					For nX := 1 To nTamArrCus
						// Verifica se moeda devera ser considerada
						If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
							Loop
						EndIf
						aAprInd[nX] := aAprInd[nX] + aCusto[nX]
					Next nX
				ElseIf cApropri != "3"
					For nX := 1 To nTamArrCus
						// Verifica se moeda devera ser considerada
						If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
							Loop
						EndIf
						aAprDir[nX] := aAprDir[nX] + aCusto[nX]
					Next nX
				EndIf
			EndIf
		EndIf

	ElseIf lM330JCM3 .And. TRB->TRB_ORDEM == '300' .And. Empty(TRB->TRB_SEQPRO) .And. !Empty(TRB->TRB_NIVEL) .And. !Empty(TRB->TRB_NIVSD3) .And. !Empty(TRB->TRB_OP)

		If !lFirstSD3
			M330PrcLog("MENSAGEM",STR0243+cFilAnt,STR0243+cFilAnt,'6B') //"Analise de movimentos internos - "
			lFirstSD3 := .T.
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Processamento por Threads para a Ordenacao 300 com Ordem de Producao ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		A330JobCM('300',aFilsCalc,lExistProc,JsonObject():New(),Strzero(ThreadID(),15),oJobCMCall)

	ElseIf TRB->TRB_ALIAS == "SD2" .And. !(lM330JCM5 .And. TRB->TRB_ORDEM == '500')

		If !lFirstSD2 .and. TRB->TRB_ORDEM >= '500'
			M330PrcLog("MENSAGEM",STR0244+cFilAnt,STR0244+cFilAnt,'6C') //"Analise de saidas - "
			lFirstSD2 := .T.
		EndIf

		dbSelectArea("SD2")
		dbGoto(TRB->TRB_RECNO)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ LOCALIZACOES - Grava o custo de saida do remito que originou ³
		//³ a nota, cuando esta proviene de um remito, pois as Notas de  ³
		//³ credito pegam o custo de saida original do SD2 a nao do REM).³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cPaisLoc == "BRA" .Or. Empty(SD2->D2_REMITO) .Or. (SD2->D2_TPDCENV $ _RMCONS)
			GravaSeq("SD2")
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Posiciona no SB1 para formulas de lancamento contabil        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lLanctoOn
				dbSelectArea("SB1")
				MsSeek(xFilial("SB1")+SD2->D2_COD)
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Posiciona no SF4 - TES                                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SF4")
			MsSeek(xFilial("SF4")+SD2->D2_TES)
			dbSelectArea("SD2")

			If SF4->F4_PODER3 == "D"
				aRet       := A330PegaSB6("SD2",.F.,"330",lCstPart,nPartes,lCusRep)
				aCM        := aRet[1]
				aRetPartes := aRet[3]
				If lCusRep
					aCMRep     := aRet[4]
				EndIf
				If lM330CD2
					aBackCusto :=ACLONE(aCM)
					aCM:=ExecBlock("M330CD2",.F.,.F.,{aCM,.F.})
					If Valtype(aCM) != "A"
						aCM:=ACLONE(aBackCusto)
					EndIf
				EndIf
				aRet       := GravaCusD2(aCM,"N",NIL,"330",lCstPart,aRegraCP,ACLONE(aRetPartes),lIntCusTMS,,lCusRep,aCMRep)   // para forcar a gravacao
				aCusto     := aRet[1]
				aRetPartes := aRet[3]
				If lCusRep
					aCMRep := aRet[4]
				EndIf
				SD2->(MsUnlock())
				B2FimComD2(aCusto,NIL,NIL,lCstPart,aRetPartes,lCusRep,aCMRep)
				TTFimComD2(aCusto,ACLONE(aRetPartes))

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Analisa se o item da nota de saida ("SD2") possui amarracao com a |
				//| guia de despacho ("Remito") e entao atualiza a guia de despacho   |
				//| com o mesmo custo da nota original. (Localizacoes)		          |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !(SD2->D2_TPDCENV $ _RMCONS) .And. cPaisLoc <> "BRA"
					A330GrvRem(2)
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ A330CDEV - Ponto de Entrada utilizado para contabilizar os   |
				//| lancamentos de devolucao de compras LP 678                   |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lA330CDEV .And. SF4->F4_PODER3 <> "R" .And. ExecBlock("A330CDEV",.F.,.F.)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Gera o lancamento no arquivo de prova                        ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					A330DET(SD2->D2_SEQCALC,"678","MATA330","SD2",,a330ParamZX)
				EndIf

			Else

				// Posicionamento do SF2 para pegar a taxa e a moeda
				If cPaisLoc<>"BRA"
					DbselectArea("SF2")
					DbSetOrder(1)
					DbSeek(xFilial("SF2")+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA)
					Do While !Eof() .And. SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA ==	F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA
						If Alltrim(F2_ESPECIE) ==Alltrim(SD2->D2_ESPECIE) // Modificado por Bruno 15/10/99
							EXIT
						Else
							DbSkip()
							Loop
						EndIf
					EndDo
					Dbselectarea("SD2")
				EndIf

				If SD2->D2_TIPO != "D"
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Obter o array de Impostos para enviar para aCusto. S¢ paises  ³
					//³ do ConeSul. Allergan - 03/03/99 JLucas...                     ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If cPaisLoc # "BRA"
						nTaxa		:=	SF2->F2_TXMOEDA
						nMoedaNf	:=	SF2->F2_MOEDA
						nRatFrete:= xMoeda(SF2->F2_FRETE * (SD2->D2_TOTAL / SF2->F2_VALMERC),SF2->F2_MOEDA,1,SF2->F2_EMISSAO,,nTaxa)
						nRatDesp := XMoeda(SF2->F2_DESPESA * (SD2->D2_TOTAL / SF2->F2_VALMERC),SF2->F2_MOEDA,1,SF2->F2_EMISSAO,,nTaxa)
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Processa as vendas                                           ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aEnvCus := A330EnvCus( aImpCusto )

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Pega os custos medios finais                                 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lCusFil .Or. lCusEmp
						aRet  := A330TTFim(SD2->D2_COD,SD2->D2_LOCAL,SD2->D2_TIPO,aEnvCus,"SD2","330",NIL,NIL,lCstPart,nPartes,lCusEmp)
						aCMRep:= {0,0,0,0,0}
					Else
						If SD2->D2_TIPO == "I" .And. SF4->F4_QTDZERO == "1" .And. SD2->D2_QUANT == 0
							aRet  := PegaCMFim(SD2->D2_COD,SD2->D2_LOCAL,"D"         ,aEnvCus,"SD2","330",.F.,NIL,lCstPart,nPartes,aRegraCP,lCusRep)
						Else
							aRet  := PegaCMFim(SD2->D2_COD,SD2->D2_LOCAL,SD2->D2_TIPO,aEnvCus,"SD2","330",NIL,NIL,lCstPart,nPartes,aRegraCP,lCusRep)
						EndIf
						If lCusRep
							aCMRep := aRet[4]
						EndIf
					EndIf
					aCM        := aRet[1]
					aRetPartes := aRet[3]
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Grava o custo da nota fiscal de saida                        ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lM330CD2
						aBackCusto :=ACLONE(aCM)
						aCM:=ExecBlock("M330CD2",.F.,.F.,{aCM,.F.})
						If Valtype(aCM) != "A"
							aCM:=ACLONE(aBackCusto)
						EndIf
					EndIf
					If SD2->D2_TIPO == "I" .And. SF4->F4_QTDZERO == "1" .And. SD2->D2_QUANT == 0
						aRet       := GravaCusD2(aCM,"D"         ,NIL,"330",lCstPart,aRegraCP,ACLONE(aRetPartes),lIntCusTMS,,lCusRep,aCMRep)
					Else
						aRet       := GravaCusD2(aCM,SD2->D2_TIPO,NIL,"330",lCstPart,aRegraCP,ACLONE(aRetPartes),lIntCusTMS,,lCusRep,aCMRep)
					EndIf
					aCusto     := aRet[1]
					aRetPartes := aRet[3]
					If lCusRep
						aCMRep := aRet[4]
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o saldo final (VFIM) com os dados do SD2            ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					B2FimComD2(aCusto,NIL,NIL,lCstPart,aRetPartes,lCusRep,aCMRep)
					TTFimComD2(aCusto,ACLONE(aRetPartes))

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Analisa se o item da nota de saida ("SD2") possui amarracao com a |
					//| guia de despacho ("Remito") e entao atualiza a guia de despacho   |
					//| com o mesmo custo da nota original. (Localizacoes)		          |
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !(SD2->D2_TPDCENV $ _RMCONS) .And. cPaisLoc <> "BRA"
						A330GrvRem(2)
					EndIf

					If lMA330D2
						ExecBlock("MA330D2",.F.,.F.)
					EndIf

					If SF4->F4_PODER3 == "R"
						A330GravaSB6("SD2",aCusto,NIL,NIL,lCstPart,aRegraCP,aRetPartes,lCusRep,aCMRep)
					EndIf

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Gera o lancamento no arquivo de prova                        ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					A330DET(SD2->D2_SEQCALC,"678","MATA330","SD2",,a330ParamZX)
					SD2->(MsUnlock())
				Else
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Processa as devolucoes de compra                             ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aEnvCus := A330EnvCus()
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Pega os custos medios finais                                 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Na Funcao PegaCMFim() Esta Tratando CUSTO FIFO / LIFO        ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lCusFil .Or. lCusEmp
						aRet  := A330TTFim(SD2->D2_COD,SD2->D2_LOCAL,SD2->D2_TIPO,aEnvCus,"SD2","330",(!MaTesSel(SD2->D2_TES)).And.QtdComp(SD2->D2_QUANT)>QtdComp(0),NIL,lCstPart,nPartes,lCusEmp)
						aCMRep:= {0,0,0,0,0}
					Else
						lDvCom := !MaTesSel(SD2->D2_TES) .And. QtdComp(SD2->D2_QUANT)>QtdComp(0)
						aRet  := PegaCMFim(SD2->D2_COD,SD2->D2_LOCAL,SD2->D2_TIPO,aEnvCus,"SD2","330",(!MaTesSel(SD2->D2_TES)).And.QtdComp(SD2->D2_QUANT)>QtdComp(0),NIL,lCstPart,nPartes,aRegraCP,lCusRep,SD2->D2_QUANT == 0)
						If lCusRep
							aCMRep := aRet[4]
						EndIf
					EndIf
					aCM       := aRet[1]
					aRetPartes:= aRet[3]
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Grava o custo da nota fiscal de saida                        ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lM330CD2
						aBackCusto :=ACLONE(aCM)
						aCM:=ExecBlock("M330CD2",.F.,.F.,{aCM,.F.})
						If Valtype(aCM) != "A"
							aCM:=ACLONE(aBackCusto)
						EndIf
					EndIf
					aRet       := GravaCusD2(aCM,SD2->D2_TIPO,NIL,"330",lCstPart,aRegraCP,ACLONE(aRetPartes),lIntCusTMS,,lCusRep,aClone(aCMRep))
					aCusto     := aRet[1]
					aRetPartes := aRet[3]
					If lCusRep
						aCMRep := aRet[4]
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o saldo final (VFIM) com os dados do SD2            ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					B2FimComD2(aCusto,NIL,NIL,lCstPart,aRetPartes,lCusRep,aClone(aCMRep))
					TTFimComD2(aCusto,ACLONE(aRetPartes))

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Analisa se o item da nota de saida ("SD2") possui amarracao com a |
					//| guia de despacho ("Remito") e entao atualiza a guia de despacho   |
					//| com o mesmo custo da nota original. (Localizacoes)		          |
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !(SD2->D2_TPDCENV $ _RMCONS) .And. cPaisLoc <> "BRA"
						A330GrvRem(2)
					EndIf

					If lMA330D2
						ExecBlock("MA330D2",.F.,.F.)
					EndIf

					If SF4->F4_PODER3 == "R"
						A330GravaSB6("SD2",aCusto,NIL,NIL,lCstPart,aRegraCP,aRetPartes,lCusRep,aClone(aCMRep))
					EndIf

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ A330CDEV - Ponto de Entrada utilizado para contabilizar os   |
					//| lancamentos de devolucao de compras LP 678                   |
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lA330CDEV .And. SF4->F4_PODER3 <> "R" .And. ExecBlock("A330CDEV",.F.,.F.)
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Gera o lancamento no arquivo de prova                        ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						A330DET(SD2->D2_SEQCALC,"678","MATA330","SD2",,a330ParamZX)
					EndIf
					SD2->(MsUnlock())
				EndIf
			EndIf
			// Adiciona custos na lista de transferencia
			If !Empty(TRB->TRB_FILTRA)
				cKeyListaTRF := cFilAnt+TRB->TRB_FILTRA+SD2->D2_DOC+SD2->D2_SERIE +A330ConvIT(SD2->D2_ITEM,'SD1')
				oListaTRF[cKeyListaTRF] := {cFilAnt,TRB->TRB_FILTRA,SD2->D2_DOC,SD2->D2_SERIE,SD2->D2_COD,TRB->TRB_QUANT,aClone(aCM),aClone(aCusto),aClone(aRetPartes),aClone(aCMRep),A330ConvIT(SD2->D2_ITEM,'SD1')}
				//AADD(aListaTrf,{cFilAnt,TRB->TRB_FILTRA,SD2->D2_DOC,SD2->D2_SERIE,SD2->D2_COD,TRB->TRB_QUANT,aClone(aCM),aClone(aCusto),aClone(aRetPartes),aClone(aCMRep),SD2->D2_ITEM})
			EndIf
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava o custo de saida que foi calculado para o Remito       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			A330GrvRem()
		EndIf

	ElseIf lM330JCM5 .And. TRB->TRB_ORDEM=='500'

		If !lFirstSD2 .and. TRB->TRB_ORDEM >= '500'
			M330PrcLog("MENSAGEM",STR0244+cFilAnt,STR0244+cFilAnt,'6C') //"Analise de saidas - "
			lFirstSD2 := .T.
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Processamento por Threads para a Ordenacao 500   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		A330JobCM('500',aFilsCalc,lExistProc,oListaTrf,Strzero(ThreadID(),15),oJobCMCall)

	EndIf
	dbSelectArea("TRB")
	dbSetOrder(3)
	dbSkip()
	// Restaura filial original
	cFilAnt:=cFilBack
End
//- Força o Flush com a tabela e destroi o objeto
If !oBulk == nil
	oBulk:Close()
	oBulk:Destroy()
	FreeObj(oBulk)
	oBulk := nil
EndIf
lFirstSD1 := .F.
lFirstSD2 := .F.
lFirstSD3 := .F.

Set(3,nDec)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Limpa a variavel de controle de numeracao   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ClearGlbValue(cSeqEmp)
//limpa a variavel de sequencialização
ClearGlbValue(cKeyRegCT)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza o log de processamento			    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
M330PrcLog("MENSAGEM",OemToAnsi(I18N(STR0100,{Alltrim(cMoeda330C)})),OemToAnsi(I18N(STR0100,{Alltrim(cMoeda330C)})),'7') //"Recalculo do Custo Medio na(s) moeda(s) 1#1[2345]# - (1) Termino "

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Integracao com o PCO processo 314    	    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PcoFinLan("000314")

Return NIL

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A330ProcRE7³ Autor ³ Marcos Bregantim     ³ Data ³ 17/10/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Processa RE7 (Desmontagem)                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpL1 = Variavel utilizada para verificar se utiliza FIFO  ³±±
±±³          ³ ExpL2 = Variavel utilizada para verificar se utiliza custo ³±±
±±³          ³         em partes                                          ³±±
±±³          ³ ExpA3 = Array contendo as regras do custo em partes        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static __nTamDec := Nil
Function A330ProcRE7(lProcFifo,lCstPart,aRegraCP,lCusRep)
Local aCM        := {0,0,0,0,0}
Local aCmFF      := {0,0,0,0,0}
Local aCustoRep  := {0,0,0,0,0}
Local aCMRep     := {0,0,0,0,0}
Local aTotsRep   := {0,0,0,0,0}
Local aCustoFF   :=	{0,0,0,0,0}
Local aRetPartes := {}
Local aEnvio     := {}
Local nOrdemSD3  := SD3->(IndexOrd())
Local cSeekSD3   := ''
Local aCusto, aTots, cNumSeq,nReg,lLast,nI,aCustoPart
Local aTotsFF,aTotsPart
Local lRunFIFO   := (lCusFifo .Or. lCusLifo) .And. lProcFifo
Local lMA330PDE7   := ExistBlock("MA330PDE7")

DEFAULT lCstPart:=.F.
DEFAULT lCusRep :=.F.
DEFAULT aRegracp:={}

If __nTamDec == Nil
	__nTamDec := TamSx3("D3_CUSTO1")[2]
EndIf

if cMoeda330C == NIL
	cMoeda330C := SuperGetMv('MV_MOEDACM',.F.,"2345")
EndIf

If D3_ESTORNO != "S"
	If lCusFil .Or. lCusEmp
		aRet  := A330TTFim(D3_COD,D3_LOCAL, , , ,"330",NIL,lRunFIFO,lCstPart,Len(aRegraCP)+1,lCusEmp)
		aCMRep:= {0,0,0,0,0}
	Else
		aRet  := PegaCMFim(D3_COD,D3_LOCAL, , , ,"330",NIL,lRunFIFO,lCstPart,Len(aRegraCP)+1,aRegraCP,lCusRep)
		If lCusRep
			aCMRep := aRet[4]
		EndIf
	EndIf
	aCM        := aRet[1]
	aCMFF      := aRet[2]
	aRetPartes := aRet[3]
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se deve re-gravar os custos                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If a330ParamZX[04] == 1
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava o custo da movimentacao                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aRet      := GravaCusD3(IF(lRunFIFO,NIL,aCM),,IF(lRunFIFO,aCMFF,NIL),"330",NIL,lCstPart,aRegraCP,ACLONE(aRetPartes),lIntCusTMS,,lCusRep,ACLONE(aCMRep))
	aCusto    := aRet[1]
	aCustoFF  := aRet[2]
	aCustoPart:= aRet[3]
	If lCusRep
		aCustoRep := aRet[4]
	EndIf
	SD3->(MsUnlock())
Else
	aCusto := {SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5}
EndIf

dbSelectArea("SB2")
dbSetOrder(1)
MsSeek(xFilial("SB2")+SD3->D3_COD+SD3->D3_LOCAL)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Nao calcula produtos "MAO DE OBRA"                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !A330ISMOD(SD3->D3_COD,.T.)
	B2FimComD3(aCusto,NIL,aCustoFF,lRunFIFO,lCusFil .Or. lCusEmp,lCstPart,aCustoPart,lCusRep,ACLONE(aCustoRep))
	If !lRunFIFO
		TTFimComD3(aCusto,ACLONE(aCustoPart),,,lCstPart)
	EndIf
	If lMA330D3
		ExecBlock("MA330D3",.F.,.F.)
	EndIf
EndIf

dbSelectArea("SD3")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Posiciona no SB1 para formulas de lancamento contabil        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lLanctoOn
	dbSelectArea("SB1")
	MsSeek(xFilial("SB1")+SD3->D3_COD)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Gera o lancamento no arquivo de prova                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
A330DET(SD3->D3_SEQCALC,"670","MATA330","SD3",,a330ParamZX)

dbSelectArea("SD3")
dbSetOrder(4)

aTots    := aClone(aCusto)
If lCusRep
	aTotsRep := aClone(aCustoRep)
EndIf
If lRunFIFO
	aTotsFF:=AClone(aCustoFF)
EndIf
If lCstPart
	aTotsPart:=AClone(aCustoPart)
EndIf
cNumSeq := SD3->D3_NUMSEQ

dbSelectArea('SD3')
dbSetOrder(4) //-- D3_FILIAL+D3_NUMSEQ+D3_CHAVE+D3_COD
If MsSeek(cSeekSD3:=xFilial('SD3')+cNumSeq, .F.) .And. Alltrim(SD3->D3_CF)=='RE7' //-- Garante que esta posicionado no 1o RE7
	dbSkip() //-- Posiciona no DE7 subsequente
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Movimentacao do Cursor                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lBat .And. !IsBlind()
		IncProc(OemToAnsi(STR0085)) //"Acertando Transferencias Multiplas"
	EndIf
	While !SD3->(Eof()) .And. cSeekSD3 == SD3->D3_FILIAL+SD3->D3_NUMSEQ .And. Alltrim(SD3->D3_CF)=='DE7' //-- Processa todas as DE7s
		nReg := SD3->(Recno())
		SD3->(dbSkip())
		If !SD3->(Eof()) .And. cSeekSD3 == SD3->D3_FILIAL+SD3->D3_NUMSEQ .And. Alltrim(SD3->D3_CF)=='DE7'
			lLast := .F.
		Else
			lLast := .T.
		EndIf
		SD3->(dbGoto(nReg))
		If lLast
			aCm := aClone(aTots)
			If lCusRep
				aCmRep := aClone(aTotsRep)
			EndIf
			If lRunFIFO
				aCmFF := aClone(aTotsFF)
			EndIf
			If lCstPart
				aRetPartes:=AClone(aTotsPart)
				aEnvio    :=ACLONE(aRetPartes)
				If !(ValType(aEnvio)=="A")
					aEnvio := {}
				EndIf
				For nI:=1 to Len(aEnvio)
					aEnvio[nI] := aEnvio[nI] /SD3->D3_QUANT
				Next nI
			EndIf
		ElseIf a330ParamZX[04]==1
			For nI := 1 to 5
				// Verifica se moeda devera ser considerada
				If nI # 1 .And. !(Str(nI,1,0) $ cMoeda330C)
					Loop
				EndIf
				If lRunFIFO
					aCmFF[nI]   := Round(aCustoFF[nI] * (SD3->D3_RATEIO / 100 ),__nTamDec)
					aTotsFF[nI] -= aCmFF[nI]
					If aTotsFF[nI] < 0  // para nao deixar custo negativo da transacao
						aCmFF[nI]   += aTotsFF[nI]
						aTotsFF[nI] := 0
					EndIf
				Else
					aCm[nI]   := Round(aCusto[nI] * (SD3->D3_RATEIO / 100),__nTamDec)
					aTots[nI] -= aCm[nI]
					If aTots[nI] < 0  // para nao deixar custo negativo da transacao
						aCm[nI]   += aTots[nI]
						aTots[nI] := 0
					EndIf
					If lCusRep
						aCmRep[nI]   := Round(aCustoRep[nI] * (SD3->D3_RATEIO / 100 ),__nTamDec)
						aTotsRep[nI] -= aCmRep[nI]
						If aTotsRep[nI] < 0  // para nao deixar custo negativo da transacao
							aCmRep[nI]   += aTotsRep[nI]
							aTotsRep[nI] := 0
						EndIf
					EndIf
				EndIf
			Next
			If lCstPart
				For nI:=1 to Len(aTotsPart)
					aRetPartes[nI] := Round(aCustoPart[nI] * (SD3->D3_RATEIO / 100 ),__nTamDec)
					aTotsPart[nI] -= aRetPartes[nI]
					If aTotsPart[nI] < 0  // para nao deixar custo negativo da transacao
						aRetPartes[nI] += aTotsPart[nI]
						aTotsPart[nI] := 0
					EndIf
				Next nI
				aEnvio:=ACLONE(aRetPartes)
				For nI:=1 to Len(aEnvio)
					aEnvio[nI] := aEnvio[nI] /SD3->D3_QUANT
				Next nI
			EndIf
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se deve re-gravar os custos                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If a330ParamZX[04] == 1
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava o custo da movimentacao                                ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lMA330PDE7
				aEnvio := ExecBlock("MA330PDE7",.F.,.F.,{lCstPart,aRegraCP,aEnvio,aCusto})
			EndIf
			aRet      :=GravaCusD3(IF(lRunFIFO,NIL,aCM),.T.,IF(lRunFIFO,aCMFF,NIL),"330",NIL,lCstPart,aRegraCP,aEnvio,lIntCusTMS,,lCusRep,ACLONE(aCustoRep))
			aCM       :=aRet[1]
			aCMFF     :=aRet[2]
			aRetPartes:=aRet[3]
			If lCusRep
				aCMRep := aRet[4]
			EndIf
			SD3->(MsUnlock())
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o SBD FIFO/LIFO com os dados do SD3                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lRunFIFO
				GravaSBD("SD3",aCMFF)
			EndIf
		Else
			aCM := {SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5}
		EndIf
		dbSelectArea("SB2")
		dbSetOrder(1)
		MsSeek(xFilial("SB2")+SD3->D3_COD+SD3->D3_LOCAL)
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o saldo final (VFIM) com os dados do SD3            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Nao calcula produtos "MAO DE OBRA"                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !A330ISMOD(SD3->D3_COD,.T.)
			B2FimComD3(aCM,NIL,aCMFF,lRunFIFO,lCusFil .Or. lCusEmp,lCstPart,aRetPartes,lCusRep,aCMRep)
			TTFimComD3(aCM,ACLONE(aRetPartes),,,lCstPart)
			If lMA330D3
				ExecBlock("MA330D3",.F.,.F.)
			EndIf
		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Movimentacao do Cursor                                       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lBat .And. !IsBlind()
			IncProc(OemToAnsi(STR0085)) //"Acertando Transferencias Multiplas"
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posiciona no SB1 para formulas de lancamento contabil        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lLanctoOn
			dbSelectArea("SB1")
			MsSeek(xFilial("SB1")+SD3->D3_COD)
		EndIf

		dbSelectArea("SD3")
		If a330ParamZX[04] == 1
			GravaSeq("SD3")
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Gera o lancamento no arquivo de prova                        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		A330DET(SD3->D3_SEQCALC,"672","MATA330","SD3",,a330ParamZX)
		SD3->(dbSkip())
	EndDo

EndIf
SD3->(dbSetOrder(nOrdemSD3))
Return NIL

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³A330Inicia³ Autor ³ Eveli Morasco         ³ Data ³ 05/01/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Pega valores do inicio do periodo para serem reprocessados ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A330Inicia(ExpC1,ExpC2)                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Variavel com nome do arquivo de trabalho p/ custo  ³±±
±±³          ³ unificado                                                  ³±±
±±³          ³ ExpC2 = Variavel com nome do indice  de trabalho p/ custo  ³±±
±±³          ³ unificado                                                  ³±±
±±³          ³ ExpL3 = Variavel que verifica a utilizacao de procedures   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function A330Inicia(lExistProc)

LOCAL aSaldoIni   := {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
LOCAL aSaldoFF[05]
LOCAL nV,nX

LOCAL bBloco      :={ |nV,nX| Trim(nV)+STR(nX,1) }
LOCAL aCmAlter    :={}

LOCAL lConsAlmox  :=.T.
LOCAL lPontoOk    :=.F.
LOCAL lProdMod    :=.F.

LOCAL nRecOrig    :=0
LOCAL nRecOrigB2  :=0
LOCAL nRetQuery as numeric

LOCAL cCodOriMOD  :=''
LOCAL cSeek       :=''

LOCAL lFiltraAlmox:=ExistBlock("MA330AL")
LOCAL lGravaCM    :=ExistBlock("M330CMU")

LOCAL cProdMNT    := SuperGetMv("MV_PRODMNT",.F.,"MANUTENCAO")
LOCAL lIntMNT     := MTA330IsMNT()
LOCAL nMed

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica a existencia dos novos campos Custo Unitario ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (lCusEmp .Or. lCusFil) .And. (	TRT->(FieldPos("TRB_QTDMOD")) <= 0 .Or. ;
									TRT->(FieldPos("TRB_TOTCM1")) <= 0 .Or. ;
									TRT->(FieldPos("TRB_TOTCM2")) <= 0 .Or. ;
									TRT->(FieldPos("TRB_TOTCM3")) <= 0 .Or. ;
									TRT->(FieldPos("TRB_TOTCM4")) <= 0 .Or. ;
									TRT->(FieldPos("TRB_TOTCM5")) <= 0 )
	Final(OemToAnsi(STR0078)) //"Atualizar MATXFUNA.PRX!!!"
EndIf

if cMoeda330C == NIL
	cMoeda330C := SuperGetMv('MV_MOEDACM',.F.,"2345")
EndIf

Afill(aSaldoIni,0.00)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza o log de processamento			    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
M330PrcLog("MENSAGEM",OemToAnsi(STR0103) +STR0067+cFilAnt,OemToAnsi(STR0103)) //"Iniciando Recuperacao de Saldos do Inicio do Periodo"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Volta os saldos iniciais do arquivo de saldos SB2            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SB2")   // saldos em estoque
dbSetOrder(1)
dbSeek(xFilial("SB2"))
While !Eof() .And. B2_FILIAL == xFilial("SB2")

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Tratamento de integracao com o SIGAMNT                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lIntMNT .And. AllTrim(cProdMNT) == AllTrim(SB2->B2_COD)
		dbSkip()
		Loop
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se filtra armazem de acordo com P.E.                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lFiltraAlmox
		lConsAlmox:=ExecBlock("MA330AL",.F.,.F.)
		If ValType(lConsAlmox) # "L"
			lConsAlmox:=.T.
		ElseIf !lConsAlmox
			dbSelectArea("SB2")
			dbSkip()
			Loop
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o produto e mao-de-obra                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	lProdMod := A330ISMOD(SB2->B2_COD,.T.)

	If !lProdMod
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posicionar e Buscar os Saldos Iniciais SB9, SD1 ,SD2 e SD3.  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aSaldoIni := CalcEst(SB2->B2_COD,SB2->B2_LOCAL,dInicio,,,lCusRep)
		cCodOriMOD := SB2->B2_COD
	Else
		If Subs(cOpcoes,1,1) == "1"
			aSaldoIni := {SB2->B2_QFIM,SB2->B2_VFIM1,SB2->B2_VFIM2,SB2->B2_VFIM3,SB2->B2_VFIM4,SB2->B2_VFIM5,SB2->B2_QFIM2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
		Else
			aSaldoIni :={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
		EndIf
		cCodOriMOD := SB2->B2_COD
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gravar os Valores finais no SB2 com os valores iniciais SB9. ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB2")
	RecLock("SB2",.F.)
	Replace B2_QFIM  With aSaldoIni[1]
	Replace B2_QFIM2 With aSaldoIni[7]
	For nX := 1 To nTamArrCus
		// Verifica se moeda devera ser considerada
		If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
			Loop
		EndIf
		Replace &(Eval(bBloco,"B2_VFIM",nX)) WITH aSaldoIni[nX+1]
		If B2_QFIM > 0
			If &(Eval(bBloco,"B2_VFIM",nX)) > 0
				Replace &(Eval(bBloco,"B2_CMFIM",nX)) WITH CusRound(&(Eval(bBloco,"B2_VFIM",nX)) / B2_QFIM,nX)
			Else
				If !lProdMod
					Replace &(Eval(bBloco,"B2_CMFIM",nX)) WITH aSaldoIni[nX+7]
				EndIf
			EndIf
 		Else
			If !lProdMod
				Replace &(Eval(bBloco,"B2_CMFIM",nX)) WITH aSaldoIni[nX+7]
			EndIf
		EndIf
		If lCusRep .And. !lProdMod
			Replace &(Eval(bBloco,"B2_CMRP",nX)) WITH aSaldoIni[nX+12]
			Replace &(Eval(bBloco,"B2_VFRP",nX)) WITH aSaldoIni[nX+17]
		EndIf
	Next nX
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza arquivo de trabalho p/ processar custo por Filial   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lCusFil .Or. lCusEmp
		dbSelectArea("TRT")
		If !dbSeek(If(lCusEmp,Space(Len(cFilAnt)),cFilAnt)+SB2->B2_COD)
			CriaTRT(If(lCusEmp,Space(Len(cFilAnt)),cFilAnt),SB2->B2_COD)
		EndIf
		RecLock("TRT",.F.)
		If !lProdMod
			If SB2->B2_QATU==0 .and. SB2->B2_CMFIM1==0
				nMed:= TRT->TRB_TOTCM1 / TRT->TRB_QTDMOD
			Else
				nMed:= SB2->B2_CMFIM1
			EndIf
			TRT->TRB_QTDMOD:= TRT->TRB_QTDMOD + 1
			TRT->TRB_TOTCM1:= TRT->TRB_TOTCM1 + nMed
			TRT->TRB_QFIM  := TRT->TRB_QFIM   + SB2->B2_QFIM
			TRT->TRB_QFIM2 := TRT->TRB_QFIM2  + SB2->B2_QFIM2
			TRT->TRB_VFIM1 := TRT->TRB_VFIM1  + SB2->B2_VFIM1
			If "2" $ cMoeda330C
				TRT->TRB_VFIM2 := TRT->TRB_VFIM2  + SB2->B2_VFIM2
				TRT->TRB_TOTCM2:= TRT->TRB_TOTCM2 + SB2->B2_CMFIM2
			EndIf
			If "3" $ cMoeda330C
				TRT->TRB_VFIM3 := TRT->TRB_VFIM3  + SB2->B2_VFIM3
				TRT->TRB_TOTCM3:= TRT->TRB_TOTCM3 + SB2->B2_CMFIM3
			EndIf
			If "4" $ cMoeda330C
				TRT->TRB_VFIM4 := TRT->TRB_VFIM4  + SB2->B2_VFIM4
				TRT->TRB_TOTCM4:= TRT->TRB_TOTCM4 + SB2->B2_CMFIM4
			EndIf
			If "5" $ cMoeda330C
				TRT->TRB_VFIM5 := TRT->TRB_VFIM5  + SB2->B2_VFIM5
				TRT->TRB_TOTCM5:= TRT->TRB_TOTCM5 + SB2->B2_CMFIM5
			EndIf
		EndIf

		If !lProdMod
			If TRT->TRB_VFIM1 > 0 .And. TRT->TRB_QFIM > 0
				TRT->TRB_CM1 := ( TRT->TRB_VFIM1 / TRT->TRB_QFIM )
			Else
				TRT->TRB_CM1 := ( TRT->TRB_TOTCM1 / TRT->TRB_QTDMOD )
			EndIf
			If "2" $ cMoeda330C
				If TRT->TRB_VFIM2 > 0 .And. TRT->TRB_QFIM > 0
					TRT->TRB_CM2 := ( TRT->TRB_VFIM2 / TRT->TRB_QFIM )
				Else
					TRT->TRB_CM2 := ( TRT->TRB_TOTCM2 / TRT->TRB_QTDMOD )
				EndIf
			EndIf
			If "3" $ cMoeda330C
				If TRT->TRB_VFIM3 > 0 .And. TRT->TRB_QFIM > 0
					TRT->TRB_CM3 := ( TRT->TRB_VFIM3 / TRT->TRB_QFIM )
				Else
					TRT->TRB_CM3 := ( TRT->TRB_TOTCM3 / TRT->TRB_QTDMOD )
				EndIf
			EndIf
			If "4" $ cMoeda330C
				If TRT->TRB_VFIM4 > 0 .And. TRT->TRB_QFIM > 0
					TRT->TRB_CM4 := ( TRT->TRB_VFIM4 / TRT->TRB_QFIM )
				Else
					TRT->TRB_CM4 := ( TRT->TRB_TOTCM4 / TRT->TRB_QTDMOD )
				EndIf
			EndIf
			If "5" $ cMoeda330C
				If TRT->TRB_VFIM5 > 0 .And. TRT->TRB_QFIM > 0
					TRT->TRB_CM5 := ( TRT->TRB_VFIM5 / TRT->TRB_QFIM )
				Else
					TRT->TRB_CM5 := ( TRT->TRB_TOTCM5 / TRT->TRB_QTDMOD )
				EndIf
			EndIf
		Else
			If Subs(cOpcoes,1,1) # "1"
				TRT->TRB_QTDMOD := TRT->TRB_QTDMOD + 1
				TRT->TRB_TOTCM1 := TRT->TRB_TOTCM1 + SB2->B2_CMFIM1
				TRT->TRB_CM1    := ( TRT->TRB_TOTCM1 / TRT->TRB_QTDMOD )
				If "2" $ cMoeda330C
					TRT->TRB_TOTCM2 := TRT->TRB_TOTCM2 + SB2->B2_CMFIM2
					TRT->TRB_CM2    := ( TRT->TRB_TOTCM2 / TRT->TRB_QTDMOD )
				EndIf
				If "3" $ cMoeda330C
					TRT->TRB_TOTCM3 := TRT->TRB_TOTCM3 + SB2->B2_CMFIM3
					TRT->TRB_CM3    := ( TRT->TRB_TOTCM3 / TRT->TRB_QTDMOD )
				EndIf
				If "4" $ cMoeda330C
					TRT->TRB_TOTCM4 := TRT->TRB_TOTCM4 + SB2->B2_CMFIM4
					TRT->TRB_CM4    := ( TRT->TRB_TOTCM4 / TRT->TRB_QTDMOD )
				EndIf
				If "5" $ cMoeda330C
					TRT->TRB_TOTCM5 := TRT->TRB_TOTCM5 + SB2->B2_CMFIM5
					TRT->TRB_CM5    := ( TRT->TRB_TOTCM5 / TRT->TRB_QTDMOD )
				EndIf
			EndIf
		EndIf
		TRT->(MsUnlock())
		dbSelectArea("SB2")
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calculo do saldo inicial do custo FIFO/LIFO                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lCusFIFO .Or. lCusLIFO
		If !lProdMod
			aSaldoFF := CalcEstFF(SB2->B2_COD,SB2->B2_LOCAL,dInicio)
		Else
			aSaldoFF := {0,0,0,0,0,0,0}
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se Saldos Negativos ou CM Negativo Inicializar com Zeros CM. ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SB2->B2_QFIMFF:= aSaldoFF[1]
		SB2->B2_CMFF1 := 0
		If "2" $ cMoeda330C
			SB2->B2_CMFF2 := 0
		EndIf
		If "3" $ cMoeda330C
			SB2->B2_CMFF3 := 0
		EndIf
		If "4" $ cMoeda330C
			SB2->B2_CMFF4 := 0
		EndIf
		If "5" $ cMoeda330C
			SB2->B2_CMFF5 := 0
		EndIf
		For nX := 1 To nTamArrCus
			// Verifica se moeda devera ser considerada
			If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
				Loop
			EndIf
			Replace &(Eval(bBloco,"B2_VFIMFF",(nX))) WITH aSaldoFF[nX+1]
			If SB2->B2_QFIMFF > 0
				If &(Eval(bBloco,"B2_VFIMFF",(nX))) > 0
					Replace &(Eval(bBloco,"B2_CMFF",(nX))) WITH &(Eval(bBloco,"B2_VFIMFF",(nX))) / SB2->B2_QFIMFF
				EndIf
			EndIf
		Next nX
	EndIf
	SB2->(MsUnlock())

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gravar os Valores finais no SB2 com o CUSTO EM PARTES.       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lCstPart
		M330InB2CP(dInicio)
	EndIf

	dbSelectArea("SB2")
	dbSkip()

	// Grava custo medio unificado para o produto
	If lGravaCM .And. (lCusFil .Or. lCusEmp)
		nRecOrigB2:=SB2->(Recno())
		nRecOrig:=TRT->(Recno())
		aCmAlter:=ExecBlock("M330CMU",.F.,.F.,{cCodOriMOD,TRT->TRB_CM1,TRT->TRB_CM2,TRT->TRB_CM3,TRT->TRB_CM4,TRT->TRB_CM5})
		If ValType(aCmAlter) == "A"
			For nX := 1 To nTamArrCus
				// Verifica se moeda devera ser considerada
				If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
					Loop
				EndIf
				If ValType(aCmAlter[nx]) == "N"
					lPontoOk:=.T.
				Else
					lPontoOk:=.F.
					Exit
				EndIf
			Next nX
			If lPontoOk
				dbSelectArea("TRT")
				dbGoto(nRecOrig)
				Reclock("TRT",.F.)
				For nX := 1 To nTamArrCus
					// Verifica se moeda devera ser considerada
					If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
						Loop
					EndIf
					FieldPut(FieldPos("TRB_CM"+Str(nx,1,0)),aCmAlter[nx])
				Next nX
				TRT->(MsUnlock())
			EndIf
		EndIf
		dbSelectArea("SB2")
		MSGoto(nRecOrigB2)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Movimentacao do Cursor                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lBat .And. !IsBlind()
			IncProc(OemToAnsi(STR0086)) //"Recuperando Saldo do Inicio do Periodo"
	EndIf
EndDo

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Volta os saldos iniciais das Ordens de Producao SC2          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SC2")
cQuery := "UPDATE "
cQuery += RetSqlName("SC2")+" "
cQuery += "SET C2_VFIM1 = C2_VINI1"
If lCusRep
	cQuery += ", C2_VFIMRP1 = C2_VINIRP1"
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inclui no UPDATE todos os campos envolvidos em todas moedas  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nX := 2 To nTamArrCus
	// Verifica se moeda devera ser considerada
	If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
		Loop
	EndIf
	cQuery += ", C2_VFIM"+Alltrim(Str(nx))+" = C2_VINI"+Alltrim(Str(nx))
	If lCusRep
		cQuery += ", C2_VFIMRP"+Alltrim(Str(nx))+" = C2_VINIRP"+Alltrim(Str(nx))
	EndIf
Next nx
For nX := 1 To nTamArrCus
	// Verifica se moeda devera ser considerada
	If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
		Loop
	EndIf
	cQuery += ", C2_APRFIM"+Alltrim(Str(nx))+" = C2_APRINI"+Alltrim(Str(nx))
	If lCusRep
		cQuery += ", C2_APRFRP"+Alltrim(Str(nx))+" = C2_APRIRP"+Alltrim(Str(nx))
	EndIf
Next nx
If lCusFIFO .Or. lCusLIFO
	For nX := 1 To nTamArrCus
		// Verifica se moeda devera ser considerada
		If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
			Loop
		EndIf
		cQuery += ", C2_VFIMFF"+Alltrim(Str(nx))+" = C2_VINIFF"+Alltrim(Str(nx))
	Next nx
	For nX := 1 To nTamArrCus
		// Verifica se moeda devera ser considerada
		If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
			Loop
		EndIf
		cQuery += ", C2_APFIFF"+Alltrim(Str(nx))+" = C2_APINFF"+Alltrim(Str(nx))
	Next nx
EndIf
If lCstPart
	cQuery += M330InC2CP()
EndIf
cQuery += " WHERE C2_FILIAL = '" +xFilial("SC2") +"' AND D_E_L_E_T_ = ' ' AND "
cQuery += " (C2_DATRF = ' ' OR C2_DATRF >= '" +DToS(dInicio) +"')"
nRetQuery := TcSqlExec(cQuery)
IIf(nRetQuery <> 0, UserException(TCSQLError()), )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³A tabela eh fechada para restaurar o buffer da aplicacao³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SC2")
dbGoto(Recno()) //-- Reposiciona na tabela/registro atual somente para atualizar gravacoes pendentes

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Processa Saldo Inicial para Lotes do custo FIFO/LIFO         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lCusFIFO .Or. lCusLIFO

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Apaga os lotes do ultimo calculo                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	BeginSQL Alias "TMPSBD"
		SELECT R_E_C_N_O_ RECSBD
		FROM %Table:SBD%
		WHERE %NotDel% AND
			BD_FILIAL = %xFilial:SBD% AND
			BD_DTPROC >= %Exp:DToS(dInicio)%
	EndSQL
	While !TMPSBD->(EOF())
		SBD->(dbGoTo(TMPSBD->RECSBD))
		RecLock("SBD",.F.)
		SBD->(dbDelete())
		SBD->(MsUnLock())

		TMPSBD->(dbSkip())
	End
	TMPSBD->(dbCloseArea())

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Caso os arquivos estejam em MODO EXCLUSIVO efetua PACK no SBD  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If l330ArqExcl
		dbSelectArea("SBD")
		PACK
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Estorna quantidades lancandas no ultimo recalculo e acerta os |
	//| campos D8_SD1DEV e D8_QFIMDEV.                                |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	BeginSQL Alias "TMPSD8"
		SELECT R_E_C_N_O_ RECSD8
		FROM %Table:SD8%
		WHERE %NotDel% AND
			D8_FILIAL = %xFilial:SD8% AND
			D8_SD1DEV > 0 AND
			D8_QFIMDEV > 0 AND
			D8_TM > '500' AND
			D8_ITEM <> ' '
	EndSQL

	While !TMPSD8->(Eof())
		SD8->(dbGoTo(TMPSD8->RECSD8))

		RecLock("SD8",.F.)
		Replace SD8->D8_SD1DEV  With SD8->(D8_SD1DEV - D8_QFIMDEV)
		Replace SD8->D8_QFIMDEV With 0
		SD8->(MsUnLock())

		TMPSD8->(dbSkip())
	EndDo
	TMPSD8->(dbCloseArea())

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Apaga os movimento de lotes SD8 referentes ao ultimo calculo ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	BeginSQL Alias "TMPSD8"
		SELECT R_E_C_N_O_ RECSD8
		FROM %Table:SD8%
		WHERE %NotDel% AND
			D8_FILIAL = %xFilial:SD8% AND
			D8_DTPROC >= %Exp:DToS(dInicio)%
	EndSQL

	While !TMPSD8->(Eof())
		SD8->(dbGoTo(TMPSD8->RECSD8))

		RecLock("SD8",.F.)
		SD8->(dbDelete())
		SD8->(MsUnlock())

		TMPSD8->(dbSkip())
	EndDo
	TMPSD8->(dbCloseArea())

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Caso os arquivos estejam em MODO EXCLUSIVO efetua PACK no SD8 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If l330ArqExcl
		dbSelectArea("SD8")
		PACK
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Inicializa os Saldos Iniciais Fifo baseado na tabela SCC     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SCC")
	dbSetOrder(3) //-- CC_FILIAL+CC_STATUS
	dbSeek(cSeek := xFilial("SCC")+"A")
	While SCC->(!Eof()) .And. cSeek == SCC->(CC_FILIAL+CC_STATUS)
		//-- Recria Resumo do Lote
		dbSelectArea("SBD")
		dbSetOrder(2) //BD_FILIAL+BD_SEQ
		If dbSeek(xFilial("SBD")+SCC->CC_SEQ)
			RecLock("SBD",.F.)
		Else
			RecLock("SBD",.T.)
			Replace BD_FILIAL  With xFilial("SBD")
			Replace BD_PRODUTO With SCC->CC_PRODUTO
			Replace BD_LOCAL   With SCC->CC_LOCAL
			Replace BD_DATA    With SCC->CC_DTORIG
			Replace BD_SEQ     With SCC->CC_SEQ
			Replace BD_DTCALC  With a330ParamZX[01]
		EndIf
		Replace BD_STATUS  With " "
		Replace BD_QINI    With SCC->CC_QINI
		Replace BD_QINI2UM With SCC->CC_QINI2UM
		Replace BD_CUSINI1 With SCC->CC_VINIFF1
		Replace BD_CUSINI2 With If("2" $ cMoeda330C,SCC->CC_VINIFF2,0)
		Replace BD_CUSINI3 With If("3" $ cMoeda330C,SCC->CC_VINIFF3,0)
		Replace BD_CUSINI4 With If("4" $ cMoeda330C,SCC->CC_VINIFF4,0)
		Replace BD_CUSINI5 With If("5" $ cMoeda330C,SCC->CC_VINIFF5,0)
		Replace BD_QFIM    With SCC->CC_QFIM
		Replace BD_QFIM2UM With SCC->CC_QFIM2UM
		Replace BD_CUSFIM1 With SCC->CC_VFIMFF1
		Replace BD_CUSFIM2 With If("2" $ cMoeda330C,SCC->CC_VFIMFF2,0)
		Replace BD_CUSFIM3 With If("3" $ cMoeda330C,SCC->CC_VFIMFF3,0)
		Replace BD_CUSFIM4 With If("4" $ cMoeda330C,SCC->CC_VFIMFF4,0)
		Replace BD_CUSFIM5 With If("5" $ cMoeda330C,SCC->CC_VFIMFF5,0)
		Replace BD_DTPROC  With a330ParamZX[01]
		SBD->(MsUnlock())

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se o saldo inicial foi gerado manualmente, caso   ³
		//| seja sera gerado registro de movimento inicial.            |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Empty(SCC->CC_DATA)
			RecLock("SD8",.T.)
			Replace D8_FILIAL  With xFilial("SD8")
			Replace D8_PRODUTO With SCC->CC_PRODUTO
			Replace D8_LOCAL   With SCC->CC_LOCAL
			Replace D8_DATA    With SCC->CC_DATA
			Replace D8_QUANT   With SCC->CC_QINI
			Replace D8_QT2UM   With SCC->CC_QINI2UM
			Replace D8_CUSTO1  With SCC->CC_VINIFF1
			Replace D8_CUSTO2  With If("2" $ cMoeda330C,SCC->CC_VINIFF2,0)
			Replace D8_CUSTO3  With If("2" $ cMoeda330C,SCC->CC_VINIFF3,0)
			Replace D8_CUSTO4  With If("2" $ cMoeda330C,SCC->CC_VINIFF4,0)
			Replace D8_CUSTO5  With If("2" $ cMoeda330C,SCC->CC_VINIFF5,0)
			Replace D8_TIPONF  With "E"
			Replace D8_SEQ     With SCC->CC_SEQ
			Replace D8_DTCALC  With a330ParamZX[01]
			Replace D8_DTPROC  With a330ParamZX[01]
			SD8->(MsUnLock())
		EndIf

		dbSelectArea("SCC")
		dbSkip()
	EndDo
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza o log de processamento			    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
M330PrcLog("MENSAGEM",OemToAnsi(STR0104) +STR0067+cFilAnt,OemToAnsi(STR0104)) //"Termino da Recuperacao dos Saldos do Inicio do Periodo"

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MA330NivCD³ Autor ³ Bregantim / Stiefano  ³ Data ³ 01/10/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Cria estrutura pela movimentação, recalcula niveis de      ³±±
±±³			 ³ estrutura e atualiza niveis no SC2  						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MA330NivCD()                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ 															  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function MA330NivCD(dInicio,dFim,lSoNiv,cNivFil)
LOCAL lEstruMov  := a330ParamZX[11] == 1
LOCAL lRet       := .T.
LOCAL lProdMnt   := MTA330IsMNT()
LOCAL lEstornado := SuperGetMV( 'MV_D3ESTOR' , .F., 'N' )== 'S'
LOCAL lD3Servico := !SuperGetMv("MV_WMSNEW",.F.,.F.) .And. SuperGetMV( 'MV_D3SERVI' ,.F., 'N' )== 'S'
LOCAL cInsUpd    := ""
LOCAL cQuery     := ""
LOCAL cLocCQ     := GetMvNNR( 'MV_CQ' , '98' )
LOCAL cProdMNT   := SuperGetMv("MV_PRODMNT",.F.,"MANUTENCAO")
LOCAL cNivAlt    := SuperGetMV("MV_NIVALT",.F.,"N")
LOCAL cFilSG1    := A320Filial(lEstruMov)
LOCAL cDbType    := TCGetDB()
Local nTC2_NUM   := TamSx3('C2_NUM')[1]
Local nTC2_ITEM  := TamSx3('C2_ITEM')[1]
Local nTC2_SEQUEN:= TamSx3('C2_SEQUEN')[1]
Local nTC2_ITEMGRD:= TamSx3('C2_ITEMGRD')[1]

Default lSoNiv := .F.
Default cNivFil := cFilAnt

//-- Alimenta tabela de estrutura com base na movimentação
If lEstruMov .and. !lSoNiv
	cQuery := "SELECT '" +iIf(lCusEmp,Space(Len(cFilAnt )),cNivFil) +"' FILPROC, "
	cQuery += "'" +cFilSG1 +"' FILIAL, "
	cQuery += "SC2.C2_PRODUTO COD, SD3.D3_COD COMP, '20491231' FIM, '01' NIV, '99' NIVINV "
	cQuery += " FROM " +RetSQLName("SD3") +" SD3 "
	cQuery += " JOIN " +RetSQLName("SC2") +" SC2 "
	cQuery += " ON SC2.C2_FILIAL = '" +xFilial("SC2") +"' "
	cQuery += " AND SC2.C2_NUM     = SUBSTR(SD3.D3_OP, 1, "+cValToChar(nTC2_NUM)+") "
	cQuery += " AND SC2.C2_ITEM    = SUBSTR(SD3.D3_OP, "+cValToChar(nTC2_NUM)+" + 1, "+cValToChar(nTC2_ITEM)+") "
	cQuery += " AND SC2.C2_SEQUEN  = SUBSTR(SD3.D3_OP, "+cValToChar(nTC2_NUM)+" + "+cValToChar(nTC2_ITEM)+" + 1, "+cValToChar(nTC2_SEQUEN)+") "
	cQuery += " AND SC2.C2_ITEMGRD = SUBSTR(SD3.D3_OP, "+cValToChar(nTC2_NUM)+" + "+cValToChar(nTC2_ITEM)+" + "+cValToChar(nTC2_SEQUEN)+" +1, "+cValToChar(nTC2_ITEMGRD)+") "
	cQuery += " AND SC2.C2_PRODUTO <> SD3.D3_COD "
	cQuery += " AND SC2.D_E_L_E_T_ = ' ' "
	cQuery += " WHERE SD3.D3_FILIAL = '" +xFilial("SD3") +"' "
	cQuery += " AND SD3.D3_OP <> '"+Space(Len(SD3->D3_OP))+"' "
	cQuery += " AND SUBSTR(SD3.D3_CF,2,1) = 'E' "
	cQuery += " AND SD3.D3_EMISSAO  >= '"+DTOS(dInicio) + "' "
	cQuery += " AND SD3.D3_EMISSAO  <= '"+DTOS(dFim) + "' "
	If lEstornado
		cQuery += " AND SD3.D3_ESTORNO = ' ' "
	EndIf
	If lProdMnt
		cQuery += " AND SD3.D3_COD <> '" +cProdMNT +"' "
	EndIf
	If !lD3Servico
	 	cQuery += " AND (D3_SERVIC = ' ' OR D3_TM <= '500' OR D3_LOCAL = '" +cLocCQ +"') "
	EndIf
	cQuery += " AND SD3.D_E_L_E_T_ = ' ' "
	cQuery += " GROUP BY D3_COD, C2_PRODUTO"
	cQuery := StrTran(Upper(ChangeQuery(cQuery)),"FOR READ ONLY","")

	If 'MSSQL' $ cDbType
		cQuery := StrTran(cQuery,"SUBSTR(","SUBSTRING(")
	EndIf

	cInsUpd := "INSERT INTO " +cNomTRBSG1 +" (G1_FILPROC,G1_FILIAL,G1_COD,G1_COMP,G1_FIM,G1_NIV,G1_NIVINV) "

	A330SQLExec(cInsUpd + cQuery, "A330EMV" +STR0067+cFilAnt, STR0226) //" filial" //Erro na Atualização de saldos atuais da OP na SC2: "
EndIf

//-- Acerta os niveis das estruturas no SG1 ou TRBSG1
If lRet .and. ((a330ParamZX[15] == 1 .And. SuperGetMv("MV_NIVALT",.F.,"N") == "S") .Or. lEstruMov)
	//-- Quando estrutura pela movimentação, simula alteração do MV_NIVALT
	If lEstruMov
		PutMV("MV_NIVALT","S")
	EndIf

	If !MA320Nivel(NIL,.T.,.F.,If(lEstruMov,cNomTRBSG1,NIL),.F.,lEstruMov,IiF(lCusEmp,Space(Len(cFilAnt )),cNivFil))
		M330PrcLog("MENSAGEM",OemToAnsi("Estrutura em recursividade"),OemToAnsi("Encontrados movimentos de produtos em recursividade"))
		lRet := A330Continua()
	EndIf

	//-- Retorna o conteudo original do parametro MV_NIVALT
	If lEstruMov
		PutMV("MV_NIVALT",cNivAlt)
	EndIf
EndIf

If lRet
	//-- Atualiza o log de processamento
	M330PrcLog("MENSAGEM",OemToAnsi(STR0089) +STR0067+cFilAnt,OemToAnsi(STR0089), '2') //"Acertando Niveis no SC2"

	//-- Atualiza nivel nas OPs do período com base na estrutura
	cInsUpd := "UPDATE " +RetSQLName("SC2") +" SET C2_NIVEL = "+MatIsnull()+"(("
	cQuery := "SELECT "
	If cDbType $ "ORACLE/POSTGRES/DB2"
		cQuery += ""
	ElseIf cDbType $ 'INFORMIX'
		cQuery += "FIRST 1 "
	Else //SQL
		cQuery += "TOP 1 "
	EndIf
	cQuery += "	CASE WHEN SG1.G1_NIV = '  ' THEN SG1.G1_NIV "
	cQuery += "		WHEN SG1.G1_NIV > '99' THEN '  ' "
	cQuery += "		WHEN SG1.G1_NIV > '90' THEN '0'||CAST(100-CAST(SG1.G1_NIV AS INT) AS CHAR(1)) "
	cQuery += "		ELSE CAST(100-CAST(SG1.G1_NIV AS INT) AS VARCHAR(2)) END "
	cQuery += " FROM " +If(lEstruMov,cNomTRBSG1,RetSQLName("SG1")) +" SG1 "
	cQuery += " WHERE SG1.G1_FILIAL = '" +iIf(lCusEmp,Space(Len(cFilSG1 )),cFilSG1)+"'"
	cQuery += " AND SG1.G1_COD = C2_PRODUTO "
	cQuery += If(lEstruMov,"AND SG1.G1_FILPROC = '" +iIf(lCusEmp,Space(Len(cFilAnt )),cNivFil)+"' ","")
	cQuery += " AND SG1.D_E_L_E_T_ = ' ' "
	If cDbType $ "ORACLE"
		cQuery += " AND ROWNUM <=1 "
	EndIf
	cQuery += " GROUP BY G1_COD, G1_NIV "
	If cDbType $ "POSTGRES/DB2"
		cQuery += " LIMIT 1 "
	EndIf
	cInsUpd += StrTran(Upper(ChangeQuery(cQuery)),"FOR READ ONLY","")
	cInsUpd += "),'  ') WHERE C2_FILIAL = '"+xFilial("SC2")+"'"
	cInsUpd += " AND C2_ITEM <> 'OS' "
	cInsUpd += " AND (C2_DATRF = '"+Space(8)+"' OR C2_DATRF >= '" +DToS(dInicio) +"' )"
	cInsUpd += " AND D_E_L_E_T_ = ' '"

	A330SQLExec(cInsUpd,"A330NVL" +STR0067+cFilAnt, STR0205) // " filial" //"Erro na atualização de níveis de OPs: "
EndIf

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A330EnvCus³ Autor ³ Marcos Bregantim      ³ Data ³ 17/10/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Monta array EnvCus para devolucao de compra                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array contendo os Custos de Importacao             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function A330EnvCus(aImpCusto)
Local aEnvCus:={}
Local nImpInc  := 0,nTotal := 0
aImpCusto   := IIf(aImpCusto == NIL, {}, aImpCusto)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se est  sendo utilizado o Roteiro de c lculo para os ³
//³ impostos variaveis - Paises do ConeSul.                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If SuperGetMV("MV_GERIMPV",.F.,"N") == "S"
	//Tratamento Provisorio ate re-formular a retcusent e
	//todos os Programas de entrada da versao de localizacoes,
	//que usam a RetCusEnt().
	//Bruno 27/04/00 07:01pm
	SFB->(DbSetOrder(1))
	SFC->(DbSeek(xFilial("SFC")+SD2->D2_TES))
	While !SFC->(Eof())  .And. xFilial("SFC")+SD2->D2_TES == SFC->FC_FILIAL+SFC->FC_TES
		If SFB->(DbSeek(xFilial("SFB")+SFC->FC_IMPOSTO))
			If (SFC->FC_INCNOTA=="S".And.SFC->FC_CREDITA == "N") .or. SFC->FC_CREDITA=="1"
				nImpInc  += &("SD2->D2_VALIMP"+SFB->FB_CPOLVRO)
			ElseIf (SFC->FC_INCNOTA=="N".And.SFC->FC_CREDITA == "S") .or. SFC->FC_CREDITA=="2"
				nImpInc  -= &("SD2->D2_VALIMP"+SFB->FB_CPOLVRO)
			EndIf
		EndIf
		SFC->(DbSkip())
	Enddo

	nTotal   := IIf(Type("SF2->F2_TXMOEDA")#"U".And.SF2->F2_MOEDA > 1,;
	xMoeda(SD2->D2_TOTAL + nImpInc,SF2->F2_MOEDA,1,SF2->F2_EMISSAO,,SF2->F2_TXMOEDA),;
	SD2->D2_TOTAL + nImpInc)

	aEnvCus := { nTotal,IIf(Len(aImpCusto)>0,aImpCusto,0),0.00,SF4->F4_CREDIPI, SF4->F4_CREDICM, , , , , , }
Else
	aEnvCus := { SD2->D2_TOTAL,SD2->D2_VALIPI,SD2->D2_VALICM,SF4->F4_CREDIPI, SF4->F4_CREDICM, , , , , , , , , ,SF4->F4_PISCOF,SF4->F4_PISCRED,SD2->D2_VALIMP5,SD2->D2_VALIMP6}

	If SF4->F4_IPI == "R" .And. SF4->F4_BASEIPI > 0
		aEnvCus[11] := NoRound(SD2->D2_TOTAL * (SB1->B1_IPI / 100) * (SF4->F4_BASEIPI/100))
	Else
		aEnvCus[11] := 0
	EndIf
EndIf
Return (aEnvCus)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A330Estru ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 03/06/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se o produto da transferencia tem estrutura       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do tipo de movimentacao                     ³±±
±±³          ³ ExpC2 = Local do CQ                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function A330Estru(cLocCQ,cNivel,cNivSD3,cTipo,cCF)
LOCAL aAreaSD7   := {}
LOCAL aAreaTRB   := TRB->(GetArea())
LOCAL aAreaSD3	 := SD3->(GetArea())
LOCAL cNovoNivel := ""
LOCAL lEstru     := .F.
LOCAL lFlagCQ    := .F.
LOCAL lAcertaMOV := .F.
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ MV_PROCQE6 - Parametro utilizado para gerar "RE6/DE6"         |
//|              nas Liberacoes do CQ quando D7_ORIGLAN = 'PR'    |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LOCAL lProCQE6:= SuperGetMV('MV_PROCQE6',.F.,.F.)

If SD3->D3_CF $ "RE4/RE7/RE6"
	// Ativa flag que indica que material veio do CQ atraves de PRODUCAO
	If SD3->D3_LOCAL == cLocCQ
		dbSelectArea("SD7")
		aAreaSD7:=GetArea()
		dbSetOrder(3)
		// Verifica se flag indica producao
		If MsSeek(xFilial("SD7")+SD3->(D3_COD+D3_NUMSEQ+D3_DOC))
			lFlagCQ:=.T.
			If SD7->D7_ORIGLAN == "PR"
				If Substr(SD3->D3_CF,2) == IIf(lProCQE6,"E4","E6")
					lAcertaMOV:=.T.
				EndIf
			Else
				If SD3->D3_CF $ "RE6"
					dbSetOrder(1)
					// Busca o nivel origem para herdar na liberação
					If MsSeek(xFilial("SD7")+SubStr(SD3->D3_DOC,1,Len(D7_NUMERO))+SD3->(D3_COD+D3_LOCAL))
						While !EOF() .And. xFilial("SD7")+D7_NUMERO+D7_PRODUTO+D7_LOCAL == xFilial("SD7")+SubStr(SD3->D3_DOC,1,Len(D7_NUMERO))+SD3->(D3_COD+D3_LOCAL)
							If D7_TIPO = 0
								TRB->(dbSetOrder(2))
								If TRB->(dbSeek(cFilAnt+"SD3"+SD7->D7_NUMSEQ)) .and. TRB->TRB_ORDEM # "100"
									cNovoNivel := TRB->TRB_NIVEL
									Exit
								EndIf
							EndIf
							DbSkip()
						Enddo
					EndIf
				Else
					TRB->(dbSetOrder(2))
					If TRB->(dbSeek(cFilAnt+"SD1"+SD3->D3_NUMSEQ)) .And. TRB->TRB_ORDEM # "100"
						cNovoNivel:=TRB->TRB_NIVEL
					EndIf
				EndIf
				TRB->(RestArea(aAreaTRB))
				aSize(aAreaTRB,0)
				aAreaTRB := nil
			EndIf
		EndIf
		RestArea(aAreaSD7)
		aSize(aAreaSD7,0)
		aAreaSD7 := nil
		dbSelectArea("TRB")
	EndIf
	If SG1->(dbSeek(Iif(a330ParamZX[11] == 1,IIf(lCusEmp,Space(Len(cFilAnt )),cFilBack),'')+A320Filial(a330ParamZX[11] == 1)+SD3->D3_COD))
		If cNovoNivel = ''
			lEstru:=.T.
		EndIf
		cNivel := StrZero(100-IIf(Val(SG1->G1_NIV)==0,1,Val(SG1->G1_NIV)),2)
	EndIf
	// Indica se grava mov. do CQ atraves de producao com "RE4/DE4"
	If Substr(SD3->D3_CF,2) == IIf(lProCQE6,"E4","E6") .And. lFlagCQ .And. lAcertaMOV
		Reclock("SD3",.F.)
		Replace SD3->D3_CF With Substr(SD3->D3_CF,1,2)+IIf(lProCQE6,"6","4")
		SD3->(MsUnlock())
		cCF := SD3->D3_CF
	EndIf

	If lEstru
		If lProCQE6 .And. lFlagCQ .And. lAcertaMOV
			cNivel += IIF(SD3->D3_CF$"DE6/RE6/DE7/RE7","w"," ")
		Else
			cNivel += IIF(SD3->D3_CF$"DE4/RE4/DE7/RE7","w"," ")
		EndIf
	Else
		cNivel := If(Empty(cNovoNivel).And.!lFlagCQ,"  w",cNovoNivel)
	EndIf

	If Subs(SD3->D3_CF,2,2)=="E6"
		If A330MovCQ(SD3->D3_NUMSEQ,cLocCQ,SD3->D3_COD,SD3->D3_QUANT)
			cNivSD3 := "5"
		Else
			cNivSD3 := If(a330ParamZX[18]==1,"1","9")
		EndIf
	Else
		cNivSD3 := "5"
	EndIf
	cTipo := "T"

	//-- Atualiza dados nos movimentos de entrada (DE) que, porventura, já estão na TRB
	TRB->(dbSetOrder(2))
	TRB->(MsSeek(cFilAnt+"SD3"+SD3->D3_NUMSEQ))
	While !TRB->(EOF()) .And. cFilAnt+"SD3"+SD3->D3_NUMSEQ == TRB->(TRB_FILIAL+TRB_ALIAS+TRB->TRB_SEQ)
		If TRB->TRB_DTORIG == SD3->D3_EMISSAO .And. Subs(TRB->TRB_CF,2,2) == Subs(SD3->D3_CF,2,2) .And. TRB->TRB_QUANT == SD3->D3_QUANT
			//-- Se mudou CF (MV_PROCQE6), atualiza SD3 da devolução
			If Subs(TRB->TRB_CF,2,2) <> Subs(cCF,2,2)
				SD3->(dbGoTo(TRB->TRB_RECNO))
				RecLock("SD3",.F.)
				Replace SD3->D3_CF With Subs(SD3->D3_CF,1,1)+Subs(cCF,2,2)
				SD3->(MsUnLock())

				SD3->(RestArea(aAreaSD3))
				aSize(aAreaSD3,0)
				aAreaSD3 := nil
			EndIf

			RecLock("TRB",.F.)
			Replace TRB->TRB_CF		With Subs(TRB->TRB_CF,1,1)+Subs(cCF,2,2)
			Replace TRB->TRB_NIVEL	With cNivel
			Replace TRB->TRB_NIVSD3	With cNivSD3
			Replace TRB->TRB_TIPO	With cTipo
			TRB->(MsUnLock())
		EndIf
		TRB->(dbSkip())
	EndDo
EndIf
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MarkChoice³ Autor ³ Gilson do Nascimento  ³ Data ³17/02/95  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Avalia aChoice para empresas a serem processadas           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Modo                                               ³±±
±±³          ³ ExpN2 = Numero de elementos                                ³±±
±±³          ³ ExpN3 = Opcao                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330 - Esta funcao ‚ utilizada pela rotina BATCH        ³±±
±±³          ³           NAO deletar.                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MarkChoice(modo,nElem,opc)
Local Ret_code:=3
Local nTecla := LastKey()
Local cCorAnt:=SetColor()
Local nTam:=Len(aEmpr[nElem])
If Modo == 3
	If nTecla == 27
		Ret_code:=0
	EndIf
	If nTecla == 13
		aEmpr[nElem]:=IIF(Subs(aEmpr[nElem],1,1)=="û"," ","û")+Subs(aEmpr[nElem],2,nTam-1)
	EndIf
	Ret_code:=2
Else
	Ret_code:=2
EndIf
SetColor(cCorAnt)
Return(Ret_code)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A330PrcPR0³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 09/12/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calcula qtd total da ordem de producao p/ proporcionalizar ³±±
±±³          ³ o custo de cada apontamento.                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A330PrcPR0()
Local cSeek:="",cWhile:="",lGrava:=.F.
Local nQuantTot:=0,nQuantPer:=0,nRecOrig:=0
dbSelectArea("TRX")
dbSeek(cFilAnt)
While !Eof() .And. TRX_FILIAL == cFilAnt
	If !lGrava
		nQuantTot:=0
		nQuantPer:=0
		nRecOrig:=Recno()
	EndIf
	cSeek:=cFilAnt+DTOS(TRX_DATA)+TRX_OP+TRX_COD
	cWhile:="TRX_FILIAL+DTOS(TRX_DATA)+TRX_OP+TRX_COD"
	While !Eof() .And. cSeek == &(cWhile)
		If !lGrava
			nQuantTot+=TRX_QUANT
			nQuantPer+=TRX_QPERDA
		Else
			Reclock("TRX",.F.)
			Replace TRX_TOTAL With nQuantTot
			Replace TRX_TPERDA With nQuantPer
			TRX->(MsUnlock())
		EndIf
		dbSkip()
	End
	If !lGrava
		lGrava:=.T.
		MsGoto(nRecOrig)
	Else
		lGrava:=.F.
	EndIf
End
Return



/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³TTFimComD1³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 15/06/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza o saldo final do TRT (VFIM) baseado no SD1        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ TTFimComD1(ExpA1)                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array com os custos gravados no SD1                ³±±
±±³          ³ ExpA2 = Array com os custos em partes gravados no SD1      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function TTFimComD1(aCusto,aRetPartes,cFilJob,lCstPart)
Local nV,nX,aVFim[5],aCM[5],aCMHist[5],nMultiplic := 1
Local bBloco := { |nV,nX| Trim(nV)+Str(nX,1) }
Local nDec:=Set(3,8)

Static nDecCM1

Default cFilJob := cFilAnt

IF nDecCM1 == nil
	nDecCM1 := TamSx3('B2_CM1')[2]
Endif

If cMoeda330C == NIL
	cMoeda330C := SuperGetMv('MV_MOEDACM',.F.,"2345")
EndIf

If lCusFil .Or. lCusEmp
	If SD1->D1_TES > "500"
		nMultiplic := -1
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona no local a ser atualizado                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("TRT")
	If !MsSeek(If(lCusEmp,Space(Len(cFilJob)),cFilJob)+SD1->D1_COD)
		CriaTRT(If(lCusEmp,Space(Len(cFilJob)),cFilJob),SD1->D1_COD)
	EndIf
	RecLock("TRT",.F.)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Pega o custo do campo e soma o custo da entrada       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If aCusto == NIL
		aVFim[01] := TRB_VFIM1 + SD1->D1_CUSTO  * nMultiplic
		aVFim[02] := TRB_VFIM2 + If("2" $ cMoeda330C,SD1->D1_CUSTO2 * nMultiplic,0)
		aVFim[03] := TRB_VFIM3 + If("3" $ cMoeda330C,SD1->D1_CUSTO3 * nMultiplic,0)
		aVFim[04] := TRB_VFIM4 + If("4" $ cMoeda330C,SD1->D1_CUSTO4 * nMultiplic,0)
		aVFim[05] := TRB_VFIM5 + If("5" $ cMoeda330C,SD1->D1_CUSTO5 * nMultiplic,0)
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Pega o custo do campo e soma o custo da entrada       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nX := 1 to 5
			// Verifica se moeda devera ser considerada
			If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
				Loop
			EndIf
			aVFim[nX] := &(Eval(bBloco,"TRT->TRB_VFIM",nX)) + aCusto[nX]
		Next nX
	EndIf
	Replace TRB_QFIM  With TRB_QFIM  + (SD1->D1_QUANT * nMultiplic)
	Replace TRB_QFIM2 With TRB_QFIM2 + (SD1->D1_QTSEGUM * nMultiplic)
	Replace TRB_VFIM1 With aVFim[01]
	If "2" $ cMoeda330C
		Replace TRB_VFIM2 With aVFim[02]
	EndIf
	If "3" $ cMoeda330C
		Replace TRB_VFIM3 With aVFim[03]
	EndIf
	If "4" $ cMoeda330C
		Replace TRB_VFIM4 With aVFim[04]
	EndIf
	If "5" $ cMoeda330C
		Replace TRB_VFIM5 With aVFim[05]
	EndIf
	aCM[01] := TRB_CM1
	aCM[02] := TRB_CM2
	aCM[03] := TRB_CM3
	aCM[04] := TRB_CM4
	aCM[05] := TRB_CM5
	aCMHist := aClone(aCM)
	For nX := 1 to 5
		// Verifica se moeda devera ser considerada
		If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
			Loop
		EndIf
		If TRB_QFIM > 0 .And. aVFim[nX] > 0
			aCM[nX] := CusRound(aVFIM[nX]/TRB_QFIM,nX)
		EndIf
	Next nX
	If !A330ISMOD(TRB_COD,.T.)
		Replace TRB_CM1 	With aCM[01]
		If "2" $ cMoeda330C
			Replace TRB_CM2 With aCM[02]
		EndIf
		If "3" $ cMoeda330C
			Replace TRB_CM3 With aCM[03]
		EndIf
		If "4" $ cMoeda330C
			Replace TRB_CM4 With aCM[04]
		EndIf
		If "5" $ cMoeda330C
			Replace TRB_CM5 With aCM[05]
		EndIf
	EndIf

	// Atualiza o custo em partes unificado
	AtuCPTRT(lCstPart,aRetPartes,nMultiplic,Nil,aClone(aCMHist))
	TRT->(MsUnlock())
EndIf
Set(3,nDec)
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³TTFimComD2³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 15/06/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza o saldo final do TRT (VFIM) baseado no SD2        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ TTFimComD2(ExpA1)                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array com os custos gravados no SD2                ³±±
±±³          ³ ExpA2 = Array com os custos em partes gravados no SD2      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function TTFimComD2(aCusto,aRetPartes,cFilJob)
Local nX,aVFim[05],aCM[05],aCMHist[5],nMultiplic := 1
Local nDec:=Set(3,8)
Static nDecCM1

Default cFilJob := cFilAnt

IF nDecCM1 == nil
	nDecCM1 := TamSx3('B2_CM1')[2]
Endif

If cMoeda330C == NIL
	cMoeda330C := SuperGetMv('MV_MOEDACM',.F.,"2345")
EndIf

If lCusFil .Or. lCusEmp
	If SD2->D2_TES > "500"
		nMultiplic := -1
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona no local a ser atualizado                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("TRT")
	If !MsSeek(If(lCusEmp,Space(Len(cFilJob)),cFilJob)+SD2->D2_COD)
		CriaTRT(If(lCusEmp,Space(Len(cFilJob)),cFilJob),SD2->D2_COD)
	EndIf
	RecLock("TRT",.F.)
	aVFim[01] := TRB_VFIM1 + aCusto[01] * nMultiplic
	aVFim[02] := TRB_VFIM2 + If("2" $ cMoeda330C,aCusto[02] * nMultiplic,0)
	aVFim[03] := TRB_VFIM3 + If("3" $ cMoeda330C,aCusto[03] * nMultiplic,0)
	aVFim[04] := TRB_VFIM4 + If("4" $ cMoeda330C,aCusto[04] * nMultiplic,0)
	aVFim[05] := TRB_VFIM5 + If("5" $ cMoeda330C,aCusto[05] * nMultiplic,0)
	Replace TRB_QFIM With TRB_QFIM   + (SD2->D2_QUANT * nMultiplic)
	Replace TRB_QFIM2 With TRB_QFIM2 + (SD2->D2_QTSEGUM * nMultiplic)
	Replace TRB_VFIM1 With aVFim[01]
	If "2" $ cMoeda330C
		Replace TRB_VFIM2 With aVFim[02]
	EndIf
	If "3" $ cMoeda330C
		Replace TRB_VFIM3 With aVFim[03]
	EndIf
	If "4" $ cMoeda330C
		Replace TRB_VFIM4 With aVFim[04]
	EndIf
	If "5" $ cMoeda330C
		Replace TRB_VFIM5 With aVFim[05]
	EndIf
	aCM[01] := TRB_CM1
	aCM[02] := TRB_CM2
	aCM[03] := TRB_CM3
	aCM[04] := TRB_CM4
	aCM[05] := TRB_CM5
	aCMHist := aClone(aCM)
	For nX := 1 to 5
		// Verifica se moeda devera ser considerada
		If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
			Loop
		EndIf
		If TRB_QFIM > 0 .And. aVFim[nX] > 0
			aCM[nX] := Round(aVFim[nX]/TRB_QFIM,nDecCM1)
		EndIf
	Next nX
	If !A330ISMOD(TRB_COD,.T.)
		Replace TRB_CM1 With aCM[01]
		If "2" $ cMoeda330C
			Replace TRB_CM2 With aCM[02]
		EndIf
		If "3" $ cMoeda330C
			Replace TRB_CM3 With aCM[03]
		EndIf
		If "4" $ cMoeda330C
			Replace TRB_CM4 With aCM[04]
		EndIf
		If "5" $ cMoeda330C
			Replace TRB_CM5 With aCM[05]
		EndIf
	EndIf

	// Atualiza o custo em partes unificado
	AtuCPTRT(lCstPart,aRetPartes,nMultiplic,Nil,aClone(aCMHist))
	TRT->(MsUnlock())
EndIf
Set(3,nDec)
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³TTFimComD3³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 15/06/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza o saldo final do TRT (VFIM) baseado no SD3        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ TTFimComD3(ExpA1)                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array com os custos gravados no SD3                ³±±
±±³          ³ ExpA2 = Array com os custos em partes gravados no SD3      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function TTFimComD3(aCusto,aRetPartes,cLocProc,cFilJob,lCstPart)
Local nX,aVFim[05],aCM[05],aCMHist[5],nMultiplic := 1
Local nDec      := Set(3,8)
Local lIntMntAt := AllTrim(SuperGetMv("MV_NGMNTES",.F.,"N")) = "S"

Static nDecCM1

Default cFilJob := cFilAnt

IF nDecCM1 == nil
	nDecCM1 := TamSx3('B2_CM1')[2]
Endif

If cMoeda330C == NIL
	cMoeda330C := SuperGetMv('MV_MOEDACM',.F.,"2345")
EndIf

If lCusFil .Or. lCusEmp
	If (SD3->D3_TM > "500" .And. cLocProc == NIL) .Or. (SD3->D3_TM <= "500" .And. cLocProc != NIL)
		nMultiplic := -1
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona no local a ser atualizado                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("TRT")
	If !MsSeek(If(lCusEmp,Space(Len(cFilJob)),cFilJob)+SD3->D3_COD)
		CriaTRT(If(lCusEmp,Space(Len(cFilJob)),cFilJob),SD3->D3_COD)
	EndIf
	RecLock("TRT",.F.)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Aqui e' acertado o Saldo do Custo do Produto, quando  ³
	//³ a movimentacao do SD3 zerar o Saldo em Estoque do Prd.³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( TRB_QFIM+((SD3->D3_QUANT+SD3->D3_PERDA) * nMultiplic) == 0 ) .And. ;
			!(Alltrim(SD3->D3_CF)$"RE3|DE4|RE4|DE5|RE5|DE6|RE6|DE7|RE8|DE8|PR0|PR1|ER0|ER1")
		If SD3->D3_TM <= "500"
			aCusto[1] := ABS(TRB_VFIM1)

			aCusto[2] := ABS(TRB_VFIM2)
			aCusto[3] := ABS(TRB_VFIM3)
			aCusto[4] := ABS(TRB_VFIM4)
			aCusto[5] := ABS(TRB_VFIM5)
		Else
			aCusto[1] := TRB_VFIM1
			aCusto[2] := TRB_VFIM2
			aCusto[3] := TRB_VFIM3
			aCusto[4] := TRB_VFIM4
			aCusto[5] := TRB_VFIM5
		EndIf
		dbSelectArea("SD3")
		RecLock("SD3",.F.)
		SD3->D3_CUSTO1 := aCusto[1]
		If "2" $ cMoeda330C
			SD3->D3_CUSTO2 := aCusto[2]
		EndIf
		If "3" $ cMoeda330C
			SD3->D3_CUSTO3 := aCusto[3]
		EndIf
		If "4" $ cMoeda330C
			SD3->D3_CUSTO4 := aCusto[4]
		EndIf
		If "5" $ cMoeda330C
			SD3->D3_CUSTO5 := aCusto[5]
		EndIf
		SD3->(MsUnLock())
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Integracao com o Modulo de Manutencao de Ativos              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lIntMntAt
			NGCUSSTLMED(SD3->D3_NUMSEQ,SD3->D3_CUSTO1)
		EndIf
		dbSelectArea("TRT")
	Else
		aCusto := {SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5}
	EndIf
	aVFim[01] := TRB_VFIM1 + aCusto[01] * nMultiplic
	aVFim[02] := TRB_VFIM2 + If("2" $ cMoeda330C,aCusto[02] * nMultiplic,0)
	aVFim[03] := TRB_VFIM3 + If("3" $ cMoeda330C,aCusto[03] * nMultiplic,0)
	aVFim[04] := TRB_VFIM4 + If("4" $ cMoeda330C,aCusto[04] * nMultiplic,0)
	aVFim[05] := TRB_VFIM5 + If("5" $ cMoeda330C,aCusto[05] * nMultiplic,0)
	Replace TRB_QFIM  With TRB_QFIM  + (SD3->D3_QUANT * nMultiplic)
	Replace TRB_QFIM2 With TRB_QFIM2 + (SD3->D3_QTSEGUM * nMultiplic)
	Replace TRB_VFIM1 With aVFim[01]
	If "2" $ cMoeda330C
		Replace TRB_VFIM2 With aVFim[02]
	EndIf
	If "3" $ cMoeda330C
		Replace TRB_VFIM3 With aVFim[03]
	EndIf
	If "4" $ cMoeda330C
		Replace TRB_VFIM4 With aVFim[04]
	EndIf
	If "5" $ cMoeda330C
		Replace TRB_VFIM5 With aVFim[05]
	EndIf
	aCM[01] := TRB_CM1
	aCM[02] := TRB_CM2
	aCM[03] := TRB_CM3
	aCM[04] := TRB_CM4
	aCM[05] := TRB_CM5
	aCMHist := aClone(aCM)
	For nX := 1 to 5
		// Verifica se moeda devera ser considerada
		If nx # 1 .And. !(Str(nx,1,0) $ cMoeda330C)
			Loop
		EndIf
		If TRB_QFIM > 0 .And. aVFim[nX] > 0
			If !(SD3->D3_CF$"RE0|DE0|RE1|DE1")
				aCM[nX] := CusRound(aVFim[nX]/TRB_QFIM,nX)
			EndIf
		EndIf
	Next nX
	If !A330ISMOD(TRB_COD,.T.)
		Replace TRB_CM1 With aCM[01]
		If "2" $ cMoeda330C
			Replace TRB_CM2 With aCM[02]
		EndIf
		If "3" $ cMoeda330C
			Replace TRB_CM3 With aCM[03]
		EndIf
		If "4" $ cMoeda330C
			Replace TRB_CM4 With aCM[04]
		EndIf
		If "5" $ cMoeda330C
			Replace TRB_CM5 With aCM[05]
		EndIf
	EndIf

	// Atualiza o custo em partes unificado
	If lCstPart
		AtuCPTRT(lCstPart,aRetPartes,nMultiplic,Nil,aClone(aCMHist))
	EndIf
	TRT->(MsUnlock())
EndIf
Set(3,nDec)
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A330GrvRem³ Autor ³Bruno Sobieski         ³ Data ³ 15.12.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza o custo do SD2 baseado no custo do Remito         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = 1 - Atualiza o custo das notas de consignacao	  ³±±
±±³          ³         2 - Atualiza o custo dos notas de saida amarradas  ³±±
±±³          ³             aos remitos de vendas ("SD2")               	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A330GrvRem(nOpcao)
Local aCusRem	:=	{}
Local aCusRep   :=  {}
Local aAreaSD2	:=	SD2->(GetArea())
Local cChave	:=	""
Local nQuant	:=	SD2->D2_QUANT

Default nOpcao := 1

if cMoeda330C == NIL
	cMoeda330C := SuperGetMv('MV_MOEDACM',.F.,"2345")
EndIf

If cPaisLoc <> "BRA"

	If nOpcao == 1
		cChave	:=	SD2->(xFilial()+D2_REMITO+D2_SERIREM+D2_CLIENTE+D2_LOJA+D2_COD+D2_ITEM)
		SD2->(DbSetOrder(3))
		If SD2->(MsSeek(cChave))
			If nQuant == SD2->D2_QUANT
				aCusRem	:=	{SD2->D2_CUSTO1,SD2->D2_CUSTO2,SD2->D2_CUSTO3,SD2->D2_CUSTO4,SD2->D2_CUSTO5}
				If lCusRep
					aCusRep	:=	{ SD2->D2_CUSRP1, SD2->D2_CUSRP2,SD2->D2_CUSRP3,SD2->D2_CUSRP4,SD2->D2_CUSRP5 }
				EndIf
			Else
				aCusRem	:=	{	nQuant * (SD2->D2_CUSTO1/SD2->D2_QUANT),;
								nQuant * (SD2->D2_CUSTO2/SD2->D2_QUANT),;
								nQuant * (SD2->D2_CUSTO3/SD2->D2_QUANT),;
								nQuant * (SD2->D2_CUSTO4/SD2->D2_QUANT),;
								nQuant * (SD2->D2_CUSTO5/SD2->D2_QUANT)  }
				If lCusRep
					aCusRep	:=	{	nQuant * (SD2->D2_CUSRP1/SD2->D2_QUANT),;
									nQuant * (SD2->D2_CUSRP2/SD2->D2_QUANT),;
									nQuant * (SD2->D2_CUSRP3/SD2->D2_QUANT),;
									nQuant * (SD2->D2_CUSRP4/SD2->D2_QUANT),;
									nQuant * (SD2->D2_CUSRP5/SD2->D2_QUANT)  }
				EndIf
			EndIf
		EndIf
		RestArea(aAreaSD2)
		aSize(aAreaSD2,0)
		aAreaSD2 := nil

		If Len(aCusRem) > 0
			Reclock("SD2",.F.)
			Replace	D2_CUSTO1		With	aCusRem[1]
			If "2" $ cMoeda330C
				Replace	D2_CUSTO2	With	aCusRem[2]
			EndIf
			If "3" $ cMoeda330C
				Replace	D2_CUSTO3	With	aCusRem[3]
			EndIf
			If "4" $ cMoeda330C
				Replace	D2_CUSTO4	With	aCusRem[4]
			EndIf
			If "5" $ cMoeda330C
				Replace	D2_CUSTO5	With	aCusRem[5]
			EndIf
			If lCusRep .And. Len(aCusRep) > 0
				Replace	D2_CUSRP1		With	aCusRep[1]
				If "2" $ cMoeda330C
					Replace	D2_CUSRP2	With	aCusRep[2]
				EndIf
				If "3" $ cMoeda330C
					Replace	D2_CUSRP3	With	aCusRep[3]
				EndIf
				If "4" $ cMoeda330C
					Replace	D2_CUSRP4	With	aCusRep[4]
				EndIf
				If "5" $ cMoeda330C
					Replace	D2_CUSRP5	With	aCusRep[5]
				EndIf
			EndIf
			SD2->(MsUnLock())
		EndIf

	ElseIf nOpcao == 2 .And. IsRemito(1,"SD2->D2_TIPODOC")
		aCusRem	:=	{SD2->D2_CUSTO1,SD2->D2_CUSTO2,SD2->D2_CUSTO3,SD2->D2_CUSTO4,SD2->D2_CUSTO5}
		If lCusRep
			aCusRem	:=	{SD2->D2_CUSRP1,SD2->D2_CUSRP2,SD2->D2_CUSRP3,SD2->D2_CUSRP4,SD2->D2_CUSRP5}
			If lCusRep
				aCusRep	:=	{ SD2->D2_CUSRP1, SD2->D2_CUSRP2,SD2->D2_CUSRP3,SD2->D2_CUSRP4,SD2->D2_CUSRP5 }
			EndIf
		EndIf
		cChave	:=	SD2->(xFilial()+D2_CLIENTE+D2_LOJA+D2_SERIE+D2_DOC+D2_ITEM)
		SD2->(DbSetOrder(9))
		If SD2->(MsSeek(cChave)) //Localiza NF amarrada ao Remito de Saida para agregar o custo correto
			If Len(aCusRem) > 0
				Reclock("SD2",.F.)
				Replace	D2_CUSTO1		With	aCusRem[1]
				If "2" $ cMoeda330C
					Replace	D2_CUSTO2	With	aCusRem[2]
				EndIf
				If "3" $ cMoeda330C
					Replace	D2_CUSTO3	With	aCusRem[3]
				EndIf
				If "4" $ cMoeda330C
					Replace	D2_CUSTO4	With	aCusRem[4]
				EndIf
				If "5" $ cMoeda330C
					Replace	D2_CUSTO5	With	aCusRem[5]
				EndIf
				If lCusRep .And. Len(aCusRep) > 0
					Replace	D2_CUSRP1		With	aCusRep[1]
					If "2" $ cMoeda330C
						Replace	D2_CUSRP2	With	aCusRep[2]
					EndIf
					If "3" $ cMoeda330C
						Replace	D2_CUSRP3	With	aCusRep[3]
					EndIf
					If "4" $ cMoeda330C
						Replace	D2_CUSRP4	With	aCusRep[4]
					EndIf
					If "5" $ cMoeda330C
						Replace	D2_CUSRP5	With	aCusRep[5]
					EndIf
				EndIf
				SD2->(MsUnLock())
			EndIf
		EndIf
		RestArea(aAreaSD2)
		aSize(aAreaSD2,0)
		aAreaSD2 := nil
	EndIf
EndIf
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A330Continua ³ Autor ³Marcelo Iuspa       ³ Data ³ 27/04/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Pergunta ao usuario se continua ou nao o processamento em  ³±±
±±³          ³ caso de recursividade.                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nenhum                                               	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A330Continua()
Local lRet := .T.
If Aviso(OemToAnsi(STR0027),OemToAnsi(STR0022),{OemToAnsi(STR0023),OemToAnsi(STR0024)}) # 1 //"Recursividade"###"Deseja prosseguir o Recalculo do Custo Medio?"###"Sim"###"Nao"
	lRet := .F.
EndIf
Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³M330InB2CP³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 23/03/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Inicializa campos do SB2 com Custo em Partes no sistema    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpD1 = Data inicial do calculo do custo medio             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function	M330InB2CP(dInicio)
Local _cCampo	:=""
Local _cCampo1	:=""
Local _cCampo2	:=""
Local _nLoop1	:=1
Local _nLoop2	:=1
Local _nPosCP	:=0
Local nPosicao	:=0
Local nValorAtu	:=0
Local nQtdMod   :=0
Local lHasRec	:=.F.
Local lSemSB9   :=.T.
Local aArea		:=GetArea()
Local aAreaSB9	:=SB9->(GetArea())
Local lCstUnit  :=SB9->(FieldPos("B9_CPM0101")) > 0
// Array com os campos de saldo inicial existentes
Local _aSaldoIni:={}
Local _aSaldoUni:={}

if cMoeda330C == NIL
	cMoeda330C := SuperGetMv('MV_MOEDACM',.F.,"2345")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de partida para compor o saldo inicial.	     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !A330ISMOD(B2_COD,.T.)
	DbSelectArea( "SB9" )
	MsSeek(xFilial("SB9")+SB2->B2_COD+SB2->B2_LOCAL)
	While !Eof() .And. xFilial("SB9")+SB2->B2_COD+SB2->B2_LOCAL == B9_FILIAL+B9_COD+B9_LOCAL
		If (B9_DATA >= dInicio) .And. lHasRec
			Exit
		Else
			lHasRec := .T.
		EndIf
		DbSkip()
	End
	If lHasRec
		DbSkip(-1)
	EndIf
	If ((xFilial("SB9")+SB2->B2_COD+SB2->B2_LOCAL == SB9->B9_FILIAL+SB9->B9_COD+SB9->B9_LOCAL) .And. 	(SB9->B9_DATA < dInicio))
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Preenche array com saldo inicial em partes           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		_cCampo:="B9_CP"
		For _nLoop1:=1 to Len(aRegraCP)+1
			AADD(_aSaldoIni,ARRAY(5))
			For _nLoop2:=1 to 5
				// Verifica se moeda devera ser considerada
				If _nLoop2 # 1 .And. !(Str(_nLoop2,1,0) $ cMoeda330C)
				 	Loop
				EndIf
				_cCampo1:=_cCampo+Strzero(_nLoop1,2,0)+Strzero(_nLoop2,2,0)
				_aSaldoIni[_nLoop1,_nLoop2]:=SB9->(FIELDGET(FieldPos(_cCampo1)))
			Next _nLoop2
		Next _nLoop1
		If lCstUnit
			_cCampo:="B9_CPM"
			For _nLoop1:=1 to Len(aRegraCP)+1
				AADD(_aSaldoUni,ARRAY(5))
				For _nLoop2:=1 to 5
					// Verifica se moeda devera ser considerada
					If _nLoop2 # 1 .And. !(Str(_nLoop2,1,0) $ cMoeda330C)
		  			  	Loop
					EndIf
					_cCampo1:=_cCampo+Strzero(_nLoop1,2,0)+Strzero(_nLoop2,2,0)
					_aSaldoUni[_nLoop1,_nLoop2]:=SB9->(FIELDGET(FieldPos(_cCampo1)))
				Next _nLoop2
			Next _nLoop1
		EndIf
		SB9->(RestArea(aAreaSB9))
		aSize(aAreaSB9,0)
		aAreaSB9 := nil
		lSemSB9:= .F.
	Else
		For _nLoop1:=1 to Len(aRegraCP)+1
			AADD(_aSaldoIni,ARRAY(5))
			For _nLoop2:=1 to 5
				// Verifica se moeda devera ser considerada
				If _nLoop2 # 1 .And. !(Str(_nLoop2,1,0) $ cMoeda330C)
				 	Loop
				EndIf
				_aSaldoIni[_nLoop1,_nLoop2]:=0
			Next _nLoop2
		Next _nLoop1
		If lCstUnit
			For _nLoop1:=1 to Len(aRegraCP)+1
				AADD(_aSaldoUni,ARRAY(5))
				For _nLoop2:=1 to 5
					// Verifica se moeda devera ser considerada
					If _nLoop2 # 1 .And. !(Str(_nLoop2,1,0) $ cMoeda330C)
					 	Loop
					EndIf
					_aSaldoUni[_nLoop1,_nLoop2]:=0
				Next _nLoop2
			Next _nLoop1
		EndIf
		lSemSB9 := .T.
	EndIf
Else
	For _nLoop1:=1 to Len(aRegraCP)+1
		AADD(_aSaldoIni,ARRAY(5))
		For _nLoop2:=1 to 5
			// Verifica se moeda devera ser considerada
			If _nLoop2 # 1 .And. !(Str(_nLoop2,1,0) $ cMoeda330C)
				Loop
			EndIf
			_aSaldoIni[_nLoop1,_nLoop2]:=0
		Next _nLoop2
	Next _nLoop1
	If lCstUnit
		For _nLoop1:=1 to Len(aRegraCP)+1
			AADD(_aSaldoUni,ARRAY(5))
			For _nLoop2:=1 to 5
				// Verifica se moeda devera ser considerada
				If _nLoop2 # 1 .And. !(Str(_nLoop2,1,0) $ cMoeda330C)
					Loop
				EndIf
				_aSaldoUni[_nLoop1,_nLoop2]:=0
			Next _nLoop2
		Next _nLoop1
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Descobre qual parte do custo deve ser atualizada     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	_nPosCP:=RetCParte(SB2->B2_COD,aRegraCP)
	_cCampo:="B2_VFIM"
	For _nLoop2:=1 to 5
		// Verifica se moeda devera ser considerada
		If _nLoop2 # 1 .And. !(Str(_nLoop2,1,0) $ cMoeda330C)
			Loop
		EndIf
		_cCampo1:=_cCampo+Strzero(_nLoop2,1,0)
		_aSaldoIni[_nPosCP,_nLoop2]:=SB2->(FIELDGET(FieldPos(_cCampo1)))
	Next _nLoop2
	lSemSB9:= .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Grava informacao do custo em partes no SB2           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
_cCampo:="B2_CPF"
dbSelectArea("SB2")
RecLock('SB2', .F.)
If lCusFil .Or. lCusEmp
	dbSelectArea("TRT")
	If !dbSeek(If(lCusEmp,Space(Len(cFilAnt)),cFilAnt)+SB2->B2_COD)
		CriaTRT(If(lCusEmp,Space(Len(cFilAnt)),cFilAnt),SB2->B2_COD)
	EndIf
	RecLock("TRT",.F.)
EndIf
For _nLoop1:=1 to Len(aRegraCP)+1
	For _nLoop2:=1 to 5
		// Verifica se moeda devera ser considerada
		If _nLoop2 # 1 .And. !(Str(_nLoop2,1,0) $ cMoeda330C)
			Loop
		EndIf
		dbSelectArea("SB2")
		_cCampo1:=_cCampo+Strzero(_nLoop1,2,0)+Strzero(_nLoop2,2,0)
		FIELDPUT(FieldPos(_cCampo1),_aSaldoIni[_nLoop1,_nLoop2])
		If lCstUnit
			_cCampo1:="B2_CP"+Strzero(_nLoop1,2,0)+Strzero(_nLoop2,2,0)
			FIELDPUT(FieldPos(_cCampo1),_aSaldoUni[_nLoop1,_nLoop2])
		Else
			If B2_QFIM > 0 .Or. lSemSB9
				_cCampo1:="B2_CP"+Strzero(_nLoop1,2,0)+Strzero(_nLoop2,2,0)
				FIELDPUT(FieldPos(_cCampo1),_aSaldoIni[_nLoop1,_nLoop2]/SB2->B2_QFIM)
			EndIf
		EndIf
		If lCusFil .Or. lCusEmp
			dbSelectArea("TRT")
			_cCampo2 :="TRB_VF"+Strzero(_nLoop1,2,0)+Strzero(_nLoop2,2,0)
			nPosicao :=FieldPos(_cCampo2)
			nValorAtu:=FieldGet(nPosicao)
			FieldPut(nPosicao,nValorAtu+_aSaldoIni[_nLoop1,_nLoop2])
			If lCstUnit
				_cCampo2:="TRB_QTDMOD"
				nQtdMod  :=FieldGet(FieldPos(_cCampo2))
				_cCampo2 :="TRB_TP"+Strzero(_nLoop1,2,0)+Strzero(_nLoop2,2,0)
				nPosicao :=FieldPos(_cCampo2)
				nValorAtu:=FieldGet(nPosicao)+_aSaldoUni[_nLoop1,_nLoop2]
				FieldPut(nPosicao,nValorAtu)
				_cCampo2:="TRB_CP"+Strzero(_nLoop1,2,0)+Strzero(_nLoop2,2,0)
				FieldPut(FieldPos(_cCampo2),nValorAtu/nQtdMod)
			Else
				_cCampo2:="TRB_CP"+Strzero(_nLoop1,2,0)+Strzero(_nLoop2,2,0)
				nPosicao:=FieldPos(_cCampo2)
				FieldPut(nPosicao,nValorAtu+_aSaldoIni[_nLoop1,_nLoop2]/TRT->TRB_QFIM)
			EndIf
		EndIf
	Next _nLoop2
Next _nLoop1

If lCusFil .Or. lCusEmp
	dbSelectArea("TRT")
	TRT->(MsUnlock())
EndIf
dbSelectArea("SB2")
SB2->(MsUnlock())
RestArea(aArea)
aSize(aArea,0)
aArea := nil
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GravaC2CPF³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 10/08/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava no SC2 as informacoes do custo em partes             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array com os valores do custo em partes            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GravaC2CPF(aRetPartes,lCstPart,cMoeda330C)
LOCAL _cCampo := "C2_CPF"
LOCAL _nLoop0 :=0
LOCAL _nLoop1 :=0
LOCAL _nValorAtu:=0
LOCAL aArea   := GetArea()

If lCstPart
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava informacao do custo em partes no SC2           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For _nLoop0:=1 to Len(aRetPartes)/5
		RecLock('SC2', .F.)
		For _nLoop1:=1 to 5
			// Verifica se moeda devera ser considerada
			If _nLoop1 # 1 .And. !(Str(_nLoop1,1,0) $ cMoeda330C)
				Loop
			EndIf
			_cCampo     := "C2_CPF"
			_cCampo     :=_cCampo+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0)
			_nValorAtu  :=SC2->(FIELDGET(FieldPos(_cCampo)))-aRetPartes[_nLoop1+If(_nLoop0==1,0,(_nLoop0-1)*5)]
			SC2->(FIELDPUT(FieldPos(_cCampo),_nValorAtu))
		Next _nLoop1
		SC2->(MsUnlock())
	Next _nLoop0
EndIf
RestArea(aArea)
aSize(aArea,0)
aArea := nil
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GravaC2APF³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 18/08/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava no SC2 as informacoes do custo em partes             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array com os valores do custo em partes            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GravaC2APF(aRetPartes,lCstPart,cMoeda330C)
LOCAL _cCampo := "C2_APF"
LOCAL _nLoop0 :=0
LOCAL _nLoop1 :=0
LOCAL aArea   := GetArea()

If lCstPart
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava informacao do custo em partes no SC2           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For _nLoop0:=1 to Len(aRetPartes)/5
		RecLock('SC2', .F.)
		For _nLoop1:=1 to 5
			// Verifica se moeda devera ser considerada
			If _nLoop1 # 1 .And. !(Str(_nLoop1,1,0) $ cMoeda330C)
				Loop
			EndIf
			_cCampo     := "C2_APF"
			_cCampo     :=_cCampo+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0)
			SC2->(FIELDPUT(FieldPos(_cCampo),aRetPartes[_nLoop1+If(_nLoop0==1,0,(_nLoop0-1)*5)]))
		Next _nLoop1
		SC2->(MsUnlock())
	Next _nLoop0
EndIf
RestArea(aArea)
aSize(aArea,0)
aArea := nil
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³PegaC2PFim³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 10/08/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Pega os custos finais em parte de uma OP                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpL1 = Variavel logica que indica se utiliza o custo em   ³±±
±±³          ³         partes ou nao                                      ³±±
±±³          ³ ExpN1 = Numero de custos possiveis                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function PegaC2PFim(lCstPart,nRegras)
Local aRetPartes:={}
Local _cCampo   := "C2_CPF"
Local _nLoop0   :=0
Local _nLoop1   :=0
Local aArea     := GetArea()

if cMoeda330C == NIL
	cMoeda330C := SuperGetMv('MV_MOEDACM',.F.,"2345")
EndIf

If lCstPart
	dbSelectArea("SC2")
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Descobre informacao do custo em partes no SC2        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For _nLoop0:=1 to nRegras
		For _nLoop1:=1 to 5
			// Verifica se moeda devera ser considerada
			If _nLoop1 # 1 .And. !(Str(_nLoop1,1,0) $ cMoeda330C)
				AADD(aRetPartes,0)
				Loop
			EndIf
			_cCampo     := "C2_CPF"
			_cCampo     :=_cCampo+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0)
			AADD(aRetPartes,SC2->(FIELDGET(FieldPos(_cCampo))))
		Next _nLoop1
	Next _nLoop0
EndIf
RestArea(aArea)
aSize(aArea,0)
aArea := nil
Return aRetPartes

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³PegaC2APF ³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 18/08/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Pega os custos apropriados finais em parte de uma OP       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpL1 = Variavel logica que indica se utiliza o custo em   ³±±
±±³          ³         partes ou nao                                      ³±±
±±³          ³ ExpN1 = Numero de custos possiveis                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function PegaC2APF(lCstPart,nRegras)
Local aRetPartes:= {}
Local _cCampo   := "C2_APF"
Local _nLoop0   := 0
Local _nLoop1   := 0
Local aArea     := GetArea()

if cMoeda330C == NIL
	cMoeda330C := SuperGetMv('MV_MOEDACM',.F.,"2345")
EndIf

If lCstPart
	dbSelectArea("SC2")
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Descobre informacao do custo em partes no SC2        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For _nLoop0:=1 to nRegras
		For _nLoop1:=1 to 5
			// Verifica se moeda devera ser considerada
			If _nLoop1 # 1 .And. !(Str(_nLoop1,1,0) $ cMoeda330C)
				AADD(aRetPartes,0)
				Loop
			EndIf
			_cCampo     := "C2_APF"
			_cCampo     :=_cCampo+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0)
			AADD(aRetPartes,SC2->(FIELDGET(FieldPos(_cCampo))))
		Next _nLoop1
	Next _nLoop0
EndIf
RestArea(aArea)
aSize(aArea,0)
aArea := nil
Return aRetPartes

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MA330LPart³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 25/09/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Indica o log dos arquivos nao criados                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array com os logs dos arquivos nao criados         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MA330LPart(aLogsPart)
LOCAL oDlg,oQual,cVarq
DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0029) From 130,70 To 350,360 OF oMainWnd PIXEL //"Campo(s) nao criado(s) para Custo em Partes"
@ 10,13 TO 90,122 LABEL "" OF oDlg  PIXEL
@ 20,18 LISTBOX oQual VAR cVarQ Fields HEADER OemToAnsi(STR0030),OemToAnsi(STR0031) SIZE 100,62 NOSCROLL OF oDlg PIXEL //"Arquivo"###"Campo"
oQual:SetArray(aLogsPart)
oQual:bLine := { || {aLogsPart[oQual:nAt,1],aLogsPart[oQual:nAt,2]}}
DEFINE SBUTTON FROM 95,90 TYPE 2 ACTION oDlg:End() ENABLE OF oDlg PIXEL
ACTIVATE MSDIALOG oDlg CENTERED
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³M330AvlDec³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 22/02/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Indica o log das decimais diferentes                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array com o Log de decimais diferentes             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function M330AvlDec(aLogDec)
Local aArea		:=GetArea()
Local lLogDec	:=.F.
Local nTamDec	:=0
Local nTamDecOld:=0
Local aCampos	:={{"SB9","B9_VINI"},{"SB2","B2_VFIM"},{"SD1","D1_CUSTO"},{"SD2","D2_CUSTO"},{"SD3","D3_CUSTO"},{"SC2","C2_VINI"},{"SC2","C2_VFIM"}}
Local nz,nx,cCampo

if cMoeda330C == NIL
	cMoeda330C := SuperGetMv('MV_MOEDACM',.F.,"2345")
EndIf

For nz:=1 to 5
	// Verifica se moeda devera ser considerada
	If nz # 1 .And. !(Str(nz,1,0) $ cMoeda330C)
		Loop
	EndIf
	For nx:=1 to Len(aCampos)
		cCampo:=aCampos[nx,2]+Strzero(nz,1,0)
		// Campo que foge a regra -> D1_CUSTO
		If cCampo == "D1_CUSTO1"
			cCampo:="D1_CUSTO"
		EndIf
		nTamDec:=TamSX3(cCampo)[2]
		AADD(aLogDec,{aCampos[nx,1],cCampo,nTamDec})
		If nx > 1 .And. nTamDec # nTamDecOld
			lLogDec:=.T.
		EndIf
		nTamDecOld:=nTamDec
	Next nx
Next nz
RestArea(aArea)
aSize(aArea,0)
aArea := nil
Return lLogDec

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³M330ShowDc³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 22/02/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Indica o log das decimais diferentes                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array com o Log de decimais diferentes             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function M330ShowDc(aLogDec)
LOCAL oDlg,oQual,cVarq
DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0033) From 130,70 To 350,360 OF oMainWnd PIXEL //"Campo(s) com divergencia(s) em decimais"
@ 10,13 TO 90,122 LABEL "" OF oDlg  PIXEL
@ 20,18 LISTBOX oQual VAR cVarQ Fields HEADER OemToAnsi(STR0030),OemToAnsi(STR0031),OemToAnsi(STR0034) SIZE 100,62 NOSCROLL OF oDlg PIXEL //"Arquivo"###"Campo"###"Decimais"
oQual:SetArray(aLogDec)
oQual:bLine := { || {aLogDec[oQual:nAt,1],aLogDec[oQual:nAt,2],aLogDec[oQual:nAt,3]}}
DEFINE SBUTTON FROM 95,90 TYPE 2 ACTION oDlg:End() ENABLE OF oDlg PIXEL
ACTIVATE MSDIALOG oDlg CENTERED
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³M330LogCus³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 05/04/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Mostra o log do calculo do custo medio                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array com as filiais em processamento			  ³±±
±±³          ³ ExpN2 = Numero da Ordem utilizada na visualizacao          ³±±
±±³          ³ ExpL3 = Variavel que verifica se utiliza custo medio       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function M330LogCus(aFilsCalc,nOrdem,lCusMed)
LOCAL aArea		:= TRB->(GetArea())
LOCAL aAlter    := {} // Campos que podem ser alterados na GETDB
LOCAL aObjects  := {}
LOCAL aCampos	:= GetTRBStru(1)
LOCAL lAtualiza	:= .F.
LOCAL nz		:= 0
LOCAL cDescri	:= ""
LOCAL cListaFil	:= A330Lista(aFilsCalc)
LOCAL cTitulo	:= If(lCusMed==Nil,OemToAnsi(STR0035),If(lCusMed,OemToAnsi(STR0035),OemToAnsi(STR0059))) //"Sequencia de Recalculo do Custo Medio"
LOCAL aButtons  := {{'AUTOM',{||  Processa({|lEnd| MA330QtTrb()},OemToAnsi(STR0007),OemToAnsi(STR0045),.F.)},OemToAnsi(STR0047),OemToAnsi(STR0073)}} //"Recalculo do Custo Medio"###"Calculando arquivo de log..."###"Recalcula colunas de Qtd"###"Recalcula"
LOCAl oTabTemp	:= FWTemporaryTable():New("TRBBKP",aCampos)
LOCAL oChk1,oDlg
LOCAL oSize,oGetDB
Local nX    as numeric

Default nOrdem  := 3
Default lCusMed := .T.

//Adiciona Botao para gerar o Log dos movimentos que deixaram o saldo negativo.
aAdd(aButtons,{'RELATORIO',{||A330LogMov()},OemToAnsi(STR0049),OemToAnsi(STR0074)})

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Montagem do AHeader.                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PRIVATE aRotina := {{"","",0,4,0,NIL}}
PRIVATE aHeader := {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Flag indicando se calcula saldo alteracao a alteracao        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PRIVATE lCalc := .T.

nz:= ASCAN(aCampos,{|x| x[1] == "TRB_DTBASE"})
cDescri:=OemToAnsi(STR0036)	//"Data Base"
If nz > 0
	AADD(aAlter,"TRB_DTBASE")
	AADD(aHeader,{cDescri,aCampos[nz,1],"",aCampos[nz,3],aCampos[nz,4],"A330VlData() .And. A330VlMov()",USADO,aCampos[nz,2],""," "})
EndIf

nz:= ASCAN(aCampos,{|x| x[1] == "TRB_SEQPRO"})
cDescri:=OemToAnsi(STR0037)	//"Seq. de Processamento"
If nz > 0
	AADD(aAlter,"TRB_SEQPRO")
	AADD(aHeader,{cDescri,aCampos[nz,1],"",aCampos[nz,3],aCampos[nz,4],"A330VlMov()",USADO,aCampos[nz,2],""," "})
EndIf

nz:= ASCAN(aCampos,{|x| x[1] == "TRB_ORDEM"})
cDescri:=OemToAnsi(STR0038)	//"Ordem processamento"
If nz > 0
	AADD(aAlter,"TRB_ORDEM")
	AADD(aHeader,{cDescri,aCampos[nz,1],"",aCampos[nz,3],aCampos[nz,4],"A330VlMov()",USADO,aCampos[nz,2],""," "})
EndIf

nz:= ASCAN(aCampos,{|x| x[1] == "TRB_NIVEL"})
cDescri:=OemToAnsi(STR0039)	//"Nivel do produto"
If nz > 0
	AADD(aAlter,"TRB_NIVEL")
	AADD(aHeader,{cDescri,aCampos[nz,1],"",aCampos[nz,3],aCampos[nz,4],"A330VlMov()",USADO,aCampos[nz,2],""," "})
EndIf

nz:= ASCAN(aCampos,{|x| x[1] == "TRB_NIVSD3"})
cDescri:=OemToAnsi(STR0040)	//"Nivel do movimento interno"
If nz > 0
	AADD(aAlter,"TRB_NIVSD3")
	AADD(aHeader,{cDescri,aCampos[nz,1],"",aCampos[nz,3],aCampos[nz,4],"A330VlMov()",USADO,aCampos[nz,2],""," "})
EndIf

nz:= ASCAN(aCampos,{|x| x[1] == "TRB_CHAVE"})
cDescri:=OemToAnsi(STR0041)	//"Chave p/ ordenacao"
If nz > 0
	AADD(aAlter,"TRB_CHAVE")
	AADD(aHeader,{cDescri,aCampos[nz,1],"",aCampos[nz,3],aCampos[nz,4],"A330VlMov()",USADO,aCampos[nz,2],""," "})
EndIf

nz:= ASCAN(aCampos,{|x| x[1] == "TRB_SEQ"})
cDescri:=OemToAnsi(STR0042)	//"Numero Sequencial"
If nz > 0
	AADD(aAlter,"TRB_SEQ")
	AADD(aHeader,{cDescri,aCampos[nz,1],"",aCampos[nz,3],aCampos[nz,4],"A330VlMov()",USADO,aCampos[nz,2],""," "})
EndIf

nz:= ASCAN(aCampos,{|x| x[1] == "TRB_COD"})
cDescri:=RetTitle("D3_COD")
If nz > 0
	AADD(aHeader,{cDescri,aCampos[nz,1],"",aCampos[nz,3],aCampos[nz,4],"",USADO,aCampos[nz,2],""," "})
EndIf

nz:= ASCAN(aCampos,{|x| x[1] == "TRB_LOCAL"})
cDescri:=RetTitle("D3_LOCAL")
If nz > 0
	AADD(aHeader,{cDescri,aCampos[nz,1],"",aCampos[nz,3],aCampos[nz,4],"",USADO,aCampos[nz,2],""," "})
EndIf

nz:= ASCAN(aCampos,{|x| x[1] == "TRB_CF"})
cDescri:=RetTitle("D3_CF")
If nz > 0
	AADD(aHeader,{cDescri,aCampos[nz,1],"",aCampos[nz,3],aCampos[nz,4],"",USADO,aCampos[nz,2],""," "})
EndIf

nz:= ASCAN(aCampos,{|x| x[1] == "TRB_QINI"})
cDescri:=OemToAnsi(STR0043) //"Qtd produto antes movimento"
If nz > 0
	AADD(aHeader,{cDescri,aCampos[nz,1],X3Picture('B2_QFIM'),aCampos[nz,3],aCampos[nz,4],"",USADO,aCampos[nz,2],""," "})
EndIf

nz:= ASCAN(aCampos,{|x| x[1] == "TRB_QUANT"})
cDescri:=OemToAnsi(STR0070) //"Qtd do movimento"
If nz > 0
	AADD(aHeader,{cDescri,aCampos[nz,1],X3Picture('B2_QFIM'),aCampos[nz,3],aCampos[nz,4],"",USADO,aCampos[nz,2],""," "})
EndIf

nz:= ASCAN(aCampos,{|x| x[1] == "TRB_QFIM"})
cDescri:=OemToAnsi(STR0044) //"Qtd produto apos movimento"
If nz > 0
	AADD(aHeader,{cDescri,aCampos[nz,1],X3Picture('B2_QFIM'),aCampos[nz,3],aCampos[nz,4],"",USADO,aCampos[nz,2],""," "})
EndIf

nz:= ASCAN(aCampos,{|x| x[1] == "TRB_FILIAL"})
cDescri:=OemToAnsi(STR0060) //"Filial"
If nz > 0
	AADD(aHeader,{cDescri,aCampos[nz,1],"",aCampos[nz,3],aCampos[nz,4],"",USADO,aCampos[nz,2],""," "})
EndIf

nz:= ASCAN(aCampos,{|x| x[1] == "TRB_FILTRA"})
cDescri:=OemToAnsi(STR0069) //"Filial transf."
If nz > 0
	AADD(aHeader,{cDescri,aCampos[nz,1],"",aCampos[nz,3],aCampos[nz,4],"",USADO,aCampos[nz,2],""," "})
EndIf

cDescri := ""
For nZ := 1 To Len(aCampos)
	cDescri += aCampos[nZ,1] +IIf(nZ < Len(aCampos),",","")
Next nZ

//-- Faz copia da TRB em tabela temporaria para caso o usuário cancele a tela
oTabTemp:Create()
TCSQLExec("INSERT INTO " +oTabTemp:GetRealName() +" (" +cDescri +") SELECT " +cDescri +" FROM " +cNomTRB +" WHERE TRB_FILIAL IN ("+cListaFil+")")

AADD(aObjects,{100,100,.T.,.T.,.F.})
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Preenche os campos de quantidade final no arquivo de trabalho³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Processa({|lEnd| MA330QtTrb()},OemToAnsi(STR0007),OemToAnsi(STR0045),.F.) 		//"Recalculo do Custo Medio"###"Calculando arquivo de log..."

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Processa pela sequencia CUSTO MEDIO                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

dbSelectArea("TRB")
dbSetOrder(nOrdem)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Calcula dimensões ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
oSize := FwDefSize():New( .F. )

oSize:AddObject( "ENCHOICE" , 100, 30, .T., .F., .T. ) // Nao dimensiona Y
oSize:AddObject( "CIMA" , 100, 3, .T., .T., .T. ) // dimensiona Y
oSize:AddObject( "BAIXO", 100, 97, .T., .T., .T. ) // Totalmente dimensionavel

oSize:lProp := .T. // Proporcional
oSize:aMargins := { 3, 3, 3, 3 } // Espaco ao lado dos objetos 0, entre eles 3

oSize:Process() // Dispara os calculos
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta GETDB para editar seq. de calculo do CUSTO MEDIO    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DEFINE MSDIALOG oDlg TITLE cTitulo FROM oSize:aWindSize[1],oSize:aWindSize[2] TO oSize:aWindSize[3],oSize:aWindSize[4] OF oMainWnd PIXEL
@ oSize:GetDimension("CIMA","LININI"),oSize:GetDimension("CIMA","COLINI") CHECKBOX oChk1 VAR lCalc PROMPT OemToAnsi(STR0046) SIZE oSize:GetDimension("CIMA","XSIZE"),oSize:GetDimension("CIMA","YSIZE") OF oDlg PIXEL ;oChk1:oFont := oDlg:oFont //"Recalcula Qtd produto apos movimento em toda alteracao"
oGetDb := MsGetDB():New(oSize:GetDimension("BAIXO","LININI"),oSize:GetDimension("BAIXO","COLINI"),oSize:GetDimension("BAIXO","LINEND"),oSize:GetDimension("BAIXO","COLEND"),1,"Allwaystrue","Allwaystrue","",,aAlter,,,,"TRB",,,,oDlg)
dbGotop()
ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||If(oGetDb:TudoOk(),(lAtualiza:=.T.,oDlg:End()),)},{||oDlg:End()},,aButtons)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Restaura TRB original caso o usuario nao confirme as alteracoes digitadas ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lAtualiza
	//- otimiza a exclusão dos registros por filial
	For nX := 1 to Len(aFilsCalc)
		If aFilsCalc[nX,1]
			TcSqlExec( "DELETE FROM "+ cNomTRB +" WHERE TRB_FILIAL = '"+aFilsCalc[nX,2]+"' AND D_E_L_E_T_  = ' '")
		EndIf
	Next nX
	TCSQLExec("INSERT INTO " +cNomTRB +" (" +cDescri +") SELECT " +cDescri +" FROM " +oTabTemp:GetRealName())
EndIf

oTabTemp:Delete()
TRB->(RestArea(aArea))
aSize(aArea,0)
aArea := nil
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A330VlData³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 05/04/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Validacao do campo de data do recalculo do custo medio     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A330VlData()
LOCAL lRet:=.T.
LOCAL dDigi:=&(ReadVar())
// So permite alterar a data na apropriacao diaria
If a330ParamZX[14] <> 3 .And. TRB->TRB_DTBASE # dDigi
	lRet:=.F.
EndIf
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A330VlMov ³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 08/04/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Validacao ref ao tipo de movimento                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A330VlMov()
LOCAL aArea   :=GetArea()
LOCAL aAreaTRB:={}
LOCAL cSeqOld:=""
LOCAL cCampo:=Substr(ReadVar(),4)
LOCAL cConteudo:=&(ReadVar())
// Caso o movimento seja de transferencia ou desmontagem garante o processamento
// dos movimentos de destino apos o movimento de origem
If TRB->TRB_ALIAS == "SD3" .And. TRB->TRB_CF $ "RE4/RE7"
	MsgRun(OemToAnsi(STR0015),,{||nil} )
	dbSelectArea("TRB")
	aAreaTRB:=GetArea()
	cSeqOld:=TRB_SEQ
	dbSetOrder(2)
	dbSeek(cFilAnt+"SD3"+cSeqOld)
	While !Eof() .And. TRB_FILIAL+TRB_ALIAS+TRB_SEQ == cFilAnt+"SD3"+cSeqOld
		Reclock("TRB",.F.)
		FieldPut(FieldPos(cCampo),cConteudo)
		TRB->(MsUnlock())
		dbSkip()
	End
	RestArea(aAreaTRB)
	aSize(aAreaTRB,0)
	aAreaTRB := nil
	// Grava o campo alterado antes de confirmar a validacao para que na chamada da
	// funcao MA330QtTrb o arquivo ja esteja correto
Else
	Reclock("TRB",.F.)
	FieldPut(FieldPos(cCampo),cConteudo)
	TRB->(MsUnlock())
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Flag indicando se calcula saldo alteracao a alteracao        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lCalc
	Processa({|lEnd| MA330QtTrb()},OemToAnsi(STR0007),OemToAnsi(STR0045),.F.) 		//"Recalculo do Custo Medio"###"Calculando arquivo de log..."
EndIf
RestArea(aArea)
aSize(aArea,0)
aArea := nil
Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MA330QtTrb³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 08/04/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Recalcula colunas de quantidade na tela de log do recalculo³±±
±±³          ³ Essas colunas servem como referencia para ordenacao dos    ³±±
±±³          ³ movimentos no recalculo do custo medio.                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MA330QtTrb()
Local aSaldos  :={{}}
Local nQuantINI:=0
Local nQuantFIM:=0
Local nQuant330:=0
Local i        :=0
Local nAchou   :=0
Local aAreaTRB :=TRB->(GetArea())
Local cThreadID
Local cFiltroTRB

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza o log de processamento			    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
M330PrcLog("MENSAGEM",OemToAnsi(STR0091),OemToAnsi(STR0091)) //"Acertando Quantidades da Tela de Log"

cThreadID := Strzero(ThreadID(),15)

// Verifica quais movimentos deixarao o saldo negativo
dbSelectArea("TRB")
cFiltroTRB := TRB->(DBFILTER())
TRB->(DbClearFilter())
dbSetOrder(7) //"TRB_THREAD+TRB_FILIAL+TRB_ORDEM+TRB_COD+TRB_NIVEL+TRB_NIVSD3+TRB_CHAVE+TRB_SEQ"
If !lBat
	ProcRegua(LastRec())
EndIf
dbSeek(cThreadID)
Do While TRB->(!Eof() .AND. TRB_THREAD==cThreadID)
	IncProc(OemToAnsi(STR0091)) //"Acertando Quantidades da Tela de Log"
	// Movimentos de saida
	If (TRB->TRB_ALIAS $ "SD1/SD2" .And. TRB_TES > "500") .Or. (TRB->TRB_ALIAS == "SD3" .And. Substr(TRB->TRB_CF,1,1) == "R")
		nMult:=-1
		// Movimentos de Entrada
	Else
		nMult:=1
	EndIf
	nQuant330:=TRB->TRB_QUANT
	For i:=1 to Len( aSaldos)
		nAchou:=ASCAN( aSaldos[i],{|x| x[1]+x[2]+x[3] == TRB_FILIAL+TRB_COD+TRB_LOCAL})
		If nAchou > 0
			nQuantINI := aSaldos[i,nAchou,4]
			aSaldos[i,nAchou,4]:= aSaldos[i,nAchou,4]+( nQuant330*nMult)
			nQuantFIM:= aSaldos[i,nAchou,4]
			Exit
		EndIf
	Next i
	If nAchou == 0
		If Len( aSaldos[Len( aSaldos)]) > 4095
			AADD( aSaldos,{})
		EndIf
		// Muda filial corrente
		cFilAnt:=TRB->TRB_FILIAL
		SB2->(dbSetOrder(1))
		If SB2->(MSSeek(xFilial("SB2")+TRB->TRB_COD+TRB->TRB_LOCAL))
			AADD( aSaldos[Len( aSaldos)],{TRB->TRB_FILIAL,TRB->TRB_COD,TRB->TRB_LOCAL,SB2->B2_QFIM+( nQuant330*nMult)})
			nQuantINI:=SB2->B2_QFIM
			nQuantFIM:=SB2->B2_QFIM+( nQuant330*nMult)
		Else
			AADD( aSaldos[Len( aSaldos)],{TRB->TRB_FILIAL,TRB->TRB_COD,TRB->TRB_LOCAL,( nQuant330*nMult)})
			nQuantINI:= 0
			nQuantFIM:= nQuant330*nMult
		EndIf
		// Restaura filial original apos processamento
		cFilAnt:=cFilBack
	EndIf
	Reclock("TRB",.F.)
	Replace TRB_QINI With nQuantINI
	Replace TRB_QFIM With nQuantFIM
	TRB->(MsUnlock())
	dbSkip()
EndDo

If !Empty(cFiltroTRB)
	TRB->(DBSETFILTER({||&cFiltroTRB}, cFiltroTRB))
EndIf
TRB->(RestArea(aAreaTRB))
aSize(aAreaTRB,0)
aAreaTRB := nil
aSize(aSaldos ,0)
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A330Period³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 27/05/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se a remessa ocorreu em outro periodo              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cTipo = Tipo de pesquisa do period D - Devolucao de Poder 3 ³±±
±±³          ³                                   V - Devolucao de Vendas  ³±±
±±³Parametros³lAtuNiv = Atualiza o nível das notas de saída/dev de remessa³±±
±±³          ³que foram enviadas em um armazém e devolvido em outro       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A330Period(cTipo,lAtuNiv)
Local lRet:=.F.
Local cAlias:=Alias()
Local aAreaSB6,aAreaSF2

Default cTipo   := ""
Default lAtuNiv := .F.

If cTipo == "D"
	aAreaSB6:=SB6->(GetArea())
	dbSelectArea("SB6")
	dbSetOrder(1)
	If dbSeek(xFilial("SB6")+SD1->D1_COD+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_IDENTB6)
		// Verifica periodo na apropriacao mensal
		If a330ParamZX[14] == 2 .And. (B6_EMISSAO >= dInicio .And. B6_EMISSAO <= a330ParamZX[01])
			lRet:=.T.
			// Verifica dia na apropriacao diaria
		ElseIf a330ParamZX[14] == 3 .And. B6_EMISSAO == SD1->D1_DTDIGIT
			lRet:=.T.
		EndIf
	EndIf
	// Atualiza o nível da nota de dev de remessa caso o armazém seja diferente do informado na saída
	If lRet .And. SD1->D1_LOCAL <> SB6->B6_LOCAL
		lAtuNiv := .T.
	EndIf
	RestArea(aAreaSB6)
	aSize(aAreaSB6,0)
	aAreaSB6 := nil
ElseIf cTipo == "V"
	aAreaSF2:=SF2->(GetArea())
	dbSelectArea("SF2")
	dbSetOrder(1)
	If dbSeek(xFilial("SF2")+SD1->D1_NFORI+SD1->D1_SERIORI)
		// Verifica periodo na apropriacao mensal
		If a330ParamZX[14] == 2 .And. (SF2->F2_EMISSAO >= dInicio .And. SF2->F2_EMISSAO <= a330ParamZX[01])
			lRet:=.T.
			// Verifica dia na apropriacao diaria
		ElseIf a330ParamZX[14] == 3 .And. SF2->F2_EMISSAO == SD1->D1_DTDIGIT
			lRet:=.T.
		EndIf
	EndIf
	RestArea(aAreaSF2)
	aSize(aAreaSF2,0)
	aAreaSF2 := nil
Else 
	// Valida a existência de notas de devolucao de remessa em armazém diferente da saída
	aAreaSB6:=SB6->(GetArea())
	dbSelectArea("SB6")
	dbSetOrder(3)
	If a330ParamZX[14] <> 1 .And. dbSeek(xFilial("SB6")+SD2->D2_IDENTB6+SD2->D2_COD+"D")
		Do While SB6->(!eof()) .And. SB6->B6_IDENT == SD2->D2_IDENTB6
			If SB6->B6_LOCAL <> SD2->D2_LOCAL .And. SB6->B6_ESTOQUE == "S"
				// Verifica periodo na apropriacao mensal
				If a330ParamZX[14] == 2 .And. (SB6->B6_EMISSAO >= dInicio .And. SB6->B6_EMISSAO <= a330ParamZX[01])
					lRet:=.T.
					Exit
				// Verifica dia na apropriacao diaria
				ElseIf a330ParamZX[14] == 3 .And. SB6->B6_EMISSAO == SD2->D2_EMISSAO
					lRet:=.T.
					Exit
				EndIf
			EndIf
			SB6->(DbSkip())
		EndDo
	EndIf
	RestArea(aAreaSB6)
	aSize(aAreaSB6,0)
	aAreaSB6 := nil
EndIf
dbSelectArea(cAlias)
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³M330InC2CP³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 26/03/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Inicializa campos do SC2 com Custo em Partes no sistema    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpL1 = Indica se o custo em partes esta habilitado ou nao ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function	M330InC2CP()
Local _cCamp1Or :="C2_CPI"
Local _cCamp1Or1:=""
Local _cCamp1Ds :="C2_CPF"
Local _cCamp1Ds1:=""
Local _cCamp2Or :="C2_API"
Local _cCamp2Or1:=""
Local _cCamp2Ds :="C2_APF"
Local _cCamp2Ds1:=""
Local _nLoop1:=1
Local _nLoop2:=1
Local cQuery:=""

if cMoeda330C == NIL
	cMoeda330C := SuperGetMv('MV_MOEDACM',.F.,"2345")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Grava informacao do custo em partes no SC2           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For _nLoop1:=1 to Len(aRegraCP)+1
		For _nLoop2:=1 to 5
			// Verifica se moeda devera ser considerada
			If _nLoop2 # 1 .And. !(Str(_nLoop2,1,0) $ cMoeda330C)
				Loop
			EndIf

			_cCamp1Or1:=_cCamp1Or+Strzero(_nLoop1,2,0)+Strzero(_nLoop2,2,0)
			_cCamp1Ds1:=_cCamp1Ds+Strzero(_nLoop1,2,0)+Strzero(_nLoop2,2,0)
			cQuery += ", "+_cCamp1Ds1 +" = "+_cCamp1Or1

			_cCamp2Or1:=_cCamp2Or+Strzero(_nLoop1,2,0)+Strzero(_nLoop2,2,0)
			_cCamp2Ds1:=_cCamp2Ds+Strzero(_nLoop1,2,0)+Strzero(_nLoop2,2,0)
			cQuery += ", "+_cCamp2Ds1 +" = "+_cCamp2Or1

		Next _nLoop2
	Next _nLoop1
Return (cQuery)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MTA330PERG³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 08/09/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Chama a pergunte para o programa e inicializa variaveis    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MTA330Perg()                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpL1 = Variavel que verifica se visualiza na tela         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MTA330Perg(lTela)
Local ni
Default lTela := .T.

If lTela
	If pergunte("MTA330",.T.)
		For ni := 1 to 21
			a330ParamZX[ni] := &("mv_par"+StrZero(ni,2))
		Next ni
	Else
		Return .F.
	EndIf
Else
	If Type("aAuto330")=="A" .And. Len(aAuto330) == 21
		a330ParamZX := aClone(aAuto330)
		For ni := 1 to 21
			&("mv_par"+StrZero(ni,2)) := a330ParamZX[ni]
		Next ni
	Else
		// Se for schedule o  grupo MTA330 do SX1, já está carregado
		If ! FWGetRunSchedule()
			Pergunte("MTA330",.F.)
		EndIf
		For ni := 1 to 21
			a330ParamZX[ni] := &("mv_par"+StrZero(ni,2))
		Next ni
	EndIf
EndIf

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MTA330TOK ³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 11/02/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida se pode efetuar o recalculo do custo medio           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function MTA330TOk()
LOCAL lRet	     := .T.
LOCAL xRet 		 := .T.
LOCAL cMessage 	 := ""
LOCAL nOpca	     := 0
LOCAL lCusFIFO   := SuperGetMV("MV_CUSFIFO",.F.,.F.)
LOCAL lCusLIFO   := SuperGetMv('MV_CUSLIFO',.F.,.F.)
LOCAL lIsBlind   := IsBlind()
Local cParAlt    := ''

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ MA330OK - Ponto de entrada utilizado para validacoes   |
//| adicionais para execucao da rotina de recalculo.       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("MA330OK")
	xRet := ExecBlock("MA330OK",.F.,.F.)
	If ValType(xRet) # "L" .AND. ValType(xRet) # "A"
		lRet := .T.
		xRet := lRet
	Else 
		If ValType(xRet) == "L"
			lRet := xRet
			cMessage := ""
		Else 
			If Len(xRet) > 0
				If ValType(xRet[1]) == "L"
					lRet := xRet[1]
				Else 
					lRet := .T.
					xRet[1] := .T.
				Endif

				If Len(xRet) > 1
					If ValType(xRet[2]) == "C"
						cMessage 	:= xRet[2]
					Else 
						cMessage := ""
						xRet[2] := ""
					Endif
				Else
					cMessage := ""
				Endif
			Else
				lRet := .T.
				xRet := lRet
				cMessage := ""
			Endif 
		Endif
	EndIf
EndIf

If !lRet
	M330PrcLog("ERRO",STR0247 + " - MA330OK ", STR0248 + Chr(13)+Chr(10) + cMessage ,"ER") 
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se processa custo fifo ou lifo qdo os dois    ³
//³ estiverem ligados.                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet .And. lCusFIFO  .And. lCusLIFO
	nOpca:=0
	If !lIsBlind
		nOpca:=Aviso(OemToAnsi(STR0006),OemToAnsi(STR0115),{OemToAnsi(STR0116),OemToAnsi(STR0117),OemToAnsi(STR0114)})
		If nOpca == 1
			lCusLIFO:=.F.
		ElseIf nOpca == 2
			lCusFIFO:=.F.
		ElseIf nOpca == 3
			lRet:=.F.
		EndIf
	Endif
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se o periodo a ser processado nao se encontra encerrado |                                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet .And. ( a330ParamZX[20] == 1 .Or. a330ParamZX[20] == 2 )
	If dInicio > a330ParamZX[1]
		If lIsBlind
			M330PrcLog("ERRO", STR0143, "ER")
		Else 
			Aviso(STR0006,STR0143,{"Ok"},,STR0144) // ATENCAO - "A data limite final informada para execução da rotina de recalculo do custo medio e menor ou igual a data de inicio de processamento do parametro MV_ULMES. Favor verificar a data informada para processamento."
		Endif
		
		lRet := .F.
	EndIf
EndIf

If lRet
	lRet := VldProc330(@cParAlt)
	If !lRet
		If lIsBlind
			M330PrcLog("ERRO", I18N(STR0265, {cParAlt}), "ER") //O parâmetro #1[MV_XPTO]# foi alterado. Reinstale a procedure 19.
		Else 
			Aviso(STR0006,I18N(STR0265, {cParAlt}),{"Ok"},,) //O parâmetro #1[MV_XPTO]# foi alterado. Reinstale a procedure 19.
		Endif
	EndIf
EndIf


Return lRet

/*/{Protheus.doc} VldProc330
	Verifica se a procedure foi instalada corretamente, 
	conforme parâmetro MV_A330SB2
	@type  Function
	@author Gianluca Moreira
	@since 19/05/2023
	/*/
Function VldProc330(cParAlt)
	Local aResult   := {}
	Local lRet      := .T.
	Local cTable    := ''
	Local cSPMAT060 := GetSPName("MAT060","19")
	Local lA330GRV  := SuperGetMV('MV_A330GRV',.F., .T.)

	If UsaTR2()
		cTable := 'TR2'
	Else
		cTable := 'SB2'
	EndIf

	If ExistProc(cSPMAT060,VerIDProc())
		aResult := TCSpExec(xProcedures(cSPMAT060),	;
							cTable,;                   //01. Nome físico do Alias SB2
							IIf(lA330GRV, 'T', 'F');   //02. Conteúdo do MV_A330GRV
		)
		If Empty(aResult) .Or. aResult[1] == '2'
			lRet := .F.
			cParAlt := 'MV_A330SB2'
		ElseIf aResult[1] == '3'
			lRet := .F.
			cParAlt := 'MV_A330GRV'
		EndIf
	EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A330VLDFIM³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 10/05/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida a data inicial do calculo do custo medio             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A330VLDFIM()
Local lRet := .T.
If mv_par01 < dInicio
	Help ( " ", 1, "FECHTO" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o log de processamento com o erro  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	M330PrcLog("ERRO","FECHTO",Ap5GetHelp("FECHTO"))
	lRet:=.F.
EndIf
Return lRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A330MovCQ   ³ Autor ³Marcelo Iuspa        ³ Data ³ 21/06/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna se um movimento e relacionado a movimentacao de CQ ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = NumSeq do movimento                                ³±±
±±³          ³ ExpC2 = Almoxarifado/armazem do CQ                         ³±±
±±³          ³ ExpC3 = Codigo do Produto                                  ³±±
±±³          ³ ExpN4 = Quantidade da movimentacao                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T. se movimentacao refere-se a CQ                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A330MovCQ(cNumSeq, cLocalCQ, cProduto, nQuant)
Local aArea    := GetArea()
Local aAreaSD3 := SD3->(GetArea())
Local cSeek    := Nil
Local lMovCQ   := .F.

dbSelectArea("SD3")
dbSetOrder(4)
dbSeek(cSeek := xFilial("SD3") + cNumSeq)
Do While ! Eof() .And. !lMovCQ .And. SD3->(D3_FILIAL + D3_NUMSEQ) == cSeek
	lMovCQ := (SD3->D3_LOCAL == cLocalCQ) .And. (SD3->D3_COD == cProduto) .And. (QtdComp(SD3->D3_QUANT) == QtdComp(nQuant))
	dbSkip()
EndDo
RestArea(aAreaSD3)
RestArea(aArea)
aSize(aAreaSD3,0)
aSize(aArea,0)
aAreaSD3 := Nil
aArea    := Nil
Return(lMovCQ)

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A330DocCQ   ³ Autor ³Rodrigo de A Sartorio³ Data ³ 28/06/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna se um movimento e relacionado a movimentacao de CQ ³±±
±±³          ³ originada de NF                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Produto do movimento                               ³±±
±±³          ³ ExpC2 = Documento do movimento                             ³±±
±±³          ³ ExpC3 = NumSeq do movimento                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T. se movimentacao refere-se a CQ originada de NF         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A330DocCQ(cProduto,cDocumento,cNumSeq)
Local aArea  := {GetArea(), SD7->(GetArea())}
Local lMovCQ := .F.
dbSelectArea("SD7")
dbSetOrder(3)
lMovCQ:=(MsSeek(xFilial("SD7")+cProduto+cNumSeq+cDocumento) .And. D7_ORIGLAN = "CP")
RestArea(aArea[2])
RestArea(aArea[1])
aSize(aArea,0)
aArea := nil
Return(lMovCQ)

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³A330LogMov  ³ Autor ³Marcos V. Ferreira   ³ Data ³ 26/01/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Realiza a impressao do log de movimentos que estao gerando ³±±
±±³          ³ saldo negativo.	                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330()                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A330LogMov()
LOCAL cTitulo :=OemToAnsi(STR0049)		//"Log de Movimentos"
LOCAL cDesc1  :=OemToAnsi(STR0050)		//"Este programa ira imprimir o Log de movimentos que"
LOCAL cDesc2  :=OemToAnsi(STR0051)		//"estao gerando saldo negativo."
LOCAL cAlias  := "TRB"
LOCAL wnrel   :="MATA330"
LOCAL Tamanho :="M"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variaveis tipo Private padrao de todos os relatorios         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PRIVATE nLastKey:=0
PRIVATE aReturn := {OemToAnsi(STR0052),1,OemToAnsi(STR0053),2,1,1,"",1} //"Zebrado"###"Administracao"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variaveis utilizadas para Impressao do Cabecalho e Rodape    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
li     := 80
m_pag  := 1
nTipo  := IIF(aReturn[4]==1,15,18)

wnRel:= SetPrint(cAlias,wnrel,"",cTitulo,cDesc1,cDesc2,"",.F.,,.F.,Tamanho)

If nLastKey = 27
	Return
EndIf

SetDefault(aReturn,cAlias)

If nLastKey = 27
	Return
EndIf
RptStatus({|lEnd| A330Imp(@lEnd,cTitulo,wnRel,Tamanho,cAlias)},cTitulo)
Return

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³A330Imp     ³ Autor ³Marcos V. Ferreira   ³ Data ³ 26/01/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Envia para funcao que faz a impressao da consulta.         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpL1 = Variavel que verifica o encerramento da rotina     ³±±
±±³          ³ ExpC2 = Titulo do relatorio                                ³±±
±±³          ³ ExpC3 = Nome do arquivo de trabalho                        ³±±
±±³          ³ ExpC4 = Tamanho do Relatorio                               ³±±
±±³          ³ ExpC5 = Alias                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330()                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A330Imp(lEnd,cTitulo,wnRel,Tamanho,cAlias)
Local aArea    := getArea()
Local cCabec1  := OemToAnsi(STR0055)
Local cCabec2  := OemToAnsi(STR0056)
Local nQuant330:= 0

cTitulo := AllTrim(cTitulo) + ' ('+OemToAnsi(STR0054)+')'

dbSelectArea(cAlias)
dbSetOrder(4)
dbGoTop()
SetRegua(LastRec())            // Total de Elementos da Regua

While !Eof()
	IncRegua()
	If lEnd
		@PROW()+1,001 PSay OemToAnsi(STR0026)	//"CANCELADO PELO OPERADOR"
		Exit
	EndIf
	If TRB_QINI >= 0 .And. TRB_QFIM < 0  //Verifica o Movimento que Gerou Saldo Negativo
		If li > 60
			cabec(cTitulo,cCabec1,cCabec2,"",Tamanho,nTipo)
		EndIf
		//Recupera Quantidade do movimento original.
		If TRB->TRB_ALIAS == "SD1"
			SD1->(dbGoto(TRB->TRB_RECNO))
			nQuant330:=SD1->D1_QUANT
		ElseIf TRB->TRB_ALIAS == "SD2"
			SD2->(dbGoto(TRB->TRB_RECNO))
			nQuant330:=SD2->D2_QUANT
		ElseIf TRB->TRB_ALIAS == "SD3"
			SD3->(dbGoto(TRB->TRB_RECNO))
			nQuant330:=SD3->D3_QUANT
		EndIf
		@ li,000 PSay TRB_ALIAS
		@ li,008 PSay TRB_DOC
		@ li,019 PSay TRB_COD
		@ li,042 PSay TRB_LOCAL
		@ li,053 PSay TRB_DTBASE
		@ li,067 PSay AllTrim(TRB_CF)
		@ li,074 PSay nQuant330 Picture PesqPict(TRB_ALIAS,SubStr(TRB_ALIAS,2,2)+"_QUANT")
		@ li,091 PSay TRB_QINI  Picture PesqPict("SD3","D3_QUANT")
		@ li,110 PSay TRB_QFIM  Picture PesqPict("SD3","D3_QUANT")
		li++
	EndIf
	dbSkip()
EndDo
If aReturn[5] = 1
	Set Printer To
	dbCommitAll()
	ourspool(wnrel)
EndIf
RestArea(aArea)
aSize(aArea,0)
aArea := nil
Return

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³A330QtdPRO  ³ Autor ³Marcos V. Ferreira   ³ Data ³ 19/09/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se existe quantidade produzida para esta ordem de |±±
±±³          ³ de producao dentro do arquivo de trabalho.                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Numero da Ordem de Producao                        ³±±
±±³          ³ ExpC2 = Codigo do Produto                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T. se existe quantidade produzida no periodo.			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A330QtdPR0(cOp, cProd)
Local aAreaAnt := GetArea()
Local cSeekTRX := ''
Local lRet := .T.

If QtdComp(SD3->D3_QUANT) == QtdComp(0)
	lRet := .F.
	dbSelectArea("TRX")
	dbSeek(cSeekTRX:=cFilAnt+DTOS(TRB->TRB_DTBASE)+TRB->TRB_OP+TRB->TRB_COD)
	While !Eof() .And. cSeekTRX == TRX_FILIAL+DTOS(TRX_DATA)+TRX_OP+TRX_COD
		If (TRX->TRX_QUANT+TRX_QPERDA) > 0
			lRet := .T.
			Exit
		EndIf
		dbSkip()
	EndDo
EndIf

RestArea(aAreaAnt)
aSize(aAreaAnt,0)
aAreaAnt := nil
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³ MNTInUse ºAutor  ³Lucas               º Data ³ 14/10/2005  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Verifica se ha integracao entre o modulo MNT com PCP, EST  º±±
±±º          ³ e COM.                                                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ Void                                                       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ Se .T. existe integracao.                                  º±±
±±º          ³ Se .F. Nao existe integracao.                              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Advanced Protheus                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function MntInUse()
Local lIntegra := .F.
If cModulo == "PCP" .And. SuperGetMV("MV_NGMNTPC",.F.,"N") == "S"			//Integração com PCP
	lIntegra := .T.
ElseIf cModulo == "COM" .And. SuperGetMV("MV_NGMNTCM",.F.,"N") == "S"		//Integração com Compras
	lIntegra := .T.
ElseIf cModulo == "EST" .And. SuperGetMV("MV_NGMNTES",.F.,"N") == "S"		//Integração com Estoque
	lIntegra := .T.
EndIf
Return( lIntegra )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o    ³ MA330FCalc                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Autor     ³ Rodrigo de Almeida Sartorio              ³ Data ³ 22/01/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Funcao para selecao das filiais para calculo por empresa   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³ ExpL1 = Indica se apresenta tela para selecao              ³±±
±±³           ³ ExpA2 = Lista com as filiais a serem consideradas (Batch)  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MA330FCalc(lMostratela,aListaFil, lJourney)
Local aFilsCalc:={}
Local aAreaSM0 :=SM0->(GetArea())
Local aSM0     := FWLoadSM0(.T.,,.T.)
Local lIsBlind := IsBlind()

// Variaveis utilizadas na selecao de categorias
Local oChkQual,lQual,oQual,cVarQ
// Carrega bitmaps
Local oOk      := LoadBitmap( GetResources(), "LBOK")
Local oNo      := LoadBitmap( GetResources(), "LBNO")
// Variaveis utilizadas para lista de filiais
Local nx       := 0
Local nAchou   := 0
Local aMA330SFI:= {}
Local nSizeIns 

Default lMostraTela :=	.F.
Default aListaFil   :=	{}
Default lJourney 	:= 	.F.

nSizeIns := TAMSX3('A1_INSCR')[1]
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Carrega filiais da empresa corrente                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aEval(aSM0,{|x| If(x[SM0_GRPEMP] == cEmpAnt .And. (x[SM0_USEROK] .Or. (lIsBlind .AND. !lJourney)) .And. (x[SM0_EMPOK] .Or. (lIsBlind .AND. !lJourney)) .And. x[SM0_EMPRESA] == FWCompany(),;
Aadd(aFilsCalc,{If((a330ParamZX[20]==1 .Or. a330ParamZX[20]==4),.T.,If(a330ParamZX[20]==2 .And. x[SM0_CODFIL]==cFilAnt,.T.,.F.)),x[SM0_CODFIL],x[SM0_NOMRED],x[SM0_CGC],.F., ;
				padr(FWSM0Util():GetSM0Data(cEmpAnt,x[SM0_CODFIL],{'M0_INSC'})[1,2],nSizeIns)}),) } )

//-- Ponto de entrada para customização da seleção de filiais e exibição da tela
If a330ParamZX[20]==3 .And. ExistBlock("MA330SFI")
	aMA330SFI := ExecBlock("MA330SFI",.F.,.F.,{aFilsCalc,lMostraTela})
	If ValType(aMA330SFI) == "A" .And. Len(aMA330SFI) == 2
		aFilsCalc := aMA330SFI[1]
		If lMostratela //-- Tratamento para não mostrar tela quando IsBlind ou lBat
			lMostraTela := aMA330SFI[2]
		EndIf
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta tela para selecao de filiais                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (lMostraTela .And. a330ParamZX[20]==3)
	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0061) STYLE DS_MODALFRAME From 145,0 To 445,628 OF oMainWnd PIXEL
	oDlg:lEscClose := .F.
	@ 05,15 TO 125,300 LABEL OemToAnsi(STR0062) OF oDlg  PIXEL
	@ 15,20 CHECKBOX oChkQual VAR lQual PROMPT OemToAnsi(STR0063) SIZE 50, 10 OF oDlg PIXEL ON CLICK (AEval(aFilsCalc, {|z| z[1] := If(z[1]==.T.,.F.,.T.)}), oQual:Refresh(.F.))
	@ 30,20 LISTBOX oQual VAR cVarQ Fields HEADER "",OemToAnsi(STR0060),OemToAnsi(STR0064) SIZE 273,090 ON DBLCLICK (aFilsCalc:=CA330Troca(oQual:nAt,aFilsCalc),oQual:Refresh()) NOSCROLL OF oDlg PIXEL
	oQual:SetArray(aFilsCalc)
	oQual:bLine := { || {If(aFilsCalc[oQual:nAt,1],oOk,oNo),aFilsCalc[oQual:nAt,2],aFilsCalc[oQual:nAt,3]}}
	DEFINE SBUTTON FROM 134,240 TYPE 1 ACTION MA330FOk(aFilsCalc,.T.,oDlg) ENABLE OF oDlg
	DEFINE SBUTTON FROM 134,270 TYPE 2 ACTION (aFilsCalc := {},oDlg:End()) ENABLE OF oDlg
	ACTIVATE MSDIALOG oDlg CENTERED
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Valida lista de filiais passada como parametro               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ElseIf a330ParamZX[20]==1 .Or. a330ParamZX[20]==4 .Or. (!lMostraTela .And. a330ParamZX[20]==3)
	// Checa parametros enviados
	For nx:=1 to Len(aListaFil)
		nAchou:=ASCAN(aFilsCalc,{|x| alltrim(x[2]) == alltrim(aListaFil[nx,2])})
		If nAchou > 0
			aFilsCalc[nAchou,1]:=.T.
		EndIf
	Next nx
	// Valida e assume somente filial corrente em caso de problema
	If !MA330FOk(aFilsCalc, !IsBlind() )
		For nx:=1 to Len(aFilsCalc)
			// Adiciona filial corrente
			aFilsCalc[nx,1]:=(aFilsCalc[nx,2]==cFilAnt)
		Next nx
	EndIf
EndIf

RestArea(aAreaSM0)
aSize(aAreaSM0,0)
aAreaSM0 := nil

Return aFilsCalc

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o    ³ MA330FOk                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Autor     ³ Rodrigo de Almeida Sartorio              ³ Data ³ 22/01/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Checa marcacao das filiais para calculo por empresa        ³±±
±±³           ³ Checa integridade dos parametros entre as filiais          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³ ExpA1 = Array com a selecao das filiais                    ³±±
±±³           ³ ExpL2 = Mostra tela de aviso no caso de inconsistencia     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function MA330FOk(aFilsCalc,lMostraTela,oDlg)
Local lRet      :=.F.
Local nx        :=0
Local nz        :=0
Local nCountFil :=0
Local lChecouPar:=.F.
Local aParCheck :={}	// Parametros que devem estar iguais em todas filiais
					 	// [1] Parametro
					 	// [2] Conteudo
Local dData330
Local lM331Data:=(ExistBlock("M331DATA") .And. IsInCallStack("MATA331"))

Default lMostraTela := .T.

aadd(aParCheck, {"MV_CQ"     , "98", "98"})
aadd(aParCheck, {"MV_CUSTEXC", "S" , "S"})
aadd(aParCheck, {"MV_CUSFIFO", .F. , .F.})
aadd(aParCheck, {"MV_CUSFIL" , "A" , "A"})
aadd(aParCheck, {"MV_CUSMED" , "M" , "M"})
aadd(aParCheck, {"MV_CUSZERO", "N" , "N"})
aadd(aParCheck, {"MV_GERIMPV", "N" , "N"})
aadd(aParCheck, {"MV_LOCPROC", "99", "99"})
aadd(aParCheck, {"MV_PRODPR0", 1   , 1})

//Não valida MV_ULMES caso exista o PE M331DATA
If !lM331Data
	AADD(aParCheck,{"MV_ULMES"		,""		,"" 	})
EndIf

AADD(aParCheck,{"MV_M330THR"	,1 		,1  	})

// Checa marcacoes efetuadas
For nx:=1 to Len(aFilsCalc)
	If aFilsCalc[nx,1]
		nCountFil++
		lRet:=.T.
	EndIf
Next nx
// Checa se existe alguma filial marcada na confirmacao
If !lRet
	If lMostraTela
		Aviso(OemToAnsi(STR0006),OemToAnsi(STR0065),{"Ok"})
	EndIf
Else
	// Checa se todos os parametros estao iguais nas filiais selecionadas
	For nx:=1 to Len(aFilsCalc)
		If aFilsCalc[nx,1]
			// Altera filial corrente
			cFilAnt:=aFilsCalc[nx,2]
			// Carrega valor na primeira filial selecionada
			If !lChecouPar
				For nz:=1 to Len(aParCheck)
					If GetMv(aParCheck[nz,1],.T.)
						aParCheck[nz,2]:=GetMv(aParCheck[nz,1])
					EndIf
				Next nz
				lChecouPar:=.T.
			Else
				For nz:=1 to Len(aParCheck)
					If aParCheck[nz,2] # If(GetMv(aParCheck[nz,1],.T.),GetMv(aParCheck[nz,1]),aParCheck[nz,3])
						If lMostraTela
							Aviso(OemToAnsi(STR0006),OemToAnsi(STR0066)+aParCheck[nz,1]+OemToAnsi(STR0067)+aFilsCalc[nx,2],{"Ok"}) // "ATENÇÄO" ## "Diferenca no parametro"  ## "filial"
						EndIf
						lRet:=.F.
						Exit
					EndIf
				Next nz
			EndIf
			//³ Verifica se o periodo a ser processado nao se encontra encerrado. |
			If lRet
				dData330 := IIF(lM331Data,dInicio,SuperGetMv("MV_ULMES",.F.,"19961231"))
				If dData330 >= a330ParamZX[1]
					If lMostraTela
						Aviso(STR0006,STR0143,{"Ok"},,STR0144) // ATENCAO - "A data limite final informada para execução da rotina de recalculo do custo medio e menor ou igual a data de inicio de processamento do parametro MV_ULMES. Favor verificar a data informada para processamento."
					EndIf
					lRet := .F.
				EndIf
			EndIf
			If !lRet
				Exit
			EndIf
		EndIf
	Next nx
	// Restaura filial original apos processamento
	cFilAnt:=cFilBack
EndIf

If lMostraTela .and. !oDlg == Nil
	If !lRet 
		oDlg:Refresh(.F.)
	Else
		oDlg:End()
	EndIf 
EndIf 

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o    ³ CA330Troca                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Autor     ³ Rodrigo de Almeida Sartorio              ³ Data ³ 12/01/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Troca marcador entre x e branco                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³ ExpN1 = Linha onde o click do mouse ocorreu                ³±±
±±³           ³ ExpA2 = Array com as opcoes para selecao                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function CA330Troca(nIt,aArray)
aArray[nIt,1] := !aArray[nIt,1]
Return aArray

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o    ³ M330TrFil                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Autor     ³ Rodrigo de Almeida Sartorio              ³ Data ³ 29/01/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Verifica se o movimento e de transferencia entre filiais   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³ ExpC1 = Arquivo que esta sendo avaliado                    ³±±
±±³           ³ ExpC2 = Codigo da TES que esta sendo avaliada              ³±±
±±³           ³ ExpA3 = Array com as selecao de filiais para calculo na    ³±±
±±³           ³         empresa corrente                                   ³±±
±±³           ³ ExpC3 = Especie do documento                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function M330TrFil(cAliasAval,cTes,aFilsCalc,cEspecie,cTipoDoc)
Local cCGC       := ""
Local cCodFil    := ""
Local cArqCliFor := ""
Local cFilRet    := ""
Local nAchoCGC   := 0
Local nAchoFil   := 0
Local aAreaAnt   := GetArea()
Local aAreaSF2   := SF2->(GetArea())
Local aAreaSF1   := SF1->(GetArea())
Local lRemTrf    := .F.
Local cInsc		 := ""
Local n			 := 0
Local nCntCGC    := 0

Default cEspecie :=""
Default cTipoDoc :=""

// So avalia se existe o campo no cadastro de TES
If SF4->(MsSeek(xFilial("SF4")+cTes)) .And. SF4->F4_TRANFIL == "1"
	// lRemTrf - Utilizada para verificar se o movimento e referente a um remito de Transferencia.
	lRemTrf := 	cPaisLoc <> "BRA" .And. AllTrim(cEspecie) $ "RTE/RTS" .And. cTipoDoc $ "54/64"
	// Tratamento para Remito de transferencia RTS / RTE
	If lRemTrf
		If cAliasAval == "SD2"
			SF2->(dbSetOrder(1))
			If SF2->(dbSeek(xFilial("SF2")+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA))
				cFilRet := SF2->F2_FILDEST
			EndIf
		ElseIf cAliasAval == "SD1"
			SF1->(dbSetOrder(1))
			If SF1->(dbSeek(xFilial("SF1")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA))
				cFilRet := SF1->F1_FILORIG
			EndIf
		EndIf
	Else
		If !lUsaFilTrf // procedimento padrao, localizar filial atraves do CNPJ do cliente/fornecedor

			// Itens de nota fiscal de entrada
			If cAliasAval == "SD1"
				If SD1->D1_TIPO $ "DB"
					cArqCliFor:="SA1"
					dbSelectArea("SA1")
					dbSetOrder(1)
					If MsSeek(xFilial("SA1")+SD1->D1_FORNECE+SD1->D1_LOJA)
						cCGC :=SA1->A1_CGC
						cInsc:=SA1->A1_INSCR
					EndIf
				Else
					cArqCliFor:="SA2"
					dbSelectArea("SA2")
					dbSetOrder(1)
					If MsSeek(xFilial("SA2")+SD1->D1_FORNECE+SD1->D1_LOJA)
						cCGC :=SA2->A2_CGC
						cInsc:=SA2->A2_INSCR
					EndIf
				EndIf
				// Itens de nota fiscal de saida
			ElseIf cAliasAval == "SD2"
				If SD2->D2_TIPO $ "DB"
					cArqCliFor:="SA2"
					dbSelectArea("SA2")
					dbSetOrder(1)
					If MsSeek(xFilial("SA2")+SD2->D2_CLIENTE+SD2->D2_LOJA)
						cCGC :=SA2->A2_CGC
						cInsc:=SA2->A2_INSCR
					EndIf
				Else
					cArqCliFor:="SA1"
					dbSelectArea("SA1")
					dbSetOrder(1)
					If MsSeek(xFilial("SA1")+SD2->D2_CLIENTE+SD2->D2_LOJA)
						cCGC :=SA1->A1_CGC
						cInsc:=SA1->A1_INSCR
					EndIf
				EndIf
			EndIf
			// Checa se cliente / fornecedor esta configurado como filial do sistema
			If !Empty(cCGC) 
				nCntCGC := 0
				For n:= 1 to len(Afilscalc)
					If aFilsCalc[n,4] == cCGC
						nCntCGC += 1
					EndIf
				Next n
				If nCntCGC > 1 .And. ((nAchoCGC:=ASCAN(aFilsCalc,{|x| x[4] == cCGC .and. x[6] == cInsc})) > 0)
					cFilRet := aFilsCalc[nAchoCGC,2]
				Else
			        If ((nAchoCGC:=ASCAN(aFilsCalc,{|x| x[4] == cCGC})) > 0)
						cFilRet := aFilsCalc[nAchoCGC,2]
					EndIf
				EndIf
			EndIf
		Else // procedimento novo, localizar a filial atraves dos campos A1_FILTRF e A2_FILTRF

			// Itens de nota fiscal de entrada
			If cAliasAval == "SD1"
				If SD1->D1_TIPO $ "DB"
					cArqCliFor:="SA1"
					dbSelectArea("SA1")
					dbSetOrder(1)
					If MsSeek(xFilial("SA1")+SD1->D1_FORNECE+SD1->D1_LOJA)
						cCodFil := SA1->A1_FILTRF
					EndIf
				Else
					cArqCliFor:="SA2"
					dbSelectArea("SA2")
					dbSetOrder(1)
					If MsSeek(xFilial("SA2")+SD1->D1_FORNECE+SD1->D1_LOJA)
						cCodFil := SA2->A2_FILTRF
					EndIf
				EndIf
				// Itens de nota fiscal de saida
			ElseIf cAliasAval == "SD2"
				If SD2->D2_TIPO $ "DB"
					cArqCliFor:="SA2"
					dbSelectArea("SA2")
					dbSetOrder(1)
					If MsSeek(xFilial("SA2")+SD2->D2_CLIENTE+SD2->D2_LOJA)
						cCodFil := SA2->A2_FILTRF
					EndIf
				Else
					cArqCliFor:="SA1"
					dbSelectArea("SA1")
					dbSetOrder(1)
					If MsSeek(xFilial("SA1")+SD2->D2_CLIENTE+SD2->D2_LOJA)
						cCodFil := SA1->A1_FILTRF
					EndIf
				EndIf
			EndIf
			// Checa se cliente / fornecedor esta configurado como filial do sistema
			If !Empty(cCodFil) .And. ((nAchoFil:=ASCAN(aFilsCalc,{|x| x[2] == cCodFil})) > 0)
				cFilRet := aFilsCalc[nAchoFil,2]
			EndIf
		EndIf
	EndIf
EndIf

RestArea(aAreaSF1)
aSize(aAreaSF1,0)
aAreaSF1 := nil

RestArea(aAreaSF2)
aSize(aAreaSF2,0)
aAreaSF2 := nil

RestArea(aAreaAnt)
aSize(aAreaAnt,0)
aAreaAnt := nil
Return cFilRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o    ³ A330PrcTrf                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Autor     ³ Rodrigo de Almeida Sartorio              ³ Data ³ 29/01/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Processa a amarracao das transferencias entre filiais      ³±±
±±³           ³ gravando em todos movimentos relacionados a sequencia de   ³±±
±±³           ³ processamento de maneira identica.                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³ aFilsCalc  - Array com as selecao de filiais para calculo  ³±±
±±³           ³              na empresa corrente                           ³±±
±±³           ³ lExistProc - Indica se utiliza Stored Procedures           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A330PrcTrf(aFilsCalc,lExistProc,cThrTRF)
Local nPos      :=0
Local nx        :=0
Local nRetry_0  :=0
Local nRetry_1  :=0
Local nHdl      :=0
Local nForFilial:=1
Local nOrderFIFO:=3
Local nI        :=0
Local aThreads  :={}
Local aJobAux   :={}

Local cStartPath:= GetSrvProfString("Startpath","")
Local cLocalCQ  := GetMvNNR('MV_CQ','98')
Local lHabCon330:= SuperGetMV('MV_M330CON',.F.,.F.)
Local aTrbArea  := TRB->(GetArea())
Local cIDThread as Character
Local cSemaforo as Character

Default lExistProc := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³MA330PRC - Ponto de entrada       		    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("MA330PRC")
	ExecBlock("MA330PRC",.F.,.F.)
Else
	If a330ParamZX[14] == 1  // Recalculo com metodo de apropriação sequencial não cria amarração das transferencias entre filiais.
		Return
	EndiF
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o log de processamento			    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	M330PrcLog("MENSAGEM",OemToAnsi(STR0092),OemToAnsi(STR0092), '5') //"Processamento das Transferencias entre Filiais - (0) Iniciando"

	cIDThread := cValToChar(ThreadID())
	cSemaforo := "M330TJOB_"+cIDThread+"_"+CEMPANT
	A330JobManual("1",cSemaforo , "M330TJOBCONNECT" )

	// Grava para todas filiais
	For nForFilial := 1 to Len(aFilsCalc)
		If aFilsCalc[nForFilial,1]

			// Reinicia variavel
			nRetry_0  :=0
			nRetry_1  :=0
			aJobAux   :={}
			aThreads  :={}

			// Altera para Filial a ser processada
			cFilAnt  := aFilsCalc[ nForFilial, 2 ]

			// Calcula a quantidade de Threads
			aThreads := M330QtdThr(9)

			If Len(aThreads) == 1
				nretry1:= 0
				TRB->(DbCloseArea())
				M330TJOB(cEmpAnt,cFilAnt,aThreads[1],'','99',cNomTrb,NIL,NIL,NIL,NIL,NIL,NIL,cLocalCQ,nOrderFIFO,lExistProc,lHabCon330,cThrTRF,cNomTR2)
			Else
				For nX :=1 to Len(aThreads)

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o log de processamento			    ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					M330PrcLog("MENSAGEM",STR0165 +StrZero(nX,3) +STR0067+cFilAnt,StrZero(nX,3)) //"Transferencias entre Filiais - Thread: ### "

					// Informacoes do semaforo
					cJobFile:= cStartPath+cEmpAnt+cFilAnt+StrZero(nX,2)+".TR"

					// Adiciona o nome do arquivo de Job no array aJobAux
					aAdd(aJobAux,{StrZero(nX,2),cJobFile})

					// Inicializa variavel global de controle de thread
					cJobAux:="T"+cEmpAnt+cFilAnt+StrZero(nX,2)
					A330LckGlb(cJobAux)
					PutGlbValue(cJobAux,"0")
					A330ULckGlb(cJobAux)

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Dispara thread para Stored Procedure        ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					while ! IPCGO( cSemaforo,cEmpAnt,cFilAnt,aThreads[nX],cJobFile,StrZero(nX,2),cNomTrb,NIL,NIL,NIL,NIL,NIL,NIL,cLocalCQ,nOrderFIFO,lExistProc,lHabCon330,cThrTRF,cNomTR2)
						for nI := 1 to 2
							sleep(1000)
						Next nI
					End

				Next nX

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Controle de Seguranca para MULTI-THREAD                                   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				For nX :=1 to Len(aThreads)

					nPos := ASCAN(aJobAux,{|x| x[1] == StrZero(nX,2)})

					// Informacoes do semaforo
					cJobFile:= aJobAux[nPos,2]

					// Inicializa variavel global de controle de thread
					cJobAux:="T"+cEmpAnt+cFilAnt+StrZero(nX,2)

					nRetry_0 := 0
					nRetry_1 := 0

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Analise das Threads em Execucao                              ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					While .T.
						Do Case
							// TRATAMENTO PARA ERRO DE SUBIDA DE THREAD
							Case GetGlbValue(cJobAux) == '0'
								If nRetry_0 > 50
									Conout(Replicate("-",80))							 	//"----------------------------------------------------------------------------"
									Conout("MATA330: "+ STR0166 + " " + StrZero(nX,3) )		//"MATA330: Não foi possivel realizar a subida da thread (Transferencia Filial)"
									Conout(Replicate("-",80))  								//"----------------------------------------------------------------------------"
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Atualiza o log de processamento			    ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									M330PrcLog("MENSAGEM",STR0167 +" -Thread: " +StrZero(nX,3) +STR0067+cFilAnt,STR0167)	//"Não foi possivel realizar a subida da thread (Transferencia)"
									Final(STR0167) 							//"Não foi possivel realizar a subida da thread (Transferencia)"
								Else
									nRetry_0 ++
								EndIf
							// TRATAMENTO PARA ERRO DE CONEXAO
							Case GetGlbValue(cJobAux) == '1'
								If FCreate(cJobFile) # -1
									If nRetry_1 > 5
										Conout(Replicate("-",80))  //"----------------------------------------------------"
										Conout(STR0168) 			//"MATA330: Erro de conexao na thread de Transferencia"
										Conout(STR0127 + cJobAux )	//"Thread numero : "
										Conout(STR0128)				//"Numero de tentativas excedidas"
										Conout(Replicate("-",80))  //"----------------------------------------------------"
										//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
										//³ Atualiza o log de processamento			    ³
										//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
										M330PrcLog("MENSAGEM",STR0168 +" -Thread: " +StrZero(nX,3) +STR0067+cFilAnt,STR0168)	//"MATA330: Erro de conexao na thread de transferencia"
										Final(STR0168)				   			//"MATA330: Erro de conexao na thread de transferencia"
									Else
										// Inicializa variavel global de controle de Job
										A330LckGlb(cJobAux)
										If GetGlbValue(cJobAux) == '1'
											PutGlbValue(cJobAux, "0" )
											A330ULckGlb(cJobAux)
										else
											A330ULckGlb(cJobAux)
											Loop
										EndIf
										// Reiniciar thread de contabilizacao
										Conout(Replicate("-",80))					//"---------------------------------------------------"
										Conout(STR0168) 							//"MATA330: Erro de conexao na thread de transferencia"
										Conout(STR0129+StrZero(nRetry_1,2))			//"Tentativa numero: "
										Conout(STR0130+StrZero(nX,3))				//"Reiniciando a thread : "
										Conout(Replicate("-",80))                  //"----------------------------------------------------"
										//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
										//³ Atualiza o log de processamento			    ³
										//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
										M330PrcLog("MENSAGEM",STR0130 +StrZero(nX,3) +STR0067+cFilAnt,STR0130 +StrZero(nX,3))	//"Reiniciando a thread : "
										//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
										//³ Dispara thread para Stored Procedure        ³
										//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
										//StartJob("M330TJOB",GetEnvServer(),lThrSeq,cEmpAnt,cFilAnt,aThreads[nX],cJobFile,StrZero(nX,2),cNomTrb,NIL,NIL,NIL,NIL,NIL,NIL,cLocalCQ,nOrderFIFO,lExistProc,lHabCon330,cThrTRF,cNomTR2)
									EndIf
									nRetry_1 ++
								EndIf
							// TRATAMENTO PARA ERRO DE APLICACAO
							Case GetGlbValue(cJobAux) == '2'
								If (nRetry_1 := FCreate(cJobFile)) # -1
									Sleep(5000)
									If GetGlbValue(cJobAux) # '2'	//-- Tratamento para falso positivo: quando thread muda entre as consultas
										FClose(nRetry_1)
										FErase(cJobAux)
										Loop
									EndIf
									Conout(Replicate("-",80))	//"-----------------------------------------------------"
									Conout(STR0169)				//"MATA330: Erro de aplicacao na thread de transferencia"
									Conout(STR0127+cJobAux)		//"Thread numero : "
									Conout(Replicate("-",80))  //"------------------------------------------------------"
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Atualiza o log de processamento			    ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									M330PrcLog(STR0169 + " " + STR0127+StrZero(nX,3) +STR0067+cFilAnt,STR0169 + "JobFile: "+cJobFile)	//"MATA330: Erro de aplicacao na thread de transferencia" ## "Thread numero : "
									Final(STR0169)				//"MATA330: Erro de aplicacao na thread de transferencia"
								EndIf
							// THREAD PROCESSADA CORRETAMENTE
							Case GetGlbValue(cJobAux) == '3'
								If File(cJobFile)
									nHdl := FOpen( cJobFile, FO_READ+FO_EXCLUSIVE )
									If nHdl > -1
										FClose(nHdl)
										If File(cJobFile)
											fErase(cJobFile)
										EndIf
									EndIf
								EndIf
								// Limpa variavel global de controle de thread
								ClearGlbValue(cJobAux)
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Atualiza o log de processamento			    ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								M330PrcLog("MENSAGEM",STR0170 + StrZero(nX,3) +STR0067+cFilAnt +" - Ok",STR0170 + StrZero(nX,3) + " - Ok ")	//"Termino Transferencia Filiais Thread : #### - Ok"
								Exit
						EndCase
						Sleep(2500)
					End
				Next nX
			EndIf
		EndIf
	Next nForFilial

	A330JobManual("2",cSemaforo , "M330TJOBCONNECT" )

	M330PrcLog("MENSAGEM",OemToAnsi(STR0092),OemToAnsi(STR0092), '5') // "Processamento das Transferencias entre Filiais - (1) Termino"

EndIf
// Restaura filial original apos processamento
cFilAnt:=cFilBack
RestArea(aTrbArea)
aSize(aTrbArea,0)
aTrbArea := nil
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o    ³ A330RecTrf                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Autor     ³ Rodrigo de Almeida Sartorio              ³ Data ³ 29/01/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Recupera custo da origem da transferencia entre filial     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³ ExpA1 = Array que devera retornar as informacoes de custo  ³±±
±±³           ³ ExpA2 = Array com informacoes dos movimentos de origem de  ³±±
±±³           ³         transferencia entre filiais                        ³±±
±±³           ³ ExpL3 = Variavel que indica se esta processando FIFO       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A330RecTrf(aRet,oListaTrf,lCusFifo,lCstPart,aRegraCP)
Local lRet:=.F.
Local lM330TRF := SuperGetMv("MV_M330TRF",.F.,.F.)
Local aRetCFil := {}
Local aFound
Local cKeySeek := TRB->TRB_FILTRA+cFilAnt+TRB->TRB_DOC+TRB->TRB_SERIE+alltrim(TRB->TRB_ITEM)

Default lCusFifo:= .F.
// Pesquisa no array de custos de transferencia
aFound := oListaTRF[cKeySeek]

If !aFound == nil .and. QtdComp(aFound[6]) == QtdComp(TRB->TRB_QUANT)
	lRet:=.T.
	If lCusFifo
		aRet:={NIL,aFound[8],aFound[9],Nil}
		lRet:=.F.  //força buscar o custo origem
	Else
		aRet:={aFound[8],NIL,aFound[9],aFound[10]}
	EndIf
	aSize(aFound,0)
	aFound := nil
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³P.E executado somente se nao encontrou referencia ³
//³no array de custos de transferencia               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lMA330TRF .And. !lRet .And. !Empty(TRB->TRB_USATRA)
	uRet := ExecBlock("MA330TRF", .F., .F., {aRet,TRB->TRB_FILIAL,TRB->TRB_FILTRA,TRB->TRB_COD,TRB->TRB_RECNO,lCusFifo})
	If ValType(uRet) == "A" .And. Len(uRet) == 3
		lRet := .T.
		aRet := uRet
	EndIf
EndIf

// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// ³ Com o parametro MV_M330TRF ativo, retorna o custo da NF  ³
// ³ de Origem quando em periodos de fechamento diferentes    ³
// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lM330TRF .And. !lRet .And. !Empty(TRB->TRB_USATRA) .And. TRB->TRB_ALIAS == "SD1"
	aRetCFil := M330TrfOri(TRB->TRB_FILIAL,TRB->TRB_FILTRA,TRB->TRB_DOC,TRB->TRB_SERIE,TRB->TRB_COD,TRB->TRB_TIPONF,TRB->TRB_QUANT,TRB->TRB_ITEM,lCstPart,aRegraCP)
	If ValType(aRetCFil) == "A"
		aRet := aClone(aRetCFil)
		lRet := .T.
	EndIf
EndIf

aSize(aRetCFil,0)
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o    ³ A330Contab                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Autor     ³ Rodrigo de Almeida Sartorio              ³ Data ³ 29/01/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Processa geracao de lancamentos contabeis                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³ ExpC1 = Nome do processo utilizado na funcao ProcLogAtu    ³±±
±±³           ³ ExpC2 = Nome do arquivo de trabalho                        ³±±
±±³           ³ ExpC3 = DESCONTINUADO									   ³±±
±±³           ³ ExpA4 = Array com as filiais selecionadas                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A330Contab(cProcLog,cNomTRC,cNomTRC1,aFilsCalc)
Static aCt5 := {}	 // Variavel para armazenar os lancamentos padroes envolvidos na rotina - Melhora de perfomance na DetProva para SigaCTB

// Numero de threads para processamento
LOCAL nThreads  := 1
// Array com controle dos registros para cada thread
LOCAL aThreads  := {}
// Numero de registros
LOCAL nRegistros:= 0
LOCAL nRegProc  := 0
LOCAL nInicio   := 0
LOCAL nValLancto:= 0
// Contador
LOCAL nX         :=0
LOCAL nZ         :=0
LOCAL nForFilial :=0
// Id do arquivo de log
LOCAL nHdl
// Variaveis utilizadas na contabilizacao
LOCAL nHdlPrv    :=NIL	// Endereco do arquivo de contra prova dos lanctos cont.
LOCAL nTotal     :=0	// Total dos lancamentos contabeis
LOCAL nTotRead   :=0   	// Total lido da thread
LOCAL cLoteEst   :=""	// Numero do lote para lancamentos do estoque
LOCAL cArquivo   :=""	// Nome do arquivo contra prova
LOCAL aDadosProva:={}  // Array com dados gerados na abertura do lancamento
LOCAL cArray     :=""
// Retorna o StartPath
LOCAL cStartPath := ""
//Array auxiliar para controle de Jobs
LOCAL cJobFile	 := ""
LOCAL cJobAux    := ""
// Controle de tentativas
LOCAL nRetry_0   := 0
LOCAL nRetry_1   := 0
// Variaveis para o reprocessamento contabil
LOCAL dReproc
LOCAL aAuxFil    := {}
// Sempre processar saldo tipo 1 - Real
LOCAL aTpSaldo   := {"1"}
LOCAL aAuxTpSld  := {"1"}
// Utilizado para verificar se gera tabela CV3
LOCAL lProcCV3

//Variaveis para gravação do código de correlativo
Local aDiario	:= {}
Local lSeqCorr

Local cListaFil

Local nI := 0
LOCAL cIDThread
LOCAL cSemaforo
Local cSubRotina := ''
Local cChaveSeq as character
Local cQuery

// Rotina default da contabilizacao
DEFAULT cProcLog :="MATA330"
DEFAULT aFilsCalc:= {}

// tras a lista de filiais envolvidas
cListaFil := A330Lista(aFilsCalc)

// contagem de registros por filial
a330RegCTB := a330RegFil(cListaFil,cNomTRC)

If Len(a330RegCTB)>0

	//
	CtbIniLan()

	cFilBack   := cFilAnt
	cStartPath := GetSrvProfString("Startpath","")
	dReproc    := a330ParamZX[01]
	lProcCV3   := SuperGetMv("MV_PROCCV3",.F.,.T.)
	lSeqCorr   := UsaSeqCor("SD3/SF1/SF2")

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ PE Inicio contabilizacao                    |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ExistBlock("MA330PGI")
		ExecBlock("MA330PGI",.F.,.F.)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica a quantidade de threads da primeira filial selecionada  |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nForFilial := 1 to Len(aFilsCalc)
		If aFilsCalc[nForFilial,1]
			// Altera filial corrente
			cFilAnt:=aFilsCalc[nForFilial,2]
			// Recupera a quantidade de threads
			_MV_M330THR := iif(_MV_M330THR == NIL, SuperGetMv('MV_M330THR',.F.,1), _MV_M330THR)
			nThreads := _MV_M330THR
			Exit
		EndIf
	Next nForFilial

	// Restaura filial original apos processamento
	cFilAnt:=cFilBack

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o log de processamento			    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	// mesma funcionalidade do proclogini
	oJourneyLog:llimpaSub := .F.
	oJourneyLog:logIni()
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o log de processamento			    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If oJourneyLog:nCondition == 1
		oJourneyLog:idMovD3X()
	elseIF oJourneyLog:nCondition == 4 .or. oJourneyLog:nCondition == 2
		oJourneyLog:idMovCV8()
	EndIf
	M330PrcLog("INICIO")
	M330PrcLog("MENSAGEM",OemToAnsi(STR0094),OemToAnsi(STR0094)) //"Geração de Lançamentos Contabeis - (0) Iniciando"

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Carrega array de adiario para gravação do correlativo³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lSeqCorr
		TRC->(dbGoTop())
		While TRC->(!EOF())
			If TRC->TRC_ALIAS == "SD3"
				SD3->(dbGoto(TRC->TRC_RECTRC))
				aAdd(aDiario, {"SD3",SD3->(Recno()),SD3->D3_DIACTB,"D3_NODIA","D3_DIACTB"})
			EndIf
			TRC->(dbSkip())
		EndDo
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ CONTABILIZACAO MULTI-THREADS                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Contabilizacao multi-thread somente SIGACTB e MV_CUSTEXC = N ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nThreads > 1 .And. !l330ArqExcl

		dbSelectArea("TRC")
		dbGoTop()

		If !lBat .And. !IsBlind()
			ProcRegua(nThreads*Len(a330RegCTB),16,4)
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica Limite Maximo de 30 Threads	    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nThreads > 30
			nThreads := 30
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o log de processamento			    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		M330PrcLog("MENSAGEM",OemToAnsi(STR0123),OemToAnsi(STR0123)) //"Iniciando Geracao do Arquivo de Contra-Prova"

		cIDThread := cValToChar(ThreadID())
		cSemaforo := "M330JCTB_"+cIDThread+"_"+CEMPANT
		A330JobManual("1", cSemaforo, "M330JCTBCONNECT" )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica numero de registros e cria array de threads.  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nZ:=1 to Len(a330RegCTB)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Posiciona registros para lancamento contabil                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cFilAnt:=a330RegCTB[nZ,1]
			aCt5 := {}
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Posiciona numero do Lote para Lancamentos do Estoque         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SX5")
			dbSeek(xFilial()+"09EST")
			cLoteEst:=IIf(!Eof(),Trim(X5Descri()),"EST ")
			cArquivo:=""    // Nome do arquivo contra prova
			nTotal  := 0    // Total dos lancamentos contabeis

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria o cabecalho do arquivo de prova                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nHdlPrv := A330HEAD(cLoteEst,"MATA330",Pad(Subs(cUsuario,7,6),6),@cArquivo,aDadosProva)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Armazena dados do cabecalho                                  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			a330RegCTB[nZ,3]:=nHdlPrv
			a330RegCTB[nZ,4]:=cLoteEst
			a330RegCTB[nZ,5]:=cArquivo

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Processa os primeiros lancamentos com a DetProva para gerar o|
			//| codigo sequencial do lancamento e informar o codigo para as  |
			//| Threads no array aDadosProva.                                |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

			// Contador de registros processados
			nRegProc := 0

			// Posiciona no registro inicial
			dbSelectArea("TRC")
			dbSeek(a330RegCTB[nz,1])

			While !Eof() .And. TRC_FILIAL == cFilAnt .And. aDadosProva[5] == -5

				// Posiciona arquivo e registro
				dbSelectArea(TRC->TRC_ALIAS)
				// Posiciona registro
				dbGoto(TRC->TRC_RECTRC)
				// Posiciona registro na tabela SB1
				SB1->(MsGoto(TRC->TRC_RECSB1))
				// Posiciona registro na tabela SF4
				If TRC->TRC_ALIAS <> "SD3"
					SF4->(MsGoto(TRC->TRC_RECSF4))
				Else
					If SD3->D3_DTLANC != dDataBase
						RecLock("SD3",.F.)
						SD3->D3_DTLANC := dDataBase
						SD3->(MsUnLock())
					EndIf
					If TRC->TRC_RECSGS > 0
						SGS->(dbGoto(TRC->TRC_RECSGS))
					EndIf
				EndIf

				nValLancto:=DETPROVA(nHdlPrv,TRC->TRC_LANTRC,TRC->TRC_ROTTRC,cLoteEst,,,,,IIf(lProcCV3,Nil,''),aCt5,,,,aDadosProva)
				nTotal += nValLancto
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Quebra utilizada para contabilizar Lancamentos 667/669 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If a330ParamZX[12] == 2 .And. TRC->TRC_LANTRC $ "667#669"
					If nValLancto > 0
						dbSelectArea("TRC")
						dbSkip()
						If TRC->TRC_AVALTR == "S"
							// Altera o flag para processar o proximo lancamento
							RecLock("TRC",.F.)
							Replace TRC->TRC_AVALTR With "N"
							TRC->(MsUnLock())
						EndIf
					EndIf
				EndIf
				nRegProc ++
				dbSelectArea("TRC")
				dbSkip()
			End
			n667669 := 0

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica numero de registros a serem processados             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nRegistros := a330RegCTB[nZ,2]

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Quantidade de registros a processar                          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			//a330RegCTB[nZ,6] := (nRegistros - nRegProc)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Analisa a quantidade de Threads X nRegistros                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If a330RegCTB[nZ,2] == 0
				aAdd(aThreads,{})
				Loop							// Nao ha lancamentos para processar
			ElseIf a330RegCTB[nZ,2] < nThreads
				aAdd(aThreads,ARRAY(1))			// Processa somente em uma thread
			Else
				aAdd(aThreads,ARRAY(nThreads))	// Processa com o numero de threads informada
			EndIf

			// Registro Inicial para contabilizacao
			nInicio := nRegProc + 1

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Calcula o registro original de cada thread e     ³
			//³ aciona thread gerando arquivo de fila.           ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For nX:=1 to Len(aThreads[nZ])

				aThreads[nZ,nX]:={0,0,""}

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Na primeira thread registro inicial 2       ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If nX == 1 .Or. (nX # 1 .And. aThreads[nZ,nX-1,2] # (nRegistros))
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Calculo para quebra de registros entre as Threads ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

					// Registro inicial para processamento
					aThreads[nZ,nX,1] := IIf( nX==1, nInicio, aThreads[nZ,nX-1,1]+aThreads[nZ,nX-1,2] )

					// Quantidade de registros a processar
					aThreads[nZ,nX,2] := IIf( nX==Len(aThreads[nZ]), nRegistros-nRegProc, Int((nRegistros-nInicio)/nThreads) )

					// Nome do arquivo de semaforo da thread
					aThreads[nZ,nX,3] := cStartPath+cEmpAnt+cFilAnt+StrZero(nX,2)+".CT"

					// Total de Registros Processados
					nRegProc += aThreads[nZ,nX,2]

					//
					// obtem a chave de inicio para busca na tabela TRC na working Thread
					//
					cQuery := "SELECT TRC_SEQUEN FROM ( "
					cQuery += "	SELECT TRC_SEQUEN ,ROW_NUMBER() OVER (ORDER BY TRC_SEQUEN ) SEQUENCIAL "
					cQuery += " FROM " +cNomTRC+ " "
					cQuery += "WHERE D_E_L_E_T_= ' ' "
					cQuery += "AND TRC_FILIAL = '"+a330RegCTB[nZ,1]+ "' "
					cQuery += " ) TMP "
					cQuery += " WHERE SEQUENCIAL = "+cValToChar(aThreads[nZ,nX,1])+" "

					cChaveSeq := MpSysExecScalar(cQuery,"TRC_SEQUEN")

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Quebra utilizada para contabilizar Lancamentos 667/669 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If a330ParamZX[12] == 2 .And. nX # Len(aThreads[nZ])
						// Posiciona no Ultimo Registro a ser processado
						dbSeek(cFilAnt+StrZero(nRegProc,10,0))
						// Checa se o lancamento atual e 667/669
						If TRC->TRC_LANTRC $ "667#669"
							aThreads[nZ,nX,2] := aThreads[nZ,nX,2] + 1
							nRegProc++
						EndIf
					EndIf

					// Inicializa variavel global de controle de thread
					cJobAux:="C"+cEmpAnt+cFilAnt+StrZero(nX,2)
					A330LckGlb(cJobAux)
					PutGlbValue(cJobAux,"0")
					A330ULckGlb(cJobAux)

					// mesma funcionalidade do proclogini
					oJourneyLog:logIni()
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o log de processamento			    ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If oJourneyLog:nCondition == 1
						oJourneyLog:idMovD3X()
					elseIF oJourneyLog:nCondition == 4 .or. oJourneyLog:nCondition == 2
						oJourneyLog:idMovCV8()
					EndIf

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o log de processamento			    ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					M330PrcLog("MENSAGEM",STR0188 + StrZero(nX,3) +STR0067+" "+cFilAnt,STR0188+StrZero(nX,3)) //"Geracao do Arquivo de Contra-Prova - Thread: "

					nRetry_1 := 1  // Numero de tentativas de execucao

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Dispara thread para contabilizar            ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					while ! IPCGO( cSemaforo,cEmpAnt,cFilAnt,cNomTRC,NIL, cChaveSeq ,aThreads[nZ,nX,2],nZ,nX,nHdlPrv,cLoteEst,cArquivo,aDadosProva,aThreads[nZ,nX,3],lProcCV3,{cUserName,__cUserID},dDataBase,cNomTR2)
						for nI := 1 to 2
							sleep(1000)
						Next nI
					End

				EndIf

			Next nX

		Next nZ

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Incluido para aguardar tempo de abertura da tabela           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Inkey(1)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Chama CA100INCL para cada thread, verificando atraves de arquivo |
		//| se terminou de gerar lancamentos.                                ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("TRC")
		For nZ:=1 to Len(a330RegCTB)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Posiciona registros para lancamento contabil                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cFilAnt:=a330RegCTB[nZ,1]

			// Posiciona na filial a ser processada
			dbSeek(a330RegCTB[nZ,1])

			For nX:=1 to Len(aThreads[nZ])
				// Informacoes do semaforo
				cJobFile:= aThreads[nZ,nX,3]
				nHdl    := 0  // Endereco do arquivo de semaforo
				nRetry_0:= 1  // Numero de tentativas de execucao
				cJobAux := "C"+cEmpAnt+cFilAnt+StrZero(nX,2)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Analise das Threads em Execucao                              ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				While .T.
					Do Case
						// TRATAMENTO PARA ERRO DE SUBIDA DE THREAD
						Case GetGlbValue(cJobAux) == '0'
							If nRetry_0 > 50
								Conout(Replicate("-",65))
								Conout("MATA330: "+STR0133 + " " + StrZero(nX,3) + STR0067 + cFilAnt) //"MATA330: Nao foi possivel realizar a subida da thread"
								Conout(Replicate("-",65))
								M330PrcLog("ERRO", STR0133 + " " + StrZero(nX,3) + STR0067 + cFilAnt, STR0167)	//"Nao foi possivel realizar a subida da thread"
								Final(STR0133) //"Não foi possivel realizar a subida da thread"
							Else
								nRetry_0 ++
							EndIf

						// TRATAMENTO PARA ERRO DE CONEXAO
						Case GetGlbValue(cJobAux) == '1'
							If FCreate(cJobFile) # -1
								Conout(Replicate("-",65))
								Conout(STR0126) 			//"MATA330: Erro de conexao na thread de contabilizacao"
								Conout(STR0127 + cJobAux )	//"Thread numero : "
								Conout(STR0128)				//"Numero de tentativas excedidas"
								Conout(Replicate("-",65))
								Final(STR0126)				//"MATA330: Erro de conexao na thread de contabilizacao"
							EndIf

						// TRATAMENTO PARA ERRO DE APLICACAO
						Case GetGlbValue(cJobAux) == '2'
							If (nRetry_0 := FCreate(cJobFile)) # -1
								Sleep(5000)
								If GetGlbValue(cJobAux) # '2'	//-- Tratamento para falso positivo: quando thread muda entre as consultas
									FClose(nRetry_0)
									FErase(cJobAux)
									Loop
								EndIf
								Conout(Replicate("-",65))
								Conout(STR0131)				//"MATA330: Erro de aplicacao na thread de contabilizacao"
								Conout(STR0127+cJobAux)		//"Thread numero : "
								Conout(Replicate("-",65))
								M330PrcLog("ERRO", STR0131 + " - Thread: " + StrZero(nX,3) + STR0067 + cFilAnt)	//"MATA330: Erro de aplicacao na thread de contabilizacao"
								Final(STR0131)				//"MATA330: Erro de aplicacao na thread de contabilizacao"
							EndIf

						// THREAD PROCESSADA CORRETAMENTE
						Case GetGlbValue(cJobAux) == '3'
							If File(cJobFile) .And. ((nHdl:=FOpen(cJobFile)) > 0)
								// Limpa variavel global de controle de thread
								ClearGlbValue(cJobAux)
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Atualiza o log de processamento			    ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								M330PrcLog("MENSAGEM", STR0189 + StrZero(nX,3) + STR0067 + cFilAnt) //"Termino Geracao do Arquivo de Contra-Prova - Thread: "
								Exit
							ElseIf nRetry_0 <= 50	//-- Retry para esperar a thread liberar o arquivo
								nRetry_0 ++
							Else
								M330PrcLog("ERRO", STR0132 + " - Thread: " + StrZero(nX,3) + STR0067 +" "+ cFilAnt) //"Termino Geracao do Arquivo de Contra-Prova - Thread: "
								Final(STR0132) //"MATA330: Erro de abertura no arquivo de contabilização"
							EndIf
					EndCase
					Sleep(500)
				End

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Movimentacao do Cursor                                       ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !lBat .And. !IsBlind()
					IncProc(STR0125) //"Gerando Arquivo de Contra-Prova "
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Pega a primeira posicao do arquivo que identifica o NOVO Lay-Out ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If nHdl > 0
					nHdlPrv :="" // Endereco do arquivo de contra prova dos lanctos cont.
					cLoteEst:="" // Numero do lote para lancamentos do estoque
					cArquivo:="" // Nome do arquivo contra prova
					nTotRead:="" // Total dos lancamentos contabeis
					cArray  :="" // Variavel com conteudo do array
					fSeek(nHdl,0,0)
					fRead(nHdl,@cFilAnt,FWGETTAMFILIAL)			// Filial          12
					fRead(nHdl,@nHdlPRV,10)						// ID do arquivo   10
					nHdlPrv:=VAL(nHdlPrv)
					fRead(nHdl,@cLoteEst,15)					// Lote do arquivo 15
					fRead(nHdl,@nTotRead,18)					// Total           18
					fRead(nHdl,@cArquivo,20)					// Arquivo         20
					fRead(nHdl,@cArray,80)						// Array           80
					cLoteEst:=Alltrim(cLoteEst)
					cArquivo:=Alltrim(cArquivo)
					aDadosProva:=STR2Array(cArray,.F.)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Confere dados do cabecalho                                   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If a330RegCTB[nZ,3] == nHdlPrv .And. a330RegCTB[nZ,4] == cLoteEst
						nTotal+=VAL(nTotRead)
					EndIf
				EndIf
				// Fecha o arquivo da thread
				fClose(nHdl)
				// Apaga arquivo da thread
				If File(cJobFile)
					fErase(cJobFile)
				EndIf
			Next nX

			If ValType(nHdlPrv) == "N" .And. nHdlPrv <> 0
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Se ele criou o arquivo de prova ele deve gravar o rodape'    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				A330RODA(nHdlPrv,nTotal,aDadosProva)
				If nTotal > 0 .And. lLanctoOn	// So contabiliza se o parametro Contabiliza estiver "Sim"
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o log de processamento			    ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					M330PrcLog("MENSAGEM",OemToAnsi(I18N(STR0096,{cFilAnt})),OemToAnsi(I18N(STR0096,{cFilAnt}))) //"Contabilizando Lançamentos na filial: #1[D MG 01]" ## "Contabilizando Lançamentos na filial: #1[D MG 01]"

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Movimentacao do Cursor                                       ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !lBat .And. !IsBlind()
						IncProc(I18N(STR0096,{cFilAnt})) //"Contabilizando Lançamentos"
					EndIf

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ CA100INCL - Funcao utilizada para inclusao dos lancamentos contabeis. |
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					cA100Incl(cArquivo,nHdlPrv,3,cLoteEst,lDigita,lAglutina,Nil,a330ParamZX[01],Nil,Nil,aDadosProva,aDiario,aAuxTpSld,,,,oJourneyLog:cIdChild)

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ aTpSaldo - Tipos de saldos para reprocessamento contabil              |
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					For nX:=1 to Len(aAuxTpSld)
						If Ascan( aTpSaldo,aAuxTpSld[nX] ) == 0
							// Não reprocessar Saldo Tipo 9 - Help CT2_TPSALD
							If ValType (aAuxTpSld[nX]) == 'C' .And. aAuxTpSld[nX] <> '9'
								Aadd( aTpSaldo,aAuxTpSld[nX] )
							EndIf
						EndIf
					Next nX

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Analisa data final para execucao do reprocessamento contabil.         |
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					CT2->(DbSetOrder(1))
					CT2->(DbSeek(Soma1(xFilial("CT2")), .T.))	// Procuro a proxima filial
					CT2->(DbSkip(-1))							// Volto para o registro anterior
					//Maior data de reprocessamento dos saldos contabeis
					If CT2->CT2_FILIAL = xFilial("CT2") .And. CT2->CT2_DATA > dReproc
						dReproc := CT2->CT2_DATA
					EndIf
				EndIf
				fClose(nHdl)
			EndIf

		Next nZ

		cIDThread := cValToChar(ThreadID())
		cSemaforo := "M330JCTB_"+cIDThread+"_"+CEMPANT
		A330JobManual("2", cSemaforo, "M330JCTBCONNECT" )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ CONTABILIZACAO PADRAO (THREAD UNICA)              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Else

		For nZ:=1 to Len(a330RegCTB)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Posiciona registros para lancamento contabil                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cFilAnt:=a330RegCTB[nZ,1]
			aCt5 := {}
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Posiciona numero do Lote para Lancamentos do Estoque         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SX5")
			dbSeek(xFilial()+"09EST")
			cLoteEst:=IIF(!Eof(),Trim(X5Descri()),"EST ")
			nTotal  :=0     // Total dos lancamentos contabeis
			cArquivo:=""    // Nome do arquivo contra prova
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria o cabecalho do arquivo de prova                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nHdlPrv := A330HEAD(cLoteEst,"MATA330",Pad(Subs(cUsuario,7,6),6),@cArquivo)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o log de processamento			    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			M330PrcLog("MENSAGEM",OemToAnsi(STR0123) +STR0067+cFilAnt,OemToAnsi(STR0123)) //"Iniciando Geração do Arquivo de Contra-Prova"

			dbSelectArea("TRC")
			dbGoTop()
			dbSeek(cFilAnt)

			If !lBat .And. !IsBlind()
				ProcRegua(LastRec(),16,4)
			EndIf

			While !Eof() .And. TRC_FILIAL == cFilAnt
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Movimentacao do Cursor                                       ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !lBat .And. !IsBlind()
					IncProc(STR0125) //"Gerando Arquivo de Contra-Prova "
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Checa se deve processar registro                             ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If TRC->TRC_AVALTR == "N" .Or. (TRC->TRC_AVALTR == "S" .And. QtdComp(n667669,.T.) > QtdComp(0,.T.))
					// Posiciona arquivo e registro
					dbSelectArea(TRC->TRC_ALIAS)
					dbGoto(TRC->TRC_RECTRC)
					// Posiciona registro na tabela SB1
					SB1->(MsGoto(TRC->TRC_RECSB1))
					// Posiciona registro na tabela SF4
					If TRC->TRC_ALIAS <> "SD3"
						SF4->(MsGoto(TRC->TRC_RECSF4))
					Else
						If SD3->D3_DTLANC != dDataBase
							RecLock("SD3",.F.)
							SD3->D3_DTLANC := dDataBase
							SD3->(MsUnLock())
						EndIf
						If TRC->TRC_RECSGS > 0
							SGS->(dbGoto(TRC->TRC_RECSGS))
						EndIf
					EndIf
					// Gera lancamento
					nValLancto:=DETPROVA(nHdlPrv,TRC->TRC_LANTRC,TRC->TRC_ROTTRC,cLoteEst,,,,,IIf(lProcCV3,Nil,''),aCt5)
					nTotal+=nValLancto
					// Checa tipo de lancamento
					If TRC->TRC_LANTRC $ "667#669"
						n667669 := nValLancto
					Else
						n667669:=0
					EndIf
				EndIf
				dbSelectArea("TRC")
				dbSkip()
			End

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o log de processamento			    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			M330PrcLog("MENSAGEM",OemToAnsi(STR0124) +STR0067+cFilAnt,OemToAnsi(STR0124)) //"Termino da Geração do Arquivo de Contra-Prova"

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se existem informacoes para fechar lancamento       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nHdlPrv != NIL
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Se ele criou o arquivo de prova ele deve gravar o rodape'    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				A330RODA(nHdlPrv,nTotal)
				If nTotal > 0 .And. lLanctoOn	// So contabiliza se o parametro Contabiliza estiver "Sim"
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o log de processamento			    ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					M330PrcLog("MENSAGEM",OemToAnsi(I18N(STR0096,{cFilAnt})),OemToAnsi(I18N(STR0096,{cFilAnt}))) //"Contabilizando Lançamentos"

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Movimentacao do Cursor                                       ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !lBat .And. !IsBlind()
						IncProc(I18N(STR0096,{cFilAnt})) //"Contabilizando Lançamentos"
					EndIf

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ CA100INCL - Funcao utilizada para inclusao dos lancamentos contabeis. |
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					cA100Incl(cArquivo,nHdlPrv,3,cLoteEst,lDigita,lAglutina,Nil,a330ParamZX[01],Nil,Nil,Nil,aDiario,aAuxTpSld,,,,oJourneyLog:cIdChild)

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o log de processamento			    ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If oJourneyLog:nCondition == 1
						oJourneyLog:idMovD3X()
					elseIF oJourneyLog:nCondition == 4 .or. oJourneyLog:nCondition == 2
						oJourneyLog:idMovCV8()
					EndIf

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ aTpSaldo - Tipos de saldos para reprocessamento contabil              |
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					For nX:=1 to Len(aAuxTpSld)
						If Ascan( aTpSaldo,aAuxTpSld[nX] ) == 0
							// Não reprocessar Saldo Tipo 9 - Help CT2_TPSALD
							If ValType (aAuxTpSld[nX]) == 'C' .And. aAuxTpSld[nX] <> '9'
								Aadd( aTpSaldo,aAuxTpSld[nX] )
							EndIf
						EndIf
					Next nX

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Analisa data final para execucao do reprocessamento contabil.         |
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					CT2->(DbSetOrder(1))
					CT2->(DbSeek(Soma1(xFilial("CT2")), .T.))	// Procuro a proxima filial
					CT2->(DbSkip(-1))							// Volto para o registro anterior
					//Maior data de reprocessamento dos saldos contabeis
					If CT2->CT2_FILIAL = xFilial("CT2") .And. CT2->CT2_DATA > dReproc
						dReproc := CT2->CT2_DATA
					EndIf
				EndIf
			EndIf

		Next nZ

	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Carrega array auxiliar de filiais           |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nForFilial := 1 to Len(aFilsCalc)
		If aFilsCalc[nForFilial,1]
			// Altera filial corrente
			cFilAnt:=aFilsCalc[nForFilial,2]
			// Adiciona filial no array auxiliar
			aAdd(aAuxFil,cFilAnt)
		EndIf
	Next nForFilial
	// Restaura filial original apos processamento
	cFilAnt:=cFilBack

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Reprocessamento Contabil para CA100INCL()            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(aAuxFil)
		A330Reproc(aAuxFil,dInicio,dReproc,aTpSaldo,"cA100Incl")
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ PE final da contabilizacao                  |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ExistBlock("MA330PGF")
		ExecBlock("MA330PGF",.F.,.F.)
	EndIf
	// mesma funcionalidade do proclogini
	oJourneyLog:logIni()
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o log de processamento			    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If oJourneyLog:nCondition == 1
		oJourneyLog:idMovD3X()
	elseIF oJourneyLog:nCondition == 4 .or. oJourneyLog:nCondition == 2
		oJourneyLog:idMovCV8()
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o log de processamento			    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	M330PrcLog("MENSAGEM",OemToAnsi(STR0095),OemToAnsi(STR0095)) //"Geração de Lançamentos Contabeis - (1) Termino"

	// Filial corrente a ser considerada
	cFilAnt:=cFilBack

	CtbFinLan()

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
	// Telemetria - Uso da classe FwCustomMetrics                          //
	// Metrica - setAverageMetric                                          //
	// Grava se utiliza se utiliza Consumo ou Produção para o processamento//
	// do recalculo do custo medio.                                        //
	//?ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
	If a330ParamZX[12] == 1
		cSubRotina := 'CONSUMO'
	ElseIf a330ParamZX[12] == 2
		cSubRotina := 'PRODUCAO'
	EndIf

	If !Empty(cSubRotina) .and. FWLibVersion() >= "20210628"
		FWCustomMetrics():setAverageMetric(	cSubRotina/*cSubRoutine*/,;
											"estoque-custos-protheus_recalculo-do-custo-medio-contabilizacao-por-consumo-e-producao_count" /*cIdMetric*/,;
											1 /*nValue*/,;
											/*dDateSend*/,;
											/*nLapTime*/,;
											"MATA330"/*cRotina*/)
	EndIf
EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³ MATA330_V ³ Autor ³ Rodrigo de A Sartorio³ Data ³ 06/02/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao utilizada para verificar a ultima versao do fonte   ³±±
±±³			 ³ mata330 aplicado no rpo do cliente, verificando assim a    ³±±
±±³			 ³ necessidade de uma atualizacao neste fonte.		    	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ EST/PCP/FAT/COM	                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MATA330_V
Local nRet := 20140916 // 16 de setembro de 2014
Return nRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³ A330CustoCQ³ Autor ³Marcos V. Ferreira   ³ Data ³ 03/05/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao utilizada para retornar os custos do movimento      ³±±
±±³          ³ original que gerou o D7_TIPO = 0, referente a entrada no CQ³±±
±±³          ³ (Somente para D7_ORIGLAN = "PR"	- Producao)				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Numero do Documento                                ³±±
±±³          ³ ExpC2 = Codigo do Produto                                  ³±±
±±³          ³ ExpC3 = Codigo do Armazem de CQ                            ³±±
±±³          ³ ExpC4 = Numero Sequencial                                  ³±±
±±³          ³ ExpA4 = Array com os custos do movimento nas 5 moedas      ³±±
±±³          ³ ExpL1 = Indica se retorna o custo de reposicao             ³±±
±±³          ³ ExpA5 = Array com os custos de reposicao                   ³±±
±±³          ³ ExpA6 = Array com os custos em partes                      ³±±
±±³          ³ ExpN1 = Numero de Partes utilizadas no custo em partes     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A330CustoCQ(cDocumento,cProduto,cLocalCQ,cNumSeq,aCM,lCusRep,aCMRep,aRetPartes,nPartes,lCstPart)
Local aAreaAnt   := GetArea()
Local aAreaSD3   := SD3->(GetArea())
Local aAreaSD7   := SD7->(GetArea())
Local lRet		 := .F.
Local cSeek		 := ""

Default aCMRep     := {0,0,0,0,0}
Default lCusRep    := .F.
Default lCstPart   := .F.

If SubStr(SD3->D3_CF,3,1) $ "RE6|DE6" .And. QtdComp(SD3->D3_QUANT) > QtdComp(0)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o movimento e referente a liberacao de CQ Producao ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SD7")
	dbSetOrder(3)
	If MsSeek(xFilial("SD7")+cProduto+cNumSeq+cDocumento)
		If Alltrim(SD7->D7_ORIGLAN) $ "TR|PR"
			dbSelectArea("SD7")
			dbSetOrder(2) //D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL+D7_NUMSEQ+D7_TIPO
			MsSeek(cSeek := xFilial("SD7")+SubStr(cDocumento,1,Len(D7_NUMERO))+cProduto+cLocalCQ)
			Do While !SD7->(Eof()) .And. cSeek == SD7->(D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL)
				//-- Valida somente os registro de entrada no CQ de Producao
				If StrZero(SD7->D7_TIPO,1) == '0' .And. AllTrim(SD7->D7_ORIGLAN) $ "TR|PR"
					dbSelectArea("SD3")
					dbSetOrder(3) //D3_FILIAL+D3_COD+D3_LOCAL+D3_NUMSEQ
					//-- Procura pelo movimento de Origem do CQ
					If MsSeek(xFilial("SD3")+SD7->D7_PRODUTO+SD7->D7_LOCAL+SD7->D7_NUMSEQ)
						If lCstPart
							aRetPartes := PegaCMPFim("D3_CP",lCstPart,nPartes,SD3->D3_QUANT)
						EndIf
						aCM := PegaCMD3() //-- Retorna o Custo do Movimento Origem
						If lCusRep
							aCMRep  := PegaCMD3(lCusRep)
						EndIf
						lRet   := .T.
					EndIf
					Exit
				EndIf
				dbSelectArea("SD7")
				dbSkip()
			EndDo
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se o movimento e referente a liberacao de CQ de NFE   |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		ElseIf SD7->D7_ORIGLAN == "CP"
			dbSelectArea("SD7")
			dbSetOrder(2) //D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL+D7_NUMSEQ+D7_TIPO
			MsSeek(cSeek := xFilial("SD7")+SubStr(cDocumento,1,Len(D7_NUMERO))+cProduto+cLocalCQ)
			Do While !SD7->(Eof()) .And. cSeek == SD7->(D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL)
				//-- Valida somente os registro de entrada no CQ (Documento de Entrada)
				If StrZero(SD7->D7_TIPO,1) == '0' .And. SD7->D7_ORIGLAN == "CP"
					dbSelectArea("SD1")
					dbSetOrder(5) //D1_FILIAL+D1_COD+D1_LOCAL+D1_NUMSEQ
					//-- Procura pelo movimento de Origem do CQ
					If MsSeek(xFilial("SD1")+SD7->D7_PRODUTO+SD7->D7_LOCAL+SD7->D7_NUMSEQ)
						aCM := PegaCMD1() //-- Retorna o Custo do Movimento Origem
						If lCstPart
							aRetPartes := PegaCMPFim("D1_CP",lCstPart,nPartes,SD1->D1_QUANT)
						EndIf
						If lCusRep
							aCMRep  := PegaCMD1(lCusRep)
						EndIf
						lRet   := .T.
					EndIf
					Exit
				EndIf
				dbSelectArea("SD7")
				dbSkip()
			EndDo
		EndIf
	EndIf
EndIf
RestArea(aAreaSD7)
aSize(aAreaSD7,0)
aAreaSD7 := nil

RestArea(aAreaSD3)
aSize(aAreaSD3,0)
aAreaSD3 := nil

RestArea(aAreaAnt)
aSize(aAreaAnt,0)
aAreaAnt := nil
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A330CusFil  |Autor  ³Marcos V. Ferreira   ³ Data ³ 07/08/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Acerta o parametro MV_CUSFIL                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   | ExpL1 = .T. Utiliza custo unificado por Empresa/Filial     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A330CusFil()
Return SuperGetMV('MV_CUSFIL',.F.,"A") $ "F|E"

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GravaRegCT³ Autor ³Rodrigo de A Sartorio  ³ Data ³ 18/08/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava registro no arquivo de trabalho para contabilizacao  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cFilTRC    = Endereco do arquivo de contra-prova           ³±±
±±³          ³ cAliasTRC  = Alias do Movimento SD1/SD2/SD3                ³±±
±±³          ³ nRecTRC    = Numero do Registro do Movimento               ³±±
±±³          ³ cSeqTRC    = Codigo sequencial do Movimento                ³±±
±±³          ³ cLanctoTRC = Numero do Lancamento Padrao                   ³±±
±±³          ³ cRotTRC    = Rotina que originou a chamada da funcao       ³±±
±±³          ³ lProcLanc  = Avalia Lancamentos 667/669                    ³±±
±±³          ³ nRecSB1    = Registro do SB1                               ³±±
±±³          ³ nRecSF4    = Registro do SF4                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function GravaRegCT(cFilTRC,cAliasTRC,nRecTRC,cSeqTRC,cLanctoTRC,cRotTRC,lProcLanc,nRecSB1,nRecSF4,nRecSGS)
Local nSequencia as Numeric
Local aStruct    as array

// define o nome das tabelas auxiliares do recalculo de custo
DefNomTrb()

If oBulk == nil
	aStruct := {}
	AADD(aStruct,{'TRC_FILIAL'})
	AADD(aStruct,{'TRC_ALIAS'})
	AADD(aStruct,{'TRC_RECTRC'})
	AADD(aStruct,{'TRC_SEQTRC'})
	AADD(aStruct,{'TRC_LANTRC'})
	AADD(aStruct,{'TRC_ROTTRC'})
	AADD(aStruct,{'TRC_AVALTR'})
	AADD(aStruct,{'TRC_RECSB1'})
	AADD(aStruct,{'TRC_RECSF4'})
	AADD(aStruct,{'TRC_RECSGS'})
	AADD(aStruct,{'TRC_SEQUEN'})

	//- cria o Objeto para Bulk com limite de 1000
	oBulk := FwBulk():New(cNomTRC,1000)
	oBulk:SetFields(aStruct)

	aSize(aStruct,0)
	aStruct := nil
EndIf

//- Garante que apenas um pegue o ID
A330LckGlb(cKeyRegCT)

//- pega o valor para a sequencia
GetGlbVars(cKeyRegCT,nSequencia)

nSequencia ++

//- atualiza o valor para
PutGlbVars(cKeyRegCT,nSequencia)
A330ULckGlb(cKeyRegCT)

oBulk:AddData({cFilTRC,cAliasTRC,cValToChar(nRecTRC),cSeqTRC,cLanctoTRC,cRotTRC,If(lProcLanc,"S","N"),;
	cValToChar(nRecSB1),cValToChar(nRecSF4),cValToChar(nRecSGS),cFilTRC+StrZero(nSequencia,10)})

RETURN

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GETTRSTRU ³ Autor ³Rodrigo de A Sartorio  ³ Data ³ 10/08/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna a estrutura do arquivo de trabalho para o recalculo ³±±
±±³          ³do custo medio realizar as contabilizacoes.                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GetTRStru(nOpc)
Local aRet := {}

Default nOpc := 1

If nOpc == 1 //-- Campos
	AADD(aRet,{ "TRC_FILIAL","C", TamSX3("B1_FILIAL")[1],0 } )
	AADD(aRet,{ "TRC_SEQUEN"	,"C",22,0 } )
	AADD(aRet,{ "TRC_ALIAS"	,"C",03,0 } )
	AADD(aRet,{ "TRC_RECTRC"	,"N",14,0 } )
	aTam:= TamSX3(MaiorCampo("D1_SEQCALC;D2_SEQCALC;D3_SEQCALC"))
	AADD(aRet,{ "TRC_SEQTRC"	,"C",aTam[1],0 } )
	AADD(aRet,{ "TRC_LANTRC"	,"C",03,0 } )
	AADD(aRet,{ "TRC_ROTTRC"	,"C",07,0 } )
	AADD(aRet,{ "TRC_AVALTR"	,"C",01,0 } )
	AADD(aRet,{ "TRC_RECSB1"	,"N",14,0 } )
	AADD(aRet,{ "TRC_RECSF4"	,"N",14,0 } )
	AADD(aRet,{ "TRC_RECSGS"	,"N",14,0 } )
Else //-- Indices
	AADD(aRet,"TRC_FILIAL+TRC_SEQUEN")
EndIf
Return (aRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MTA330IsMNT ³ Autor ³ Lucas               ³ Data ³ 03.10.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se ha integracao com o modulo SigaMNT/NG          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function MTA330IsMNT()
Local aArea      := GetArea()
Local cProdMNT   := SuperGetMv("MV_PRODMNT",.F.,"MANUTENCAO")
Local lIntegrMNT := .F.

SB1->(DbSelectArea( "SB1" ))
SB1->(DbSetOrder(1))
If SB1->(MSSeek( xFilial('SB1') + cProdMNT))
	lIntegrMNT := .T.
EndIf
RestArea(aArea)
aSize(aArea,0)
aArea := nil
Return( lIntegrMNT )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³IsFechFifo  ³ Autor ³ Marcos V. Ferreira  ³ Data ³ 22.11.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica a utilizacao da nova rotina de Fechamento Fifo    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function IsFechFifo()
Local lRet := .F.
lRet := .T.
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A330Reproc  ³ Autor ³ Marcos V. Ferreira  ³ Data ³ 22.03.07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Reprocessamento Contabil para o MATA330                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array com a lista de filiais contabilizadas        ³±±
±±³          ³ ExpD2 = Data inicial de reprocessamento                    ³±±
±±³          ³ ExpD3 = Data final de reprocessamento                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A330Reproc(aAuxFil,dInicio,dFim,aTpSaldo,cProcesso)
Local nForFilial := 0
Local nTipoSaldo := 0
Local cFilIni    := ""
Local cFilFim    := ""
Local aAreaAnt   := GetArea()
Local lReproc    := SuperGetMv('MV_A330190',.F.,"S") == "S"

Default aTpSaldo  := {"1"}  // Sempre processar saldo tipo 1 - Real
Default aAuxFil   := {}

Default cProcesso := ""

If lReproc

	M330PrcLog("MENSAGEM",OemToAnsi(STR0224)+" - "+cProcesso,OemToAnsi(STR0224))

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ordena filiais processadas                            |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	ASORT(aAuxFil,,,{ |x, y| x < y })
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Se for base compartilhada assume intervalo de filiais |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("CT2")
	If Empty(xFilial("CT2"))
		// Reprocessamento contabil base compartilhada
		For nTipoSaldo:=1 to Len(aTpSaldo)
			CTBA190(.T.,dInicio,dFim,"  ","ZZ",aTpSaldo[nTipoSaldo],.F.,"  " , .T.)
		Next nTipoSaldo
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Realiza o reprocessamento das filiais De/Ate |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(aAuxFil) == 1
			
			cFilAnt := aAuxFil[1]
			dInicio := SuperGetMv("MV_ULMES",.F.,SToD("19961231"))+1

			// Reprocessamento contabil apenas uma filial
			For nTipoSaldo:=1 to Len(aTpSaldo)
				CTBA190(.T.,dInicio,dFim,aAuxFil[1],aAuxFil[1],aTpSaldo[nTipoSaldo],.F.,"  ",.T.)
			Next nTipoSaldo

			cFilAnt := cFilBack
			dInicio := dIniBack
		Else
			// Reprocessamento contabil com varias filiais
			For nForFilial := 1 To Len(aAuxFil)
				oJourneyLog:llimpaSub := .F.
				oJourneyLog:cSubProc := 'MA330PROCESS'	
				If nForFilial == 1
					cFilIni := aAuxFil[nForFilial]
				Else
					If Soma1(aAuxFil[nForFilial-1]) # aAuxFil[nForFilial]
						For nTipoSaldo:=1 to Len(aTpSaldo)
							CTBA190(.T.,dInicio,dFim,cFilIni,cFilFim,aTpSaldo[nTipoSaldo],.F.,"  ",.T.)
						Next nTipoSaldo
						cFilIni := aAuxFil[nForFilial]
					ElseIf Len(aAuxFil) == nForFilial
						For nTipoSaldo:=1 to Len(aTpSaldo)
							CTBA190(.T.,dInicio,dFim,cFilIni,aAuxFil[nForFilial],aTpSaldo[nTipoSaldo],.F.,"  ",.T.)
						Next nTipoSaldo
					EndIf
				EndIf
				cFilFim := aAuxFil[nForFilial]
			Next nForFilial
		EndIf
	EndIf
	M330PrcLog("MENSAGEM",OemToAnsi(STR0225)+" - "+cProcesso,OemToAnsi(STR0225))
Else
	M330PrcLog("FIM")
EndIf
RestArea(aAreaAnt)
aSize(aAreaAnt,0)
aAreaAnt := nil
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A330Lista   ³ Autor ³ Marcos V. Ferreira  ³ Data ³ 05.04.07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Carrega a Lista de filiais a serem processadas             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array com a lista de filiais                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A330Lista(aFilsCalc)
Local nForFilial := 0
Local cRet       := ""

Default aFilsCalc := {}

For nForFilial := 1 to Len(aFilsCalc)
	If aFilsCalc[nForFilial,1]
		cRet += "'" + aFilsCalc[nForFilial,2] + "',"
	EndIf
Next nForFilial
cRet := Substr(cRet,1,Len(cRet)-1)

Return cRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A330FilNum  ³ Autor ³ Marcos V. Ferreira  ³ Data ³ 15.04.07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao utilizada para converter as filiais com codigo      ³±±
±±³          ³ caracter para codigo numerico /  MULT-THREAD               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo da Filial                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A330FilNum(cFil)
Local aAreaAnt  := GetArea()
Local aAreaSM0  := SM0->(GetArea())
Local nRet      := Val(cFil)
Local cSeek     := ''
Local nContador := 100

If cFil > '99' .Or. Len(cFil) > 2 .Or. SubStr(cFil,2,1) > '9' .Or. (cFil == Replicate("0",Len(cFil)))
	dbSelectArea("SM0")
	dbSetOrder(1)
	dbSeek(cSeek:=cEmpAnt)
	Do While !Eof() .And. cSeek == SM0->M0_CODIGO
		If AllTrim(cFil) == AllTrim(SM0->M0_CODFIL)
			nRet := nContador
			Exit
		EndIf
		nContador++
		dbSkip()
	EndDo
EndIf

RestArea(aAreaSM0)
aSize(aAreaSM0,0)
aAreaSM0 := nil

RestArea(aAreaAnt)
aSize(aAreaAnt,0)
aAreaAnt := nil
Return nRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³VerIDProc ³ Autor ³ Marcelo Pimentel      ³ Data ³24.07.2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Identifica a sequencia de controle do fonte ADVPL com a     ³±±
±±³          ³stored procedure, qualquer alteracao que envolva diretamente³±±
±±³          ³a stored procedure a variável sera incrementada.            ³±±
±±³          ³Procedure MAT004                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function VerIDProc()
Return '011'

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A330VldCal³ Autor ³ Marcos V. Ferreira    ³ Data ³20.08.2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida o calendario contabil a fim e evitar que a rotina    ³±±
±±³          ³inclua lancamentos em uma calendario ja encerrado.          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpD1 = Data Inicial                                       ³±±
±±³          ³ ExpD2 = Data Final                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A330VldCal(dDtIni,dDtFim)
Local lRet     := .F.
Local aAreaAnt := GetArea()
Local lVldIni  := .F.

//-- Verifica parametro de contabilizacao
If a330ParamZX[10] == 1 .Or. a330ParamZX[10] == 2
	lVldIni := SuperGetMv('MV_VLCLOTE',.F.,.F.)
	//-- Analisa Data Inicial e Data Final do processamento
	If (!lVldIni .and. !CtbDtComp(5,dDtIni,"01")) .Or. !CtbDtComp(5,dDtFim,"01")
		lRet := .T.
	ElseIf !CtbValiDt (Nil ,dDtIni,.T. ,Nil ,Nil ,{"EST001"}) .or. !CtbValiDt (Nil ,dDtFim,.T. ,Nil ,Nil ,{"EST001"})
		lRet := .T.
	EndIf
EndIf

RestArea(aAreaAnt)
aSize(aAreaAnt,0)
aAreaAnt := nil
Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A330AtuCM  ³ Autor ³ TOTVS S/A            ³ Data ³08.02.2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao utilizada para compatibilizar o custo unitario final ³±±
±±³          ³com o campo B2_CM para mater o legado.                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aFilsCalc - Filiais a serem processadas                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function A330AtuCM(aFilsCalc)
Local aAreaAnt
Local aAreaSB2
Local cAliasSB2  := "SB2"
Local cChave     := ""
Local cQuery     := ""
Local nForFilial := 0
Local nMax       := 0
Local nX         := 0
Local cSB2Filial

If SuperGetMv("MV_330ATCM",.F.,.F.)

	aAreaAnt   := GetArea()
	aAreaSB2   := SB2->(GetArea())

	// Tabela Compartilhada
	If Empty(xFilial("SB2"))

		if cMoeda330C == NIL
			cMoeda330C := SuperGetMv('MV_MOEDACM',.F.,"2345")
		EndIf

		M330PrcLog("MENSAGEM",STR0158,STR0158) //"Atualização do custo unitario de fechamento - (0) Iniciando"
		dbSelectArea("SB2")
		dbSetOrder(1)
		dbGoTop()
		Do While !Eof()
			RecLock("SB2",.F.)
			Replace B2_CM1     With B2_CMFIM1
			If "2" $ cMoeda330C
				Replace B2_CM2 With B2_CMFIM2
			EndIf
			If "3" $ cMoeda330C
				Replace B2_CM3 With B2_CMFIM3
			EndIf
			If "4" $ cMoeda330C
				Replace B2_CM4 With B2_CMFIM4
			EndIf
			If "5" $ cMoeda330C
				Replace B2_CM5 With B2_CMFIM5
			EndIf
			Replace B2_VATU1 With B2_QATU * B2_CMFIM1
			If "2" $ cMoeda330C
				Replace B2_VATU2 With B2_QATU * B2_CMFIM2
			EndIf
			If "3" $ cMoeda330C
				Replace B2_VATU3 With B2_QATU * B2_CMFIM3
			EndIf
			If "4" $ cMoeda330C
				Replace B2_VATU4 With B2_QATU * B2_CMFIM4
			EndIf
			If "5" $ cMoeda330C
				Replace B2_VATU5 With B2_QATU * B2_CMFIM5
			EndIf
			SB2->(MsUnLock())
			dbSkip()
		EndDo
		M330PrcLog("MENSAGEM",STR0159,STR0159) //"Atualização do custo unitario de fechamento - (1) Termino"
	// Tabela Exclusiva
	Else
		cSB2Table := RetSQLName("SB2")
		For nForFilial := 1 To Len(aFilsCalc)
			If aFilsCalc[nForFilial,1]
				// Altera filial corrente
				cFilAnt:=aFilsCalc[nForFilial,2]
				M330PrcLog("MENSAGEM",OemToAnsi(I18N(STR0227,{cFilAnt})), OemToAnsi(I18N(STR0227,{cFilAnt}))) //"Atualização do custo unitario de fechamento - Filial:#1[D MG 01] - (0) Iniciando"

				cSB2Filial := xFilial("SB2")

				cAliasSB2 := GetNextAlias()
				If Select(cAliasSB2) > 0
					(cAliasSB2)->(dbCloseArea())
				EndIf
				cQuery := "SELECT COUNT(R_E_C_N_O_) COUNTREG "
				cQuery += " FROM " +cSB2Table+ " "
				cQuery += " WHERE B2_FILIAL='" +cSB2Filial+ "' "
				cQuery +=   "AND B2_CMFIM1 > 0 "
				cQuery +=   "AND D_E_L_E_T_=' '"
				cQuery := ChangeQuery(cQuery)
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB2)
				nMax := (cAliasSB2)->COUNTREG
				dbCloseArea()
				dbSelectArea("SB2")
				cQuery := "UPDATE " +cSB2Table+ " "
				cQuery +=     " SET B2_CM1 = B2_CMFIM1 "
				If "2" $ cMoeda330C
					cQuery +=    ", B2_CM2 = B2_CMFIM2 "
				EndIf
				If "3" $ cMoeda330C
					cQuery +=    ", B2_CM3 = B2_CMFIM3 "
				EndIf
				If "4" $ cMoeda330C
					cQuery +=    ", B2_CM4 = B2_CMFIM4 "
				EndIf
				If "5" $ cMoeda330C
					cQuery +=    ", B2_CM5 = B2_CMFIM5 "
				EndIf
				cQuery += ", B2_VATU1 = B2_QATU * B2_CMFIM1 "
				If "2" $ cMoeda330C
					cQuery +=    ", B2_VATU2 = B2_QATU * B2_CMFIM2 "
				EndIf
				If "3" $ cMoeda330C
					cQuery +=    ", B2_VATU3 = B2_QATU * B2_CMFIM3 "
				EndIf
				If "4" $ cMoeda330C
					cQuery +=    ", B2_VATU4 = B2_QATU * B2_CMFIM4 "
				EndIf
				If "5" $ cMoeda330C
					cQuery +=    ", B2_VATU5 = B2_QATU * B2_CMFIM5 "
				EndIf
				cQuery += "WHERE R_E_C_N_O_ in ("

				For nX := 1 To nMax Step 4096
					cChave := "	SELECT R_E_C_N_O_ FROM ( "
					cChave += "	SELECT R_E_C_N_O_ ,ROW_NUMBER() OVER (ORDER BY R_E_C_N_O_ ) SEQUENCIAL "
					cChave += " FROM " +cSB2Table+ " "
					cChave += " WHERE B2_FILIAL = '" +cSB2Filial+"' and B2_CMFIM1 > 0 and D_E_L_E_T_ =' ' "
					cChave += " ) TMP "
					cChave += " WHERE SEQUENCIAL >="+cValToChar(nX)+" AND SEQUENCIAL <="+cValToChar(nX+4096)+" "

					TcSqlExec(cQuery+cChave+")")
				Next nX
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³A tabela e fechada para restaurar o buffer da aplicacao ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				SB2->(DbGoTo(SB2->(Recno()))) //Força refresh do cache
				TcRefresh(cSB2Table)

				M330PrcLog("MENSAGEM",OemToAnsi(I18N(STR0228,{cFilAnt})), OemToAnsi(I18N(STR0228,{cFilAnt}))) //"Atualização do custo unitario de fechamento - Filial:#1[D MG 01] - (1) Termino"
			EndIf
		Next nForFilial
		// Restaura filial original apos processamento
		cFilAnt:=cFilBack
	EndIf
	RestArea(aAreaSB2)
	aSize(aAreaSB2,0)
	aAreaSB2 := nil

	RestArea(aAreaAnt)
	aSize(aAreaAnt,0)
	aAreaAnt := nil
EndIf
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MA330LRep ³ Autor ³Microsiga S/A          ³ Data ³ 12/12/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Indica o log dos arquivos nao criados                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array com os logs dos arquivos nao criados         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MA330LRep(aLogsRep)
LOCAL oDlg,oQual,cVarq
DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0163) From 130,70 To 350,360 OF oMainWnd PIXEL //"Campo(s) nao criado(s) para Custo de Reposicao"
@ 10,13 TO 90,122 LABEL "" OF oDlg  PIXEL
@ 20,18 LISTBOX oQual VAR cVarQ Fields HEADER OemToAnsi(STR0030),OemToAnsi(STR0031) SIZE 100,62 NOSCROLL OF oDlg PIXEL //"Arquivo"###"Campo"
oQual:SetArray(aLogsRep)
oQual:bLine := { || {aLogsRep[oQual:nAt,1],aLogsRep[oQual:nAt,2]}}
DEFINE SBUTTON FROM 95,90 TYPE 2 ACTION oDlg:End() ENABLE OF oDlg PIXEL
ACTIVATE MSDIALOG oDlg CENTERED
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MA330AvRep³ Autor ³ Microsiga S/A         ³ Data ³ 12/12/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Avalia se sera utilizado o Custo de Reposicao no Sistema   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpL1 := MA330AvRep(ExpA1,ExpA2)                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpA1 := Array com os campos faltantes                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MA330AvRep(aLogsRep)
Local _cCampo :=""
Local _cCampo1:=""
Local _nLoop1 :=1
Local _nLoop2 :=1
Local _nLoop3 :=1
// Array com os campos que precisam ser criados para calculo do custo de reposicao
Local _aAreas :={	{"SB2","B2_CMRP","B2_VFRP"},;
					{"SB6","B6_CUSRP"},;
					{"SB9","B9_CMRP","B9_VINIRP"},;
					{"SC2","C2_VFIMRP","C2_VINIRP","C2_APRIRP","C2_APRFRP"},;
					{"SD1","D1_CUSRP"},;
					{"SD2","D2_CUSRP"},;
					{"SD3","D3_CUSRP"}}

Default aLogsRep := {}

if cMoeda330C == NIL
	cMoeda330C := SuperGetMv('MV_MOEDACM',.F.,"2345")
EndIf

// Verifica se todos os campos necessarios foram criados
For _nLoop1:=1 to Len(_aAreas)
	For _nLoop2:=2 to Len(_aAreas[_nLoop1])
		_cCampo:=_aAreas[_nLoop1,_nLoop2]
		For _nLoop3:=1 to 5
			// Verifica se moeda devera ser considerada
			If _nLoop3 # 1 .And. !(Str(_nLoop3,1,0) $ cMoeda330C)
				Loop
			EndIf
			_cCampo1:=_cCampo+Strzero(_nLoop3,1)
			dbSelectArea(_aAreas[_nLoop1,1])
			// Inclui campo no array para indicar problemas ao usuario
			If FIELDPOS(_cCampo1) <= 0
				AADD(aLogsRep,{_aAreas[_nLoop1,1],_cCampo1})
			EndIf
		Next _nLoop3
	Next _nLoop2
Next _nLoop1

Return (Len(aLogsRep)==0)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³A330AjCusto ³ Autor ³ Microsiga S/A       ³ Data ³ 12/12/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³ Funcao utilizada para ajustar o custo de fechamento de     ³±±
±±³          ³ acordo com custo unitario informado.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpL1 := A330AjCusto(ExpN1,ExpA1)	                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ nTipo   := 1 - Ajuste do Custo Medio                       ³±±
±±³          ³            2 - Ajuste do Custo de Reposicao                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpL1 := .T. - Indica que o ajuste foi realizado           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A330AjCusto(nTipo,lProcREA)
Local nCMRep   := 0
Local nVFimRep := 0
Local nVFimNew := 0
Local nVFim    := 0
Local cMoeda   := 0
Local nNewCusto:= 0
Local aCM      := {0,0,0,0,0}

Local lInverte := .F.

Local aAreaAnt := {}
Local aAreaSD3 := {}
Local aAreaSB2 := {}

Default nTipo  	 := 0
Default lProcREA := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ajuste do Custo Medio                                 |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nTipo == 1
	If Alltrim(SD3->D3_CF) $ "REA/DEA"
		aAreaAnt := GetArea()
		aAreaSD3 := SD3->(GetArea())
		aAreaSB2 := SB2->(GetArea())
		dbSelectArea("SB2")
		dbSetOrder(1)
		If MsSeek(xFilial("SB2")+SD3->D3_COD+SD3->D3_LOCAL)
			lCalcInd:=.F.
			If cPaisLoc=="BOL"
				If SD3->D3_INDICE > 0
					lCalcInd:=.T.
				EndIf
			EndIf
			If lCalcInd
				cMoeda   := IIf(Empty(SD3->D3_MOEDA),1,SD3->D3_MOEDA)
				nCM      := Iif (cPaisLoc=="BOL",SD3->D3_INDICE,0)
				nVFim    := &("SB2->B2_VFIM"+cMoeda)
				nVFimNew := IIf(&("SB2->B2_VFIM"+cMoeda) <= 0, (SB2->B2_QFIM * nCM),&("SB2->B2_VFIM"+cMoeda)*nCM)
				If nVFimNew > nVFim
					nNewCusto := (nVFimNew - nVFim)
					lInverte  := .F.
				ElseIf nVFimNew < nVFim
					nNewCusto := (nVFim - nVFimNew)
					lInverte  := .T.
				EndIf
			Else
				cMoeda   := IIf(Empty(SD3->D3_MOEDA),1,SD3->D3_MOEDA)
				nCM      := SD3->D3_CMFIXO
				If (lCusFil .Or. lCusEmp) .And. lProcREA
					A330TT2B2(,,,,,,.F.,cNomTRT,NIL,lCstPart,aRegraCP,lCusEmp,lCusFil,,.T.,cNomTR2)
				EndIf
				nVFim    := &("SB2->B2_VFIM"+cMoeda)
				nVFimNew := (SB2->B2_QFIM * nCM)
				If nVFimNew > nVFim
					nNewCusto := (nVFimNew - nVFim)
					lInverte  := .F.
				ElseIf nVFimNew < nVFim
					nNewCusto := (nVFim - nVFimNew)
					lInverte  := .T.
				EndIf
			EndIf
			Reclock("SD3",.F.)
			Replace D3_CF With IIf(lInverte,"REA","DEA")
			Replace D3_TM With IIf(lInverte,"999","499")
			Fieldput(Fieldpos("D3_CUSTO"+cMoeda),nNewCusto)
			SD3->(MsUnlock())
			aCM[Val(cMoeda)] := nNewCusto
		EndIf
		RestArea(aAreaSD3)
		aSize(aAreaSD3,0)
		aAreaSD3 := nil

		RestArea(aAreaSB2)
		aSize(aAreaSB2,0)
		aAreaSB2 := nil

		RestArea(aAreaAnt)
		aSize(aAreaAnt,0)
		aAreaAnt := nil
	EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ajuste do Custo de Reposicao                          |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ElseIf nTipo == 2
	If SD3->D3_STATUS == 'RP'
		aAreaAnt := GetArea()
		aAreaSD3 := SD3->(GetArea())
		aAreaSB2 := SB2->(GetArea())
		dbSelectArea("SB2")
		dbSetOrder(1)
		If MSSeek(xFilial("SB2")+SD3->D3_COD+SD3->D3_LOCAL)
			If SB2->B2_QFIM > 0
				cMoeda   := IIf(Empty(SD3->D3_MOEDRP),1,SD3->D3_MOEDRP)
				nCMRep   := SD3->D3_CMRP
				nVFimRep := &("SB2->B2_VFRP"+cMoeda)
				nVFimNew := (SB2->B2_QFIM * nCMRep)
				If nVFimNew > nVFimRep
					nNewCusto := (nVFimNew - nVFimRep)
					lInverte  := .F.
				ElseIf nVFimNew < nVFimRep
					nNewCusto := (nVFimRep - nVFimNew)
					lInverte  := .T.
				EndIf
				Reclock("SD3",.F.)
				Replace D3_CF With IIf(lInverte,"RE6","DE6")
				Replace D3_TM With IIf(lInverte,"999","499")
				Fieldput(Fieldpos("D3_CUSRP"+cMoeda),nNewCusto)
				SD3->(MsUnlock())
				aCM[Val(cMoeda)] := nNewCusto
			EndIf
		EndIf
		RestArea(aAreaSD3)
		aSize(aAreaSD3,0)
		aAreaSD3 := nil

		RestArea(aAreaSB2)
		aSize(aAreaSB2,0)
		aAreaSB2 := nil

		RestArea(aAreaAnt)
		aSize(aAreaAnt,0)
		aAreaAnt := nil
	Else
		aCM := {SD3->D3_CUSRP1,SD3->D3_CUSRP2,SD3->D3_CUSRP3,SD3->D3_CUSRP4,SD3->D3_CUSRP5}
	EndIf
EndIf
Return aCM

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³A330Seq300  ³ Autor ³ Microsiga S/A       ³ Data ³ 24/02/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³ Funcao utilizada para sequenciar a ordem 300 dos movimentos³±±
±±³          ³ a serem processados pela rotina de recalculo.              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpL1 := A330Seq300()	                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A330Seq300()
Local aAreaAnt
Local aAreaTRB
Local aMovimento	:= {}
Local aAjuste		:= {}
Local nAjuste		:= 0
Local nCount		:= ''
Local cOP			:= ''
Local lSeq300		:= SuperGetMv("MV_SEQ300",.F.,.F.)
Local cMovProd
Local cFiltroTRB
Local cThreadID
Local cMessage
Local cQuery
Local cAliMOD300
Local aMovProd 	:= {}
Local cMovPrd 		:= ''
Local n

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Processa o arquivo de trabalho 'TRB' para sequenciar os movimentos de ordem 300 |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lSeq300 .And. (a330ParamZX[14] == 2 .Or. a330ParamZX[14] == 3)

	M330PrcLog("MENSAGEM",OemToAnsi(STR0211),OemToAnsi(STR0211)) // "Sequencia os movimentos de ordem 300 - (0) Iniciando"

	aAreaAnt	:= GetArea()
	aAreaTRB	:= TRB->(GetArea())

	cMovProd	:= SuperGetMv("MV_M330TCF",.F.,"RE5/DE5/RE6/DE6")

	aMovProd := StrToKarr(cMovProd,'/')

	For n := 1 to len(aMovProd)
		If !aMovProd[n] $ 'RE5DE5' 			// retira os tipos RE5/DE5 do parametro MV_M330TCF pois são sequenciados
			cMovPrd += "'"+aMovProd[n]+"'"  // com a mesma sequencia da nota de entrada ou exclusão nota de entrada
			If n < len(aMovProd)
				cMovPrd += ','
			EndIf
		EndIf
	Next n
	If Empty(cMovPrd)
		cMovPrd := "' '"
	EndIf
	cThreadID := Strzero(ThreadID(),15)

	dbSelectArea("TRB")
	dbSetOrder(5)
	cFiltroTRB := TRB->(dbFilter())
	TRB->(dbClearFilter())

	// Movimentos com ordem superior a 300
	cQuery := "UPDATE " + cNomTRB + " SET TRB_SEQPRO = '" + Replicate('z',Len(TRB->TRB_SEQPRO)) +"' "
	cQuery += " WHERE TRB_ORDEM >'300' AND TRB_THREAD = '" +cThreadID+"' "
	A330SQLExec(cQuery, "A330Seq300", STR0212) // "Falha no sequenciamento MV_SEQ300: "

	// Movimentos com ordem 300 que são MOD com ordem e produção ou sem MOD
	cQuery := "UPDATE " + cNomTRB + " SET TRB_SEQPRO = TRB_SEQ "
	cQuery += " WHERE TRB_THREAD = '" + cThreadID + "' AND TRB_ORDEM = '300' "
	cQuery += " AND (TRB_MOD='0' OR (TRB_MOD='1' AND TRB_OP <>  ' ' )) AND "
	cQuery += " TRB_CF NOT IN ("+cMovPrd+")"
	A330SQLExec(cQuery, "A330Seq300", STR0212) // "Falha no sequenciamento MV_SEQ300: "

	TCRefresh(cNomTRB)

	// Movimentos com ordem 300 que são MOD com ordem de produção ou sem MOD
	cQuery := "SELECT TRB.R_E_C_N_O_ TRBRecno, TRB.TRB_OP, TRB.TRB_SEQ, TRB.TRB_CF FROM " + cNomTRB + " TRB "
	cQuery += " WHERE TRB.TRB_THREAD = '" + cThreadID + "' AND TRB.TRB_ORDEM = '300' "
	cQuery += "AND (TRB.TRB_MOD='0' OR (TRB.TRB_MOD='1' AND TRB.TRB_OP <>  ' ' ))"
	cAliMOD300 := MPSysOpenQuery( cQuery )
	If !Empty(cAliMOD300) .and. Select(cAliMOD300) >0
		DO WHILE (cAliMOD300)->(!Eof())
			IF !(AllTrim((cAliMOD300)->TRB_CF)$cMovProd) .And. !Empty((cAliMOD300)->TRB_OP)
				aAdd(aMovimento,{(cAliMOD300)->TRB_OP,(cAliMOD300)->TRB_SEQ,AllTrim(SubStr((cAliMOD300)->TRB_CF,1,2)),(cAliMOD300)->TRBRecno })
			ENDIF
			(cAliMOD300)->(dbSkip())
		ENDDO
	EndIf
	(cAliMOD300)->(dbCloseArea())

	dbSelectArea("TRB")
	aSort( aMovimento,,, { |x,y| x[1]+x[2] < y[1]+y[2] } )
	For nCount := 1 to Len(aMovimento)
		If cOP == aMovimento[nCount,1]
			If aMovimento[nCount,3] $ 'RE|DE'
				aAdd(aAjuste,{aMovimento[nCount,1],cNumSeq,aMovimento[nCount,3],aMovimento[nCount,4]})
			ElseIf aMovimento[nCount,3] $ 'PR'
				aAjuste  := {}
				cNumSeq  := aMovimento[nCount,2]
			EndIf
		Else
			If Len(aAjuste) > 0
				For nAjuste := 1 to Len(aAjuste)
					If !Empty(aAjuste[nAjuste,2])
						dbGoTo(aAjuste[nAjuste,4])
						RecLock("TRB",.F.)
						Replace TRB_SEQPRO With aAjuste[nAjuste,2]
						TRB->(MsUnLock())
					EndIf
				Next nAjuste
			EndIf
			aAjuste := {}
			cNumSeq := ''
			If aMovimento[nCount,3] $ 'RE|DE'
				aAdd(aAjuste,{aMovimento[nCount,1],cNumSeq,aMovimento[nCount,3],aMovimento[nCount,4]})
			ElseIf aMovimento[nCount,3] $ 'PR'
				aAjuste  := {}
				cNumSeq  := aMovimento[nCount,2]
			EndIf
			// Proxima OP
			cOP := aMovimento[nCount,1]
		EndIf
	Next nCount

	If Len(aAjuste) > 0
		For nAjuste := 1 to Len(aAjuste)
			If !Empty(aAjuste[nAjuste,2])
				dbGoTo(aAjuste[nAjuste,4])
				RecLock("TRB",.F.)
				Replace TRB_SEQPRO With aAjuste[nAjuste,2]
				TRB->(MsUnLock())
			EndIf
		Next nAjuste
	EndIf

	aSize(aMovimento,0)
	aSize(aAjuste,0)

	If !Empty(cFiltroTRB)
		TRB->(DBSETFILTER({||&cFiltroTRB}, cFiltroTRB))
	EndIf

	RestArea(aAreaTRB)
	aSize(aAreaTRB,0)
	aAreaTRB := nil

	RestArea(aAreaAnt)
	aSize(aAreaAnt,0)
	aAreaAnt := nil

	M330PrcLog("MENSAGEM",OemToAnsi(STR0213),OemToAnsi(STR0213)) // "Sequencia os movimentos de ordem 300 - (1) Termino"

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
	// Telemetria - Uso da classe FwCustomMetrics                   //
	// Metrica - setAverageMetric                                   //
	// Grava se utiliza a ordenação das movimentações internas      //
	// ativando o parametro MV_SEQ300.                              //
	//?ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
	If FWLibVersion() >= "20210628"
		FWCustomMetrics():setAverageMetric(	"SEQ300"/*cSubRoutine*/,;
											"estoque/custos-protheus_recalculo-do-custo-medio-sequencia-da-ordem-300_count" /*cIdMetric*/,;
											1 /*nValue*/,;
											/*dDateSend*/,;
											/*nLapTime*/,;
											"MATA330"/*cRotina*/)
	EndIf

EndIf

Return

/*/{Protheus.doc} A330NivCQ
	Funcao utilizada para ordenar os movimentos de liberacao e
	rejeicao do armazem de Controle de Qualidade (CQ).
	Obs.: O arquivo de trabalho (TRB) deve estar posicionado.
	@type  Function
	@author Microsiga S/A
	@since 24/02/10
	@version 1.0
	@param cLocCQ, caracter, Codigo do Armazem de CQ
	@param cOrdem, caracter, Ordem para TRB_ORDEM (atualizado por ref.)
	@param cNivel, caracter, Nivel para TRB_NIVEL (atualizado por ref.)
	@param cNivSD3, caracter, NivSD3 p/ TRB_NIVSD3 (atualizado por ref.)
	@param cChave, caracter, Chave para TRB_CHAVE (atualizado por ref.)
	@param lSeq500, logico, Conteudo de MV_SEQ500

	@return lRet, logico, Se houve atualização dos parametros passados por referencia
	/*/
Static Function A330NivCQ(cLocCQ,cOrdem,cNivel,cNivSD3,cChave,lSeq500)
Local aAreaAnt := {}
Local aAreaSD3 := {}
Local aAreaSD7 := {}
Local lRet     := .F.
Local lM330JCM1:= ("1" $ SuperGetMv("MV_M330JCM" ,.F.,""))
Local cSeekSD7 := ""
Local cSeekTRB := ""
Local nRecnoSD1
Default cLocCQ := GetMvNNR('MV_CQ','98')

If SD3->D3_CF $ "RE6/DE6" .And. a330ParamZX[14] # 1
	aAreaAnt := GetArea()
	aAreaSD3 := SD3->(GetArea())
	aAreaSD7 := SD7->(GetArea())
	SD7->(dbSetOrder(2)) //D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL+D7_NUMSEQ+D7_TIPO
	SD7->(MsSeek(cSeekSD7 := xFilial("SD7")+SubStr(SD3->D3_DOC,1,Len(SD7->D7_NUMERO))+SD3->D3_COD+cLocCQ))
	Do While !SD7->(Eof()) .And. cSeekSD7 == SD7->(D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL)
		//-- Valida somente os registro de entrada no CQ
		If SD3->D3_QUANT > 0
			If StrZero(SD7->D7_TIPO,1) == "0"
				If SD7->D7_ORIGLAN == "CP"
					TRB->(dbSetOrder(2)) //TRB_FILIAL+TRB_ALIAS+TRB_SEQ
					If TRB->(MsSeek(cFilAnt+"SD1"+SD7->D7_NUMSEQ))
						cOrdem := TRB->TRB_ORDEM
						cNivel := TRB->TRB_NIVEL
						cNivSD3 := TRB->TRB_NIVSD3
						cChave := ""
						nRecnoSD1 := SD1->(Recno())
						SD1->(MsGoto(TRB->(TRB_RECNO)))
						If cOrdem=="500" .And. lSeq500
							If rTrim(TRB->TRB_CHAVE) == rTrim(SD1->D1_NUMSEQ+SD1->D1_FORNECE+DTOS(TRB->TRB_DTORIG)+SD1->D1_DOC+SD1->D1_SERIE)
								cChave := SD1->D1_NUMSEQ+SD1->D1_FORNECE+DTOS(TRB->TRB_DTORIG)+SD1->D1_DOC+SD1->D1_SERIE
							EndIf
						EndIf
						If Empty(cChave) .and. rTrim(TRB->TRB_CHAVE) == rTrim(SD1->D1_FORNECE+DTOS(TRB->TRB_DTORIG)+SD1->D1_NUMSEQ+SD1->D1_DOC+SD1->D1_SERIE)
							cChave := SD1->D1_FORNECE+DTOS(TRB->TRB_DTORIG)+SD1->D1_NUMSEQ+SD1->D1_DOC+SD1->D1_SERIE
						EndIf
						If Empty(cChave)
							cChave := RTrim(TRB->TRB_CHAVE)
						EndIf
						cChave += "x"
						lRet := .T.
						SD1->(MsGoto(nRecnoSD1))
					EndIf
				ElseIf SD7->D7_ORIGLAN == "PR"
					TRB->(dbSetOrder(2)) //TRB_FILIAL+TRB_ALIAS+TRB_SEQ
					TRB->(MsSeek(cSeekTRB := cFilAnt+"SD3"+SD7->D7_NUMSEQ))
					Do While !TRB->(Eof()) .And. cSeekTRB == cFilAnt+"SD3"+TRB->TRB_SEQ
						If TRB->TRB_CF $ "PR0/PR1"
							cOrdem := TRB->TRB_ORDEM
							cNivel := TRB->TRB_NIVEL
							cNivSD3 := TRB->TRB_NIVSD3
							cChave := RTrim(TRB->TRB_CHAVE)+"x"
							lRet := .T.
							Exit
						EndIf
						TRB->(dbSkip())
					EndDo
				EndIf
				Exit
			EndIf
		ElseIf StrZero(SD7->D7_TIPO,1) == "8"
			TRB->(dbSetOrder(2)) //TRB_FILIAL+TRB_ALIAS+TRB_SEQ
			If TRB->(MsSeek(cFilAnt+"SD1"+SD7->D7_NUMSEQ))
				cOrdem := TRB->TRB_ORDEM
				cNivel := TRB->TRB_NIVEL
				cNivSD3 := TRB->TRB_NIVSD3
				cChave := ""
				nRecnoSD1 := SD1->(Recno())
				SD1->(MsGoto(TRB->(TRB_RECNO)))
				If cOrdem=="500" .And. lSeq500
					If rTrim(TRB->TRB_CHAVE) == rTrim(SD1->D1_NUMSEQ+SD1->D1_FORNECE+DTOS(TRB->TRB_DTORIG)+SD1->D1_DOC+SD1->D1_SERIE)
						cChave := SD1->D1_NUMSEQ+SD1->D1_FORNECE+DTOS(TRB->TRB_DTORIG)+SD1->D1_DOC+SD1->D1_SERIE
					EndIf
				EndIf
				If Empty(cChave) .and. rTrim(TRB->TRB_CHAVE) == rTrim(SD1->D1_FORNECE+DTOS(TRB->TRB_DTORIG)+SD1->D1_NUMSEQ+SD1->D1_DOC+SD1->D1_SERIE)
					cChave := SD1->D1_FORNECE+DTOS(TRB->TRB_DTORIG)+SD1->D1_NUMSEQ+SD1->D1_DOC+SD1->D1_SERIE
				EndIf
				If Empty(cChave)
					cChave := RTrim(TRB->TRB_CHAVE)
				EndIf
				cChave += "x"
				lRet := .T.
				SD1->(MsGoto(nRecnoSD1))
			EndIf
		EndIf
		If lRet
			Exit
		Else
			SD7->(dbSkip())
		EndIf
	EndDo

	If cOrdem == "100" .And. lM330JCM1
		cOrdem := "101"
	EndIf
	RestArea(aAreaSD7)
	aSize(aAreaSD7,0)
	aAreaSD7 := nil

	RestArea(aAreaSD3)
	aSize(aAreaSD3,0)
	aAreaSD3 := nil

	RestArea(aAreaAnt)
	aSize(aAreaAnt,0)
	aAreaAnt := nil
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³A330JobCM    ³ Autor ³ TOTVS S/A          ³ Data ³ 02/09/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³ Funcao utilizada para disparar as threads para realizar o  ³±±
±±³          ³ calculo de custo dos movimentos de ordem 100, 300 e 500    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cOrdem     := Codigo da Ordem a ser Processada              ³±±
±±³          ³aFilsCalc  := Array com as selecao de filiais para calculo  ³±±
±±³          |lExistProc := Utiliza Stored Procedures para Calculo        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A330JobCM(cOrdem,aFilsCalc,lExistProc,oListaTrf,cThreadID,oJobCMCall)

Local nPos      :=0
Local nx        :=0
Local nRetry_0  :=0
Local nRetry_1  :=0
Local nProxRecno:=0
Local nForFilial:=1

Local aThreads  :={}
Local aJobAux   :={}

Local cChave    := ''
Local cListaFil := A330Lista(aFilsCalc)

Local lHabCon330:= SuperGetMV('MV_M330CON',.F.,.F.)
Local dMVUlMes  := SuperGetMV("MV_ULMES",.F.,"19961231")
Local cLocalCQ  := GetMvNNR('MV_CQ','98')
Local cDepTran  := SuperGetMV("MV_DEPTRAN",.F.,"")
Local lIntMntAt := SuperGetMv("MV_NGMNTES",.F.,"N") == "S"

Local lM330CD1  := ExistBlock("M330CD1")
Local lM330CD2  := ExistBlock("M330CD2")
Local lMA330D3  := ExistBlock("MA330D3")
Local lMA330C3  := ExistBlock("MA330C3")
Local lMA330P3  := ExistBlock("MA330P3")

Local cStartPath:= GetSrvProfString("Startpath","")
Local dDataTRB  := TRB->TRB_DTBASE
Local cSeqPro   := TRB->TRB_SEQPRO
Local cNivel    := TRB->TRB_NIVEL
Local cNivSD3   := TRB->TRB_NIVSD3
Local aAreaAnt  := GetArea()
Local aAreaSB2  := SB2->(GetArea())
Local aPE       := {lMA330D1,lM330CD2,lMA330D2,lM330CD1,lMA330D3,lMA330C3,lMA330P3}
Local nI := 0
LOCAL cIDThread
LOCAL cSemaforo
Local cData		:=  ObjjsonCon()
Local nCall as numeric
Local cChamada as character

if cMoeda330C == NIL
	cMoeda330C := SuperGetMv('MV_MOEDACM',.F.,"2345")
EndIf

nCall := oJobCMCall[cOrdem]
If nCall == nil
	nCall := 0
EndIf
oJobCMCall[cOrdem] := nCall+1
cChamada := strzero(nCall,2)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Processamento em Threads dos Movimentos:     ³
//³ Ordem 100 - Documento de Entrada (Tabela SD1)³
//³ Ordem 500 - Documento de Saida   (Tabela SD2)³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cOrdem $ "100/500"

	cIDThread := cValToChar(ThreadID())
	cSemaforo := "M330JOBCM_"+cIDThread+"_"+CEMPANT
	A330JobManual("1", cSemaforo, "M330JOBCONNECT" )

	// Grava para todas filiais
	For nForFilial := 1 to Len(aFilsCalc)

		If aFilsCalc[nForFilial,1]

			// Reinicia variavel
			nRetry_0  :=0
			nRetry_1  :=0
			aJobAux   :={}
			aThreads  :={}

			// Altera para Filial a ser processada
			cFilAnt  := aFilsCalc[ nForFilial, 2 ]

			// Calcula a quantidade de Threads
			aThreads := M330QtdThr()

			For nX :=1 to Len(aThreads)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o log de processamento			    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				M330PrcLog("MENSAGEM",OemToAnsi(I18N(STR0179,{cOrdem,cFilAnt,cChamada+' '+StrZero(nX,3)})),OemToAnsi(I18N(STR0179,{cOrdem,cFilAnt,cChamada+' '+StrZero(nX,3)}))) // "Processando Ordem #1[100]# - Filial #2[D MG 01]# -#3[01]#- Thread numero :#4[001]# - (0) Inicio"

				// Informacoes do semaforo
				cJobFile:= cStartPath+cFilAnt+StrZero(nX,2)+".CM"

				// Adiciona o nome do arquivo de Job no array aJobAux
				aAdd(aJobAux,{StrZero(nX,2),cJobFile})

				// Inicializa variavel global de controle de thread
				cJobAux:="M"+cEmpAnt+cFilAnt+StrZero(nX,2)
				A330LckGlb(cJobAux)
				PutGlbValue(cJobAux,"0")
				A330ULckGlb(cJobAux)

				SB2->(DbGoTo(SB2->(Recno()))) //Força refresh do cache
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Dispara thread para processamento           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				while ! IPCGO( cSemaforo,cEmpAnt,cFilAnt,cOrdem,aThreads[nX],cJobFile,StrZero(nX,2),{cNomTRB,cNomTRC,cNomTRT,cNomTRX,cNomTR2},lCstPart,aRegraCP,lCusRep,cPaisLoc,lCusFil,lCusEmp,aPE,dMVUlMes,a330ParamZX,lExistProc,{cLocalCQ,cDepTran},cChave,nProdProp,lIntMntAt,oListaTrf,cSeqEmp,cListaFil,cThreadID, cData, {cUserName,__cUserID}, cKeyRegCT)
					for nI := 1 to 2
						sleep(1000)
					Next nI
				End

			Next nX

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Controle de Seguranca para MULTI-THREAD                                   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For nX :=1 to Len(aThreads)

				nPos := ASCAN(aJobAux,{|x| x[1] == StrZero(nX,2)})

				// Informacoes do semaforo
				cJobFile:= aJobAux[nPos,2]

				// Inicializa variavel global de controle de thread
				cJobAux:="M"+cEmpAnt+cFilAnt+StrZero(nX,2)
				// Inicializa variaveis de tentativas
				nRetry_0 := 0
				nRetry_1 := 0

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Analise das Threads em Execucao                              ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				While .T.

					Do Case
						// TRATAMENTO PARA ERRO DE SUBIDA DE THREAD
						Case GetGlbValue(cJobAux) == '0'
							If nRetry_0 > 50
								Conout(Replicate("-",80))							 					//"-------------------------------------------------------------"
								Conout("MATA330: "+ STR0174 + " " + cOrdem + " " + StrZero(nX,3) )		//"MATA330: Não foi possivel realizar a subida da thread  - ### "
								Conout(Replicate("-",80))  												//"-------------------------------------------------------------"
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Atualiza o log de processamento			    ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								M330PrcLog("MENSAGEM",STR0175+" "+cOrdem+" - " +STR0127 +StrZero(nX,3) +STR0067+cFilAnt,STR0175+" "+cOrdem)	//"Não foi possivel realizar a subida da thread (Custo Medio Ordem ###)"
								Final(STR0175+" "+cOrdem) 										//"Não foi possivel realizar a subida da thread (Custo Medio Ordem ###)"
							Else
								nRetry_0 ++
							EndIf
						// TRATAMENTO PARA ERRO DE CONEXAO
						Case GetGlbValue(cJobAux) == '1'
							If FCreate(cJobFile) # -1
								If nRetry_1 > 5
									Conout(Replicate("-",80))  //"----------------------------------------------------"
									Conout(STR0176) 			//"MATA330: Erro de conexao na thread de Custo Medio   "
									Conout(STR0127 + cJobAux )	//"Thread numero : "
									Conout(STR0128)				//"Numero de tentativas excedidas"
									Conout(Replicate("-",80))  //"----------------------------------------------------"
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Atualiza o log de processamento			    ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									M330PrcLog("MENSAGEM",STR0176+" "+cOrdem+" - " +STR0127 +StrZero(nX,3) +STR0067+cFilAnt,STR0176)	//"MATA330: Erro de conexao na thread de Custo Medio"
									Final(STR0176)				   			//"MATA330: Erro de conexao na thread de Custo Medio"
								Else
									// Inicializa variavel global de controle de Job
									A330LckGlb(cJobAux)
									If GetGlbValue(cJobAux) == '1'
										PutGlbValue(cJobAux, "0" )
										A330ULckGlb(cJobAux)
									else
										A330ULckGlb(cJobAux)
										Loop
									EndIf
									// Reiniciar thread de contabilizacao
									Conout(Replicate("-",65))
									Conout(STR0176) 					//"MATA330: Erro de conexao na thread de procedures"
									Conout(STR0129+StrZero(nRetry_1,2))	//"Tentativa numero: "
									Conout(STR0130+cJobAux )			//"Reiniciando a thread : "
									Conout(Replicate("-",65))
									SB2->(DbGoTo(SB2->(Recno()))) //Força refresh do cache
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Dispara thread para processamento           ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									//StartJob("M330JobCM",GetEnvServer(),lThrSeq,cEmpAnt,cFilAnt,cOrdem,aThreads[nX],cJobFile,StrZero(nX,2),{cNomTRB,cNomTRC,cNomTRT,cNomTRX,cNomTR2},lCstPart,aRegraCP,lCusRep,cPaisLoc,lCusFil,lCusEmp,aPE,dMVUlMes,a330ParamZX,lExistProc,{cLocalCQ,cDepTran},cChave,nProdProp,lIntMntAt,aListaTrf,cSeqEmp,cListaFil,cThreadID)
								EndIf
								nRetry_1 ++
							EndIf
						// TRATAMENTO PARA ERRO DE APLICACAO
						Case GetGlbValue(cJobAux) == '2'
							If (nRetry_1 := FCreate(cJobFile)) # -1
								Sleep(5000)
								If GetGlbValue(cJobAux) # '2'	//-- Tratamento para falso positivo: quando thread muda entre as consultas
									FClose(nRetry_1)
									FErase(cJobAux)
									Loop
								EndIf
								Conout(Replicate("-",80))	//"-----------------------------------------------------"
								Conout(STR0177)				//"MATA330: Erro de aplicacao na thread de Custo Medio  "
								Conout(STR0127+cJobAux)		//"Thread numero : "
								Conout(Replicate("-",80))  //"------------------------------------------------------"
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Atualiza o log de processamento			    ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								M330PrcLog("ERRO",STR0177+" "+cOrdem+" - " +STR0127 +StrZero(nX,3) +STR0067+cFilAnt,STR0177+" JobFile:" +cJobFile)	//"MATA330: Erro de aplicacao na thread de Custo Medio" ## "Thread numero : "
								Final(STR0177)				//"MATA330: Erro de aplicacao na thread de Custo Medio"
							EndIf
						// THREAD PROCESSADA CORRETAMENTE
						Case GetGlbValue(cJobAux) == '3'
							// Limpa variavel global de controle de thread
							ClearGlbValue(cJobAux)
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Atualiza o log de processamento			    ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							M330PrcLog("MENSAGEM",OemToAnsi(I18N(STR0173,{cOrdem,cFilAnt,cChamada+' '+StrZero(nX,3)})),OemToAnsi(I18N(STR0173,{cOrdem,cFilAnt,+' '+StrZero(nX,3)}))) // "Processando Ordem #1[100]# - Filial #2[D MG 01]# -#3[01]#- Thread numero :#4[001]# - (1) Termino"
							Exit
					EndCase

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Habilita Log via Conout para Analise                         ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lHabCon330
						Conout("JOB: A330JOBCM -> VGlobal: " + cJobAux + " | " + "Conteudo: " + GetGlbValue(cJobAux) + " | " + "Arquivo: " + cJobFile)
					EndIf

					for nI := 1 to 2
						sleep(1000)
					Next nI

				End
			Next nX

		EndIf
	Next nForFilial

	cIDThread := cValToChar(ThreadID())
	cSemaforo := "M330JOBCM_"+cIDThread+"_"+CEMPANT
	A330JobManual("2", cSemaforo, "M330JOBCONNECT" )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Processamento em Threads dos Movimentos:     ³
//³ Ordem 300 - Movimentos Internos (Tabela SD3) ³
//³ ** Somente Movimentos relacionados a Ordem   ³
//³    de Producao.                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ElseIf cOrdem == "300"

 	// Chave de processamento
	cChave := DTOS(TRB->TRB_DTBASE)+TRB->TRB_SEQPRO+TRB->TRB_ORDEM+TRB->TRB_NIVEL+TRB->TRB_NIVSD3

	// Reinicia variavel
	nRetry_0  :=0
	aJobAux   :={}
	aThreads  :={}

	cIDThread := cValToChar(ThreadID())
	cSemaforo := "M330JOBCM_"+cIDThread+"_"+CEMPANT
	A330JobManual("1", cSemaforo, "M330JOBCONNECT" )

	// Calcula a quantidade de Threads
	aThreads := M330QtdThr(2,cChave)

	For nX :=1 to Len(aThreads)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o log de processamento			    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		M330PrcLog("MENSAGEM",OemToAnsi(I18N(STR0179,{cOrdem,cFilAnt,cChamada+' '+StrZero(nX,3)})),OemToAnsi(I18N(STR0179,{cOrdem,cFilAnt,cChamada+' '+StrZero(nX,3)}))) // "Processando Ordem #1[100]# - Filial #2[D MG 01]# -#3[01]#- Thread numero :#4[001]# - (0) Inicio"

		// Informacoes do semaforo
		cJobFile:= cStartPath+cFilAnt+StrZero(nX,2)+".CM"

		// Adiciona o nome do arquivo de Job no array aJobAux
		aAdd(aJobAux,{StrZero(nX,2),cJobFile})

		// Inicializa variavel global de controle de thread
		cJobAux:="M"+cEmpAnt+cFilAnt+StrZero(nX,2)
		A330LckGlb(cJobAux)
		PutGlbValue(cJobAux,"0")
		A330ULckGlb(cJobAux)

		SB2->(DbGoTo(SB2->(Recno()))) //Força refresh do cache
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Dispara thread para processamento           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		while ! IPCGO( cSemaforo,cEmpAnt,cFilAnt,cOrdem,aThreads[nX],cJobFile,StrZero(nX,2),{cNomTRB,cNomTRC,cNomTRT,cNomTRX,cNomTR2},lCstPart,aRegraCP,lCusRep,cPaisLoc,lCusFil,lCusEmp,aPE,dMVUlMes,a330ParamZX,lExistProc,{cLocalCQ,cDepTran},cChave,nProdProp,lIntMntAt,oListaTrf,cSeqEmp,cListaFil,cThreadID, cData, {cUserName,__cUserID}, cKeyRegCT)
			for nI := 1 to 2
				sleep(1000)
			Next nI
		End

	Next nX

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Controle de Seguranca para MULTI-THREAD                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nX :=1 to Len(aThreads)

		nPos := ASCAN(aJobAux,{|x| x[1] == StrZero(nX,2)})

		// Informacoes do semaforo
		cJobFile:= aJobAux[nPos,2]

		// Inicializa variavel global de controle de thread
		cJobAux:="M"+cEmpAnt+cFilAnt+StrZero(nX,2)

		// Inicializa variaveis de tentativas
		nRetry_0 := 0
		nRetry_1 := 0

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Analise das Threads em Execucao                              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		While .T.

			Do Case
				// TRATAMENTO PARA ERRO DE SUBIDA DE THREAD
				Case GetGlbValue(cJobAux) == '0'
					If nRetry_0 > 50
						Conout(Replicate("-",80))							 					//"-------------------------------------------------------------"
						Conout("MATA330: "+ STR0174 + " " + cOrdem + " " + StrZero(nX,3) )		//"MATA330: Não foi possivel realizar a subida da thread  - ### "
						Conout(Replicate("-",80))  												//"-------------------------------------------------------------"
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Atualiza o log de processamento			    ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						M330PrcLog("MENSAGEM",STR0175 +" " +cOrdem +" - " +STR0127 +StrZero(nX,3),STR0175+" "+cOrdem)	//"Não foi possivel realizar a subida da thread (Custo Medio Ordem ###)"
						Final(STR0175+" "+cOrdem) 										//"Não foi possivel realizar a subida da thread (Custo Medio Ordem ###)"
					Else
						nRetry_0 ++
					EndIf
				// TRATAMENTO PARA ERRO DE CONEXAO
				Case GetGlbValue(cJobAux) == '1'
					If FCreate(cJobFile) # -1
						If nRetry_1 > 5
							Conout(Replicate("-",80))  //"----------------------------------------------------"
							Conout(STR0176) 			//"MATA330: Erro de conexao na thread de Custo Medio   "
							Conout(STR0127 + cJobAux )	//"Thread numero : "
							Conout(STR0128)				//"Numero de tentativas excedidas"
							Conout(Replicate("-",80))  //"----------------------------------------------------"
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Atualiza o log de processamento			    ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							M330PrcLog("MENSAGEM",STR0176 +" " +cOrdem +" - " +STR0127 +StrZero(nX,3),STR0176)	//"MATA330: Erro de conexao na thread de Custo Medio"
							Final(STR0176)				   			//"MATA330: Erro de conexao na thread de Custo Medio"
						Else
							// Inicializa variavel global de controle de Job
							A330LckGlb(cJobAux)
							If GetGlbValue(cJobAux) == '1'
								PutGlbValue(cJobAux, "0" )
								A330ULckGlb(cJobAux)
							else
								A330ULckGlb(cJobAux)
								Loop
							EndIf
							// Reiniciar thread de contabilizacao
							Conout(Replicate("-",65))
							Conout(STR0176) 					//"MATA330: Erro de conexao na thread de procedures"
							Conout(STR0129+StrZero(nRetry_1,2))	//"Tentativa numero: "
							Conout(STR0130+cJobAux )			//"Reiniciando a thread : "
							Conout(Replicate("-",65))
							SB2->(DbGoTo(SB2->(Recno()))) //Força refresh do cache
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Dispara thread para processamento           ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//							StartJob("M330JobCM",GetEnvServer(),lThrSeq,cEmpAnt,cFilAnt,cOrdem,aThreads[nX],cJobFile,StrZero(nX,2),{cNomTRB,cNomTRC,cNomTRT,cNomTRX,cNomTR2},lCstPart,aRegraCP,lCusRep,cPaisLoc,lCusFil,lCusEmp,aPE,dMVUlMes,a330ParamZX,lExistProc,{cLocalCQ,cDepTran},cChave,nProdProp,lIntMntAt,{},cSeqEmp,cListaFil,cThreadID)
						EndIf
						nRetry_1 ++
					EndIf
				// TRATAMENTO PARA ERRO DE APLICACAO
				Case GetGlbValue(cJobAux) == '2'
					If (nRetry_1 := FCreate(cJobFile)) # -1
						Sleep(5000)
						If GetGlbValue(cJobAux) # '2'	//-- Tratamento para falso positivo: quando thread muda entre as consultas
							FClose(nRetry_1)
							FErase(cJobAux)
							Loop
						EndIf
						Conout(Replicate("-",80))	//"-----------------------------------------------------"
						Conout(STR0177)				//"MATA330: Erro de aplicacao na thread de Custo Medio  "
						Conout(STR0127+cJobAux)		//"Thread numero : "
						Conout(Replicate("-",80))  //"------------------------------------------------------"
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Atualiza o log de processamento			    ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						M330PrcLog(STR0177 +" " +cOrdem +" - " +STR0127 +StrZero(nX,3),STR0177+ "JobFile: "+cJobFile)	//"MATA330: Erro de aplicacao na thread de Custo Medio"  ## "Thread numero : "
						Final(STR0177)				//"MATA330: Erro de aplicacao na thread de Custo Medio"
					EndIf
				// THREAD PROCESSADA CORRETAMENTE
				Case GetGlbValue(cJobAux) == '3'
					// Limpa variavel global de controle de thread
					ClearGlbValue(cJobAux)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o log de processamento			    ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					M330PrcLog("MENSAGEM",OemToAnsi(I18N(STR0173,{cOrdem,cFilAnt,+' '+StrZero(nX,3)})),OemToAnsi(I18N(STR0173,{cOrdem,cFilAnt,cChamada+' '+StrZero(nX,3)}))) // "Processando Ordem #1[100]# - Filial #2[D MG 01]# -#3[01]#- Thread numero :#4[001]# - (1) Termino"
					Exit
			EndCase

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Habilita Log via Conout para Analise                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lHabCon330
				Conout("JOB: A330JOBCM -> VGlobal: " + cJobAux + " | " + "Conteudo: " + GetGlbValue(cJobAux) + " | " + "Arquivo: " + cJobFile)
			EndIf

			for nI := 1 to 2
				sleep(1000)
			Next nI

		End
	Next nX

	cIDThread := cValToChar(ThreadID())
	cSemaforo := "M330JOBCM_"+cIDThread+"_"+CEMPANT
	A330JobManual("2", cSemaforo, "M330JOBCONNECT" )

EndIf

RestArea(aAreaSB2)
aSize(aAreaSB2,0)
aAreaSB2 := nil
RestArea(aAreaAnt)
aSize(aAreaAnt,0)
aAreaAnt := nil

// Posiciona Arquivo de Trabalho
TRB->(dbSetOrder(3)) //"DTOS(TRB_DTBASE)+TRB_SEQPRO+TRB_ORDEM+TRB_NIVEL+TRB_NIVSD3+TRB_CHAVE+TRB_SEQ"
If cOrdem == "300"
	dbSeek(DTOS(dDataTRB)+cSeqPro+"300"+cNivel+cNivSD3+Replicate("z",Len(TRB->TRB_CHAVE)),.T.)
	nProxRecno := TRB->(Recno())

	If !TRB->(Eof())
		TRB->(dbSkip(-1))
	EndIf
Else
	dbSeek(DTOS(dDataTRB)+cSeqPro+IIf(cOrdem=="500","501","101"),.T.)
	nProxRecno := TRB->(Recno())

	If !TRB->(Eof()) .And. !(TRB->TRB_ORDEM == cOrdem)
		TRB->(dbSkip(-1))
	EndIf
EndIf
// Restaura filial original apos processamento
cFilAnt:=cFilBack
Return nProxRecno

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o    ³ A330CMUnif                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Autor     ³ TOTVS S.A.                               ³ Data ³ 26/12/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡ao ³ Processa o custo medio unificado por Empresa / Filial      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³ aFilsCalc  - Array com a selecao de filiais para calculo.  ³±±
±±³           ³ lExistProc - Indica a utilizacao de stored procedures      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A330CMUnif(aFilsCalc,lExistproc)
Local nPos       := 0
Local nx         := 0
Local nRetry_0   := 0
Local nRetry_1   := 0
Local nForFilial := 0

Local aThreads   := {}
Local aJobAux    := {}

Local lJobEmp    := .F.
Local lJobFil    := .F.

Local aAreaSB2   := SB2->(GetArea())
Local aAreaSB1   := SB1->(GetArea())
Local aAreaAnt   := GetArea()

Local nThreads
Local cStartPath := GetSrvProfString("Startpath","")
Local lFiltraUnif:= ExistBlock("MA330UNI")

Local nI := 0
LOCAL cIDThread
LOCAL cSemaforo

_MV_M330THR := iif(_MV_M330THR == NIL, SuperGetMv('MV_M330THR',.F.,1), _MV_M330THR)
nThreads := _MV_M330THR

M330PrcLog("MENSAGEM",IIf(lCusFil,STR0111,STR0119),CountTRT(aFilsCalc,)) //"Acerto de custo unificado por Filial - (0) Iniciando" ## "Acerto de custo unificado por Empresa - (0) Iniciando"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Custo Unificado por Empresa  |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lCusEmp
	If l330ArqExcl .Or. nThreads <= 1
		// Processa o Custo Unificado por Empresa
		A330TT2B2(.F.,,,,,,lExistProc,cNomTRT,NIL,lCstPart,aRegraCP,lCusEmp,lCusFil,lFiltraUnif,,cNomTR2)
	Else
		// Processa o Custo Unificado por Empresa em Job
		lJobEmp := .T.
	EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Custo Unificado por Filial   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ElseIf lCusFil
	If l330ArqExcl .Or. nThreads <= 1
		For nForFilial := 1 to Len(aFilsCalc)
			If aFilsCalc[nForFilial,1]
				// Altera filial corrente
				cFilAnt:=aFilsCalc[nForFilial,2]
				// Processa o Custo Unificado por Filial
				A330TT2B2(.F.,,,,,,lExistProc,cNomTRT,NIL,lCstPart,aRegraCP,lCusEmp,lCusFil,lFiltraUnif,,cNomTR2)
			EndIf
		Next nForFilial
	Else
		// Processa o Custo Unificado por Filial em Job
		lJobFil := .T.
	EndIf
EndIf

If lJobEmp .Or. lJobFil

	cIDThread := cValToChar(ThreadID())
	cSemaforo := "A330TT2B2_"+cIDThread+"_"+CEMPANT
	A330JobManual("1", cSemaforo, "M330TT2CONNECT" )

	For nForFilial := 1 to Len(aFilsCalc)
		If aFilsCalc[nForFilial,1]
			// Altera filial corrente
			cFilAnt:=aFilsCalc[nForFilial,2]

			// Reinicia variavel
			nRetry_0  :=0
			nRetry_1  :=0
			aJobAux   :={}
			aThreads  :={}

			// Calcula a quantidade de Threads
			aThreads := M330QtdThr()

			For nX :=1 to Len(aThreads)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o log de processamento			    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				M330PrcLog("MENSAGEM",OemToAnsi(I18N(STR0181,{cFilAnt,StrZero(nX,3)})), CountTRT(,aThreads[nX])) //"Custo Unificado - Filial:#1[D MG 01] - Thread:#1[001] - (0) Inicio"

				// Informacoes do semaforo
				cJobFile:= cStartPath + CriaTrab(Nil,.F.)+".job"

				// Adiciona o nome do arquivo de Job no array aJobAux
				aAdd(aJobAux,{StrZero(nX,2),cJobFile})

				// Inicializa variavel global de controle de thread
				cJobAux:="cUNI"+cEmpAnt+cFilAnt+StrZero(nX,2)
				A330LckGlb(cJobAux)
				PutGlbValue(cJobAux,"0")
				A330ULckGlb(cJobAux)

				// Fecha as tabelas utilizadas no Job
				SB2->(DbGoTo(SB2->(Recno()))) //Força refresh do cache
				SB1->(DbGoTo(SB1->(Recno()))) //Força refresh do cache

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Dispara thread para o calculo do Custo Unificado ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				while ! IPCGO( cSemaforo,cEmpAnt,cFilAnt,aThreads[nX],cJobFile,StrZero(nX,2),lExistProc,cNomTRT,NIL,lCstPart,aRegraCP,lCusEmp,lCusFil,lFiltraUnif,,cNomTR2)
					for nI := 1 to 2
						sleep(1000)
					Next nI
				End
			Next nX

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Controle de Seguranca para MULTI-THREAD                                   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For nX :=1 to Len(aThreads)
				nPos := ASCAN(aJobAux,{|x| x[1] == StrZero(nX,2)})

				// Informacoes do semaforo
				cJobFile:= aJobAux[nPos,2]

				// Inicializa variavel global de controle de thread
				cJobAux:="cUNI"+cEmpAnt+cFilAnt+StrZero(nX,2)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Analise das Threads em Execucao                              ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				While .T.
					Do Case
						// TRATAMENTO PARA ERRO DE SUBIDA DE THREAD
						Case GetGlbValue(cJobAux) == '0'
							If nRetry_0 > 50
								Conout(Replicate("-",80))							 	//"----------------------------------------------------------------------------"
								Conout("MATA330: "+ STR0182 + " " + StrZero(nX,3) )		//"MATA330: Não foi possivel realizar a subida da thread (Custo Unificado)     "
								Conout(Replicate("-",80))  								//"----------------------------------------------------------------------------"
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Atualiza o log de processamento			    ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								M330PrcLog("MENSAGEM",STR0183 +" " +STR0127 +StrZero(nX,3) +STR0067+cFilAnt,STR0183)	//"Não foi possivel realizar a subida da thread (Custo Unificado)"
								Final(STR0167) 							//"Não foi possivel realizar a subida da thread (Custo Unificado)"
							Else
								nRetry_0 ++
							EndIf
						// TRATAMENTO PARA ERRO DE CONEXAO
						Case GetGlbValue(cJobAux) == '1'
							If FCreate(cJobFile) # -1
								If nRetry_1 > 5
									Conout(Replicate("-",80))  //"----------------------------------------------------"
									Conout(STR0184) 			//"MATA330: Erro de conexao na thread Custo Unificado "
									Conout(STR0127 + cJobAux )	//"Thread numero : "
									Conout(STR0128)				//"Numero de tentativas excedidas"
									Conout(Replicate("-",80))  //"----------------------------------------------------"
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Atualiza o log de processamento			    ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									M330PrcLog("MENSAGEM",STR0184 +" " +STR0127 +StrZero(nX,3) +STR0067+cFilAnt,STR0184)	//"MATA330: Erro de conexao na thread Custo Unificado "
									Final(STR0184)				   			//"MATA330: Erro de conexao na thread Custo Unificado "
								Else
									// Inicializa variavel global de controle de Job
									A330LckGlb(cJobAux)
									If GetGlbValue(cJobAux) == '1'
										PutGlbValue(cJobAux, "0" )
										A330ULckGlb(cJobAux)
									else
										A330ULckGlb(cJobAux)
										Loop
									EndIf
									// Reiniciar thread de contabilizacao
									Conout(Replicate("-",80))					//"---------------------------------------------------"
									Conout(STR0184) 							//"MATA330: Erro de conexao na thread Custo Unificado "
									Conout(STR0129+StrZero(nRetry_1,2))			//"Tentativa numero: "
									Conout(STR0130+StrZero(nX,3))				//"Reiniciando a thread : "
									Conout(Replicate("-",80))                  //"----------------------------------------------------"
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Atualiza o log de processamento			    ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									M330PrcLog("MENSAGEM",STR0130+StrZero(nX,3) +STR0067+cFilAnt,STR0130+StrZero(nX,3))	//"Reiniciando a thread : "
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Dispara thread para o calculo do Custo Unificado ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//									StartJob("A330TT2B2",GetEnvServer(),lThrSeq,.T.,cEmpAnt,cFilAnt,aThreads[nX],cJobFile,StrZero(nX,2),lExistProc,cNomTRT,NIL,lCstPart,aRegraCP,lCusEmp,lCusFil,lFiltraUnif,,cNomTR2)
								EndIf
								nRetry_1 ++
							EndIf
						// TRATAMENTO PARA ERRO DE APLICACAO
						Case GetGlbValue(cJobAux) == '2'
							If (nRetry_1 := FCreate(cJobFile)) # -1
								Sleep(5000)
								If GetGlbValue(cJobAux) # '2'	//-- Tratamento para falso positivo: quando thread muda entre as consultas
									FClose(nRetry_1)
									FErase(cJobAux)
									Loop
								EndIf
								Conout(Replicate("-",80))	//"-----------------------------------------------------"
								Conout(STR0185)				//"MATA330: Erro de aplicacao na thread Custo Unificado "
								Conout(STR0127+cJobAux)		//"Thread numero : "
								Conout(Replicate("-",80))  //"------------------------------------------------------"
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Atualiza o log de processamento			    ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								M330PrcLog(STR0185+ " " +STR0127 +StrZero(nX,3) +STR0067+cFilAnt,STR0185+ "JobFile: "+cJobFile)	//"MATA330: Erro de aplicacao na thread Custo Unificado " ## "Thread numero : "
								Final(STR0185)				//"MATA330: Erro de aplicacao na thread Custo Unificado "
							EndIf
						// THREAD PROCESSADA CORRETAMENTE
						Case GetGlbValue(cJobAux) == '3'
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Atualiza o log de processamento			    ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							M330PrcLog("MENSAGEM",OemToAnsi(I18N(STR0186,{cFilAnt,StrZero(nX,3)})), OemToAnsi(I18N(STR0186,{cFilAnt,StrZero(nX,3)}))) //"Custo Unificado - Filial:#1[D MG 01] - Thread:#1[001] - (1) Termino"
							Exit
					EndCase
					for nI := 1 to 2
						sleep(1000)
					Next nI
				End
			Next nX

			// Custo por Empresa somente executar uma unica vez
			If lCusEmp
				Exit
			EndIf
		EndIf
	Next nForFilial

	cIDThread := cValToChar(ThreadID())
	cSemaforo := "A330TT2B2_"+cIDThread+"_"+CEMPANT
	A330JobManual("2", cSemaforo, "M330TT2CONNECT" )

EndIf

// Restaura filial original apos processamento
cFilAnt:=cFilBack

M330PrcLog("MENSAGEM",IIf(lCusFil,STR0112,STR0120),IIf(lCusFil,STR0112,STR0120)) //"Acerto de custo unificado por Filial - (1) Termino" ## "Acerto de custo unificado por Empresa - (1) Termino"

RestArea(aAreaSB1)
aSize(aAreaSB1,0)
aAreaSB1 := nil

RestArea(aAreaSB2)
aSize(aAreaSB2,0)
aAreaSB2 := nil

RestArea(aAreaAnt)
aSize(aAreaAnt,0)
aAreaAnt := nil
Return

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³M330TrfOri  ³ Autor ³ Robson Sales		³      |22/10/2013³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retorna o custo da NF de saida para transferencia entre    ³±±
±±³          ³ Filiais onde entrada e saida estao em periodos diferentes  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cFilDest - Filial de destino da transferencia              ³±±
±±³          ³ cDoc     - Numero do documento da transferencia            ³±±
±±³          ³ cSerie   - Numero de serie da transferencia                ³±±
±±³          ³ cProd    - Codigo do produto                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ aRet     - Array contendo o custo da NF de saida           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ*/

Function M330TrfOri(cFilDest,cFilOri,cDoc,cSerie,cProd,cTipoNf,nQuant,cItem,lCstPart,aRegraCP)

Local aAreaA1   := SA1->(GetArea())
Local aAreaD2   := SD2->(GetArea())
Local aAreaM0   := SM0->(GetArea())
Local cAlias    := GetNextAlias()
Local lContinua := .F.
Local aCM       := {0,0,0,0,0}
Local aCMFF     := {0,0,0,0,0}
Local aCMRep    := {0,0,0,0,0}
Local _cCampo   := ""
Local _nLoop0   := 0
Local _nLoop1   := 0
Local nNumRegD2 := 0
Local aRetPartes:= {}
Local cCNPJ		:= ""
Local cCliOri   := Space(Len(SA2->A2_COD))
Local cLojaOri  := Space(Len(SA2->A2_LOJA))
Local cQry		:= ""
Local aRet[04]
Local lCusFIFO  := SuperGetMV("MV_CUSFIFO",.F.,.F.)
Local lCusRep   := SuperGetMv("MV_CUSREP",.F.,.F.)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Caso o cliente utilize o processo de transferencia com MV_FILTRF=.T. ³
//³ realiza a pesquisa via Query para ganho de performance               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If UsaFilTrf()
	If cTipoNf $ "D|B"  // Se SD1 tipo B/D, saida do tipo B (Usa fornecedor - SA2)
		cQry := "SELECT A2_FILIAL, A2_COD, A2_LOJA, A2_FILTRF FROM "+RetSqlName("SA2")
		cQry += "WHERE A2_FILIAL = '"+xFilial("SA2",cFilOri)+"' AND A2_FILTRF = '"+cFilDest+"' AND D_E_L_E_T_ = ' '"
		cQry := ChangeQuery(cQry)
		DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQry),cAlias,.T.,.T.)
		If !(cAlias)->(Eof())
			cCliOri := (cAlias)->A2_COD
			cLojaOri := (cAlias)->A2_LOJA
			lContinua := .T.
		EndIf
		(cAlias)->(dbCloseArea())
	Else               // Se SD1 tipo N, saida do tipo N (Usa cliente - SA1)
		cQry := "SELECT A1_FILIAL, A1_COD, A1_LOJA, A1_FILTRF FROM "+RetSqlName("SA1")
		cQry += "WHERE A1_FILIAL = '"+xFilial("SA1",cFilOri)+"' AND A1_FILTRF = '"+cFilDest+"' AND D_E_L_E_T_ = ' '"
		cQry := ChangeQuery(cQry)
		DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQry),cAlias,.T.,.T.)
		If !(cAlias)->(Eof())
			cCliOri := (cAlias)->A1_COD
			cLojaOri := (cAlias)->A1_LOJA
			lContinua := .T.
		EndIf
		(cAlias)->(dbCloseArea())
	EndIf
Else
	dbSelectArea("SM0") // Busca o CNPJ da Filial Destino
	If MsSeek(cEmpAnt+cFilDest)
		cCNPJ := SM0->M0_CGC
	EndIf

	If cTipoNf $ "D|B"  // Se SD1 tipo B/D, saida do tipo B (usa fornecedor - SA2)
		dbSelectArea("SA2")
		dbSetOrder(3)
		If MsSeek(xFilial("SA2",cFilOri)+cCNPJ)
			cCliOri   := A2_COD
			cLojaOri  := A2_LOJA
			lContinua := .T.
		EndIf
	Else              // Se SD1 tipo N, saida do tipo N (usa cliente - SA1)
		dbSelectArea("SA1")
		dbSetOrder(3)
		If MsSeek(xFilial("SA1",cFilOri)+cCNPJ)
			cCliOri   := A1_COD
			cLojaOri  := A1_LOJA
			lContinua := .T.
		EndIf
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Caso o nao encontre a NF de origem, aCust retorna NIL para garantir  ³
//³ o funcionamento do processo                                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lContinua

	cQry := "SELECT R_E_C_N_O_ NUMREGD2 FROM "+RetSqlName("SD2")
	cQry += " WHERE D2_FILIAL = '" + xFilial("SD2",cFilOri) + "'"
	cQry += " AND D2_DOC     = '" + cDoc + "'"
	cQry += " AND D2_SERIE   = '" + cSerie + "'"
	cQry += " AND D2_CLIENTE = '" + cCliOri + "'"
	cQry += " AND D2_LOJA    = '" + cLojaOri + "'"
	cQry += " AND D2_ITEM    = '" + A330ConvIT(SD1->D1_ITEM,'SD2')+ "'" //STATICCALL(MATA103,CodeSoma1,SD1->D1_ITEM,TamSX3("D2_ITEM")[1]) + "'"
	cQry += " AND D_E_L_E_T_ = ' ' "

	//cQry := ChangeQuery(cQry)

	DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQry),cAlias,.T.,.T.)
	If !(cAlias)->(Eof())
		nNumRegD2 := (cAlias)->NUMREGD2

		// Calculo do Custo Medio para retornos de transferencia de Filial
		SD2->(dbGoto(nNumRegD2))
		aCM[1] := SD2->D2_CUSTO1
		aCM[2] := SD2->D2_CUSTO2
		aCM[3] := SD2->D2_CUSTO3
		aCM[4] := SD2->D2_CUSTO4
		aCM[5] := SD2->D2_CUSTO5
		// Calculo do Custo FIFO para retornos de transferencia de Filial
		If lCusFIFO
			aCMFF[1] :=	SD2->D2_CUSFF1
			aCMFF[2] := SD2->D2_CUSFF2
			aCMFF[3] := SD2->D2_CUSFF3
			aCMFF[4] := SD2->D2_CUSFF4
			aCMFF[5] := SD2->D2_CUSFF5
		EndIf
		// Calculo do Custo de Reposicao para retornos de transferencia de Filial
		If lCusRep
			aCMRep[1] := SD2->D2_CUSRP1
			aCMRep[2] := SD2->D2_CUSRP2
			aCMRep[3] := SD2->D2_CUSRP3
			aCMRep[4] := SD2->D2_CUSRP4
			aCMRep[5] := SD2->D2_CUSRP5
		EndIf
		// Calculo do Custo em Partes para retornos de transferencia de Filial
		If lCstPart
			For _nLoop0:=1 to Len(aRegraCP)+1
				For _nLoop1:=1 to 5
					_cCampo := "D2_CP"
					_cCampo :=_cCampo+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0)
					AADD(aRetPartes,SD2->(FIELDGET(FieldPos(_cCampo))))
				Next _nLoop1
			Next _nLoop0
		EndIf
	EndIf
	(cAlias)->(dbCloseArea())
EndIf

// Montagem do Array de Retorno
aRet[01] := aCM
aRet[02] := aCMFF
aRet[03] := aRetPartes
aRet[04] := aCMRep

RestArea(aAreaA1)
aSize(aAreaA1,0)
aAreaA1 := nil

RestArea(aAreaD2)
aSize(aAreaD2,0)
aAreaD2 := nil

RestArea(aAreaM0)
aSize(aAreaM0,0)
aAreaM0 := nil

Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} MAEnvInteg()
Envia para IntegDef
@author Leonardo Quintania
@since 01/05/2014
@version 1.0
@return NIL
/*/
//-------------------------------------------------------------------
Static Function MAEnvInteg(cLista)
Local cJoin		:= ""
Local cHaving 	:= ""
Local cQuery 	:= ""
Local cFuncSubs := "SUBSTRING"
Local nTamSB1   := AtTamFilTab("SB1")
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Tratamento para SUBSTRING em diferentes BD's ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If TCGetDB() $ "ORACLE/POSTGRES/DB2/INFORMIX"
	cFuncSubs  	:= "SUBSTR"
EndIf

cAliasTemp := GetNextAlias()

If Empty(cLista)
	cLista := "'" + PadR(cFilAnt,Len(xFilial("SB2"))) + "'"
EndIf

//-- Parametro para filtrar produtos sem movimentação no período do recálculo
If SuperGetMV("MV_I330FSM",.F.,.F.)
	//-- Analisa SD1
	cJoin += "	LEFT JOIN "+RetSqlName('SD1')+" SD1 ON "
	cJoin += "SD1.D1_FILIAL = SB2.B2_FILIAL AND "
	cJoin += "SD1.D1_COD = SB2.B2_COD AND "
	cJoin += "SD1.D1_LOCAL = SB2.B2_LOCAL AND "
	cJoin += "SD1.D1_DTDIGIT BETWEEN '" +DToS(dInicio) +"' AND '" +DToS(a330ParamZX[01]) +"' AND "
	cJoin += "EXISTS (SELECT 1 FROM "+ RetSqlName("SF4") +" SF4 WHERE SF4.F4_FILIAL = '"+ xFilial("SF4") +"' AND"
	cJoin += " SF4.F4_CODIGO = SD1.D1_TES AND SF4.F4_ESTOQUE = 'S' AND  "
	cJoin += " SF4.D_E_L_E_T_ = ' ') AND "
	cJoin += " SD1.D_E_L_E_T_ = ' ' "
	//-- Analisa SD2
	cJoin += "LEFT JOIN "+RetSqlName('SD2')+" SD2 ON SD2.D_E_L_E_T_ = ' ' AND "
	cJoin += "SD2.D2_FILIAL = SB2.B2_FILIAL AND "
	cJoin += "SD2.D2_COD = SB2.B2_COD AND "
	cJoin += "SD2.D2_LOCAL = SB2.B2_LOCAL AND "
	cJoin += "SD2.D2_EMISSAO BETWEEN '" +DToS(dInicio) +"' AND '" +DToS(a330ParamZX[01]) +"' AND "
	cJoin += "SD2.D2_ESTOQUE = 'S' "
	//-- Analisa SD3
	cJoin += "LEFT JOIN "+RetSqlName('SD3')+" SD3 ON SD3.D_E_L_E_T_ = ' ' AND "
	cJoin += "SD3.D3_FILIAL = SB2.B2_FILIAL AND "
	cJoin += "SD3.D3_COD = SB2.B2_COD AND "
	cJoin += "SD3.D3_LOCAL = SB2.B2_LOCAL AND "
	cJoin += "SD3.D3_ESTORNO = ' ' AND "
	cJoin += "SD3.D3_EMISSAO BETWEEN '" +DToS(dInicio) +"' AND '" +DToS(a330ParamZX[01]) +"' "

	//-- Analisa SD1
	cHaving += " HAVING COUNT(SD1.D1_FILIAL) > 0 OR COUNT(SD2.D2_FILIAL) > 0 OR COUNT(SD3.D3_FILIAL) > 0 "
EndIf

cQuery := " SELECT SB2.B2_FILIAL,"
cQuery += " 	SB2.B2_COD"
cQuery += " FROM " + RetSqlName("SB2") + " SB2"
cQuery += " JOIN " + RetSqlName("SB1") + " SB1"
cQuery += "     ON SB1.D_E_L_E_T_ = ' '"
If FWModeAccess("SB1") == "E"
	cQuery += " AND SB1.B1_FILIAL = SB2.B2_FILIAL"
ElseIf nTamSB1 == 0
	cQuery += " AND SB1.B1_FILIAL = '" + Space(Len(FWCodFil())) + "' "
Else
	cQuery += " AND RTRIM(SB1.B1_FILIAL) = RTRIM(" + cFuncSubs + "(SB2.B2_FILIAL,1," + cValToChar(nTamSB1) +"))"
EndIf
cQuery += "     AND SB1.B1_COD = SB2.B2_COD"
cQuery += "     AND SB1.B1_CCCUSTO = '" + CriaVar("B1_CCCUSTO") + "'"
cQuery += "     AND "+cFuncSubs+"(SB1.B1_COD,1,3) <> 'MOD'"
cQuery += cJoin
cQuery += " WHERE SB2.D_E_L_E_T_ = ' '"
cQuery += " AND SB2.B2_FILIAL IN (" + cLista + ")"
cQuery += " GROUP BY SB1.B1_FILIAL, SB2.B2_FILIAL, SB2.B2_COD "
cQuery += cHaving
cQuery += " ORDER BY SB2.B2_COD"

cQuery := ChangeQuery(cQuery)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTemp,.F.,.T.)

TCSetField(cAliasTemp,"B1_UCOM","D",8,0)
TCSetField(cAliasTemp,"B1_UCALSTD","D",8,0)

While !(cAliasTemp)->(EOF())
	cFilAnt := (cAliasTemp)->B2_FILIAL // posiciona para uso no integdef e mati330 devido a query acima nunca será em branco
	SB1->(dbSetOrder(1))
	SB1->(MSSeek(xFilial('SB1')+(cAliasTemp)->B2_COD))
	SB5->(MSSeek(xFilial('SB5')+(cAliasTemp)->B2_COD))
	FwIntegDef("MATA330")
	(cAliasTemp)->(dbSkip())
EndDo

(cAliasTemp)->(DbCloseArea())
cFilAnt := cFilBack

Return NIL

//-------------------------------------------------------------------
/*/{Protheus.doc} IntegDef()
Funcao de tratamento para o recebimento/envio de mensagem
@author Leonardo Quintania
@since 01/05/2014
@version 1.0
@return NIL
/*/
//-------------------------------------------------------------------
Static Function IntegDef( cXML, nTypeTrans, cTypeMessage, cVersion, cTransac, lEAIObj )
Local aRet := {}

Default cXML := ""
Default nTypeTrans := ""
Default cTypeMessage := ""
Default cVersion := ""
Default cTransac := ""
Default lEAIObj := .F.

aRet := MATI330(cXML, nTypeTrans, cTypeMessage ,@cAliasTemp, cVersion, cTransac, lEAIObj)

Return aRet

//--------------------------------------------------------------------------
/*/{Protheus.doc} A330LimCtt
Limpa variavel de controle de threads por filial
@author Victor Rezende
@since 17/03/17
@param cFilTRC
/*/
//--------------------------------------------------------------------------
Function A330LimCtt(cFilTRC)
Local nIndFil	:= Ascan(a330RegCTB, {|x| x[1] == cFilTRC})
If nIndFil > 0
	a330RegCTB[nIndFil] := {cFilTRC,0,0,"","",0}
EndIf
Return Nil


/*/{Protheus.doc} M330DocTran
Processa os documento de Entrada referentes ao documento em transito proveniente da transferencia entre filiais
ATENÇÃO: O uso desta funcao é dependente da chamada pelas funcoes A330Recalc/M330JobCM, fora isso o seu uso não é recomendado
@author reynaldo
@since 28/06/2018
@version 1.0
@return ${return}, ${return_description}
@param aCusto, array, descricao
@param aCustoFF, array, descricao
@param lCstPart, logical, descricao
@param aRegraCP, array, descricao
@param aCMPartes, array, descricao
@param lIntCusTMS, logical, descricao
@param lCusRep, logical, descricao
@param aCMRep, array, descricao
@param lCusFil, logical, descricao
@param lCusEmp, logical, descricao
@param aRetPartes, array, descricao
@param cLocTran, characters, descricao
@type function
/*/
Function M330DocTran(aCusto,aCustoFF,lCstPart,aRegraCP,aCMPartes,lIntCusTMS,lCusRep,aCMRep,lCusFil,lCusEmp,aRetPartes,cLocTran)
Local aArea    := {}
Local aAreaSD3 := {}
Local cFilialSD3

aArea := GetArea()
If SF4->F4_TRANSIT == 'S'

	dbSelectArea("SD3")
	aAreaSD3 := SD3->(GetArea())
	dbSetOrder(3)

	cFilialSD3 := xFilial("SD3")

	If dbSeek(cFilialSD3+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_NUMSEQ+"DE6")
		//Funcao que irá efetuar a gravação referente a movimentacao do documento em transito na transferencia de filiais.
		GrvMovTran(aCusto,aCustoFF,lCstPart,aRegraCP,aCMPartes,lIntCusTMS,lCusRep,aCMRep,lCusFil,lCusEmp,aRetPartes)

	EndIf

	If dbSeek(cFilialSD3+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_NUMSEQ+"RE6")
		//Funcao que irá efetuar a gravação referente a movimentacao do documento em transito na transferencia de filiais.
		GrvMovTran(aCusto,aCustoFF,lCstPart,aRegraCP,aCMPartes,lIntCusTMS,lCusRep,aCMRep,lCusFil,lCusEmp,aRetPartes)

	EndIf

	If dbSeek(cFilialSD3+SD1->D1_COD+cLocTran+SD1->D1_NUMSEQ+"DE6")
		//Funcao que irá efetuar a gravação referente a movimentacao do documento em transito na transferencia de filiais.
		GrvMovTran(aCusto,aCustoFF,lCstPart,aRegraCP,aCMPartes,lIntCusTMS,lCusRep,aCMRep,lCusFil,lCusEmp,aRetPartes)

	EndIf

	If dbSeek(cFilialSD3+SD1->D1_COD+cLocTran+SD1->D1_NUMSEQ+"RE6")
		//Funcao que irá efetuar a gravação referente a movimentacao do documento em transito na transferencia de filiais.
		GrvMovTran(aCusto,aCustoFF,lCstPart,aRegraCP,aCMPartes,lIntCusTMS,lCusRep,aCMRep,lCusFil,lCusEmp,aRetPartes)

	EndIf

	RestArea(aAreaSD3)
	aSize(aAreaSD3,0)
	aAreaSD3 := nil
EndIf
RestArea(aArea)
aSize(aArea,0)
aArea := nil

Return .T.

/*/{Protheus.doc} GrvMovTran
Funcao que irá efetuar a gravação referente a movimentacao do documento em transito na transferencia de filiais.
 O uso desta funcao é dependente da chamada pela funcao M330DocTran, fora isso o seu uso não é recomendado
@author reynaldo
@since 28/06/2018
@version 1.0
@return ${return}, ${return_description}
@param aCusto, array, descricao
@param aCustoFF, array, descricao
@param lCstPart, logical, descricao
@param aRegraCP, array, descricao
@param aCMPartes, array, descricao
@param lIntCusTMS, logical, descricao
@param lCusRep, logical, descricao
@param aCMRep, array, descricao
@param lCusFil, logical, descricao
@param lCusEmp, logical, descricao
@param aRetPartes, array, descricao
@type function
/*/

Static Function GrvMovTran(aCusto,aCustoFF,lCstPart,aRegraCP,aCMPartes,lIntCusTMS,lCusRep,aCMRep,lCusFil,lCusEmp,aRetPartes)

Local cAliasBkp := Alias()
Local nOrdemBkp := IndexOrd()
Local aRet		:= {}

	If aCusto != NIL
		aRet   := GravaCusD3(aCusto,.T.,Nil,"330",NIL,lCstPart,aRegraCP,aClone(aCMPartes),lIntCusTMS,SD3->D3_QUANT,lCusRep,aCMRep)
		aCusto := AClone(aRet[1])
	Else
		aRet  	 := GravaCusD3(NIL,.T.,aCustoFF,"330",NIL,lCstPart,aRegraCP,aClone(aCMPartes),lIntCusTMS,SD3->D3_QUANT,lCusRep,aCMRep)
		aCustoFF := AClone(aRet[2])
	EndIf

	// Nesta funcao não tem a necessidade de posicionar o recno, por isso q não foi utilizado getarea/restarea
	// Pois a  função TTFimcomD3 não retorna para a area do alias SD3, desposicionado o alias original
	//por isso é necessário abrir novamente a área senão o proximo dbseek é feito no alias TRT
	If !Empty(cAliasBkp)
		dbSelectArea(cAliasBkp)
		dbSetOrder(nOrdemBkp)
	EndIf

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} A330CrTabs
Abre/cria as tabelas/alias temporarios utilizados no recalculo de custos

Importante: Esta função é chamada no MATA330 e CFGX051.
@author andre.oliveira
@since 18/07/2019
@param ${aFilsCalc}	, ${array},  ${Array de controle das filiais em processamento do recalculo de custos medio}
@param ${lCFG20}	, ${lógico}, ${Indica se a chamada é do CFGX051, processo 20}
@return ${return}	, ${Nulo}
/*/
//-------------------------------------------------------------------
Function A330CrTabs(aFilsCalc,lCFG20,cThreadID)
Local lEstruMov := .F.
Local lCheck    := .F.
Local lLoadInd  := .F.
Local nX        := 0
Local nY        := 0
Local nIndice   := 0
Local cDelete   := ""
Local cListaFil := ""
Local aCampos   := {}
Local aIndices  := {}
Local aAliasTmp := {}
Local nSG1Index := 0
Local nZ        := 0

Local cWhere
Default lCFG20 := .F.

If IsInCallStack ('MATA331')
	aAliasTmp := {	{"TRC","TRC"+cEmpAnt+"SP","GetTRStru("} }    //-- Esta Função está codificada no arquivo MATA330.PRX
Else
	aAliasTmp := {	{"TRA","TRA"+cEmpAnt+"SP","GetTRAStru("},;         //-- Esta Função esta codificada no arquivo MATXFUNA.PRX
					{"TRB","TRB"+cEmpAnt+"SP","GetTRBStru("},;         //-- Esta Função esta codificada no arquivo MATXFUNA.PRX
					{"SG1","TRB"+cEmpAnt+"SPSG1","GetTSG1Str("},;      //-- Esta Função esta codificada no arquivo MATA330.PRX
					{"TRC","TRC"+cEmpAnt+"SP","GetTRStru("},;          //-- Esta Função esta codificada no arquivo MATA330.PRX
					{"TRD","TRD"+cEmpAnt+"SP","GetTRDStru("},;		   //-- Esta Função esta codificada no arquivo MATXFUNA.PRX
					{"TRT","TRT"+cEmpAnt+"SP","GetTRTStru(NIL,NIL,"},; //-- Esta Função esta codificada no arquivo MATXFUNA.PRX
					{"TRX","TRX"+cEmpAnt+"SP","GetTRXStru("}}          //-- Esta Função esta codificada no arquivo MATXFUNA.PRX
	If UsaTR2()
		AAdd(aAliasTmp, {"TR2","TR2"+cEmpAnt+"SP","GetTR2Stru("}) //-- Esta Função está codificada no arquivo MATA330.PRX
	EndIf
EndIf

If Empty(aFilsCalc) //-- Chamada do CFGX051 - Instalação de procedures
	//-- Dropa todas os indices e as tabelas para forçar sua recriação
	For nY := 1 To Len(aAliasTmp)
		If (!lCFG20 .Or. aAliasTmp[nY,1] == "SG1") .And. TcCanOpen(aAliasTmp[nY,2])
			aRetIndex := GetTSG1Str (2)
			For nz:= 1 to len(aRetIndex)
				cIndexName := "TRB"+cEmpAnt+"SPSG1"+strzero(nz,2)
				If TCCanOpen("TRB"+cEmpAnt+"SPSG1", cIndexName )
					TcDelIndex("TRB"+cEmpAnt+"SPSG1",cIndexName)
				EndIf
			Next n 			
			TcDelFile(aAliasTmp[nY,2])
		EndIf
	Next nY
Else //-- Chamda do MATA330 - Recalculo de custos
	lEstruMov := a330ParamZX[11] == 1
EndIf

//-- Abre/cria tabelas
For nY := 1 To Len(aAliasTmp)
	If lCFG20 .And. aAliasTmp[nY,1] <> "SG1" //-- Instalação da procedure do processo 20 (processa somente SG1)
		Loop
	EndIf

	//-- MATA330: Ajusta indice de pesquisa da SG1 de acordo com uso da estrutura temporária
	If !Empty(aFilsCalc) .And. aAliasTmp[nY,1] == "SG1" .And. !lEstruMov
		SG1->(dbSetOrder(1)) //-- G1_FILIAL+G1_COD+G1_COMP
		Loop
	EndIf

	//Limpeza dos arrays
	For nZ := 1 To Len(aCampos)
		aSize(aCampos[nZ], 0)
		aCampos[nZ] := Nil
	Next nZ
	aSize(aCampos, 0)
	aCampos := Nil
	aSize(aIndices, 0)
	aIndices := Nil

	//-- Obtem estrutura da tabela e indices
	aCampos  := &(aAliasTmp[nY,3] +"1)")
	aIndices := &(aAliasTmp[nY,3] +"2)")

	//-- Cria tabela fisica, se não existir, e abre alias
	If !TCCanOpen(aAliasTmp[nY,2])
		If (IsInCallStack("EngPre19Compile") .Or. IsInCallStack("EngPre20Compile")) .And. FindFunction("EngSPSWorkTable")
			EngSPSWorkTable("",aAliasTmp[nY,2],aCampos,.T.)
		Else
			CriaTmpDb("",aAliasTmp[nY,2],aCampos,.T.)
		EndIf
		lCheck := .T.	//-- Não valida estrutura
	EndIf
	If Select(aAliasTmp[nY,1]) > 0
		(aAliasTmp[nY,1])->(dbCloseArea())
	EndIf
	dbUseArea(.T.,"TOPCONN",aAliasTmp[nY,2],aAliasTmp[nY,1],.T.,.F.)

	If aAliasTmp[nY,1] == "SG1"
		DBClearIndex()
		nSG1Index := 0
		For nX := 1 To Len (aIndices)
			If TCCanOpen(aAliasTmp[nY,2],aAliasTmp[nY,2] +StrZero(nX,2))
				DBSetIndex(aAliasTmp[nY,2] +StrZero(nX,2))
				nSG1Index++
			EndIf
			//Se algum índice criado no banco diverge da estrutura, dropa todos os índices
			If !Empty(alltrim((aAliasTmp[nY,1])->(INDEXKEY(nX)))) .And.;
			    alltrim((aAliasTmp[nY,1])->(INDEXKEY(nX))) <> alltrim(aIndices [nX])
				A330DelIndex( aAliasTmp[nY,2] )
				nSG1Index := Len(aIndices)
				Exit
			EndIf
		Next nX
		//Se a quantidade de índices for diferente da estrutura, dropa todos os índices
		If nSG1Index > 0 .And. nSG1Index <> Len(aIndices)
			A330DelIndex( aAliasTmp[nY,2] )
		EndIf
	ENDIF

	//-- Se estrutura da tabela mudou, força recriação
	If !lCheck .And. !EstruTabOk(aAliasTmp[nY,1],aCampos)
		(aAliasTmp[nY,1])->(dbCloseArea())

		A330DelIndex( aAliasTmp[nY,2] ) // exclui todos os indices da tabela
		TcDelFile(aAliasTmp[nY,2])

		If FindFunction("EngSPSWorkTable")
			EngSPSWorkTable("",aAliasTmp[nY,2],aCampos,.T.)
		Else
			CriaTmpDb("",aAliasTmp[nY,2],aCampos,.T.)
		EndIf
		dbUseArea(.T.,"TOPCONN",aAliasTmp[nY,2],aAliasTmp[nY,1],.T.,.F.)
	EndIf

	//-- Valida e recria (se necessario) indices
	nIndice := 0
	lLoadInd := .F.
	For nX := 1 To Len(aIndices)
		nIndice++
		If TCCanOpen(aAliasTmp[nY,2],aAliasTmp[nY,2] +StrZero(nX,2))
			DBSetIndex(aAliasTmp[nY,2] +StrZero(nX,2))
			If !((aAliasTmp[nY,1])->(SqlOrder(IndexKey(nIndice))) == SqlOrder(aIndices[nX]))
				A330DelIndex( aAliasTmp[nY,2], aAliasTmp[nY,2] +StrZero(nX,2) ) // exclui 1 indice da tabela
				DBCreateIndex(aAliasTmp[nY,2] +StrZero(nX,2),aIndices[nX])
				//-- DBCreateIndex fecha todos os indices abertos e mantem somente o criado
				nIndice := 1
				lLoadInd := .T. //-- Flag para forçar atualização dos indices ao término
			EndIf
		Else
			//-- DBCreateIndex fecha todos os indices abertos e mantem somente o criado
			DBCreateIndex(aAliasTmp[nY,2] +StrZero(nX,2),aIndices[nX])
			nIndice := 1
			lLoadInd := .T. //-- Flag para forçar atualização dos indices ao término
		EndIf
	Next nX
	//-- Se mudou estrutura de indices, recarrega na ordem correta
	If lLoadInd
		DBClearIndex()
		For nX := 1 To Len (aIndices)
			DBSetIndex(aAliasTmp[nY,2] +StrZero(nX,2))
		Next nX
	EndIf

	If Empty(aFilsCalc)	.or. IsInCallStack ('MATA331') //-- Chamada do CFGX051 - Instalação de procedures ou contabilização
		(aAliasTmp[nY,1])->(dbCloseArea())
	Else 				//-- Chamada do MATA330 - Recalculo de custos
		TCRefresh(aAliasTmp[nY,2])

		cListaFil := A330Lista(aFilsCalc)

		//- montagem da estrutura para exclusão
		cDelete := "DELETE FROM "+aAliasTmp[nY,2]
		If aAliasTmp[nY,1] $ "TRB|TRT"
			If aAliasTmp[nY,1] == "TRT" .and. (lCusEmp .or. (!lCusEmp .and. !lCusFil))
				cDelete += "" // quando mv_cusfil = E ou A apaga todos os registros da TRT
			else
				cDelete += " WHERE TRB_FILIAL "
			EndIf
		ElseIf aAliasTmp[nY,1] == "SG1"
			cDelete += " WHERE G1_FILPROC "
		Elseif aAliasTmp[nY,1] == "TR2"
			cDelete += " WHERE B2_FILIAL "
		Else
			cDelete += " WHERE " +aAliasTmp[nY,1] +"_FILIAL "
		EndIf

		//- verfica se tem filiais
		If Empty(cListaFil)
			If "WHERE" $ cDelete
				If aAliasTmp[nY,1] == "TRT" .and. (lCusEmp .or. (!lCusEmp .and. !lCusFil))
					cWhere :=  "" // quando mv_cusfil = E ou A apaga todos os registros da TRT
				Else
					cWhere := " = ' '"
				EndIf
			EndIf

			If TcSqlExec(cDelete+cWhere) < 0
				//-- Atualiza o log de processamento com o erro
				M330PrcLog("ERRO","A330CrTabs",TCSQLError()) //-- Erro na execução da query
			EndIf
		Else
			For nX := 1 to Len(aFilsCalc)
				If aFilsCalc[nX, 1]
					cWhere := ""
					If "WHERE" $ cDelete
						If aAliasTmp[nY,1] == "TRT" .and. (lCusEmp .or. (!lCusEmp .and. !lCusFil))
							cWhere := "" // quando mv_cusfil = E ou A apaga todos os registros da TRT
						ElseIf aAliasTmp[nY,1] == 'SG1'
							cWhere := " = '"+cFilAnt+"' " //Quando SG1, apaga da filial logada do processamento
						Else
							cWhere := " = '"+aFilsCalc[nX,2]+"'"
						EndIf
					EndIf

					If TcSqlExec(cDelete+cWhere) < 0
						//-- Atualiza o log de processamento com o erro
						M330PrcLog("ERRO","A330CrTabs",TCSQLError()) //-- Erro na execução da query
					EndIf
				EndIf
			Next nX
		EndIF

		//-- Se custo unificado por empresa, adiciona produtos na TRT
		If aAliasTmp[nY,1] == "TRT" .And. lCusEmp
			TcSqlExec( "INSERT INTO " +aAliasTmp[nY,2] +" (TRB_COD) SELECT B1_COD FROM " +RetSqlName('SB1') +" WHERE D_E_L_E_T_ = ' ' GROUP BY B1_COD ")
		EndIf

		//-- Ajusta indice de pesquisa da SG1 de acordo com uso da estrutura temporária
		If aAliasTmp[nY,1] == "SG1"
			SG1->(dbSetOrder(Len(aIndices))) //-- G1_FILPROC+G1_FILIAL+G1_COD+G1_COMP
		EndIf

	EndIf
Next nY

For nZ := 1 To Len(aCampos)
	aSize(aCampos[nZ], 0)
	aCampos[nZ] := Nil
Next nZ
aSize(aCampos, 0)
aCampos := Nil
aSize(aIndices, 0)
aIndices := Nil
For nZ := 1 To Len(aAliasTmp)
	aSize(aAliasTmp[nZ], 0)
	aAliasTmp[nZ] := Nil
Next nZ
aSize(aAliasTmp, 0)
aAliasTmp := Nil
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} GetSG1Stru
Retorna estrutura da tabela temporária TRB##SPSG1

@author andre.oliveira
@since 18/07/2019
@param ${nOpc}	, ${numérico},	${1 para retornar campos, 2 para retornar indices)}
@return ${aRet}	, ${array},		${Array com campos, para nOpc = 1, ou índices, para nOpc = 2.}
/*/
//-------------------------------------------------------------------
Function GetTSG1Str(nOpc)
	Local aRet	:= {}
	Local aIndex := {}
	Local cIndex := ''
	Local nIndex := 0
	Local nField := 0

	If nOpc == 1 //-- Campos
		aRet := SG1->(dbStruct())
		aAdd(aRet,{"G1_FILPROC","C",FWSizeFilial(),0})
	Else //-- Indices
		aIndex := FWSIXUtil():GetAliasIndexes('SG1')
		For nIndex := 1 To Len(aIndex)
			cIndex := 'G1_FILPROC+'
			For nField := 1 To Len(aIndex[nIndex])
				cIndex += aIndex[nIndex,nField]+'+'
			Next nField
			cIndex := SubStr(cIndex, 1, Len(cIndex)-1)
			AAdd(aRet, cIndex)
		Next nIndex
		aAdd(aRet,"G1_FILPROC+G1_FILIAL+G1_COD+G1_COMP") //-- Indice para calculo de niveis
	EndIf

Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A330Param
registra na tabela CV8 os conteudo dos parametros (SX6) configurados na filial a ser processadas.

@author reynaldo
@since 25/09/2019
@param nenhum
@return nenhum
/*/
//-------------------------------------------------------------------
Static Function A330Param()
Local aNomParSX6
Local nLoop
Local cConteudo
Local uValue

	aNomParSX6 := {}
	aAdd(aNomParSX6,"MV_330ATCM")
	aAdd(aNomParSX6,"MV_A330190")
	aAdd(aNomParSX6,"MV_A330GRV")
	aAdd(aNomParSX6,"MV_AJUSNFC")
	aAdd(aNomParSX6,"MV_CQ")
	aAdd(aNomParSX6,"MV_CUSFIFO")
	aAdd(aNomParSX6,"MV_CUSFIL" )
	aAdd(aNomParSX6,"MV_CUSLIFO")
	aAdd(aNomParSX6,"MV_CUSMED")
	aAdd(aNomParSX6,"MV_CUSREP")
	aAdd(aNomParSX6,"MV_CUSTEXC")
	aAdd(aNomParSX6,"MV_CUSZERO")
	aAdd(aNomParSX6,"MV_D3SERVI")
	aAdd(aNomParSX6,"MV_DEPTRAN")
	aAdd(aNomParSX6,"MV_GERIMPV")
	aAdd(aNomParSX6,"MV_I330FSM")
	aAdd(aNomParSX6,"MV_LOCALIZ")
	aAdd(aNomParSX6,"MV_LOCPROC")
	aAdd(aNomParSX6,"MV_M330CON")
	aAdd(aNomParSX6,"MV_M330JCM")
	aAdd(aNomParSX6,"MV_M330PR1")
	aAdd(aNomParSX6,"MV_M330TCF")
	aAdd(aNomParSX6,"MV_M330THR")
	aAdd(aNomParSX6,"MV_MOEDACM")
	aAdd(aNomParSX6,"MV_NEGESTR")
	aAdd(aNomParSX6,"MV_NGMNTCM")
	aAdd(aNomParSX6,"MV_NGMNTES")
	aAdd(aNomParSX6,"MV_NGMNTPC")
	aAdd(aNomParSX6,"MV_NIVALT")
	aAdd(aNomParSX6,"MV_PCOINTE")
	aAdd(aNomParSX6,"MV_PROCCV3")
	aAdd(aNomParSX6,"MV_PROCQE6")
	aAdd(aNomParSX6,"MV_PRODMNT")
	aAdd(aNomParSX6,"MV_PRODMOD")
	aAdd(aNomParSX6,"MV_PRODPR0")
	aAdd(aNomParSX6,"MV_PROPCP")
	aAdd(aNomParSX6,"MV_RASTRO")
	aAdd(aNomParSX6,"MV_REMINT")
	aAdd(aNomParSX6,"MV_REQAUT")
	aAdd(aNomParSX6,"MV_SEQ300")
	aAdd(aNomParSX6,"MV_SEQ500")
	aAdd(aNomParSX6,"MV_SEQREBE")
	aAdd(aNomParSX6,"MV_THRSEQ")
	aAdd(aNomParSX6,"MV_ULMES")
	aAdd(aNomParSX6,"MV_UPC2ATU")
	aAdd(aNomParSX6,"MV_WMSNEW")
	aAdd(aNomParSX6,"MV_A330SB2")

	cConteudo := ""
	cConteudo += STR0202 + cFilAnt + chr(10) // "Filial a ser processada: "

	For nLoop := 1 to len(aNomParSX6)
		If aNomParSX6[nLoop] $ "MV_UPC2ATU|MV_SEQREBE|MV_A330SB2"
			uValue := GetMV(aNomParSX6[nLoop],.F.,.F.)
		Else
			uValue := GetMV(aNomParSX6[nLoop],.F.)
		EndIf

		cConteudo += Padr(aNomParSX6[nLoop] ,10)+": "
		cConteudo += cValToChar( uValue )
		cConteudo += Chr(10)
	Next nLoop

	M330PrcLog("MENSAGEM",STR0201 +cFilAnt ,cConteudo) // "Parametros do sistema da Filial "
	aSize(aNomParSX6,0)
Return


//-------------------------------------------------------------------
/*/{Protheus.doc} MontProc
Formata em uma string os valores informado no array aDataParam

@author reynaldo
@since 25/09/2019
@param nenhum
@return nenhum
/*/
//-------------------------------------------------------------------
Static Function MontProc(cProc, aDataParam)

Local nLoop:= 0
Local nTotal:= 0
Local cExecProc := ""
Local cParametro := ""
Local cType := ""

nTotal := Len(aDataParam)
cParam := ""
For nLoop := 1 To nTotal

	cParametro := aDataParam[nLoop]
	cType := ValType(cParametro)

	If cType == "C"
		cParam += "'"+cParametro+"' "
	ElseIf cType == "N"
		cParam += cValToChar(cParametro)+" "
	EndIf

	If nLoop< nTotal
		cParam += ","
	EndIf

Next nLoop

cExecProc := cProc +"("+cParam+")"

Return cExecProc

/*/{Protheus.doc} a330RegFil
	Quantifica por filial para contabilizacao
	@type  Function
	@author reynaldo
	@since 23/12/2019
	@version 1.0
	@param cListaFil, character, lista das filiais a serem processadas
	@param cNomTRC, character, nome da tabela TRC
	@return aRegCTB, array, tem as filiais selecionadas com a quantidade de movimentos a serem contabilizados
/*/
Static Function a330RegFil(cListaFil,cNomTRC)
Local cQuery	:= ""
Local cAliasFIL:= CriaTrab(,.F.)
Local aArea		:= {}
Local aRegCTB	:= {}
aArea := GetArea()

cQuery += "SELECT TRC_FILIAL, COUNT(1) COUNTREG "
cQuery += "FROM " + cNomTRC + " " + cAliasFIL + " "
cQuery += " WHERE TRC_FILIAL IN ("+cListaFil+") "
cQuery += " AND D_E_L_E_T_= ' ' "
cQuery += " GROUP BY TRC_FILIAL "
cQuery += " ORDER BY TRC_FILIAL ASC"

MPSysOpenQuery( cQuery, cAliasFIL,)

While (cAliasFIL)->(!Eof())

	If (cAliasFIL)->COUNTREG >0
		aAdd( aRegCTB,{(cAliasFIL)->TRC_FILIAL,(cAliasFIL)->COUNTREG,0,"","",0})
	EndIf

	(cAliasFIL)->(dbSkip())
Enddo
(cAliasFIL)->(dbCloseArea())
RestArea(aArea)
aSize(aArea,0)
aArea := nil
Return aRegCTB

/*/{Protheus.doc} M330331Lk
	Semaforo de execução do recalculo e contabilização
	@type  Function
	@author Nilton
	@since 22/02/2020
	@version 1.0
	@param aFilsCalc
	@return lRet
/*/
Function M330331Lk(aFilsCalc, lM038)
Local lRet       := .T.
Local nTentativa := 0
Local nForFilial := 0
Local cFilProb   := ""
Local nSizeIns	 := 0

Default lM038    := .F.

nSizeIns := TAMSX3('A1_INSCR')[1]

If !lM038
	cFilAnt:=cFilBack
	//Lock na filial logada, para impedir concorrência na CV8
	While !LockByName("M330331"+cEmpAnt+cFilAnt,.T.,.F.,.T.) .And. nTentativa <= 50
		nTentativa++
		Sleep(100)
	EndDo
	If nTentativa > 50
		lRet := .F.
		Aviso(STR0134,STR0135+cFilAnt,{"Ok"},2) // ##"Concorrência"##"As seguintes filiais da empresa corrente já estão sendo utilizadas no processo de recálculo do custo médio: "
		cFilAnt:=cFilBack
		Return lRet
	EndIf
EndIf

For nForFilial := 1 to Len(aFilsCalc)
	If lM038 .and. len(afilscalc[nForFilial]) < 6
		Aadd(afilscalc[nForFilial],padr(FWSM0Util():GetSM0Data(cEmpAnt,afilscalc[nForFilial,2],{'M0_INSC'})[1,2],nSizeIns))
	EndIf
	If aFilsCalc[nForFilial,1]
		// Altera filial corrente
		cFilAnt:=aFilsCalc[nForFilial,2]
		// Variavel de controle de tentativas
		nTentativa := 0
		// Trava arquivo para somente este usuario utilizar rotina
		While !LockByName("MT330331"+cEmpAnt+cFilAnt,.T.,.F.,.T.) .And. nTentativa <= 50
			nTentativa++
			Sleep(100)
		End
		// Tenta travar somente 50 vezes, e se nao conseguir coloca na lista de filiais com concorrencia
		If nTentativa > 50
			If Empty(cFilProb)
				cFilProb:=cFilAnt
			Else
				cFilProb+=","+cFilAnt
			EndIf
		Else
			// Marca que travou filial
			aFilsCalc[nForFilial,5]:=.T.
		EndIf
	EndIf
Next nForFilial
// Nao permite processamento concorrente
If !Empty(cFilProb)
	lRet := .F.
	Aviso(STR0134,STR0135+cFilProb,{"Ok"},2) // ##"Concorrência"##"As seguintes filiais da empresa corrente já estão sendo utilizadas no processo de recálculo do custo médio: "
EndIf
// Restaura filial original apos processamento
cFilAnt:=cFilBack
Return lRet

/*/{Protheus.doc} M330331ULk
	Reinicia o controle de semaforo do recalculo e contabilização
	@type  Function
	@author Nilton
	@since 22/02/2020
	@version 1.0
	@param aFilsCalc
	@return
/*/
Function M330331ULk(aFilsCalc, lM038)
Local nForFilial := 0

Default lM038    := .F.

If !lM038
	cFilAnt:=cFilBack
	UnLockByName("M330331"+cEmpAnt+cFilAnt,.T.,.F.,.T.)
EndIf

For nForFilial := 1 to Len(aFilsCalc)
	If aFilsCalc[nForFilial,5]
		// Altera filial corrente
		cFilAnt:=aFilsCalc[nForFilial,2]
		// Destrava o bloqueio de filiais
		UnLockByName("MT330331"+cEmpAnt+cFilAnt,.T.,.F.,.T.)
	EndIf
Next nForFilial
// Restaura filial original apos processamento
cFilAnt:=cFilBack
Return

/*/{Protheus.doc} A330CtbRat - Verifica se existe rateio por centro de custo na SA para contabilizar LP 67A/67B
@author Totvs
@since 10/03/2020
@version 1.0
@param cNumSA
@param cItemSA
@param cSeqCalc
@param cCodLan
@param lLct667669
@param a330ParamZX
@return Nao ha
/*/
Function A330CtbRat(cNumSA, cItemSA, cSeqCalc, cCodLan, lLct667669, a330ParamZX)

	Local aArea    := GetArea()
	Local cSeekSGS := ""

	DbSelectArea("SCP")	// Solicitacao ao Armazem
	DbSetOrder(1)
	If MsSeek(xFilial("SCP")+cNumSA+CItemSA)
		If CP_RATEIO == "1"
			DbSelectArea("SGS")	// Tabela de rateio por centro de custo da SA
			DbSetOrder(1)
			If MsSeek(xFilial("SGS")+SCP->(CP_NUM+CP_ITEM))
				cSeekSGS := GS_FILIAL+GS_SOLICIT+GS_ITEMSOL
				While !SGS->(Eof()) .And. SGS->(GS_FILIAL+GS_SOLICIT+GS_ITEMSOL) == cSeekSGS

					A330DET(cSeqCalc, cCodLan, "MATA330", "SD3", lLct667669, a330ParamZX, SGS->(Recno()))

					SGS->(DbSkip())
				End

			EndIf
		EndIf
	EndIf
	RestArea(aArea)
	aSize(aArea,0)
	aArea := nil
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} SchedDef
Retorna as perguntas definidas no schedule.

@return aReturn         Array com os parametros

@author  André Maximo
@since 	 07.04.2020
@version 12
/*/
//-------------------------------------------------------------------

Static Function Scheddef()

Local aParam  := {}

aParam := { "P",;           //Tipo R para relatorio P para processo
			"MTA330",;      //Pergunte do relatorio, caso nao use passar ParamDef
			,;              //Alias
			,;              //Array de ordens
			}               //Titulo

Return aParam

/*/{Protheus.doc} M330JOBSTART - Função para iniciar o ambiente
pela empresas/filial informada na chamada da MANUALJOB
@author Totvs
@since 06/04/2020
@version 1.0
@param cParam - Codigo da empresa e filial concatenadas por chr(255)
@return logico - sempre verdadeiro
/*/
FUNCTION M330JOBSTART(cParam)
LOCAL aParam := {}
LOCAL aTabelas   := {"SB2","SF4","SD1","SD2","SD3","SF2","SF1","SB6","SD7"}
LOCAL cLFil
LOCAL cLEmp
LOCAL cGlbName
Local cParam3  := '' As Character
Local nIndex   := 0  As Numeric

   cGlbName  := "cThrWrk"+cValToChar(ThreadId())
	A330LckGlb(cGlbName)
   PutGlbValue(cGlbName,"1")
	A330ULckGlb(cGlbName)
	aParam := STRTOKARR( cParam, chr(255) )

	cLEmp := aParam[1]
	cLFil := aParam[2]
	If Len(aParam) > 2 .And. !Empty(aParam[3])
		cParam3 := aParam[3]
	EndIf

	RpcSetType(3)
	RpcSetEnv( cLEmp,cLFil,,,'EST',,aTabelas)

	If 'TR2' $ cParam3
		//Restaura o Alias TR2
		TR2->(DbCloseArea())
		dbUseArea(.T.,"TOPCONN",cParam3,"TR2",.T.)
		For nIndex := 1 To Len(GetTR2Stru(2))
			dbSetIndex(cParam3+StrZero(nIndex,2))
		Next nIndex
	EndIf

	A330LckGlb(cGlbName)
   PutGlbValue(cGlbName,"0")
	A330ULckGlb(cGlbName)

RETURN .T.

/*/{Protheus.doc} M330JOBEXIT - Função ao encerrar a thread da chamada da MANUALJOB
@author Totvs
@since 06/04/2020
@version 1.0
@return logico - sempre verdadeiro
/*/
FUNCTION M330JOBEXIT()
RETURN .T.

/*/{Protheus.doc} M330JOBCONNECT - Executa a funcao M330JOCM para calculo do custo dos movimentos
@author Totvs
@since 06/04/2020
@version 1.0
@return nulo
/*/
Function M330JOBCONNECT(cEmp,cFil,cOrdem,aThreads,cJobFile,cThread,aArqs,lCstPart,aRegraCP,lCusRep,cPaisLoc,lPCusFil,lPCusEmp,aPE,dMVUlMes,a330ParamZX,lExistProc,aLocais,cChave,nProdProp,lIntMntAt,oListaTrf,cSeqCalc,cListaFil,cThreadID, cData, aUser, cKeyRegCT)
LOCAL cGlbName
LOCAL cThisThread
Private oJourneyLog

oJourneyLog := LogConverObj(cData)

	If cEmp=="##QUIT##"
		cThisThread := cValToChar(ThreadId())
		cGlbName := "cThrWrk"+cThisThread // define o nome da variavel global
		ClearGlbValue(cGlbName)
		killapp(.T.)
	ELSE
		cGlbName  := "cThrWrk"+cValToChar(ThreadId())
		A330LckGlb(cGlbName)
		PutGlbValue(cGlbName,"1")
		A330ULckGlb(cGlbName)

		M330JobCM(cEmp,cFil,cOrdem,aThreads,cJobFile,cThread,aArqs,lCstPart,aRegraCP,lCusRep,cPaisLoc,lPCusFil,lPCusEmp,aPE,dMVUlMes,a330ParamZX,lExistProc,aLocais,cChave,nProdProp,lIntMntAt,oListaTrf,cSeqCalc,cListaFil,cThreadID,oJourneyLog, aUser, cKeyRegCT)

	EndIf
	A330LckGlb(cGlbName)
	PutGlbValue(cGlbName,"0")
	A330ULckGlb(cGlbName)

RETURN


/*/{Protheus.doc} M330TT2CONNECT - Executa a funcao A330TT2B2 para calculo do custo unificado por empresa/filial
@author Totvs
@since 06/04/2020
@version 1.0
@return nulo
/*/
Function M330TT2CONNECT(cEmp,cFil,aThreads,cJobFile,cThread,lExistProc,cNomTRT,cNomTrbU1,lCstPart,aRegraCP,lCusEmp,lCusFil,lFiltraUnif,lProcREA,cNomTR2)
LOCAL cGlbName as Character
LOCAL lThread as Logical

	cGlbName  := "cThrWrk"+cValToChar(ThreadId())
	A330LckGlb(cGlbName)
	PutGlbValue(cGlbName,"1")
	A330ULckGlb(cGlbName)

	lThread := .T.
	A330TT2B2(lThread,cEmp,cFil,aThreads,cJobFile,cThread,lExistProc,cNomTRT,cNomTrbU1,lCstPart,aRegraCP,lCusEmp,lCusFil,lFiltraUnif,,cNomTR2)

	A330LckGlb(cGlbName)
    PutGlbValue(cGlbName,"0")
	A330ULckGlb(cGlbName)

	If cEmp=="##QUIT##"
		ClearGlbValue(cGlbName)
		killapp(.T.)
	EndIf

RETURN


/*/{Protheus.doc} M330JPRCCONNECT - Executa a funcao M330JPRC para executar a procedure MAT004 por filial
@author Totvs
@since 06/04/2020
@version 1.0
@return nulo
/*/
Function M330JPRCCONNECT(cEmp,cFil,aProcNam,aDataProc,cJobFile)
LOCAL cGlbName
LOCAL cThisThread

	If cEmp=="##QUIT##"
		cThisThread := cValToChar(ThreadId())
		cGlbName := "cThrWrk"+cThisThread // define o nome da variavel global
		ClearGlbValue(cGlbName)
		killapp(.T.)
	ELSE
		cGlbName  := "cThrWrk"+cValToChar(ThreadId())
		A330LckGlb(cGlbName)
		PutGlbValue(cGlbName,"1")
		A330ULckGlb(cGlbName)

		M330JPRC(cEmp,cFil,aProcNam,aDataProc,cJobFile)
	Endif
	A330LckGlb(cGlbName)
	PutGlbValue(cGlbName,"0")
	A330ULckGlb(cGlbName)

RETURN

/*/{Protheus.doc} M330JCTBCONNECT - Executa a funcao M330JCTB para contabilizar por filial
@author Totvs
@since 06/04/2020
@version 1.0
@return nulo
/*/
Function M330JCTBCONNECT(cEmp,cFil,cNomTrc,cNomTRC1,cChave,nTotRegs,nZ,nX,nHdlPrv,cLoteEst,cArquivo,aDadosProva,cSemaforo,lProcCV3,aUser,dDtProc,cNomTR2)
LOCAL cGlbName
LOCAL cThisThread

	If cEmp=="##QUIT##"
		cThisThread := cValToChar(ThreadId())
		cGlbName := "cThrWrk"+cThisThread // define o nome da variavel global
		ClearGlbValue(cGlbName)
		killapp(.T.)
	ELSE
		cGlbName  := "cThrWrk"+cValToChar(ThreadId())
		A330LckGlb(cGlbName)
		PutGlbValue(cGlbName,"1")
		A330ULckGlb(cGlbName)

		M330JCTB(cEmp,cFil,cNomTrc,cNomTRC1,cChave,nTotRegs,nZ,nX,nHdlPrv,cLoteEst,cArquivo,aDadosProva,cSemaforo,lProcCV3,aUser,dDtProc,cNomTR2)
	EndIf
	A330LckGlb(cGlbName)
   PutGlbValue(cGlbName,"0")
	A330ULckGlb(cGlbName)

RETURN

/*/{Protheus.doc} DefNomTrb - Define o nome das tabelas auxiliares do recalculo pela Empresa
@author Totvs
@since 15/04/2020
@version 1.0
@return nulo
/*/
STATIC FUNCTION DefNomTrb()
IF cNomTRA == NIL
	cNomTRA		:= "TRA"+cEmpAnt+"SP"
ENDIF

IF cNomTRB == NIL
	cNomTRB		:= "TRB"+cEmpAnt+"SP"
ENDIF

IF cNomTRBSG1 == NIL
	cNomTRBSG1	:= "TRB"+cEmpAnt+"SPSG1"
ENDIF

IF cNomTRC == NIL
	cNomTRC		:= "TRC"+cEmpAnt+"SP"
ENDIF

IF cNomTRD == NIL
	cNomTRD		:= "TRD"+cEmpAnt+"SP"
ENDIF

IF cNomTRT == NIL
	cNomTRT		:= "TRT"+cEmpAnt+"SP"
ENDIF

IF cNomTRX == NIL
	cNomTRX		:= "TRX"+cEmpAnt+"SP"
ENDIF

If cNomTR2 == Nil
	If UsaTR2()
		cNomTR2 := "TR2"+cEmpAnt+"SP"
	Else
		cNomTR2 := RetSqlName('SB2')
	EndIf
EndIf
RETURN

/*/{Protheus.doc} EstruTabOK
//Função que verifica se a tabela física está com a estrutura de campos OK.
@author andre.oliveira
@since 10/12/2019
@version 1.0
@return lRet, Indica se a estrutura fisica está atualizada
@param cAlias, characters, Nome físico da tabela temporária
@param aCampos, array, Campos que devem existir na tabela
@type function
/*/
Static Function EstruTabOK(cAlias,aCampos)
Local lRet		:= .T.
Local nX		:= 0
Local aEstruFis	:= (cAlias)->(dbStruct())

//-- Valida a quantidade de campos
lRet := Len(aCampos) == Len(aEstruFis)

//-- Valida tipo e tamanho de campo
If lRet
	aSort(aCampos,,,{|x,y| x[1] < y[1]})
	aSort(aEstruFis,,,{|x,y| x[1] < y[1]})
	For nX := 1 To Len(aCampos)
		If !(lRet := aCampos[nX,2] == aEstruFis[nX,2] .And. aCampos[nX,3] == aEstruFis[nX,3] .And. aCampos[nX,4] == aEstruFis[nX,4])
			Exit
		EndIf
	Next nX
EndIf

Return lRet

/*/{Protheus.doc} A330ISMOD
	Encapsula a função ISPRODMOD para melhora de performance no recalculo de custo(MATA330),
	desde que a base a ser processada tenha o parametro MV_PRODMOD Ativo e até 50 produtos com
	o campo B1_CCCUSTO preenchido. Caso contrario menta a chamada da ISPRODMOD.
	@type  Function
	@author Reynaldo Miyashita
	@since 17/04/2020
	@version 1.0
	@param cCod, caracter, código do produto a ser pesquisado
	@param lRecalc, logical, obsoleto
	@return lRet, Logical, se o produto é de mão de obra ou não
	@example
	(examples)
	@see (links_or_references)
/*/
Function A330ISMOD(cCod,lRecalc)

Local lRet

IF PCount() == 0.00

	IF _A330MOD == NIL
		_A330MOD := JsonObject():New()
		_A330MOD:fromJson('{"Total":0}')
		STA330MOD()
	ELSE
		_A330MOD:fromJson("{}")
		_A330MOD := NIL
	ENDIF
ELSE

	IF _A330MOD == NIL

		lRet := IsProdMOD(cCod,lRecalc)
	ELSE

		If _A330MOD[cFilAnt] == NIL
			STA330MOD()
		ENDIF

		IF _A330MOD == NIL
			lRet := .F.
		ELSE

			oProdutos := _A330MOD[cFilAnt]

			IF oProdutos[cCod] == NIL
				lRet := .F.
			ELSE
				lRet := .T.
			ENDIF

		ENDIF
	ENDIF

ENDIF

Return lRet

/*/{Protheus.doc} STA330MOD
	Carrega a variavel estatica _A330MOD com os produtos que são MOD, desde que o parametro MV_PRODMOD Ativo
	e até 100 produtos com o campo B1_CCCUSTO preenchido.
	@type  Function
	@author Reynaldo Miyashita
	@since 17/04/2020
	@version version
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function STA330MOD()
Local cAliQry
Local oProdutos
Local cAliasOld
Local nTotProdFil

	cAliasOld := Alias()

	nTotProdFil := ListaMOD("2")

	_A330MOD["Total"] += nTotProdFil

	// não pode ultrapassar de 4000 produtos de mão de obra, considerando todos os produtos
	// envolvidos nas filiais
	// Isto é, se processar 1 ou mais filiais pode ter somente 4000 produtos.
	// Indiferente do compartilhamento da tabela SB1.
	If _A330MOD["Total"] < 4001
		// faz um select dos produtos que são do tipo mão de obra
		cAliQry := ListaMOD()
		IF Select(cAliQry) >0

			nLimMax := 0
			oProdutos := JsonObject():New()
			oProdutos:fromJson("{}")

			dbSelectArea(cAliQry)
			WHILE !EOF()
				oProdutos[(cAliQry)->B1_COD] := "T"
				dbSkip()
			END
			dbCloseArea()

			_A330MOD[cFilAnt] := oProdutos

		ENDIF
	Else
		_A330MOD:fromJson("{}")
		_A330MOD := NIL
	EndIf

	IF !Empty(cAliasOld)
		dbSelectArea(cAliasOld)
	ENDIF

RETURN

/*/{Protheus.doc} ListaMOD
	Lista os codigos de produto ou total de produtos do tipo mão de obra encontrado no
	cadastro de produto por filial
	@type  Static Function
	@author reynaldo
	@since 11/08/2020
	@version 1.00
	@param  cTipo	, Caracter	, Informa se o retorno vai ser o alias com a lista de produtos ou o Total de produtos
	@return xResult	, indefinido	, Retorna o alias ou numero total de produtos de acordo com o parametro cTipo
	@example
	(examples)
	@see (links_or_references)
/*/
Static Function ListaMOD(cTipo)
Local cQuery
Local cSQLWhere
Local xResult

DEFAULT cTIpo := "1"

	cSQLWhere := ""
	cSQLWhere += " WHERE B1_FILIAL = '"+xFilial("SB1")+"' "
	cSQLWhere += " AND ( SUBSTRING(B1_COD, 1, 3) = 'MOD' "
	If SuperGetMV("MV_PRODMOD",.F.,.T.)  // se for tratamento pelo campo B1_CCCUSTO
		cSQLWhere += " or B1_CCCUSTO <> ' ' "
	ENDIF
	cSQLWhere += ") "
	cSQLWhere += " AND D_E_L_E_T_ = ' ' "

	// ALIAS com os codigos de  produtos do tipo mao de obra tem na tabela SB1
	If cTipo == "1"
		cQuery := "SELECT B1_COD FROM "+ RetSQLName("SB1") + " "
		cQuery += cSQLWhere
		cQuery := ChangeQuery(cQuery)

		xResult := ""
		xResult := MPSysOpenQuery( cQuery , /*[cAlias]*/ , /*[aSetField]*/ )

	// contagem de qtos produtos do tipo mao de obra tem na tabela SB1
	ElseIf cTipo == "2"
		cQuery := "SELECT COUNT(R_E_C_N_O_) NCOUNT FROM " + RetSqlName("SB1")
		cQuery += cSQLWhere
		cQuery := ChangeQuery(cQuery)
		xResult := MpSysExecScalar(cQuery,"NCOUNT")
	EndIf

Return xResult

/*/{Protheus.doc} A330DelIndex
	Funcao Responsavel por Verificar Build do Ambiente e Direcionar como
	Sera a Exclusao do Indice das Tabelas de Apoio do Recalculo
	@type  Static Function
	@author reynaldo
	@since 09/06/2020
	@version 1.00
	@param  cAlias	, Caracter	, Alias da Tabela a Ser Manipulada
	@return lRet	, Boolean	, Retorna se o Indice foi Deletado
	@example
	(examples)
	@see (links_or_references)
/*/
Static Function A330DelIndex( cAlias, cIndice )
Local lRet      := .T.

DEFAULT cIndice := " "

If GetRpoRelease() < "12.1.023"
	If cIndice == ""
		lRet := TcInternal( 69,cAlias ) == '1'
	Else
		lRet := TcInternal(60,cAlias+ "|" + cIndice) == '1'
	EndiF
ELSE
	lRet := TcDelIndex(cAlias,cIndice)
ENDIF
Return lRet

/*/{Protheus.doc} A330JobManual
	Abertura de threads filhas para processamento
	@type  Function
	@author reynaldo
	@since 23/06/2020
	@version 1.0
	@param cStatus, caracter, se faz abre as threads ou encerra
	@param cIdentificador, caracter, Nome do semaforo
	@param cJobConnect, caracter, Nome da funçao que faz o processamento
	@return Sempre retorno .T.
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function A330JobManual(cStatus, cIdentificador, cJobConnect, nTotThread, cSessionKey )
LOCAL nMinThread
LOCAL nMaxThread
LOCAL nFreeThread
LOCAL nIncThread

Default nTotThread  := SuperGetMV("MV_M330THR",.F.,1)
Default cSessionKey := cEmpAnt+CHR(255)+cFilAnt+CHR(255)

	// inicia o manualJob
	If cStatus == "1"
		If nTotThread > 10
			nTotThread := 10
		ElseIf nTotThread == 9
			nTotThread := 10
		Else
			nTotThread := nTotThread+2
		EndIf
		
		nMinThread := Val(GetSrvProfString( "ThreadMinOrdem", cValToChar(nTotThread) ))
		nMaxThread := Val(GetSrvProfString( "ThreadMaxOrdem", "30" ))
		nFreeThread := 2
		nIncThread := 2
	EndIf

	// encerra o manualJob
	If cStatus == "2"
		nMinThread := 0
		nMaxThread := 0
		nFreeThread := 0
		nIncThread := 0
	EndIf

   ManualJob(	cIdentificador/*Nome do indentificador do job*/,;
				GetEnvServer()/*Ambiente que vc vai abrir este cara*/,;
				"IPC"/*Tipo do job. Mantenha como Ipc*/,;
				"M330JOBSTART"/*Função que será chamada quando uma nova thread subir*/,;
				cJobConnect/*Função que será chamada toda vez que vc mandar um ipcgo para ela*/,;
				"M330JOBEXIT"/*Função que será invocada quando a thread cair pelo timeout dela*/,;
				cSessionKey/*Não alterar. É o SessionKey*/,;
				300 /*Tempo em segundos que a thread será reavaliada e irá cair. Vamos manter 5 minutos. Se não receber nada ela morre*/,;
				nMinThread /*Minimo de threads inicias. Vamos deixar 0 para que quando cair por timeout ele acabe*/,;
				nMaxThread /*máximo de threads que ele vai subir*/,;
				nFreeThread /*mínimo de threads livres*/,;
				nIncThread /*incremento de threads livres*/,;
      		)

	If cStatus == "2"
		DownThread(cIdentificador)
	EndIf

Return .T.

/*/{Protheus.doc} DownThread
	Baixa das working thread abertas, onde o controle é feito através de variaveis globais
	@type  Function
	@author reynaldo
	@since 30/06/2020
	@version 1.0
	@param cIdentificador, caracter, Nome do semaforo
	@return Sempre retorno NIL
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function DownThread(cIdentificador)
LOCAL lLoop
LOCAL nI
LOCAL nCntThread
LOCAL aUsers
LOCAL cGlbName
LOCAL cGlbValue
LOCAL cIDThread

	lLoop := .T.
	nI := 0
	aUsers := {}

	M330PrcLog("MENSAGEM",OemToAnsi(I18N(STR0217,{cIdentificador})),OemToAnsi(I18N(STR0217,{cIdentificador}))) // ## "Encerramento das working threads #1[A330TT2B2_37688_01]# - (0) Inicio"
	ConOut("[MATA330] "+dtoc(Date())+" "+Time()+" " +I18N(STR0217,{cIdentificador}) ) // ## "Encerramento das working threads #1[A330TT2B2_37688_01]# - (0) Inicio"

	While lLoop // loop de controle para encerramento de todas as working threads
		aUsers := GetUserInfoArray()
		For nI := 1 to len(aUsers)
			If aUsers[nI][1] == cIdentificador // semaforo

				nCntThread++ // conta qtas working threads abertas

				cIDThread := cValToChar(aUsers[nI][3])  // ID da working thread

				cGlbName := "cThrWrk"+cIDThread // define o nome da variavel global

				cGlbValue := GetGlbValue(cGlbName) // Verifica valor da variável

				If cGlbValue == "0"
					IPCGO( cIdentificador,"##QUIT##")

				EndIf
			EndIf
		Next nI
		aUsers := aSize(aUsers,0)
		If nCntThread ==0
			lLoop := .F.
		EndIf
		nCntThread := 0
		sleep(1000)
	EndDo
	ConOut("[MATA330] "+dtoc(Date())+" "+Time()+" " +I18N(STR0218,{cIdentificador}) ) // ## "Encerramento das working threads #1[A330TT2B2_37688_01] - (1) Termino"
	M330PrcLog("MENSAGEM",OemToAnsi(I18N(STR0218,{cIdentificador})),OemToAnsi(I18N(STR0218,{cIdentificador}))) // ## "Encerramento das working threads #1[A330TT2B2_37688_01] - (1) Termino"

RETURN NIL

/*/{Protheus.doc} CountTRB
	Conta o total de registros e por filial+ordem e monta um tabela em string
	@type  Function
	@author reynaldo
	@since 29/07/2020
	@version 1.0
	@param nenhum
	@return cTexto, Caracter, tabela em formato de texto das informacoes encontradas
	@example
		CountTRB()
	@see (links_or_references)
/*/
Static Function CountTRB(aFilsCalc)
Local cQuery
Local cTmpAlias
Local cTexto
Local nCntReg
LOCAL cListaFil	:= A330Lista(aFilsCalc)

	cQuery:= "select TRB.TRB_FILIAL,TRB.TRB_ORDEM,count(*) TOTAL from "+cNomTRB+" TRB "
	cQuery+= " where "
	cQuery+= " TRB.TRB_FILIAL in (" +cListaFil+ ") "
	cQuery+= " and TRB.TRB_THREAD = '"+SPACE(LEN(TRB->TRB_THREAD))+ "' "
	cQuery+= " and TRB.D_E_L_E_T_ = ' ' "
	cQuery+= " group by TRB.TRB_FILIAL,TRB.TRB_ORDEM "
	cQuery := ChangeQuery(cQuery)

	cTmpAlias := MPSysOpenQuery( cQuery )
	If !Empty(cTmpAlias) .and. Select(cTmpAlias) >0
		nCntReg := 0
		cTexto := "FILIAL;ORDEM;TOTAL;"+chr(10)
		While (cTmpAlias)->(!Eof())
			cTexto += (cTmpAlias)->(TRB_FILIAL+";"+TRB_ORDEM+";"+cValToChar(TOTAL))+";"+chr(10)
			nCntReg := nCntReg+(cTmpAlias)->TOTAL
			(cTmpAlias)->(dbSkip())
		End
		cTexto := chr(10) + STR0215 + cValToChar(nCntReg) + chr(10) + cTexto // "Total registros: "
		(cTmpAlias)->(dbCloseArea())
	Else
		cTexto := chr(10) + STR0215 + STR0216 //"Total registros: " ## "não encontrado."
	EndIf

Return cTexto

/*/{Protheus.doc} LogConverObj
	(long_description)
	@type  Function
	@author user
	@since date
	@version version
	@param param, param_type, param_descr
	@return return, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
	/*/
Function LogConverObj(cData)
Local oJourneyLog:= acJourneyLog():new()
Local jJourneyLog:= JsonObject():new()

jJourneyLog:fromJson(cData)
oJourneyLog:cIdParent   := jJourneyLog[ 'cIdParent' ]
oJourneyLog:cIdChild    := jJourneyLog[ 'cIdChild' ]
oJourneyLog:cProcess    := jJourneyLog[ 'cProcess' ]
oJourneyLog:cIdCV8      := jJourneyLog[ 'cIdCV8' ]
oJourneyLog:cIdD3X      := jJourneyLog[ 'cIdD3X' ]
oJourneyLog:cIdD3X      := jJourneyLog[ 'cIdD3X' ]
oJourneyLog:cSubProc    := jJourneyLog[ 'cSubProc' ]
oJourneyLog:nCondition  := jJourneyLog[ 'nStatus' ]
oJourneyLog:llimpaSub   := jJourneyLog[ 'llimpaSub' ]
oJourneyLog:oJsonParams := jJourneyLog[ 'oJsonParams' ]

Return oJourneyLog

/*/{Protheus.doc} ObjjsonCon
	(long_description)
	@type  Function
	@author Pedro
	@since date
	@version version
	@param param, param_type, param_descr
	@return return, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
	/*/
Function ObjjsonCon()

Local jJsonObjs:= JsonObject():New()

jJsonObjs[ 'cIdChild' ]    := oJourneyLog:cIdChild
jJsonObjs[ 'cIdCV8' ]      := oJourneyLog:cIdCV8
jJsonObjs[ 'cIdD3X' ]      := oJourneyLog:cIdD3X
jJsonObjs[ 'cIdParent' ]   := oJourneyLog:cIdParent
jJsonObjs[ 'cProcess' ]    := oJourneyLog:cProcess
jJsonObjs[ 'cSubProc' ]    := oJourneyLog:cSubProc
jJsonObjs[ 'nStatus' ]     := oJourneyLog:nCondition
jJsonObjs[ 'llimpaSub' ]   := oJourneyLog:llimpaSub
jJsonObjs[ 'oJsonParams' ] := oJourneyLog:oJsonParams

Return jJsonObjs:toJson()

/*/{Protheus.doc} CountTRT
	Conta o total de registros na tabela TRT por filial para serem processadas ou filial + Produto por thread processada
	@type  Function
	@author reynaldo
	@since 04/02/2021
	@version 1.0
	@param nenhum
	@return cTexto, Caracter, tabela em formato de texto das informacoes encontradas
	@example
		CountTRB()
	@see (links_or_references)
/*/
Static Function CountTRT(aFilsCalc,aThread)
Local cQuery
Local cTmpAlias
Local cTexto
Local nCntReg
Local nForFilial
Local cSelFiliais
Local cWhereProd

DEFAULT aFilsCalc := {}
DEFAULT aThread   := {}

	cSelFiliais := ""
	For nForFilial := 1 to Len(aFilsCalc)
		If aFilsCalc[nForFilial,1]
			// Altera filial corrente
			cSelFiliais += " '"
			cSelFiliais += aFilsCalc[nForFilial,2]
			cSelFiliais += "', "
		EndIf
	Next nForFilial

	cSelFiliais := LEFT(cSelFiliais,len(cSelFiliais)-2 )

	If Empty(cSelFiliais)
		cSelFiliais := "'"
		cSelFiliais += cFilAnt
		cSelFiliais +=  "'"
	EndIf

	cWhereProd := ""
	If Len(aThread) >0
		cWhereProd += "and TRT.TRB_COD >= '" +aThread[1]+ "' "
		cWhereProd += "and TRT.TRB_COD <= '" +aThread[2]+ "' "
	EndIf

	cQuery:= "select TRT.TRB_FILIAL,count(*) TOTAL from "+cNomTRT+" TRT "
	cQuery+= " where TRT.D_E_L_E_T_ = ' ' "
	cQuery+= " and TRT.TRB_FILIAL IN ( " +cSelFiliais+" ) "
	If !Empty(cWhereProd)
		cQuery+= cWhereProd
	EndIf
	cQuery+= " group by TRT.TRB_FILIAL "
	cQuery := ChangeQuery(cQuery)

	cTmpAlias := MPSysOpenQuery( cQuery )
	If !Empty(cTmpAlias) .and. Select(cTmpAlias) >0
		nCntReg := 0
		cTexto := "FILIAL;CONTAGEM DE PRODUTOS;"+chr(10)
		While (cTmpAlias)->(!Eof())
			cTexto += (cTmpAlias)->(TRB_FILIAL+";"+cValToChar(TOTAL))+";"+chr(10)
			(cTmpAlias)->(dbSkip())
		End
		(cTmpAlias)->(dbCloseArea())
	Else
		cTexto := chr(10) + STR0215 + STR0216 //"Total registros: " ## "não encontrado."
	EndIf

Return cTexto

/*/{Protheus.doc} M330PrcLog
	Encapsula chamada da ProcLogAtu para garantir gravação da filial da CV8 com a filial
	que está executando o processo.
	@type  Function
	@author andre.oliveira
	@since 04/09/2020
	@version 1.0
	@param cTipo, caracter, tipo do log a ser gerado
	@param cTexto, caracter, mensagem a ser gravada no log gerado
	@param cDetalhe, caracter, detalhe a ser gravado para o log gerado
/*/
Function M330PrcLog(cTipo,cTexto,cDetalhe, cStatus, cFilInfo)

Default cFilInfo := ''

Iif(!empty(cFilInfo), cFilAnt := cFilInfo, cFilAnt)
oJourneyLog:LogProAtu(cTipo,cTexto,cDetalhe,cFilBack, cStatus,a330ParamZX[1], cFilAnt, lJourney)

Return

/*/{Protheus.doc} A330LogProfiler
	Bloqueia o uso da rotina se a chave logprofiler estiver ativo e a chave ConsoleMaxSize
	não estiver com o conteudo minimo exigido.
	Finalidade para reduzir a possibilidade do arquivo console.log com logprofiler
	ser gerado incompleto
	@type  Function
	@author reynaldo
	@since 03/02/2021
	@version 1.0
	@param lJanela, logica, Se apresenta a janela de aviso
/*/
Static Function A330LogProfiler(lJanela)
Local cLogProfiler
Local cConsoleMaxSize
Local nMaxSize
Local nSizeRequired
Local lRet
Local cEndWeb

	// endereco web que informações sobre a chave ConsoleMaxSize
	cEndWeb := "https://tdn.totvs.com/x/oIpc"

	// Conteudo da chave ConsoleMaxSize com o tamanho minimo necessario
	// 104857600 equivale a 100MB
	nSizeRequired := 104857600

	lRet := .T.
	// Conteúdo de uma chave de configuração do ambiente em uso
	cLogProfiler := GetSrvProfString( "LogProfiler","")
	If cLogProfiler == "1"
		// Busca na seção [GENERAL] a chave de configuração do ambiente em uso
		cSecao := "GENERAL"
		cConsoleMaxSize := GetPvProfString(cSecao, "ConsoleMaxSize", "", GetSrvIniName())

		nMaxSize := Val(cConsoleMaxSize)
		If nMaxSize < nSizeRequired
			If lJanela
				MessageShow(cEndWeb, cSecao, cConsoleMaxSize, nSizeRequired)
			EndIf
			lRet := .F.
		Endif

	EndIf

RETURN lRet

/*/{Protheus.doc} MessageShow
	Bloqueia o uso da rotina se a chave logprofiler estiver ativo e a chave ConsoleMaxSize
	não estiver com o conteudo minimo exigido.
	Finalidade para reduzir a possibilidade do arquivo console.log com logprofiler
	ser gerado incompleto
	@type  Function
	@author reynaldo
	@since 03/02/2021
	@version 1.0
	@param lJanela, logica, Se apresenta a janela de aviso
/*/
Static Function MessageShow(cEndWeb, cSecao, cValorINI, nValorMinimo)
local oSay2      := nil
local oSay3      := nil
local oSay4      := nil
local oSay5      := nil
local oSay6      := nil

// conteudo obrigatorio da chave ConsoleMaxSize
cSizeMax := cValtoChar(nValorMinimo)

oModal := FWDialogModal():New()
oModal:SetCloseButton( .F. )
oModal:SetEscClose( .F. )
oModal:setTitle(STR0229) // "LogProfiler ativo"
oModal:setSubTitle(STR0230) // "Identificado chave do logprofiler ativo no APPSERVER.INI"

//define a altura e largura da janela em pixel
oModal:setSize(200, 250)

oModal:createDialog()

oModal:AddButton( STR0237, {||oModal:DeActivate()}, STR0237, , .T., .F., .T., ) // "Voltar" ## "Voltar"

oContainer := TPanel():New( ,,, oModal:getPanelMain() )
oContainer:Align := CONTROL_ALIGN_ALLCLIENT

oSay1 := TSay():New( 10,10,{||STR0231},oContainer,,,,,,.T.,,,200,20,,,,,,.T.) //"Foi identificado que a chave LogProfiler do appserver.ini esta configurado como 1. "

If cValorINI == ""
	cMsg2 := i18n(STR0232,{GetEnvServer(),GetSrvIniName()}) //"A chave ConsoleMaxSize não foi encontrada nas seções: #1[Environment]# ou [GENERAL] no arquivo #2[appserver.ini]#."
	cMsg3 := i18n(STR0238,{cSizeMax}) //"É necessario incluir a chave ConsoleMaxSize para um valor igual ou superior a #1[104857600]#."
Else
	cMsg2 := i18n(STR0239,{cSecao,GetSrvIniName()}) //"A chave ConsoleMaxSize foi encontrada na seção: #1[Environment]# no arquivo #2[appserver.ini]#."
	cMsg3 := i18n(STR0240,{cValorINI,cSizeMax}) //"Porem o seu conteudo atual de #1[1234]# é inferior ao valor minimo necessario de #2[104857600]#. Deve ser ajustado o valor."
EndIf

oSay2 := TSay():New( 30,10,{||cMsg2 },oContainer,,,,,,.T.,,,200,20,,,,,,.T.)

oSay3 := TSay():New( 50,10,{||cMsg3 },oContainer,,,,,,.T.,,,200,20,,,,,,.T.)

oSay4 := TSay():New( 70,10,{||STR0233},oContainer,,,,,,.T.,,,200,20,,,,,,.T.) // "Isso se faz necessario pois a rotina MATA330 gera um volume alto de informações para o logprofiler podendo estourar o tamanho do arquivo console.log."

oSay5 := TSay():New( 90,10,{||STR0234},oContainer,,,,,,.T.,,,200,20,,,,,,.T.) // "Somente com o ajuste no conteudo da chave ConsoleMaxSize ou a chave Logprofiler igual a 0 para continuar o processo."

oSay6 := TSay():New(110,10,{||i18n(STR0235,{cEndWeb})},oContainer,,,,,,.T.,,,200,10,,,,,,.T.) // "Para maiores detalhes: <a href='#1[https://tdn.totvs.com/display/tec/ConsoleMaxSize+--+29343]'>ConsoleMaxSize</a> "
oSay6:bLClicked := {|| MsgRun( STR0236, "URL",{|| ShellExecute("open",cEndWeb,"","",1) } ) } // "Abrindo o link... Aguarde..."

oModal:Activate()

return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A330TRT   ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 15/06/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Cria arquivo de trabalho para processar custo unificado    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A330TRT(ExpC1,ExpC2)                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Variavel com nome do arquivo de trabalho p/ custo  ³±±
±±³          ³ unificado                                                  ³±±
±±³          ³ ExpC2 = Variavel com nome do indice  de trabalho p/ custo  ³±±
±±³          ³ unificado                                                  ³±±
±±³          ³ ExpL3 = Variavel utilizada para verificar se utiliza custo ³±±
±±³          ³         em partes                                          ³±±
±±³          ³ ExpN4 = Numero de partes do custo em partes                ³±±
±±³          ³ ExpL5 = Variavel utilizada para verificar se o arquivo TRT ³±±
±±³          ³         esta aberto                                        ³±±
±±³          ³ ExpL6 = Variavel que verifica a utilizacao de procedures   ³±±
±±³          ³ ExpA7 = Array com as filiais selecionadas                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A330TRT(cNomTrbU,cNomTrbU1,lCstPart,nPartes,lOpenTrt,lExistProc,aFilsCalc)
Local aArea      := GetArea()
Local aCamposTRT := GetTRTStru(lCstPart,nPartes)
Local cNomeTab   := "SP"
Local cTopTRT    := "TRT"+cEmpAnt+cNomeTab
Local nLoop as numeric

Default lExistProc  := .F.

If TcSrvType() <> "AS/400" .And. !lOpenTRT .And. lExistProc
	If TcCanOpen(cTopTRT)
		// Verifica se esta utilizando custo unificado por Filial ou Empresa
		If lCusFil
			// Limpeza da tabela TRT utilizada para aglutinacao do custo unificado (STORED PROCEDURES)
			TcSqlExec( "DELETE FROM "+cTopTRT+" WHERE TRB_FILIAL = '  ' AND D_E_L_E_T_  = ' '")
			For nLoop := 1 to Len(aFilsCalc)
				If aFilsCalc[nLoop,1]
					TcSqlExec( "DELETE FROM "+cTopTRT+" WHERE TRB_FILIAL = '"+aFilsCalc[nLoop,2]+"' AND D_E_L_E_T_  = ' '")
				EndIf
			Next nX
		Else
			// Limpeza da tabela TRT utilizada para aglutinacao do custo unificado (STORED PROCEDURES)
			TcSqlExec( "DELETE FROM "+cTopTRT+" WHERE D_E_L_E_T_  = ' '")
			TcSqlExec( "INSERT INTO "+cTopTRT+" (TRB_COD ) SELECT B1_COD from "+RetSqlName('SB1')+" WHERE D_E_L_E_T_ = ' '")
		EndIf
      // Abre o arquivo de trabalho do custo unificado
		dbUseArea( .T.,"TOPCONN",cTopTRT, "TRT",.T.,.F.)
		IndRegua("TRT",cTopTRT,"TRB_FILIAL+TRB_COD",,,OemToAnsi(STR0012))		//"Criando Arquivo Trabalho ..."
		lOpenTRT:= .T.
	EndIf
EndIf

If !lOpenTRT
	// Incluido para evitar duplicidade
	Inkey(2)

	If FindFunction("EngSPSWorkTable")
		EngSPSWorkTable("",cTopTRT,aCamposTRT,.T.)
	Else
		CriaTmpDb("",cTopTRT,aCamposTRT,.T.)
	EndIf
	cNomTrbU1 := Subs(cTopTRT,1,7)+"01"
	dbUseArea( .T.,"TOPCONN",cTopTRT,"TRT",.T.,.F.)
	A330DelIndex( cTopTRT, cNomTrbU1 ) // exclui 1 indice da tabela
	DBCreateIndex(cNomTrbU1,"TRB_FILIAL+TRB_COD")
	dbClearIndex()
	DBSetIndex(cNomTrbU1)
	dbSetOrder(1)

	lOpenTRT:=.T.
EndIf
RestArea(aArea)
aSize(aArea,0)
aArea := nil
Return

/*/{Protheus.doc} EngPre19Compile
Funcao executada antes da compilacao das procedures (Pre-Compile)
Utilizada para criacao das tabelas temporarias do processo
@type function
@version 1.0
@author Squad Entradas
@since 28/10/2021
@param cProcesso, character, Codigo do processo
@param cEmpresa, character, Codigo da empresa
@param cError, character, Passada por referencia, deve conter a mensagem de erro caso ocorra
@return logical, .T. caso tudo ok
/*/
Function EngPre19Compile(cProcesso as character, cEmpresa as character, cError as character)

	A330CrTabs()

Return .T.

/*/{Protheus.doc} EngOn19Compile
Funcao executada durante a compilacao da procedure (On Compile)
Utilizada para adaptar o codigo original da procedure, substituindo as tags '###' pela
sequencia especifica de acordo com a regra de negócio da área responsável pelo processo
@type function
@version 1.0
@author Squad Entradas
@since 28/10/2021
@param cProcesso, character, Codigo do processo
@param cEmpresa, character, Codigo da empresa
@param cProcName, character, Nome da stored procedure
@param cBuffer, character, Codigo original da procedure (corpo da procedure)
@param cError, character, Passada por referencia, deve conter a mensagem de erro caso ocorra
@return logical, .T. caso tudo ok
/*/
Function EngOn19Compile(cProcesso as character, cEmpresa as character, cProcName as character, cBuffer as character, cError as character)

	Local cNomeTab := "SP"

	// Faz a troca das tags "###" nos nomes de tabelas especificas do processo
	cBuffer := StrTran( cBuffer, "TRA###", "TRA"+cEmpresa+cNomeTab )
	cBuffer := StrTran( cBuffer, "TRB###", "TRB"+cEmpresa+cNomeTab )
	cBuffer := StrTran( cBuffer, "TRC###", "TRC"+cEmpresa+cNomeTab )
	cBuffer := StrTran( cBuffer, "TRD###", "TRD"+cEmpresa+cNomeTab )
	cBuffer := StrTran( cBuffer, "TRT###", "TRT"+cEmpresa+cNomeTab )
	cBuffer := StrTran( cBuffer, "TRX###", "TRX"+cEmpresa+cNomeTab )

	If UsaTR2()
		cBuffer := StrTran( cBuffer, "SB2###", "TR2"+cEmpresa+cNomeTab )
		cBuffer := StrTran( cBuffer, "#SB2OUTR2#", "'TR2'")
	Else
		cBuffer := StrTran( cBuffer, "#SB2OUTR2#", "'SB2'")
	EndIf

	If SuperGetMV('MV_A330GRV',.F., .T.)
		cBuffer := StrTran( cBuffer, "#A330GRV#", "'T'")
	Else
		cBuffer := StrTran( cBuffer, "#A330GRV#", "'F'")
	EndIf

Return .T.

/*/{Protheus.doc} EngPos19Compile
Funcao executada apos a compilacao da procedure pela MsParse (Pos-Compile)
Utilizada para fazer ajustes no codigo ja adaptado ao banco de dados em uso
@type function
@version 1.0
@author Squad Entradas
@since 28/10/2021
@param cProcesso, character, Codigo do processo
@param cEmpresa, character, Codigo da empresa
@param cProcName, character, Nome da stored procedure
@param cLocalDB, character, Banco de dados em uso (ORACLE, MSSQL, POSTGRES, etc...)
@param cBuffer, character, Conteudo da procedure ja convertido para a linguagem do banco (pos MsParse)
@param cError, character, Passada por referencia, deve conter a mensagem de erro caso ocorra
@return logical, .T. caso tudo ok
/*/
Function EngPos19Compile(cProcesso as character, cEmpresa as character, cProcName as character, cLocalDB as character, cBuffer as character, cError as character)

	Do Case

		Case cLocalDB == "INFORMIX"

			If cProcName == "MAT006"
				cBuffer := StrTran(cBuffer, 'MAX ( SUBSTR ( B9_DATA , 1 , 8 ))', 'MAX ( B9_DATA ) ')
			EndIf

		Case cLocalDB == "ORACLE"

			If cProcName == "MAT007"
				cBuffer	:= StrTran( cBuffer, "CUR_A330INI%NOTFOUND1", "CUR_A330INI%NOTFOUND")
			EndIf

	EndCase

Return .T.

/*/{Protheus.doc} EngSPS19Delete
Funcoes executadas durante a desinstalacao dos processos (On Uninstall)
Utilizada para fazer a exclusao das tabelas da classe "TR".
@type function
@version 1.0
@author Squad Entradas
@since 28/10/2021
@param cProcesso, character, Codigo do processo
@param cEmpresa, character, Codigo da empresa
@param cError, character, Passada por referencia, deve conter a mensagem de erro caso ocorra
@return logical, .T. caso tudo ok
/*/
Function EngSPS19Delete(cProcesso as character, cEmpresa as character, cError as character)
Local cIndexName := ""
Local n
Local aRetIndex

	If TcCanOpen("TRA"+cEmpresa+"SP")
		aRetIndex := GetTRAStru (2)
		For n:= 1 to len(aRetIndex)
			cIndexName := "TRA"+cEmpresa+"SP"+strzero(n,2)
			If TCCanOpen("TRA"+cEmpresa+"SP", cIndexName )
				TcDelIndex("TRA"+cEmpresa+"SP",cIndexName)
			EndIf
		Next n
		TcDelFile("TRA"+cEmpresa+"SP")
	EndIf
	If TcCanOpen("TRB"+cEmpresa+"SP")
		aRetIndex := GetTRBStru (2)
		For n:= 1 to len(aRetIndex)
			cIndexName := "TRB"+cEmpresa+"SP"+strzero(n,2)
			If TCCanOpen("TRB"+cEmpresa+"SP", cIndexName )
				TcDelIndex("TRB"+cEmpresa+"SP",cIndexName)
			EndIf
		Next n 
		TcDelFile("TRB"+cEmpresa+"SP")
	EndIf
	// caso a procedure "MAT005_20_nn" exista, significa que a tabela TRBnnSPSG1 nao pode ser apagada
	If !TCSPExist( 'MAT005_20_'+cEmpresa) .and. TcCanOpen("TRB"+cEmpresa+"SPSG1")
		aRetIndex := GetTSG1Str (2)
		For n:= 1 to len(aRetIndex)
			cIndexName := "TRB"+cEmpresa+"SPSG1"+strzero(n,2)
			If TCCanOpen("TRB"+cEmpresa+"SPSG1", cIndexName )
				TcDelIndex("TRB"+cEmpresa+"SPSG1",cIndexName)
			EndIf
		Next n 
		TcDelFile("TRB"+cEmpresa+"SPSG1")
	EndIf
	If TcCanOpen("TRD"+cEmpresa+"SP")
		aRetIndex := GetTRDStru (2)
		For n:= 1 to len(aRetIndex)
			cIndexName := "TRD"+cEmpresa+"SP"+strzero(n,2)
			If TCCanOpen("TRD"+cEmpresa+"SP", cIndexName )
				TcDelIndex("TRD"+cEmpresa+"SP",cIndexName)
			EndIf
		Next n
		TcDelFile("TRD"+cEmpresa+"SP")
	EndIf
	If TcCanOpen("TRT"+cEmpresa+"SP")
		aRetIndex := GetTRTStru (,,2)
		For n:= 1 to len(aRetIndex)
			cIndexName := "TRT"+cEmpresa+"SP"+strzero(n,2)
			If TCCanOpen("TRT"+cEmpresa+"SP", cIndexName )
				TcDelIndex("TRT"+cEmpresa+"SP",cIndexName)
			EndIf
		Next n 
		TcDelFile("TRT"+cEmpresa+"SP")
	EndIf
	If TcCanOpen("TRX"+cEmpresa+"SP")
		aRetIndex := GetTRXStru (2)
		For n:= 1 to len(aRetIndex)
			cIndexName := "TRX"+cEmpresa+"SP"+strzero(n,2)
			If TCCanOpen("TRX"+cEmpresa+"SP", cIndexName )
				TcDelIndex("TRX"+cEmpresa+"SP",cIndexName)
			EndIf
		Next n 
		TcDelFile("TRX"+cEmpresa+"SP")
	EndIf
	If TcCanOpen("TRC"+cEmpresa+"SP")
		cIndexName := "TRC"+cEmpresa+"SP01"
		If TCCanOpen("TRC"+cEmpresa+"SP", cIndexName )
			TcDelIndex("TRC"+cEmpresa+"SP",cIndexName)
		EndIf
		TcDelFile("TRC"+cEmpresa+"SP")
	EndIf
	If TcCanOpen("TR2"+cEmpresa+"SP")
		aRetIndex := GetTR2Stru (2)
		For n:= 1 to len(aRetIndex)
			cIndexName := "TR2"+cEmpresa+"SP"+strzero(n,2)
			If TCCanOpen("TR2"+cEmpresa+"SP", cIndexName )
				TcDelIndex("TR2"+cEmpresa+"SP",cIndexName)
			EndIf
		Next n 
		TcDelFile("TR2"+cEmpresa+"SP")
	EndIf

Return .T.

/*/{Protheus.doc} EngSPS19Signature
Funcao executada durante a exibicao de informacoes detalhadas do processo na
interface de gestao de procedures.
Faz a execucao da funcao static VerIdProc
@type function
@version 1.0
@author Squad Entradas
@since 14/01/2021
@param cProcesso, character, Codigo do processo
@return character, Retorna a assinatura do processo
/*/
Function EngSPS19Signature(cProcess as character)

	Local cAssinatura as character

	cAssinatura := VerIDProc()

Return cAssinatura


Function A330Legacy()

Return getLegacy()

/*/{Protheus.doc} M330Analysis
	Chama processo de analise apos fim de processamento
	@type  Function
	@author pedro.missaglia
	@since 21/12/2021
	@version 1.0
/*/
Static Function M330Analysis(aFilList)

Local nForFilial 	:= 0
Local aFilsFilter 	:= {}
Local oAnalysis	 	:= EstAcMiddle('ac.Results.Analysis.Service', 'acResultsAnalysisService():new()')
Local oBranches  	:= EstAcMiddle('ac.branchesList.Serv', 'acBranchesListServ():New()')
Local oBranchObj 	:= JsonObject():New()
Local oItemObj 	 	:= JsonObject():New()
Local aFilterAna 	:= {{"FILTER", ''}}

If Valtype(oAnalysis) == 'O' .and. Valtype(oBranches) == 'O'

	For nForFilial := 1 to Len(aFilList)
		If aFilList[nForFilial,1]
			Aadd(aFilsFilter, aFilList[nForFilial])
		EndIf
	Next nForFilial

	oItemObj["items"] 		:= oBranches:listBranchesinformated(aFilsFilter)
	oBranchObj["branches"] 	:= oItemObj
	oAnalysis:doTheAnalysis(oJourneyLog:cIdParent, .F., .T., 1, 10, aFilterAna, oBranchObj)

	oItemObj 	:= NIL
	oBranchObj  := NIL
	oAnalysis   := NIL
	aFilterAna  := {}
	aFilsFilter := {}
ENDIF

Return

/*/{Protheus.doc} A330ConvIT
	Função responsável pela conversão do item em formato compatível
	com os itens da D1_ITEM/D2_ITEM
	@type  Function
	@author Nilton Rodrigues
	@since 22/07/2022
	@param cItem, character, Item a ser convertido
	@param cTab , character, indica para qual alias será convertido o item
	@version 1.0
/*/
Function A330ConvIT(cItem,cTab)
Local cItConv  as character
Local nX       as numeric
Local nValor   as numeric
Local cKey     := AllTrim(cItem)+'|'+cTab as character

//- Valida a existência do Objeto
If _oItem == nil
	_oItem := JsonObject():New()
EndIF
//- retira os espaços em branco
cItem := AllTrim(cItem)
//- verifico se o item já foi convertido
//- caso não, converte
If (cItConv := _oItem[cKey]) == nil
	If cTab == 'SD1'
		cItConv := StrZero(DecodSoma1(cItem),TamSX3('D1_ITEM')[1])
	Else
		nValor := DecodSoma1(cItem)

		cItConv := StrZero(0,TamSX3('D2_ITEM')[1])
		For nX := 1 to nValor
			cItConv := Soma1(cItConv,TamSX3('D2_ITEM')[1])
		Next nX

	EndIF

	_oItem[cKey] := cItConv

EndIf
Return cItConv

/*/{Protheus.doc} JOBCMCount
	Contagem dos registros que poderiam executar no jobcm 100/300/500 e tambem os que não entram com o CF
	@type  Function
	@author reynaldo
	@since 16/09/2022
	@param cTab , character, Qual alias que será mostrado a sua tabel real de apoio
	@version 1.0
/*/
Static Function JOBCMCount(cThreadID)

LOCAL cQuery    as character
LOCAL cTmpAlias as character
LOCAL nCntReg   as Numeric
LOCAL nCountTRB as Numeric
LOCAL cDados    as character
LOCAL cTexto    as character

cQuery := "SELECT COUNT(*) COUNT "
cQuery += "from TRB"+cEmpAnt+"SP TRB "
cQuery += "where "
cQuery += "TRB_THREAD = '" +cThreadID+ "' and TRB.D_E_L_E_T_ = ' ' "

nCountTRB := MpSysExecScalar(cQuery,"COUNT")

cQuery := ""
cQuery += "select TRB_ORDEM,'JOBCM' PROCESSO, '  ' TRB_CF, count(*) CONTAGEM "
cQuery += "from TRB"+cEmpAnt+"SP TRB "
cQuery += "where "
cQuery += "TRB_ORDEM = '300' "
cQuery += "and TRB_SEQPRO = ' ' and TRB_NIVEL <> ' ' and TRB_NIVSD3 <> ' ' and TRB_OP <> ' ' "
cQuery += "and TRB_THREAD = '" +cThreadID+ "' and TRB.D_E_L_E_T_ = ' ' "
cQuery += "group by TRB_DTBASE, TRB_SEQPRO,TRB_ORDEM,TRB_NIVEL,TRB_NIVSD3 "
cQuery += "UNION "
cQuery += "select TRB_ORDEM,'JOBCM' PROCESSO, '  ' TRB_CF, count(*) CONTAGEM "
cQuery += "from TRB"+cEmpAnt+"SP TRB "
cQuery += "where "
cQuery += "TRB_ORDEM IN ('100','500')  "
cQuery += "and TRB_THREAD = '" +cThreadID+ "' and TRB.D_E_L_E_T_ = ' ' "
cQuery += "group by TRB_ORDEM "
cQuery += "UNION "
cQuery += "select TRB_ORDEM, '     ' PROCESSO, TRB_CF, count(*) CONTAGEM "
cQuery += "from TRB"+cEmpAnt+"SP TRB "
cQuery += "where "
cQuery += "TRB_ORDEM = '300' "
cQuery += "AND NOT (TRB_SEQPRO = ' ' and TRB_NIVEL <> ' ' and TRB_NIVSD3 <> ' ' and TRB_OP <> ' ') "
cQuery += "and TRB_THREAD = '" +cThreadID+ "' and TRB.D_E_L_E_T_ = ' ' "
cQuery += "group by TRB_ORDEM, TRB_CF "
cQuery += "UNION "
cQuery += "select TRB_ORDEM, '     ' PROCESSO, TRB_CF, count(*) CONTAGEM "
cQuery += "from TRB"+cEmpAnt+"SP TRB "
cQuery += "where "
cQuery += "TRB_ORDEM NOT IN ('300','100','500') "
cQuery += "AND NOT (TRB_SEQPRO = ' ' and TRB_NIVEL <> ' ' and TRB_NIVSD3 <> ' ' and TRB_OP <> ' ') "
cQuery += "and TRB_THREAD = '" +cThreadID+ "' and TRB.D_E_L_E_T_ = ' ' "
cQuery += "group by TRB_ORDEM, TRB_CF "
cQuery += "order by TRB_ORDEM, TRB_CF "
cQuery := ChangeQuery(cQuery)

cTmpAlias := MPSysOpenQuery( cQuery )
If !Empty(cTmpAlias) .and. Select(cTmpAlias) >0
	nCntReg := 0
   cDados := "FILIAL;ORDEM;PROCESSO;CF;CONTAGEM"+chr(10)
	While (cTmpAlias)->(!Eof())
		cDados += (cTmpAlias)->(TRB_ORDEM+";"+PROCESSO+";"+TRB_CF+";"+cValToChar(CONTAGEM))+";"+chr(10)
		nCntReg := nCntReg+(cTmpAlias)->CONTAGEM
		(cTmpAlias)->(dbSkip())
	End
	(cTmpAlias)->(dbCloseArea())

	cDados := cValToChar(nCntReg) + chr(10) + cDados
Else
	cDados := STR0216 // "não encontrado."
EndIf

cTexto := I18N(STR0200,{cThreadID,cValToChar(nCountTRB)}) //"Registros encontrados para thread #1[000000000004868]# na tabela TRB: #2[1050] "
cTexto += chr(10) + STR0215 + cDados // "Total registros: "

Return OemToAnsi(cTexto)

/*/{Protheus.doc} A330LckGlb
	Função responsável por garantir o uso da varável global em atualização
	@type  Function
	@author Nilton Rodrigues
	@since 05/09/2022
	@param cNameGlobal , character, Nome da variável global
	@version 1.0
/*/
Function A330LckGlb(cNameGlobal)
	//- Garante que apenas um pegue o ID
	While !KillApp()
		//- Valida se peguei a chave
		If GlbNmLock(cNameGlobal)
			Exit
		EndIf
		Sleep(175)
	EndDo
Return

/*/{Protheus.doc} A330ULckGlb
	Função responsável por liberar o uso da varável global em atualização
	@type  Function
	@author Nilton Rodrigues
	@since 05/09/2022
	@param cNameGlobal , character, Nome da variável global
	@version 1.0
/*/
Function A330ULckGlb(cNameGlobal)
GlbNmUnlock(cNameGlobal)
Return

/*/{Protheus.doc} A330SQLExec
	Executa comando SQL e grava log caso ocorra erro
	@type  Function
	@author reynaldo
	@since 30/09/2022
	@param cQuery , character,
	@param cTitleMsg , character,
	@param cMessage , character,
	@version 1.0
/*/
Function A330SQLExec(cQuery,cTitleMsg,cMessage)
Local nError as Numeric

DEFAULT cTitleMsg := ""
DEFAULT cMessage  := ""

	nError := TCSQLExec(cQuery)

	If nError < 0

		If ! Empty(cTitleMsg)
			cMessage += TCSQLError()
			M330PrcLog("ERRO", cTitleMsg, cMessage )
		EndIf

	EndIf

Return

/*/{Protheus.doc} GetTR2Stru
	Retorna estrutura da TR2 - Tabela espelho da SB2
	1 - Estrutura de campos
	2 - Índices
	@type  Function
	@author Gianluca Moreira
	@since 03/11/2022
	/*/
Static __aTR2Fields := Nil
Function GetTR2Stru(nOpc As Numeric) As Array
	Local aSB2Str  := {}  As Array
	Local aSB2All  := {}  As Array
	Local aRet     := {}  As Array
	Local aIndex   := {}  As Array
	Local cIndex   := ''  As Character
	Local nIndex   := 0   As Numeric
	Local nField   := 0   As Numeric

	If nOpc == 1 //Campos
		If __aTR2Fields == Nil
			__aTR2Fields := {}
			aSB2Str := SB2->(DBStruct()) //Estrutura da SB2 no BD
			aSB2All := CampoB2Fim(SB2_ALL) //Somente os campos do recalculo

			//Adiciona estrutura ao array somente para os campos utilizados no recalculo
			For nField := 1 To Len(aSB2Str)
				If AScan(aSB2All, {|x| AllTrim(x[1]) == AllTrim(aSB2Str[nField,1])}) > 0
					AAdd(__aTR2Fields, aSB2Str[nField])
				EndIf
			Next nField

			AAdd(__aTR2Fields, {"TR2_MOD","C",1,0})
		EndIf
		aRet := AClone(__aTR2Fields)

	Else //indices
		aIndex := FWSIXUtil():GetAliasIndexes('SB2')
		For nIndex := 1 To Len(aIndex)
			cIndex := ''
			For nField := 1 To Len(aIndex[nIndex])
				cIndex += aIndex[nIndex,nField]+'+'
			Next nField
			cIndex := SubStr(cIndex, 1, Len(cIndex)-1)
			AAdd(aRet, cIndex)
		Next nIndex
	EndIf

Return aRet

/*/{Protheus.doc} A330TR2Ini
	Inicializa a TR2 com os dados atuais da SB2
	@type  Static Function
	@author Gianluca Moreira
	@since 14/11/2022
/*/
Static Function A330TR2Ini(aFilsCalc As Array)
	Local aBind      := {}  As Array
	Local cQry       := ''  As Character
	Local cLogTit    := ''  As Character
	Local cLogMes    := ''  As Character
	Local cWhere     := ''  As Character
	Local nForFilial := 0   As Numeric
	Local nTotal     := 0   As Numeric

	//-- Gravação de métrica
	// Telemetria - Uso da classe FwCustomMetrics
	// Metrica - setAverageMetric
	// Grava se utiliza a tabela TR2XXSP no recálculo
	// ativando o parametro MV_A330SB2.

	If FWLibVersion() >= "20210628"
		FWCustomMetrics():setAverageMetric(	"A330TR2Ini"/*cSubRoutine*/,;
											"estoque-custos-protheus_recalculo-do-custo-medio-atualizacao-tardia-da-tabela-sb2_count" /*cIdMetric*/,;
											1 /*nValue*/,;
											/*dDateSend*/,;
											/*nLapTime*/,;
											"MATA330"/*cRotina*/)
	EndIf

	//Gravação Log
	cLogTit := STR0249 //"Populando a tabela TR2 com os dados da SB2 - (0) Iniciando"
	cLogTit := OemToAnsi(I18N(cLogTit))
	M330PrcLog("MENSAGEM", cLogTit)

	For nForFilial := 1 to Len(aFilsCalc)
		If aFilsCalc[nForFilial,1]
			//Apaga a tabela e repopula com os dados mais recentes
			cQry := " DELETE FROM "+cNomTR2+" "
			cQry += " WHERE B2_FILIAL = '"+FWXFilial('SB2', aFilsCalc[nForFilial,2])+"' "
			A330SQLExec(cQry, 'A330TR2Ini', STR0255) //Falha ao apagar dados da TR2

			cWhere := " B2_FILIAL = ? "
			cWhere += " And D_E_L_E_T_ = ? "
			ASize(aBind, 0)
			aBind := {}
			AAdd(aBind, FWXFilial('SB2', aFilsCalc[nForFilial,2]))
			AAdd(aBind, ' ')
			InsertTR2(cWhere, aBind, 'A330TR2Ini', STR0256) //Falha ao gravar dados na TR2
			
			//Gravação Log
			nTotal  := TR2Count(aFilsCalc[nForFilial,2])
			cLogTit := STR0250 //"Filial: #1[D MG 01]# - Populou a tabela TR2 com os dados da SB2"
			cLogMes := STR0251 //"Total de registros gravados: #1[10.000]#"
			cLogTit := OemToAnsi(I18N(cLogTit,{aFilsCalc[nForFilial,2]}))
			cLogMes := OemToAnsi(I18N(cLogMes,{Transform(nTotal, "@E 999,999,999,999")}))
			M330PrcLog("MENSAGEM", cLogTit, cLogMes)
		EndIf
	Next nForFilial

	//Troca o Alias SB2 para a tabela alternativa
	A330AbreB2(cNomTR2)

	//Gravação Log
	cLogTit := STR0252 //"Populando a tabela TR2 com os dados da SB2 - (1) Termino"
	cLogTit := OemToAnsi(I18N(cLogTit))
	M330PrcLog("MENSAGEM", cLogTit)

	ASize(aBind, 0)
	aBind := Nil
Return

/*/{Protheus.doc} InsertTR2
	Realiza a inserção de dados na TR2 com base na SB2, de acordo com o filtro informado
	@type  Static Function
	@author Gianluca Moreira
	@since 05/12/2022
/*/
Static __cCposInsert := Nil
Static __aCposInsert := Nil
Static __aQrySB2     := {}
Static Function InsertTR2(cWhere As Character, aBind As Array, cTitMsg As Character, cMsg As Character)
	Local aCposB2    := {} As Array
	Local aCposTR2   := {} As Array
	Local aCpos      := {} As Array
	Local aLine      := {} As Array
	Local cQry       := '' As Character
	Local cTmpSB2    := '' As Character
	Local cMD5       := '' As Character
	Local cCpos      := '' As Character
	Local nCpo       := 0  As Numeric
	Local nBind      := 0  As Numeric
	Local nQry       := 0  As Numeric
	Local oBulk            As Object

	//Verifica quais campos da SB2 estão na estrutura da TR2
	If __cCposInsert == Nil .Or. __aCposInsert == Nil
		aCposTR2 := GetTR2Stru(1)
		aCposB2  := FWSX3Util():GetAllFields('SB2', .F.)

		For nCpo := 1 To Len(aCposB2)
			If AScan(aCposTR2, {|x| AllTrim(x[1]) == AllTrim(aCposB2[nCpo])}) > 0
				AAdd(aCpos, {aCposB2[nCpo]})
			EndIf
		Next nCpo

		__cCposInsert := ''
		For nCpo := 1 To Len(aCpos)
			__cCposInsert += aCpos[nCpo,1]+','
		Next nCpo
		__cCposInsert := SubStr(__cCposInsert, 1, Len(__cCposInsert)-1)

		//Limpeza de arrays
		aSize(aCposB2,0)
		aCposB2 := Nil
		For nCpo := 1 To Len(aCposTR2)
			aSize(aCposTR2[nCpo],0)
			aCposTR2[nCpo] := Nil
		Next nCpo
		aSize(aCposTR2,0)
		aCposTR2 := Nil
		
		__aCposInsert := aCpos
	EndIf
	cCpos := __cCposInsert
	aCpos := __aCposInsert

	//Prepara a query com bind
	cQry  := " Select "+cCpos+" From "+RetSqlName("SB2")+" "
	cQry  += " Where "+cWhere
	cQry  += " Order by R_E_C_N_O_"
	cMD5  := MD5(cQry)
	nQry := AScan(__aQrySB2, {|x| x[1] == cMD5})
	If nQry == 0
		If __lLibVer
			AAdd(__aQrySB2, {cMD5, FwExecStatement():New()})
		Else
			AAdd(__aQrySB2, {cMD5, FWPreparedStatement():New()})
		EndIf
		nQry := Len(__aQrySB2)
		__aQrySB2[nQry, 2]:SetQuery(ChangeQuery(cQry))
	EndIf

	For nBind := 1 To Len(aBind)
		__aQrySB2[nQry, 2]:SetString(nBind, aBind[nBind])
	Next nBind

	If __lLibVer
		cTmpSB2 := GetNextAlias()
		__aQrySB2[nQry, 2]:OpenAlias(cTmpSB2)
	Else
		cQry := __aQrySB2[nQry, 2]:getFixQuery()
		cTmpSB2 := MpSysOpenQuery(cQry)
	EndIf	

	//Inicializa Bulk
	oBulk := FwBulk():New(cNomTR2, 1000)
	oBulk:SetFields(aCpos)

	While !(cTmpSB2)->(EoF())
		ASize(aLine, 0)
		aLine := {}
		for nCpo := 1 to len(aCpos)
			aAdd(aLine, (cTmpSB2)->(FieldGet(FieldPos(aCpos[nCpo,1]))))
		Next nCpo
		oBulk:AddData(aLine)

		(cTmpSB2)->(DbSkip())
	EndDo
	(cTmpSB2)->(DbCloseArea())

	oBulk:Close()
	oBulk:Destroy()
	FreeObj(oBulk)

	ASize(aLine, 0)
	aLine := {}
Return

/*/{Protheus.doc} CampoB2Fim
	Inicializa e retorna lista de campos da SB2 utilizados no recálculo,
	conforme parametrização
	@type  Static Function
	@author Gianluca Moreira
	@since 29/11/2022
/*/
Static __aCpoGrvB2 := Nil
Static __aCpoMODB2 := Nil
Static __aCpoObrB2 := Nil
Static Function CampoB2Fim(cTipo As Character, lMA330CP As Logical) As Array
	Local aCampos := {} As Array
	Local nI      := 0  As Numeric
	Local cCampo  := '' As Character
	Local nRegra  := 0  As Numeric
	Local nMoeda  := 0  As Numeric

	Default cTipo := SB2_ALL
	Default lMA330CP := ExistBlock("MA330CP")

	If SB2_MOD $ cTipo
		If __aCpoMODB2 == Nil
			__aCpoMODB2 := {}
			For nMoeda := 1 To 5
				AAdd(__aCpoMODB2, {'B2_CM'+cValToChar(nMoeda), 'N'})
			Next nMoeda
		EndIf

		For nI := 1 To Len(__aCpoMODB2)
			AAdd(aCampos, __aCpoMODB2[nI])
		Next nI
	EndIf

	If SB2_GRV $ cTipo
		If __aCpoGrvB2 == Nil
			__aCpoGrvB2 := {}
			AAdd(__aCpoGrvB2, {'B2_QFIM', 'N'})
			AAdd(__aCpoGrvB2, {'B2_QFIM2', 'N'})
			AAdd(__aCpoGrvB2, {'B2_QFIMFF', 'N'})
			For nMoeda := 1 To 5
				AAdd(__aCpoGrvB2, {'B2_VFIM'+cValToChar(nMoeda), 'N'})
				AAdd(__aCpoGrvB2, {'B2_CMFIM'+cValToChar(nMoeda), 'N'})
				AAdd(__aCpoGrvB2, {'B2_VFIMFF'+cValToChar(nMoeda), 'N'})
				AAdd(__aCpoGrvB2, {'B2_CMFF'+cValToChar(nMoeda), 'N'})
				AAdd(__aCpoGrvB2, {'B2_VFRP'+cValToChar(nMoeda), 'N'})
				AAdd(__aCpoGrvB2, {'B2_CMRP'+cValToChar(nMoeda), 'N'})
			Next nMoeda

			//Verifica se existe algum campo do custo em partes
			If lMA330CP
				For nRegra := 1 to 99
					For nMoeda := 1 to 5
						//A primeira chamada para montar o array é quando a TR2 será criada
						cCampo := "B2_CPF"+Strzero(nRegra,2,0)+Strzero(nMoeda,2,0)
						If SB2->(FieldPos(cCampo)) > 0
							aAdd(__aCpoGrvB2, {cCampo, 'N'})
						EndIf
						cCampo := "B2_CP"+Strzero(nRegra,2,0)+Strzero(nMoeda,2,0)
						If SB2->(FieldPos(cCampo)) > 0
							aAdd(__aCpoGrvB2, {cCampo, 'N'})
						EndIf
					Next nMoeda
				Next nRegra
			EndIf

			//Outros campos gravados durante o recálculo
			If SB2->(FieldPos("B2_MSEXP")) > 0
				AAdd(__aCpoGrvB2, {'B2_MSEXP', 'C'})
			EndIf
			AAdd(__aCpoGrvB2, {'B2_USAI', 'C'})
		EndIf

		For nI := 1 To Len(__aCpoGrvB2)
			AAdd(aCampos, __aCpoGrvB2[nI])
		Next nI
	EndIf

	If SB2_OBR $ cTipo
		If __aCpoObrB2 == Nil
			__aCpoObrB2 := {}
			AAdd(__aCpoObrB2, {'B2_FILIAL', 'C'})
			AAdd(__aCpoObrB2, {'B2_COD', 'C'})
			AAdd(__aCpoObrB2, {'B2_LOCAL', 'C'})
			AAdd(__aCpoObrB2, {'B2_QACLASS', 'N'}) //Faz parte do índice 3
			AAdd(__aCpoObrB2, {'B2_TIPO', 'C'})
			AAdd(__aCpoObrB2, {'B2_LOCALIZ', 'C'})
			AAdd(__aCpoObrB2, {'B2_QATU', 'N'})
		EndIf

		For nI := 1 To Len(__aCpoObrB2)
			AAdd(aCampos, __aCpoObrB2[nI])
		Next nI
	EndIf

Return aCampos

/*/{Protheus.doc} A330B2Fim
	Realiza a gravação dos dados na SB2 a partir dos dados da TR2
	@type  Function
	@author Gianluca Moreira
	@since 04/11/2022
	/*/
Function A330B2Fim(aFilsCalc As Array, oObj)
	Local aFils      := {} As Array //Lista circular
	Local aCpoGrv    := CampoB2Fim(SB2_GRV) As Array
	Local aCpoMod    := CampoB2Fim(SB2_MOD) As Array
	Local cFilCalc   := '' As Character
	Local nIndex     := 0  As Numeric
	Local nFil       := 0  As Numeric
	Local cLogTit    := '' As Character
	Local cLogMes    := '' As Character
	Local nTotal     := 0  As Numeric
	Local nTotalProc := 0  As Numeric
	Local nTries     := 1  As Numeric
	Local aBind      := {} As Array
	Local cAlTR2     := '' As Character
	Local cQuery     := '' As Character
	Local cQryTR2    := '' As Character
	Local nCpo       := 0  As Numeric
	Local nBind      := 0  As Numeric
	Local jTR2Rec    := JsonObject():New()
	Local nCount     := 0  As Numeric
	Local oQryTR2          As Object
	Local cIDThread  := '' As Character
	Local cSemaforo  := '' As Character
	Local nThreads   := Max(0, SuperGetMV("MV_M330THR",.F.,1))
	Local cSSKey     := cEmpAnt+CHR(255)+cFilAnt+CHR(255)+cNomTR2
	Local lLoop      := .T.
	Local aUsers     := {}
	Local nCntThread := 0
	Local cIDSubThr  := ''
	Local cGlbName   := ''
	Local cGlbValue  := ''
	Local nI         := 0

	//Preparação para manualjob
	cIDThread := cValToChar(ThreadID())
	cSemaforo := Upper("GrvSB2Fim_"+cIDThread+"_"+cEmpAnt)
	A330JobManual('1', cSemaforo, 'M330B2GRVCONNECT', nThreads, cSSKey)

	//Query de seleção dos campos a serem lidos no IPCGO
	cQryTR2 := " Select "
	For nCpo := 1 To Len(aCpoGrv)
		cQryTR2 += aCpoGrv[nCpo, 1]+","
	Next nCpo
	For nCpo := 1 To Len(aCpoMod)
		cQryTR2 += aCpoMod[nCpo, 1]+","
	Next nCpo
	cQryTR2 := SubStr(cQryTR2, 1, Len(cQryTR2)-1)
	cQryTR2 += " From "+cNomTR2+" "
	cQryTR2 += " Where R_E_C_N_O_  = ? "
	cQuery += "  Order by B2_FILIAL, B2_COD, B2_LOCAL "
	cQryTR2 := ChangeQuery(cQryTR2)

	//Query de seleção dos registros a gravar
	cQuery := " Select R_E_C_N_O_ TR2REC "
	cQuery += " From "+cNomTR2+" "
	cQuery += " Where B2_FILIAL  = ? "
	cQuery += "   And D_E_L_E_T_ = ? "
	cQuery += " Order by B2_FILIAL, B2_COD, B2_LOCAL "
	cQuery := ChangeQuery(cQuery)
	If __lLibVer
		oQryTR2 := FwExecStatement():New(cQuery)
	Else
		oQryTR2 := FWPreparedStatement():New(cQuery)
	EndIf

	//Filiais executadas
	For nFil := 1 To Len(aFilsCalc)
		If aFilsCalc[nFil,1]
			AAdd(aFils, aFilsCalc[nFil,2])
			nTotal += TR2Count(aFilsCalc[nFil,2])
		EndIf
	Next nFil

	//Gravação Log
	cLogTit := STR0253 //"Gravação do Saldo Final (SB2) a partir da TR2 - (0) Iniciando"
	cLogMes := STR0254 //"Total de registros pendentes de gravação: #1[10.000]#"
	cLogTit := OemToAnsi(I18N(cLogTit))
	cLogMes := OemToAnsi(I18N(cLogMes,{Transform(nTotal, "@E 999,999,999,999")}))
	M330PrcLog("MENSAGEM", cLogTit, cLogMes)

	If !lBat .And. !IsBlind() .And. oObj <> Nil
		oObj:cCaption := OemToAnsi(cLogTit+cLogMes)
		ProcessMessages()
	EndIf

	//Restaura o Alias SB2
	A330AbreB2(RetSqlName('SB2'))

	//Restaura o Alias TR2
	TR2->(DbCloseArea())
	dbUseArea(.T.,"TOPCONN",cNomTR2,"TR2",.T.)
	For nIndex := 1 To Len(GetTR2Stru(2))
		dbSetIndex(cNomTR2+StrZero(nIndex,2))
	Next nIndex

	SB2->(DbSetOrder(1)) //B2_FILIAL+B2_COD+B2_LOCAL
	TR2->(DbSetOrder(1)) //B2_FILIAL+B2_COD+B2_LOCAL
	TR2->(DbGoTop())

	//Varre a lista de filiais gravando os registros não travados
	nFil := 1
	While nFil <= Len(aFils)
		cFilCalc := aFils[nFil]
		nCount   := 0

		//Preenchimento do filtro
		ASize(aBind, 0)
		aBind := {}
		AAdd(aBind, FWXFilial('SB2', cFilCalc)) //B2_FILIAL
		AAdd(aBind, ' ') //D_E_L_E_T_

		For nBind := 1 To Len(aBind)
			oQryTR2:SetString(nBind, aBind[nBind])
		Next nBind

		If __lLibVer
			cAlTR2 := GetNextAlias()
			oQryTR2:OpenAlias(cAlTR2)
		Else
			cQuery := oQryTR2:GetFixQuery()
			cAlTR2 := MpSysOpenQuery(cQuery)
		EndIf

		//Acumula os recnos para gravar de mil em mil
		While !(cAlTR2)->(EoF())
			nCount++
			If nCount <= 1000
				jTR2Rec[Str(nCount)] := (cAlTR2)->TR2REC
			EndIf

			If nCount == 1000
				While !IpcGo(cSemaforo, cEmpAnt, cFilAnt, cNomTR2, aCpoGrv, aCpoMod, jTR2Rec:ToJson(), cQryTR2)
					Sleep(500)
				EndDo
				nCount := 0
				jTR2Rec:FromJson('{}')
			EndIf
			(cAlTR2)->(DbSkip())
		EndDo
		(cAlTR2)->(DbCloseArea())

		//Grava os que sobraram
		If nCount > 0
			While !IpcGo(cSemaforo, cEmpAnt, cFilAnt, cNomTR2, aCpoGrv, aCpoMod, jTR2Rec:ToJson(), cQryTR2)
				Sleep(500)
			EndDo
			nCount := 0
			jTR2Rec:FromJson('{}')
		EndIf
		
		nFil++
		//Varreu todas as filiais
		If nFil > Len(aFils)
			//Verifica se ainda existe alguma thread processando e aguarda o término
			lLoop      := .T.
			nCntThread := 0

			While lLoop 
				aUsers := GetUserInfoArray()
				For nI := 1 to len(aUsers)
					If aUsers[nI][1] == cSemaforo // semaforo
						cIDSubThr := cValToChar(aUsers[nI][3])  // ID da working thread
						cGlbName := "cThrWrk"+cIDSubThr // define o nome da variavel global
						cGlbValue := GetGlbValue(cGlbName) // Verifica valor da variável

						If cGlbValue == "1"
							nCntThread++ // conta qtas working threads abertas e executando
						EndIf
					EndIf
				Next nI

				If nCntThread == 0
					lLoop := .F. //Todas processadas, encerra o loop
				EndIf
				nCntThread := 0
				sleep(2000)

				//Limpa array
				For nI := 1 To Len(aUsers)
					aSize(aUsers[nI], 0)
				Next nI
				aUsers := aSize(aUsers,0)
			EndDo

			//Processou todos os registros das filiais -> remove do array
			nI := 1
			nTotalProc := 0
			While nI <= Len(aFils)
				cFilCalc := aFils[nI]
				If (nTotal := TR2Count(cFilCalc)) <= 0 
					ADel(aFils, nI)
					ASize(aFils, Len(aFils)-1)
					nI--
				EndIf
				nTotalProc += nTotal

				//Gravação Log
				cLogTit := STR0257 //"Filial: #1[D MG 01 ]# - Gravação do Saldo Final (SB2) a partir da TR2"
				cLogMes := STR0258 //"Tentativa #1[123]#: Total de registros pendentes de gravação: #2[10.000]#"
				cLogTit := OemToAnsi(I18N(cLogTit,{cFilCalc}))
				cLogMes := OemToAnsi(I18N(cLogMes,{CValToChar(nTries),Transform(nTotal, "@E 999,999,999,999")}))
				If nTotal > 0
					cLogMes += CRLF+"Recnos pendentes: "+CRLF
					cLogMes += TR2List(cFilCalc)
				EndIf
				M330PrcLog("MENSAGEM", cLogTit, cLogMes)
				nI++
			EndDo

			If !lBat .And. !IsBlind() .And. oObj <> Nil
				cLogMes := STR0258 //"Tentativa #1[123]#: Total de registros pendentes de gravação: #2[10.000]#"
				oObj:cCaption := OemToAnsi(I18N(cLogMes, {CValToChar(nTries),Transform(nTotalProc, "@E 999,999,999,999")}))
				ProcessMessages()
			EndIf

			//Volta ao começo
			nFil := 1
			Sleep(1000)
			nTries++
		EndIf
	EndDo
	
	//Encerra a manualjob
	A330JobManual('2', cSemaforo, 'M330B2GRVCONNECT', nThreads, cSSKey )

	TR2->(DbCloseArea())

	//Gravação Log
	nTotal := 0
	For nFil := 1 To Len(aFilsCalc)
		If aFilsCalc[nFil,1]
			nTotal += TR2Count(aFilsCalc[nFil,2])
		EndIf
	Next nFil

	cLogTit := STR0259 //"Gravação do Saldo Final (SB2) a partir da TR2 - (1) Termino"
	cLogMes := STR0254 //"Total de registros pendentes de gravação: #1[10.000]#"
	cLogTit := OemToAnsi(I18N(cLogTit))
	cLogMes := OemToAnsi(I18N(cLogMes,{Transform(nTotal, "@E 999,999,999,999")}))
	M330PrcLog("MENSAGEM", cLogTit, cLogMes)

	ASize(aFils,0)
	aFils := Nil
	ASize(aCpoGrv,0)
	aFils := Nil
	ASize(aCpoMod,0)
	aFils := Nil
	jTR2Rec:FromJson('{}')
	FreeObj(jTR2Rec)

Return

/*/{Protheus.doc} GrvSB2Fim
	A partir da lista de recnos da TR2, localiza e atualiza os registros na SB2
	Execução em manualjob
	@type Function
	@author Gianluca Moreira
	@since 04/11/2022
/*/
Static __cUpdGrvB2 := Nil
Function GrvSB2Fim(cEmp, cFil, cNomTR2, aCpoGrv, aCpoMod, cJRecTR2, cQryTR2)
	Local aBind   := {}
	Local cAlTR2  := GetNextAlias()
	Local cQuery  := ''
	Local cCampo  := ''
	Local cTipo   := ''
	Local cValor  := ''
	Local nCpo    := 0
	Local nBind   := 0
	Local jTR2Rec := JsonObject():New()
	Local nCount  := 0
	Local oQryTR2 := Nil
	Local lDeleteTR2 := .F.
	Local cNomSB2 := RetSqlName("SB2")

	If __lLibVer == Nil
		__lLibVer := FWLibVersion() >= "20211116"
	EndIf

	SB2->(DbSetOrder(1)) //B2_FILIAL+B2_COD+B2_LOCAL
	TR2->(DbSetOrder(1)) //B2_FILIAL+B2_COD+B2_LOCAL
	TR2->(DbGoTop())
	
	If __lLibVer
		oQryTR2 := FwExecStatement():New(cQryTR2)
	Else
		oQryTR2 := FWPreparedStatement():New(cQryTR2)
	EndIf
	
	jTR2Rec:FromJson(cJRecTR2)

	For nCount := 1 To 1000
		If jTR2Rec[Str(nCount)] == NIL
			Loop
		EndIf

		//Preenchimento do filtro
		ASize(aBind, 0)
		aBind := {}
		AAdd(aBind, jTR2Rec[Str(nCount)]) //R_E_C_N_O_

		For nBind := 1 To Len(aBind)
			oQryTR2:setNumeric(nBind, aBind[nBind])
		Next nBind

		If __lLibVer
			oQryTR2:OpenAlias(cAlTR2)
		Else
			cQuery := oQryTR2:GetFixQuery()
			MpSysOpenQuery(cQuery, cAlTR2)
		EndIf

		While !(cAlTR2)->(EoF())
			lDeleteTR2 := .F.
			TR2->(DbGoto(jTR2Rec[Str(nCount)]))
			If SB2->(DbSeek(TR2->(B2_FILIAL+B2_COD+B2_LOCAL)))
				If SB2->(SimpleLock())
					cQuery := " Update "+cNomSB2+" "
					cQuery += " Set "
					For nCpo := 1 To Len(aCpoGrv)
						cCampo := aCpoGrv[nCpo, 1]
						cTipo  := aCpoGrv[nCpo, 2]
						If cTipo == 'N'
							cValor := cValToChar((cAlTR2)->(FieldGet(FieldPos(cCampo))))
						Else
							cValor := "'"+(cAlTR2)->(FieldGet(FieldPos(cCampo)))+"'"
						EndIf
						cQuery += cCampo+" = "+cValor+","
					Next nCpo
					If TR2->TR2_MOD == '1'
						For nCpo := 1 To Len(aCpoMod)
							cCampo := aCpoMod[nCpo, 1]
							cQuery += cCampo+" = "+cValToChar((cAlTR2)->(FieldGet(FieldPos(cCampo))))+","
						Next nCpo
					EndIf
					cQuery := SubStr(cQuery, 1, Len(cQuery)-1)
					cQuery += " Where R_E_C_N_O_ = "+cValToChar(SB2->(Recno()))
					A330SQLExec(cQuery, 'GrvSB2Fim', STR0260) //Falha ao gravar SB2
					SB2->(MsrUnlock())
					lDeleteTR2 := .T.
				EndIf
			Else
				lDeleteTR2 := .T.
			EndIf

			If lDeleteTR2
				If TR2->(!EOF() .AND. RECNO() == jTR2Rec[Str(nCount)])
					If RecLock('TR2', .F.)
						TR2->(DbDelete())
						TR2->(MsUnlock())
					EndIf
				EndIf
			EndIf

			(cAlTR2)->(DbSkip())
		EndDo
		(cAlTR2)->(DbCloseArea())
	Next nCount

	ASize(aBind,0)
	aBind := Nil
	jTR2Rec:FromJson('{}')
	FreeObj(jTR2Rec)
Return

/*/{Protheus.doc} M330B2GRVCONNECT
	Prepara função para gravar os dados na SB2
	@type  Function
	@author g.moreira
	@since 09/12/2022
	/*/
Function M330B2GRVCONNECT(cEmp, cFil, cNomTR2, aCpoGrv, aCpoMod, cJRecTR2, cQryTR2)
LOCAL cGlbName
LOCAL cThisThread

	If cEmp=="##QUIT##"
		cThisThread := cValToChar(ThreadId())
		cGlbName := "cThrWrk"+cThisThread // define o nome da variavel global
		ClearGlbValue(cGlbName)
		killapp(.T.)
	ELSE
		cGlbName  := "cThrWrk"+cValToChar(ThreadId())
		A330LckGlb(cGlbName)
		PutGlbValue(cGlbName,"1")
		A330ULckGlb(cGlbName)

		GrvSB2Fim(cEmp, cFil, cNomTR2, aCpoGrv, aCpoMod, cJRecTR2, cQryTR2)
	Endif
	A330LckGlb(cGlbName)
	PutGlbValue(cGlbName,"0")
	A330ULckGlb(cGlbName)

RETURN

/*/{Protheus.doc} TR2Count
	Retorna quantos registros ainda não foram gravados na SB2 para a filial especificada
	@type  Static Function
	@author Gianluca Moreira
	@since 04/11/2022
/*/
Static __oTR2Cnt := Nil
Static Function TR2Count(cFilSel As Character) As Numeric
	Local cQuery := '' As Character
	Local aBind  := {} As Array
	Local nBind  := 0  As Numeric
	Local nCount := 0  As Numeric

	If __oTR2Cnt == Nil
		cQuery := " Select Count(R_E_C_N_O_) COUNT "
		cQuery += " From "+cNomTR2+" "
		cQuery += " Where B2_FILIAL  = ? "
		cQuery += "   And D_E_L_E_T_ = ? "
		cQuery := ChangeQuery(cQuery)

		If __lLibVer
			__oTR2Cnt := FwExecStatement():New(cQuery)
		Else
			__oTR2Cnt := FWPreparedStatement():New(cQuery)
		EndIf
	EndIf

	//Preenchimento do filtro
	aBind := {}
	AAdd(aBind, FWXFilial('SB2', cFilSel)) //B2_FILIAL
	AAdd(aBind, ' ') //D_E_L_E_T_

	For nBind := 1 To Len(aBind)
		__oTR2Cnt:SetString(nBind, aBind[nBind])
	Next nBind

	If __lLibVer
		nCount := __oTR2Cnt:ExecScalar('COUNT')
	Else
		cQuery := __oTR2Cnt:GetFixQuery()
		nCount := MpSysExecScalar(cQuery, 'COUNT')
	EndIf
	
	ASize(aBind,0)
	aBind := Nil
Return nCount

/*/{Protheus.doc} TR2List
	Retorna os registros ainda não foram gravados na SB2 para a filial especificada
	@type  Static Function
	@author Gianluca Moreira
	@since 24/02/2023
/*/
Static __oTR2List := Nil
Static Function TR2List(cFilSel As Character) As Character
	Local cQuery := '' As Character
	Local cAlTmp := '' As Character
	Local aBind  := {} As Array
	Local nBind  := 0  As Numeric
	Local cList  := "" As Character

	If __oTR2List == Nil
		cQuery := " Select R_E_C_N_O_ RECNO "
		cQuery += " From "+cNomTR2+" "
		cQuery += " Where B2_FILIAL  = ? "
		cQuery += "   And D_E_L_E_T_ = ? "
		cQuery := ChangeQuery(cQuery)

		If __lLibVer
			__oTR2List := FwExecStatement():New(cQuery)
		Else
			__oTR2List := FWPreparedStatement():New(cQuery)
		EndIf
	EndIf

	//Preenchimento do filtro
	aBind := {}
	AAdd(aBind, FWXFilial('SB2', cFilSel)) //B2_FILIAL
	AAdd(aBind, ' ') //D_E_L_E_T_

	For nBind := 1 To Len(aBind)
		__oTR2List:SetString(nBind, aBind[nBind])
	Next nBind

	If __lLibVer
		cAlTmp := GetNextAlias()
		__oTR2List:OpenAlias(cAlTmp)
	Else
		cQuery := __oTR2List:GetFixQuery()
		cAlTmp := MpSysOpenQuery(cQuery)
	EndIf

	While !(cAlTmp)->(EoF())
		cList += cValToChar((cAlTmp)->RECNO)+CRLF
		(cAlTmp)->(DbSkip())
	EndDo
	(cAlTmp)->(DbCloseArea())
	
	ASize(aBind,0)
	aBind := Nil
Return cList

/*/{Protheus.doc} A330AbreB2
	Abre o Alias SB2 a partir do nome físico informado
	@type  Function
	@author Gianluca Moreira
	@since 10/11/2022
	/*/
Static __nQtIdxB2 := Nil
Function A330AbreB2(cNomFisico)
	Local nI   := 0
	Local nTam := 1

	If 'TR2' $ cNomFisico
		nTam := 2
	EndIf

	If __nQtIdxB2 == Nil
		__nQtIdxB2 := Len(GetTR2Stru(2))
	EndIf

	SB2->(DbCloseArea())
	dbUseArea(.T.,"TOPCONN",cNomFisico,"SB2",.T.)
	For nI := 1 To __nQtIdxB2
		dbSetIndex(cNomFisico+StrZero(nI,nTam))
	Next nI
Return

/*/{Protheus.doc} A330CriaB2
	Cria armazém para o produto, caso este tenha sido excluído, com base na TRB
	Chamada após o PE MA330TRB, caso tenha sido manipulado pelo usuário
	@type  Static Function
	@author Gianluca Moreira
	@since 14/11/2022
/*/
Static Function A330CriaB2(aFilsCalc)
	Local aArea      := GetArea()
	Local aAreaSB2   := SB2->(GetArea())
	Local aAreaSB1   := SB1->(GetArea())
	Local aAreaNNR   := NNR->(GetArea())
	Local aBind      := {}
	Local aCriarB2   := {}
	Local aBindIns   := {}
	Local cQuery     := ''
	Local cWhere     := ''
	Local cFilCalc   := ''
	Local cAlTmp     := ''
	Local cFilBkp    := cFilAnt
	Local cLista     := ''
	Local cLogTit    := ''
	Local cLogMes    := ''
	Local nForFilial := 0
	Local nBind      := 0
	Local nTotal     := 0
	Local nB2        := 0
	Local oCriaSB2   := Nil

	If oCriaSB2 == Nil
		cQuery := " Select TRB_FILIAL, TRB_COD, TRB_LOCAL "
		cQuery += "   From "+cNomTRB+" TRB "
		cQuery += "  Where Not Exists ( "
		cQuery += " Select B2_FILIAL "
		cQuery += "   From "+RetSqlName('SB2')+" SB2 "
		cQuery += "  Where B2_FILIAL = TRB_FILIAL "
		cQuery += "    And B2_COD    = TRB_COD "
		cQuery += "    And B2_LOCAL  = TRB_LOCAL "
		cQuery += "    And B2_FILIAL = ? "
		cQuery += "    And SB2.D_E_L_E_T_ = ? "
		cQuery += " ) "
		cQuery += "    And TRB_FILIAL = ? "
		cQuery += "    And TRB.D_E_L_E_T_ = ? "
		cQuery += " Group By TRB_FILIAL, TRB_COD, TRB_LOCAL "
		cQuery := ChangeQuery(cQuery)

		If __lLibVer
			oCriaSB2 := FwExecStatement():New(cQuery)
		Else
			oCriaSB2 := FWPreparedStatement():New(cQuery)
		EndIf
	EndIf

	NNR->(DbSetOrder(1)) //NNR_FILIAL+NNR_CODIGO
	SB1->(DbSetOrder(1)) //B1_FILIAL+B1_COD
	
	For nForFilial := 1 To Len(aFilsCalc)
		If aFilsCalc[nForFilial,1]
			cFilCalc := aFilsCalc[nForFilial,2]
			cFilAnt  := cFilCalc
			nTotal   := 0
			cLogTit  := ""
			cLogMes  := ""
			cLista   := ""

			//Preenchimento do filtro
			ASize(aBind,0)
			aBind := {}
			AAdd(aBind, FWXFilial('SB2', cFilCalc)) //B2_FILIAL
			AAdd(aBind, ' ') //D_E_L_E_T_
			AAdd(aBind, cFilCalc) //TRB_FILIAL
			AAdd(aBind, ' ') //D_E_L_E_T_

			For nBind := 1 To Len(aBind)
				oCriaSB2:SetString(nBind, aBind[nBind])
			Next nBind

			If __lLibVer
				cAlTmp := GetNextAlias()
				oCriaSB2:OpenAlias(cAlTmp)
			Else
				cQuery := oCriaSB2:GetFixQuery()
				cAlTmp := MpSysOpenQuery(cQuery)
			EndIf

			For nB2 := 1 To Len(aCriarB2)
				ASize(aCriarB2[nB2],0)
				aCriarB2[nB2] := Nil
			Next nB2
			ASize(aCriarB2,0)
			aCriarB2 := {}
			While !(cAlTmp)->(EoF())
				If SB1->(DbSeek(FWXFilial('SB1')+(cAlTmp)->TRB_COD)) .And.;
				   NNR->(DbSeek(FWXFilial('NNR')+(cAlTmp)->TRB_LOCAL))
					nTotal++
					cLista += CRLF+(cAlTmp)->TRB_COD+'/'+(cAlTmp)->TRB_LOCAL
					AAdd(aCriarB2, {(cAlTmp)->TRB_COD, (cAlTmp)->TRB_LOCAL})
				EndIf
				(cAlTmp)->(DbSkip())
			EndDo
			(cAlTmp)->(DbCloseArea())
			
			If nTotal > 0
				//Certifica que está aberto na SB2
				If 'TR2' $ cNomTR2
					A330AbreB2(RetSqlName('SB2'))
				EndIf

				//Inclui SB2
				For nB2 := 1 To Len(aCriarB2)
					CriaSB2(aCriarB2[nB2, 1], aCriarB2[nB2, 2])
				Next nB2
				
				If 'TR2' $ cNomTR2
					//Restaura alias TR2
					A330AbreB2(cNomTR2)

					//Copia apenas os campos necessários na TR2
					For nB2 := 1 To Len(aCriarB2)
						cWhere := " B2_FILIAL    = ? "
						cWhere += " And B2_COD   = ? "
						cWhere += " And B2_LOCAL = ? "
						cWhere += " And D_E_L_E_T_ = ? "
						ASize(aBindIns, 0)
						aBindIns := {}
						AAdd(aBindIns, FWXFilial('SB2', cFilCalc))
						AAdd(aBindIns, aCriarB2[nB2, 1])
						AAdd(aBindIns, aCriarB2[nB2, 2])
						AAdd(aBindIns, ' ')
						cLogMes := STR0262 //Falha ao incluir #1[D MG 01 ]#/#2[PRODUTO01]#/#3[LOCAL01]# na TR2
						cLogMes := OemToAnsi(I18N(cLogTit,{cFilCalc, aCriarB2[nB2, 1], aCriarB2[nB2, 2]}))
						InsertTR2(cWhere, aBindIns, 'A330CriaB2', cLogMes)
					Next nB2
				EndIf

				//Grava Log
				cLogTit := STR0263 //"Filial #1[D MG 01 ]#: Identificado(s) #2[12]# Produto(s)/Local(ais) sem SB2 e foram criados automaticamente"
				cLogMes := STR0264 //'Avalie a necessidade de executar a rotina Refaz Saldos (MATA300) para os produtos/armazéns abaixo:'
				cLogMes += cLista
				cLogTit := OemToAnsi(I18N(cLogTit,{cFilCalc,cValToChar(nTotal)}))
				cLogMes := OemToAnsi(I18N(cLogMes))
				M330PrcLog("MENSAGEM", cLogTit, cLogMes)
			EndIf
		EndIf
	Next nForFilial

	RestArea(aAreaSB2)
	RestArea(aAreaSB1)
	RestArea(aAreaNNR)
	RestArea(aArea)
	cFilAnt := cFilBkp

	//Limpeza de arrays
	For nB2 := 1 To Len(aCriarB2)
		ASize(aCriarB2[nB2],0)
		aCriarB2[nB2] := Nil
	Next nB2
	ASize(aCriarB2,0)
	ASize(aAreaSB2, 0)
	ASize(aAreaSB1, 0)
	ASize(aAreaNNR, 0)
	ASize(aArea, 0)
	ASize(aBind,0)
	ASize(aBindIns, 0)
	aCriarB2 := Nil
	aAreaSB2 := Nil
	aAreaSB1 := Nil
	aAreaNNR := Nil
	aArea := Nil
	aBind := Nil
	aBindIns := Nil
Return

/*/{Protheus.doc} UsaTR2
	Verifica a versão do RPO e o parâmetro MV_A330SB2 para utilizar a SB2 ou TR2
	@type  Static Function
	@author Gianluca Moreira
	@since 11/04/2023
/*/
Static Function UsaTR2()
Return GetRpoRelease() >= '12.1.2310' .Or. SuperGetMv('MV_A330SB2',.F., .F.)

/*/{Protheus.doc} M330startC
	Chama processo de analise apos fim de processamento
	@type  Function
	@author andre.maximo
	@since 21/12/2021
	@version 1.0
/*/
Function M330startC(aListaFil , cIdParent, cfilant, cCompany, oJourneyLog )

Local oContabil 	:= EstAcMiddle('ac.acContab.Service', 'acContabServ():New()')
Local oRet			:= JsonObject():New()
Default oJourneyLog := JsonObject():New()
 oRet  := oContabil:validAutExecOfTheAccounting(cIdParent,aListaFil, cfilant, cCompany)

Return oRet

//------------------------------------------------------------------
/*{Protheus.doc} M330Proced()
Faz a Instalação da Procedure ctb250 sem o Configurador            

@author 
                       
@version P12
@return
*/
//-------------------------------------------------------------------
Function M330Proced()
Local cCompany    as character
Local cMsg        as character
Local cProcess    as character
Local oInstall    as object
Local oMyProcess  as object
Local oRPOProcess as object

cCompany := cEmpAnt

If SPSMigrated()
	cProcess := "26"
	cCompany := cEmpAnt

	// Retorna objeto com o status do processo na base de dados
	oMyProcess := EngSPSStatus(cProcess/*processo*/,cCompany/*empresa*/) // código da empresa não é obrigatório - Default = cEmpAnt
	If oMyProcess["status"] == DEF_SPS_NOT_INSTALLED // se não está instalado, possibilita a instalação com o que está no RPO ou TPH
				
		conout(OemToAnsi(I18N(STR0268,{oMyProcess["process"],cCompany})))//"O processo #1[26]# não está instalado para a empresa #2[T1]#"
		
		oRPOProcess := EngSPSGetProcess(DEF_SPS_FROM_RPO/*origem*/, oMyProcess["process"]/*processo*/, /*empresa*/)
		If oRPOProcess["status"] <> "FALSE"

			conout(OemToAnsi(I18N(STR0269,{oMyProcess["process"],cCompany})))//"Iniciando a instalação do processo #1[26]# na empresa #2[T1]# com o pacote do RPO..."
			oInstall := EngSPSInstall(oMyProcess["process"], cCompany, DEF_SPS_FROM_RPO )
			If Empty(oInstall["error"])
				cMsg := OemToAnsi(I18N(STR0270,{oInstall["process"],cCompany,oInstall["idlog"]}))//"Processo #1[26]# instalado corretamente na empresa #2[T1]# - IDLog da operação: #3[000001]#"
			Else
				cMsg := OemToAnsi(I18N(STR0271,{oInstall["idlog"],oInstall["error"]}))//"Falha - IDLog da operação: #1[000001]# - Erro: #2[Erro]#"
			EndIf
			conout(cMsg)						
		EndIf
	EndIf
Else	
	AVISO(STR0272,STR0273, {STR0274}, 2 )
EndIf

Return
