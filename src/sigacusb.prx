#INCLUDE "SIGACUSA.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "FWLIBVERSION.CH"
#INCLUDE "FWEVENTVIEWCONSTS.CH"

STATIC __lIntWMS 
STATIC __lCusaVLib
STATIC __lCusbVLib

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ AvalTes  ³ Autor ³ Ben-Hur M. Castilho   ³ Data ³ 31/01/97  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Avalia TES Conforme Condicoes de Atualizacao de Estoque e   ³±±
±±³          ³ Geracao de Duplicatas.                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe  ³ AvalTes(ExpC1,ExpC2,ExpC3)                                  ³±±
±±³          ³ ExpC1 -> Codigo do TES a Avaliar                            ³±±
±±³          ³ ExpC2 -> String Referente a Estoque (S/N/SN)                ³±±
±±³          ³ ExpC3 -> String Referente a Duplicatas (S/N/SN)             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/

Function AvalTes( cTes,cEstoq,cDupli )

Local lRet   := .F.,;
	cAlias := ""

If !((cAlias := Alias()) == "SF4")
	DbSelectArea( "SF4" )
Endif

If (xFilial("SF4")+cTes == SF4->F4_FILIAL+SF4->F4_CODIGO) .Or. DbSeek( xFilial( "SF4" )+cTes,.F. )
	Do Case
	Case (cEstoq # NIL) .And. (cDupli # NIL)
		lRet := ((SF4->F4_ESTOQUE $ cEstoq) .And. (SF4->F4_DUPLIC $ cDupli))
	Case (cDupli == NIL) .And. (cEstoq # NIL)
		lRet := (SF4->F4_ESTOQUE $ cEstoq)
	Case (cEstoq == NIL) .And. (cDupli # NIL)
		lRet := (SF4->F4_DUPLIC $ cDupli)
	EndCase
EndIf

If !(cAlias == "SF4")
	DbSelectArea( cAlias )
EndIf

Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ SaldoRJCQ  ³Autor³    Marcos Simidu      ³ Data ³ 19.05.97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica o total de itens rejeitados no CQ, totalizando a   ³±±
±±³          ³somatoria dos valores rejeitados mais as devolucoes.        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function SaldoRJCQ(cProd,cDocOri,cSerieOri,cCliente,cLoja,cLote,cItemOri,dDataAtu,cLocal,cNumero,lTranCQ,cNumseq)
Local aSavArea    := GetArea()
Local cSeek       := xFilial("SD1")+cDocOri+cSerieOri+cCliente+cLoja+cProd
Local cSeek1      := ""
Local cComp       := ""
Local aRet        := { 0, 0, 0, 0, 0, 0, "", 0, 0, 0, 0}
Local aRet2UM     := { 0, 0, 0, 0, 0, 0, 0}
Local nOrdSD7     := 1
Local lValidLocal :=.F.
Local lLocaliza   := Localiza(cProd,.T.)

Default cLocal   := ""
Default cNumero  := ""
Default lTranCQ  := .F.
Default cNumseq  := ""

cLote := IF(cLote==NIL,cLote:=Space(6),cLote)

dDataAtu := If(dDataAtu==Nil,CtoD('  /  /  '),dDataAtu)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Estrutura do Array aRet (Retorno)               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
// aRet[01] - Saldo Original do CQ
// aRet[02] - Saldo Qtde. Liberada
// aRet[03] - Saldo Qtde. Rejeitada
// aRet[04] - Qtde. Liberada Estornada
// aRet[05] - Qtde. Rejeitada Estornada
// aRet[06] - Movimentacao
// aRet[07] - Local da Primeira Liberacao
// aRet[08] - Saldo em Aberto para Liberacao/Rejeicao ou Transferencia
// aRet[09] - Saldo em Aberto na Segunda unidade de Medida Transferencia
// aRet[10] - Transferencias entre Filiais
// aRet[11] - Estorno da Transferencia

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Procura Notas originais do CQ       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SD1")
dbSetOrder(1)
If dbSeek(cSeek)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se esta posicionado no item correto³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cItemOri != NIL
		Do While !Eof() .And. cSeek == D1_FILIAL+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_COD
			If D1_ITEM != cItemOri
				dbSkip()
				Loop
			EndIf
			Exit
		EndDo
	Else
		Do While !Eof() .And. cSeek == D1_FILIAL+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_COD
			If D1_LOTECTL != cLote .Or. IIF( Alltrim(cNumero)=="", .T., D1_NUMCQ != cNumero)
				dbSkip()
				Loop
			EndIf
			Exit
		EndDo
	EndIf
	If !Eof() .And. !Empty(SD1->D1_NUMCQ)
		cSeek1 := SD1->D1_NUMCQ+SD1->D1_COD+SD1->D1_LOCAL
		nOrdSD7:= 1
		cComp  := "D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL"
	EndIf
EndIf
// Caso nao tenha encontrado dados do documento original e tenha preenchido armazem pesquisa por produto e valida o armazem no laco do SD7
If Empty(cSeek1) .And. !Empty(cLocal)
    lValidLocal:=.T.
    cSeek1 := cProd
    nOrdSD7:= 3
    cComp  := "D7_FILIAL+D7_PRODUTO"
    If !Empty(cNumero)
		nOrdSD7:= 2
        cSeek1 := cNumero + cSeek1
        cComp  := "D7_FILIAL+D7_NUMERO+D7_PRODUTO"
    EndIf
EndIf

dbSelectArea("SD7")
dbSetOrder(nOrdSD7)
If dbSeek(xFilial("SD7")+cSeek1)
	Do While !Eof() .And. xFilial("SD7")+cSeek1 == &(cComp)
		If ( D7_ESTORNO == "S" .And. D7_TIPO != 0 .And. !lTranCQ) .Or. If(lValidLocal,D7_LOCAL # cLocal,.F.)
			dbSkip()
			Loop
		Endif
		//-- S¢ soma Movimenta‡äes Posteriores a Data Atual no Saldo
		If !Empty(dDataAtu) .And. (D7_TIPO==1.Or.D7_TIPO==2.Or.D7_TIPO==6.Or.D7_TIPO==7) .And. dDataAtu < D7_DATA
			dbSkip()
			Loop
		EndIf
		//-- Faz o cálculo apenas do Lote ( se for passado ) em questão
		If !Empty(cLote) .And. D7_LOTECTL != cLote
			dbSkip()
			Loop
		EndIF
		//-- Faz o cálculo apenas do Numero do CQ em questao
		If !Empty(cNumero) .And. SD7->D7_NUMERO != cNumero
			dbSkip()
			Loop
		EndIF


		Do Case
			Case D7_TIPO == 0
				aRet[1]    += D7_SALDO		// Original
				aRet2UM[1] += D7_SALDO2  	// Original 2UM
				//Abate o saldo a enderecar da tabela SDA
				If lLocaliza .And. lTranCQ
					aRet[1] -= SDASaldo(D7_PRODUTO,D7_LOCAL,D7_NUMSEQ)
				EndIf
			Case D7_TIPO == 1
				aRet[2]    += D7_QTDE   	// Liberada
				aRet2UM[2] += D7_QTSEGUM	// Liberada 2UM
				If Empty(aRet[7])
					aRet[7]:=D7_LOCDEST
				EndIf
			Case D7_TIPO == 2
				aRet[3]    += D7_QTDE   	// Rejeitada
				aRet2UM[3] += D7_QTSEGUM	// Rejeitada 2UM
			Case D7_TIPO == 3
				aRet[10]   += D7_QTDE   	// Transferida
				aRet2UM[6] += D7_QTSEGUM	// Transferida 2UM
			Case D7_TIPO == 4
				aRet[11]   += D7_QTDE   	// Estorno Transferencia
				aRet2UM[7] += D7_QTSEGUM	// Estorno Transferencia 2UM
				//Abate o saldo a enderecar da tabela SDA
				If lLocaliza .And. lTranCQ
					aRet[11] -= SDASaldo(D7_PRODUTO,D7_LOCAL,D7_NUMSEQ)
				EndIf
			Case D7_TIPO == 6
				aRet[4]    += D7_QTDE   	// Estorno da Liberacao
				aRet2UM[4] += D7_QTSEGUM	// Estorno da Liberacao 2UM
				//Abate o saldo a enderecar da tabela SDA
				If lLocaliza .And. lTranCQ
					aRet[4] -= SDASaldo(D7_PRODUTO,D7_LOCAL,D7_NUMSEQ)
				EndIf
			Case D7_TIPO == 7
				aRet[5]    += D7_QTDE   	// Estorno da Rejeicao
				aRet2UM[5] += D7_QTSEGUM	// Estorno da Rejeicao 2UM
				//Abate o saldo a enderecar da tabela SDA
				If lLocaliza .And. lTranCQ
					aRet[5] -= SDASaldo(D7_PRODUTO,D7_LOCAL,D7_NUMSEQ)
				EndIf
		EndCase
		dbSkip()
	EndDo
EndIf

// Saldo Quantidade Liberada/Rejeitada
aRet[06] := aRet[02]    + aRet[03]    - aRet[04]    - aRet[05]
// Saldo Disponivel para Transferencia
aRet[08] := aRet[01]    - aRet[02]    - aRet[03]    - aRet[10]    + aRet[04]    + aRet[05]    + aRet[11]
// Saldo Disponivel para Transferencia 2UM
aRet[09] := aRet2UM[01] - aRet2UM[02] - aRet2UM[03] - aRet2UM[06] + aRet2UM[04] + aRet2UM[05] + aRet2UM[07]

RestArea(aSavArea)
Return(aRet)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ SldMovCQ | Autor ³ TOTVS S/A            ³ Data ³29/10/2014³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao utilizada para retornar o Saldo Disponivel no CQ.   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ ESTOQUE/FATURAMENTO/COMPRAS (somente TOPCONNECT)          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function SldMovCQ(lTotal,cProd,cLoteCtl,cNumLote,cNumCQ,cNumSeq,cDocOri,cSerieOri,cCliente,cLoja,cItemOri,dDataAtu,cLocal,lNecessida,lSaldoSemR)
Local   aRetorno   := {0,0}
Local   aRetRes    := {0,0}
Local   aSaldoCQ   := {}

Default cLoteCtl   := ''
Default cNumLote   := ''
Default cNumCQ     := ''
Default cNumSeq    := ''
Default cDocOri    := ''
Default cSerieOri  := ''
Default cCliente   := ''
Default cLoja      := ''
Default cItemOri   := ''
Default cLocal	   := ''
Default dDataAtu   := dDataBase
Default lTotal     := .T.
Default lNecessida := .T.
Default lSaldoSemR := .T.

// Total do Saldo de CQ disponivel para Liberacao/Rejeicao/Transferencia
If lTotal //Saldo Total
	//Saldo Disponivel para transferencia de controle de qualidade (FORCA PARAMETROS EM BRANCO PARA COMPOSICAO DO TOTAL)
	aSaldoCQ := SaldoRJCQ(SB2->B2_COD,'','','','','',Nil,dDataBase,SB2->B2_LOCAL,Nil,.T.,cNumSeq)
	//Saldo de Reservas
	aRetRes  := IIf(lSaldoSemR,GetReserva(SB2->B2_FILIAL,SB2->B2_COD,SB2->B2_LOCAL,'',''),{0,0})
	If Len(aSaldoCQ) >=9
		//Saldo disponivel na 1aUM
		aRetorno[1] := aSaldoCQ[8] - IIf(Len(aRetRes)>=1,aRetRes[1],0)
		//Saldo disponivel na 2aUM
		aRetorno[2] := aSaldoCQ[9] - IIf(Len(aRetRes)>=2,aRetRes[2],0)
	EndIf
//Saldo por Lote
Else
	//Saldo Disponivel para transferencia de controle de qualidade
	aSaldoCQ    := SaldoRJCQ(cProd,cDocOri,cSerieOri,cCliente,cLoja,cLoteCtl,Nil,dDataAtu,cLocal,cNumCQ,.T.,cNumSeq)
	//Saldo de Reservas
	aRetRes     := If(lSaldoSemR,GetReserva(xFilial("SD7"),cProd,cLocal,cLoteCtl,cNumLote),{0,0})
	If Len(aSaldoCQ) >= 9
		//Saldo disponivel na 1aUM
		aRetorno[1] := aSaldoCQ[8] - aRetRes[1]
		//Saldo disponivel na 2aUM
		aRetorno[2] := aSaldoCQ[9] - aRetRes[2]
	EndIf
EndIf

Return aRetorno

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ GetQAClass ³ Autor ³    Will Carvalho    ³ Data ³ 15/10/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna a quantidade enderecada                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GetQAClass(cFil,cProduto,cLocal,cLoteCTL,cNumLote,cNrSeqCQ)
Local aArea      := GetArea()
Local cAlias     := GetNextAlias()
Local cQry       := ""
Local aAClass    := {0,0}
Local aTam1		 := TamSx3("DA_SALDO")
Local aTam2		 := TamSx3("DA_QTSEGUM")

#IFDEF TOP
	cQry := "SELECT SUM(DA_SALDO) SALDO, SUM(DA_QTSEGUM) QTSEGUM FROM "+RetSqlName("SDA")
	cQry += " WHERE DA_FILIAL = '" + cFil + "'"
	cQry += " AND DA_PRODUTO = '" + cProduto + "'"
	cQry += " AND DA_LOCAL = '" + cLocal + "'"
	cQry += " AND DA_QTDORI > DA_SALDO "
	If !Empty(cLoteCTL)
		cQry += " AND DA_LOTECTL = '" + cLoteCTL + "'"
	EndIf
	If !Empty(cNumLote)
		cQry += " AND DA_NUMLOTE = '" + cNumLote + "'"
	EndIf
	If !Empty(cNrSeqCQ)
		cQry += " AND DA_NUMSEQ = '" + cNrSeqCQ + "'"
	EndIf
	cQry += " AND D_E_L_E_T_ = ' '"
	cQry := ChangeQuery(cQry)

	DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQry),cAlias,.T.,.T.)
	TCSetField(cAlias,"SALDO","N",aTam1[1],aTam1[2])
	TCSetField(cAlias,"QTSEGUM","N",aTam2[1],aTam2[2])

	If !(cAlias)->(Eof())
		aAClass[1] := (cAlias)->SALDO
		aAClass[2] := (cAlias)->QTSEGUM
	EndIf
	(cAlias)->(dbCloseArea())
#ENDIF

RestArea(aArea)

Return(aAClass)

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ GetReserva ³ Autor ³    Will Carvalho    ³ Data ³ 15/10/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o total das reservas na SC9                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GetReserva(cFil,cProduto,cLocal,cLoteCTL,cNumLote)
Local aArea    := GetArea()
Local cAlias   := GetNextAlias()
Local aReserva := {0,0}
Local cQry     := ""
Local aTam1	   := TamSx3("C9_QTDLIB")
Local aTam2	   := TamSx3("C9_QTDLIB2")

#IFDEF TOP
	cQry := "SELECT SUM(C9_QTDLIB) QTDLIB, SUM(C9_QTDLIB2) QTDLIB2 FROM "+RetSqlName("SC9")
	cQry += " WHERE C9_FILIAL = '" + cFil + "'"
	cQry += " AND C9_PRODUTO = '" + cProduto + "'"
	cQry += " AND C9_LOCAL = '" + cLocal + "'"
	If !Empty(cLoteCTL)
		cQry += " AND C9_LOTECTL = '" + cLoteCTL + "'"
	EndIf
	If !Empty(cNumLote)
		cQry += " AND C9_NUMLOTE = '" + cNumLote + "'"
	EndIf
	cQry += " AND C9_NFISCAL = ''"
	cQry += " AND D_E_L_E_T_ = ' '"
	cQry := ChangeQuery(cQry)

	DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQry),cAlias,.T.,.T.)
	TCSetField(cAlias,"QTDLIB","N",aTam1[1],aTam1[2])
	TCSetField(cAlias,"QTDLIB2","N",aTam2[1],aTam2[2])

	If !(cAlias)->(Eof())
		aReserva[1] := (cAlias)->QTDLIB
		aReserva[2] := (cAlias)->QTDLIB2
	EndIf
	(cAlias)->(dbCloseArea())
#ENDIF

RestArea(aArea)

Return(aReserva)

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ SDASaldo ³ Autor ³    Will Carvalho      ³ Data ³ 29/10/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Recupera o saldo nao enderecado do movimento de CQ         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function SDASaldo(cProduto,cLocal,cNumSeq)
Local aArea    := GetArea()
Local cAlias   := GetNextAlias()
Local cQry     := ""
Local nSaldo   := 0

Default cNumSeq   := ""

If !Empty(cNumSeq)
	#IFDEF TOP
		cQry := "SELECT DA_SALDO FROM " + RetSqlName("SDA")
		cQry += " WHERE DA_FILIAL  = '" + xFilial("SDA") + "'"
		cQry +=   " AND DA_PRODUTO = '" + cProduto       + "'"
		cQry +=   " AND DA_LOCAL   = '" + cLocal         + "'"
		cQry +=   " AND DA_NUMSEQ  = '" + cNumSeq        + "'"
		cQry +=   " AND D_E_L_E_T_ = ' '"
		cQry +=   " AND DA_SALDO > 0 "
		DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQry),cAlias,.T.,.T.)
		If !(cAlias)->(Eof())
			nSaldo := DA_SALDO
		Else
			nSaldo := 0
		EndIf
		(cAlias)->(dbCloseArea())
	#ENDIF
EndIf
RestArea(aArea)
Return nSaldo

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ ConsCQ   ³ Autor ³    Marcos Simidu      ³ Data ³ 03/06/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Faz a consulta dos Lotes Rejeitados do CQ                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ConsCQ(cNumCq,cProd,cLocal)

Local aAreaAnt   := GetArea()
Local aAreaSB8   := SB8->(GetArea())
Local aAreaSB8a  := SB8->(GetArea())
Local aAreaSD7   := SD7->(GetArea())
Local nX         := 0
Local nQtd       := 0
Local cSeekSD7   := ''
Local cQtd       := ''
Local cValor     := ''
Local cPicD1Qtd  := PesqPictQt('D1_QUANT', 12)
Local cPicD1Val  := PesqPict('SD1', 'D1_VUNIT', 12)
Local lFoundSB8  := .F.
Local aF4        := {}
Local aArray     := {}

SD7->(dbSetOrder(1))

If SD7->(dbSeek(cSeekSD7 := xFilial('SD7')+cNumCQ+cProd+cLocal, .F.))
	Do While !SD7->(Eof()) .And. cSeekSD7 == SD7->D7_FILIAL+SD7->D7_NUMERO+SD7->D7_PRODUTO+SD7->D7_LOCAL
		If SD7->D7_ESTORNO#'S' .And. (SD7->D7_TIPO == 1 .Or. SD7->D7_TIPO == 2)

			If !Empty(SD7->D7_NUMLOTE)
				SB8->(dbSetOrder(2))
				lFoundSB8 := SB8->(dbSeek(xFilial('SB8')+SD7->D7_NUMLOTE+SD7->D7_LOTECTL+SD7->D7_PRODUTO+SD7->D7_LOCDEST,.F.))
			Else
				SB8->(dbSetOrder(3))
				lFoundSB8 := SB8->(dbSeek(xFilial('SB8')+SD7->D7_PRODUTO+SD7->D7_LOCDEST+SD7->D7_LOTECTL,.F.))
			EndIf

			If lFoundSB8
				nQtd := 0

				aAreaSB8a := SB8->(GetArea())
				aArray := SldPorLote(SB8->B8_PRODUTO, SB8->B8_LOCAL, SD7->D7_QTDE, SD7->D7_QTSEGUM,SB8->B8_LOTECTL,If(Rastro(cProd,"S"),SB8->B8_NUMLOTE,""),,,,.F.,,.F.)
				For nX := 1 to Len(aArray)
					nQtd += aArray[nX, 5]
				Next nX
				RestArea(aAreaSB8a)

				If nQtd > 0
					cQtd   := Transform(nQtd,cPicD1Qtd)
					cValor := Transform(SD1->D1_VUNIT,cPicD1Val)
					aAdd(aF4, {SD1->D1_DOC,SD1->D1_SERIE,SD1->D1_ITEM,DtoC(SD7->D7_DATA),cQtd,cValor,SB8->B8_LOCAL,SB8->B8_LOTECTL,If(Rastro(cProd,"S"),SB8->B8_NUMLOTE,""),,})
				EndIf
			EndIf

		Endif
		SD7->(dbSkip())
	EndDo
Endif

RestArea(aAreaSD7)
RestArea(aAreaSB8)
RestArea(aAreaAnt)

Return(aF4)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ VerDevol ³ Autor ³    Marcos Simidu      ³ Data ³ 03/06/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Faz a consulta dos Lotes Devolvidos do CQ                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function VerDevol(cLote)
Local aSavEst := { Alias(), IndexOrd(), Recno() }
Local nRet := 0, cSeek := ""

cSeek := xFilial()+SD1->D1_COD+SD1->D1_LOCAL
dbSelectArea("SD2")
dbSetOrder(1)
If dbSeek(cSeek)
	Do While !Eof() .And. cSeek == D2_FILIAL+D2_COD+D2_LOCAL
		If SF4->(dbSeek(xFilial("SF4")+SD2->D2_TES))
			If !(SF4->F4_ESTOQUE == "S")
				dbSelectArea("SD2")
				dbSkip()
				Loop
			Endif
		Endif
		If D2_TIPO # "D" .Or. D2_NUMLOTE # cLote
			dbSkip()
			Loop
		Endif
		nRet += D2_QUANT
		dbSkip()
	EndDo
Endif

dbSelectArea(aSavEst[1])
dbSetOrder(aSavEst[2])
MsGoto(aSavEst[3])
Return(nRet)

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ SeleOpc  ³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 12/09/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna a selecao de opcionais de acordo com os parametros ³±±
±±³          ³ recebidos.                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ SeleOpc(ExpN1)                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Expressao numerica usada para indicar o tipo de    ³±±
±±³          ³ entrada de dados (1) Enchoice (2) GetDados (3) GetDB       ³±±
±±³          ³ (4) Get Fixo                                               ³±±
±±³          ³ ExpC2 = Nome do Programa                                   ³±±
±±³          ³ ExpC3 = Codigo do Produto                                  ³±±
±±³          ³ ExpL4 = Verifica se Produto e uma referencia               ³±±
±±³          ³ ExpC5 = Retorno com a string de opcionais                  ³±±
±±³          ³ ExpC6 = Opcionais marcados                                 ³±±
±±³          ³ ExpC7 = Campo com o nome do produto pai                    ³±±
±±³          ³ ExpL8 = Visualiza janela de selecao de opcionais           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function SeleOpc(nTipo,cProg,cProd,lReferencia,cRet,cOpcMarc,cCampo,lVisual,nQtd,dDataVal,cRevisao,lPreEstr,mRet)
	Local lRet
	//Função migrada para PCPXFUN
	lRet := SeleOpcPcp(@nTipo,@cProg,@cProd,@lReferencia,@cRet,@cOpcMarc,@cCampo,@lVisual,@nQtd,@dDataVal,@cRevisao,@lPreEstr,@mRet)
Return lRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ MarkOpc  ³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 17/12/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao recursiva que permite a selecao de Opcionais .      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MarkOpc(ExpC1,ExpC2,ExpA1,ExpC3,ExpC4)                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Produto a ter os opcionais escolhidos.             ³±±
±±³          ³ ExpC2 = Retorno da string com os opcionais selecionados.   ³±±
±±³          ³ ExpA1 = Array com retorno de toda estrutura utilizada      ³±±
±±³          ³ ExpC3 = Produto pai da Estrutura                           ³±±
±±³          ³ ExpC4 = String com os produtos da estrutura                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MarkOpc(cProduto,cRet,aRetorOpc,cProdPai,cProdAnt,cProg,cOpcMarc,lVisual,nNivel,nQtd,dDataVal,cRevisao,lPreEstr)
	Local lOpca	:= .F.
	//Função migrada para PCPXFUN
	lOpca := MarkOpcPcp(@cProduto,@cRet,@aRetorOpc,@cProdPai,@cProdAnt,@cProg,@cOpcMarc,@lVisual,@nNivel,@nQtd,@dDataVal,@cRevisao,@lPreEstr)
Return lOpca

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o    ³ OpcTroca                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Autor     ³ Rodrigo de Almeida Sartorio              ³ Data ³ 12/09/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Troca marcador entre x e branco                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe    ³ Versao Windows-> OpcTroca(ExpN1,ExpA1)                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³ (Somente versao WINDOWS)                                   ³±±
±±³           ³ ExpN1 = Linha em que esta sendo efetuado o Double-Click    ³±±
±±³           ³ ExpA1 = Array utilizado na marcacao                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Uso      ³ Selecao de Opcionais                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function OpcTroca(nIt,aArray)
LOCAL aAcho:={}
Local lMultOpc	:= SuperGetMv("MV_MULTOPC",.F.,.F.)
Local nX := 0
// Muda caso seja ITEM
If aArray[nIt,2] == "1"
	If !aArray[nIt,8]
		Help( ,, 'Help',, "Componente vencido. Seleção não permitida.", 1, 0 )
	Else
		If aArray[nIt,1]
			//Desmarca o opcional selecionado
			aArray[nIt,1] := ! aArray[nIt,1]
		Else
			If !lMultOpc
				// Varre o array para verificar se marcou apenas um item por grupo
				aAcho:={ASCAN(aArray,{|x| x[4] == aArray[nIt,4] .And. x[1]})}
			Else
				aAcho:=OpcConc(aArray,aArray[nIt,4],SubStr(aArray[nIt,3],1,TamSX3("GA_OPC")[1]))
			EndIf

			// Desmarca Item
			For nX := 1 To Len(aAcho)
				If aAcho[nX] # 0
					aArray[aAcho[nX],1]:= .F.
				EndIf
			Next nX
			aArray[nIt,1]  := !aArray[nIt,1]
		EndIf
	EndIf
EndIf
Return aArray

//-------------------------------------------------------------------
/*/{Protheus.doc} OpcConc(aArray)
Rotina que informa opcionais concorrentes

@author alexandre.gimenez
@param aArray - Array de Opcionais
@param cGrupo - Grupo de Opcionais
@param cOpc- Opcional
@return aRet Array com posições do concorente no array de opcionais
@since 25/09/2013
@version 1.0
/*/
//------------------------------------------------------------------
Function OpcConc(aArray,cGrupo,cOpc)
Local aRet := {}
Local cAliasSql	:= GetNextAlias()
Local nAux := 0

BeginSQL Alias cAliasSql
SELECT
		SGT.GT_OPCCONC  AS GTCONC
	FROM
		%table:SGT% SGT
	WHERE
		SGT.GT_FILIAL = %xfilial:SGT%
		AND SGT.GT_GROPC = %exp:cGrupo%
		AND SGT.GT_OPC = %exp:cOpc%
		AND SGT.%NotDel%
EndSql

(cAliasSQL)->(dbEval({|| nAux := aScan(aArray,{|x| SubStr(x[3],1,TamSX3("GA_OPC")[1]) == GTCONC .And. x[2] == '1' .And. x[4] == cGrupo}) , If(!Empty(nAux),aAdd(aRet,nAux),NIL) }))

(cAliasSql)->(DbCloseArea())

Return aRet


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o    ³ OpcTudOk                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Autor     ³ Rodrigo de Almeida Sartorio              ³ Data ³ 12/09/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Verifica se esta tudo Ok na selecao dos opcionais          ³±±
±±³           ³ e monta string com os opcionais selecionados               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe    ³ OpcTudOk(ExpC1,ExpA1,ExpA2,ExpA3,ExpC2)                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³ ExpC1 = Codigo do produto                                  ³±±
±±³           ³ ExpA1 = Array utilizado na marcacao                        ³±±
±±³           ³ ExpA2 = Array com os grupo de Opcionais                    ³±±
±±³           ³ ExpA3 = Registros selecionados                             ³±±
±±³           ³ ExpC2 = String com os Opcionais selecionados               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Uso      ³ Selecao de Opcionais                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function OpcTudOk(cProduto,aArray,aGrupos,aRegs,cOpcionais,cProg,aOpcionAUX,cOpcMark)
	LOCAL lRet:=.T.
	//Função migrada para PCPXFUN
	lRet := OpcTdOkPcp(@cProduto,@aArray,@aGrupos,@aRegs,@cOpcionais,@cProg,@aOpcionAUX,@cOpcMark)
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡„o    ³ PrazoEstru                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Autor     ³ Rodrigo de Almeida Sartorio              ³ Data ³ 30/09/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Varre a estrutura do produto e calcula o prazo de entrega  ³±±
±±³           ³ somado de todos os seus niveis                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe    ³ ExpN1:=PrazoEstru(ExpC1,ExpN2)                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³ ExpC1 = String com o codigo do produto                     ³±±
±±³           ³ ExpN1 = Retorno do numero de dias do prazo de entrega      ³±±
±±³           ³ ExpN2 = Quantidade do Produto                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Uso      ³ Genercio Estoque/PCP                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function PrazoEstru(cProduto,nQuant,dDataEnt)
Local aAreaSB1	 := SB1->(GetArea())
Local aAreaSG1	 := SG1->(GetArea())
Local nTotPrazo  := 0  // Prazo de Entrega total do produto
Local nPrazoNiv  := 0  // Prazo de Entrega deste Nivel
Local cNivel     := "" // Nivel da Estrutura em que esta sendo feito o calculo
Local oTempTable := NIL

Private nEstru   := 0

Default dDataEnt := dDataBase

Estrut2(cProduto,nQuant,,@oTempTable)
ESTRUT->(dbGoTop())
While .T.
	If ESTRUT->(EOF()) .Or. cNivel # ESTRUT->NIVEL
		//-- Soma prazo do nivel anterior
		nTotPrazo += nPrazoNiv

		//-- Se fim da estrutura sai do laco
		If ESTRUT->(EOF())
			Exit
		EndIf

		//-- Atualiza variaveis de controle
		dDataEnt -= nPrazoNiv												//-- Data de entrega do nivel
		cNivel    := ESTRUT->NIVEL											//-- Nivel atual processado
		nPrazoNiv := CalcPrazo(ESTRUT->COMP,ESTRUT->QUANT,,,.F.,dDataEnt)	//-- Prazo mais longo do nivel
	Else
		nPrazoNiv := Max(nPrazoNiv,CalcPrazo(ESTRUT->COMP,ESTRUT->QUANT,,,.F.,dDataEnt))
	EndIf

	ESTRUT->(dbSkip())
End

oTempTable:Delete()

SG1->(RestArea(aAreaSG1))
SB1->(RestArea(aAreaSB1))

Return nTotPrazo


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ ConvUm   ³ Autor ³Marcelo Pimentel       ³  Data³06.01.98  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Converte a Unidade de Medida.                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpA1 := ConvUm(ExpC1,ExpN1,ExpN2,ExpC2)                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do Produto                                  ³±±
±±³          ³ ExpN1 = Quantidade 1a Unidade Medida                       ³±±
±±³          ³ ExpN2 = Quantidade 2a Unidade Medida                       ³±±
±±³          ³ ExpC2 = Unidade de Medida(1|2)                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³ Todos os Parametros Devem Ser Passados !!!                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ConvUm( cCod,nQtd1,nQtd2,nUnid )

Static nToler1UM
Static nToler2UM
Static lPConvUm

Local nBack := 0
Local aArea := NIL
Local aArea1:= {}
Local nValPe:=0
Local lAreaSB1 := .F.
Local lPosic   := .F.

nToler1UM := QtdComp(If(ValType(nToler1UM) == "N",nToler1UM,GetMV("MV_NTOL1UM")))
nToler2UM := QtdComp(If(ValType(nToler2UM) == "N",nToler2UM,GetMV("MV_NTOL2UM")))
lPConvUm  := If(Valtype(lPConvUm) # "L",ExistBlock("CONVUM"),lPConvUM)

If ((ValType(nQtd1) == "N") .And. ;
		(ValType(nQtd2) == "N") .And. ;
		(ValType(nUnid) == "N"))

	If Alias() != "SB1"
		aArea := { Alias(), IndexOrd(), Recno() }
	EndIf

	nBack := If( (nUnid == 1),nQtd1,nQtd2 )

	DbSelectArea("SB1")
	If (xFilial("SB1")+cCod == B1_FILIAL+B1_COD)
		lPosic   := .T.
	Else
		lAreaSB1 := .T.
		aArea1 := GetArea()
		DbSetOrder(1)
		lPosic   := MsSeek(xFilial("SB1")+cCod,.F.)
	EndIf

	If lPosic
		If (B1_CONV != 0)
			If ( SB1->B1_TIPCONV != "D" )
				If ( nUnid == 1 )
					nBack := (nQtd2 / B1_CONV)
					If nToler1UM > QtdComp(0) .And. ABS(QtdComp(nBack-nQtd1)) <= nToler1UM
						nBack:=nQtd1
					EndIf
				Else
					nBack := (nQtd1 * B1_CONV)
					If nToler2UM > QtdComp(0) .And. ABS(QtdComp(nBack-nQtd2)) <= nToler2UM
						nBack:=nQtd2
					EndIf
				EndIf
			Else
				If ( nUnid == 1 )
					nBack := (nQtd2 * B1_CONV)
					If nToler1UM > QtdComp(0) .And. ABS(QtdComp(nBack-nQtd1)) <= nToler1UM
						nBack:=nQtd1
					EndIf
				Else
					nBack := (nQtd1 / B1_CONV)
					If nToler2UM > QtdComp(0) .And. ABS(QtdComp(nBack-nQtd2)) <= nToler2UM
						nBack:=nQtd2
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
	// Ponto de Entrada para calcular qtd nas unidades de medida
	If lPConvUm
		nValPe:=ExecBlock("CONVUM",.F.,.F.,{nQtd1,nQtd2,nUnid,nBack})
		If ValType(nValPe) == "N"
			nBack:=nValPe
		EndIf
	EndIf
	If lAreaSB1
		RestArea(aArea1)
	EndIf
	If aArea != Nil .and. !Empty(aArea[1])
		DbSelectArea( aArea[1] )
		DbSetOrder( aArea[2] )
		If (RecNo() != aArea[3])
			MsGoto( aArea[3] )
		EndIf
	EndIf
EndIf
Return( nBack )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡„o    ³ SaldoLote                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Autor     ³ Rodrigo de Almeida Sartorio              ³ Data ³ 24/10/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Busca o saldo do lote somando pelo saldo dos sublotes      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe    ³ ExpN1:=SaldoLote(ExpC1,ExpC2,ExpC3)                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³ ExpC1 = String com o codigo do produto                     ³±±
±±³           ³ ExpC2 = String com o local a ser pesquisado                ³±±
±±³           ³ ExpC3 = String com o lote de Controle                      ³±±
±±³           ³ ExpC4 = String com o Numero do lote                        ³±±
±±³           ³ ExpL5 = Considera Empenho                                  ³±±
±±³           ³ ExpL6 = Considera Lotes Vencidos                           ³±±
±±³           ³ ExpL7 = Considera saldo a classificar                      ³±±
±±³           ³ ExpD1 = Indica a data de referencia do saldo               ³±±
±±³           ³ ExpC5 = Codigo da Ordem de Producao                        ³±±
±±³           ³ ExpC6 = Considera que existe saldo caso venda de um P.V.   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Uso      ³ Generico Rastreabilidade                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function SaldoLote(cProduto,cLocal,cLoteCTL,cNumLote,lBaixaEmp,lConsVenc,lConsClas,dDataRef,cOP,lSaldo,lEmpPrev)
Local cAlias	:= Alias()
Local nOrder	:= IndexOrd()
Local nRecno	:= Recno()
Local nRetorno	:= 0
Local cQuery    := ""
Local cAliasSB8 := "SB8"

Default lEmpPrev := If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)
Default cLoteCTL := ""
Default cNumLote := ""

If (Rastro(cProduto,"L") .Or. Empty(cLoteCTL+cNumLote))
	dbSelectArea("SB8")
	dbSetOrder(3)
		SB8->(dbCommit())
		cAliasSB8 := "SALDOLOTE"
		cQuery := "SELECT * FROM "+RetSqlName("SB8")+" SB8 WHERE SB8.B8_FILIAL ='"+xFilial("SB8")+"' AND "
		cQuery += "SB8.B8_PRODUTO ='"+cProduto+"' AND SB8.B8_LOCAL='"+cLocal+"' AND "
		If !Empty(cLoteCtl)
			cQuery += "SB8.B8_LOTECTL='"+cLoteCtl+"' AND "
		EndIf
		cQuery += "SB8.D_E_L_E_T_ =' ' ORDER BY "+SqlOrder(SB8->(IndexKey()))
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB8,.T.,.T.)
		aEval(SB8->(dbStruct()), {|x| If(x[2] <> "C", TcSetField(cAliasSB8,x[1],x[2],x[3],x[4]),Nil)})
	While (!Eof() .And. If(Empty(cQuery),(cAliasSB8)->B8_FILIAL == xFilial("SB8") .And.;
			(cAliasSB8)->B8_PRODUTO	== cProduto	.And. (cAliasSB8)->B8_LOCAL == cLocal,.T.))
		If Empty(cLoteCtl+cNumLote) .Or. (cAliasSB8)->B8_LOTECTL == cLoteCtl
				nRetorno+=SB8Saldo(lBaixaEmp,lConsVenc,lConsClas,NIL,cAliasSB8,lEmpPrev,NIL,dDataRef,lSaldo,cOP)
		EndIf
		dbSelectArea(cAliasSB8)
		dbSkip()
	EndDo
ElseIf ( Rastro(cProduto,"S" ) )
	dbSelectArea("SB8")
	dbSetOrder(2)
	If ( dbSeek(xFilial("SB8")+cNumLote+cLoteCtl+cProduto+cLocal) )
		nRetorno := SB8Saldo(lBaixaEmp,lConsVenc,lConsClas,NIL,NIL,lEmpPrev,NIL,dDataRef,,cOP)
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fecha query criada                                                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(cQuery)
	dbSelectArea(cAliasSB8)
	dbCloseArea()
EndIf
dbSelectArea(cAlias)
dbSetOrder(nOrder)
MsGoto(nRecno)
Return nRetorno

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡„o    ³ EmpLote                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Autor     ³ Rodrigo de Almeida Sartorio              ³ Data ³ 20/08/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Busca saldo empenhado do lote somando pelo saldo empenhado ³±±
±±³           ³ dos sub-lotes.                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe    ³ ExpN1:=EmpLote(ExpC1,ExpC2,ExpC3,ExpC4,ExpL5,ExpL6,ExpL7)  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³ ExpC1 = String com o codigo do produto                     ³±±
±±³           ³ ExpC2 = String com o local a ser pesquisado                ³±±
±±³           ³ ExpC3 = String com o lote de Controle                      ³±±
±±³           ³ ExpC4 = String com o Numero do lote                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Uso      ³ Generico Rastreabilidade                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function EmpLote(cProduto,cLocal,cLoteCTL,cNumLote)
Local aArea     := GetArea()
Local nRetorno	:= 0
Local lEmpPrev  := If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)

If ( Rastro(cProduto,"L") )
	dbSelectArea("SB8")
	dbSetOrder(3)
	If ( dbSeek(xFilial("SB8")+cProduto+cLocal+cLoteCtl) )
		While ( !Eof() .And. SB8->B8_FILIAL 	== xFilial("SB8") .And.;
				SB8->B8_PRODUTO	== cProduto			.And.;
				SB8->B8_LOCAL		== cLocal			.And.;
				SB8->B8_LOTECTL 	== cLoteCtl )
			nRetorno+=SB8SALDO(.T.,,,,,lEmpPrev,,,.T.)
			dbSelectArea("SB8")
			dbSkip()
		EndDo
	EndIf
EndIf
If ( Rastro(cProduto,"S" ) )
	dbSelectArea("SB8")
	dbSetOrder(2)
	If ( dbSeek(xFilial("SB8")+cNumLote+cLoteCtl+cProduto+cLocal) )
		nRetorno := SB8SALDO(.T.,,,,,lEmpPrev,,,.T.)
	EndIf
EndIf
RestArea(aArea)
Return nRetorno

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Localiza  ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 05/11/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Pesquisa no SB1 se produto corrente usa localizacao fisica  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Localiza(cProd)                                            ³±±
±±³          ³ cProd := C¢digo do produto a ser pesquisado no SB1.        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ EST/PCP/FAT/COM                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Localiza(cProd,lWMS,lWmsPai)
Local lRet      := .F.
Local aAreaAnt  := {}
Local aAreaSB1  := {}
Local aAreaSB5  := {}
Local lWmsNew   := .F.
Local cSeek
Local cFilialPrd  

static __lUsaLocal
Static __lTestLoc
Static __Localiza
Static __cFilset

Default lWMS      := .F.
Default lWmsPai   := .F.

If __lIntWMS == nil 
	__lIntWMS := IntWMS()
EndIF 

lWmsNew   := __lIntWMS .And. SuperGetMV("MV_WMSNEW",.F.,.F.)

If __lUsaLocal == nil .or. !__cFilset == cFilant 
	 __cFilset := cFilAnt
	__lUsaLocal := SuperGetMV("MV_LOCALIZ") == "S"
EndIf 

If __lUsaLocal
	aAreaAnt  := GetArea()

	__lTestLoc := IF(__lTestLoc == Nil, Existblock("TESTLOC"), __lTestLoc)

	//- se não existir uso do ponto de entrada usa o cache
	If !__lTestLoc 
		//- verifica a existência do objeto 
		If __Localiza == nil 
			__Localiza := JsonObject():New()
		EndIf 
		//- montagem da chave de pesquisa
		If !RetArqProd(cProd)
			cFilialPrd := xFilial("SBZ")
		Else
			cFilialPrd := xFilial("SB1")
		EndIf
		cSeek := cFilialPrd+cProd+cValToChar(lWMS)+cValToChar(lWmsPai)
		//- procura da chave
		lRet := __Localiza[cSeek]	
	EndIf 
	
	If lRet == nil .or. __lTestLoc
		lRet      := .F.

		If (SB1->(B1_FILIAL+B1_COD) == xFilial("SB1")+cProd)
			lRet := Iif(RetFldProd(cProd,"B1_LOCALIZ") == "S",.T.,.F.)
			If __lTestLoc
				lRet := Execblock("TESTLOC",.F.,.F.,{lRet})
			EndIf
		Else
			aAreaSB1 := SB1->(GetArea())
			SB1->(DbSetOrder(1))
			If SB1->(MsSeek(xFilial("SB1")+cProd,.F.))
				lRet := Iif(RetFldProd(cProd,"B1_LOCALIZ") == "S",.T.,.F.)
			EndIf
			If __lTestLoc
				lRet := Execblock("TESTLOC",.F.,.F.,{lRet})
			EndIf
			RestArea(aAreaSB1)
		EndIf

		If lRet .And. lWmsNew .And. SB5->(FieldPos("B5_CTRWMS")) > 0
			If (SB5->(B5_FILIAL+B5_COD) == xFilial("SB5")+cProd)
				If !lWMS .And. RetFldProd(cProd,"B5_CTRWMS") == "1"
					lRet  := .F.
				EndIf
			Else
				aAreaSB5 := SB5->(GetArea())

				SB5->(DbSetOrder(1))
				SB5->(MSSeek(xFilial("SB5")+cProd))
				If !lWMS .AND. RetFldProd(cProd,"B5_CTRWMS") == "1"
					lRet  := .F.
				EndIf
				RestArea(aAreaSB5)
			EndIf
		EndIf
		If !__lTestLoc
			__Localiza[cSeek]:= lRet
		EndIf
		RestArea(aAreaAnt)
	EndIf 
	If lRet .and. lWmsNew .And. lWmsPai
		lRet := MTVerPai(cProd,.F.)
	EndIf
EndIf

aSize(aAreaAnt,0)
aAreaAnt := nil 
aSize(aAreaSB1,0)
aAreaSB1 := nil
aSize(aAreaSB5,0)
aAreaSB5 := nil

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ CriaSDA  ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 05/11/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Cria registro de saldo a classificar (SDA)                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CriaSDA(cAlias,nQuant,lExclui,lEmpenho)                    ³±±
±±³          ³ cAlias  := Alias do arquivo que esta criando o registro.   ³±±
±±³          ³ nQuant  := Quantidade do registro de saldo a classificar.  ³±±
±±³          ³ lExclui := Indica se exclui registro no SDA.               ³±±
±±³          ³ lEmpenho:= Indica se gravara empenho ao fazer a distribuic.³±±
±±³          ³ nQuant2 := Quantidade do registro de saldo a classificar   ³±±
±±³          ³            na segunda Unidade de Medida                    ³±±
±±³          ³ lApropri:= Indica se Utiliza Apropriacao Indireta.         ³±±
±±³          ³ lCriaNew:= Indica se criou novo sub-lote.                  ³±±
±±³          ³ cNovoSLote:= Numero do Sub-Lote com saldo a enderecar      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ EST/PCP/FAT/COM                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CriaSDA(cAlias,nQuant,lExclui,lEmpenho,nQuant2,lApropri,lCriaNew,cNovoSLote,cLoteDef,cNumLoteDef)
Local cOldAlias :=Alias()
Local aAreaSBE  := SBE->(GetArea())
Local aAreaSAN  := {}
Local cSeek     := ""
Local cCompara  := ""
Local cLocaliz  := ""
Local nEmpenho  := 0,nEmpenh2:=0,nBaixaEmp:=0,nBaixaEmp2
Local nOrdSB8   := 0,nRecSB8:=0
Local nX        := 0
Local nForTimes := 0
Local nTamContX6:= 0
Local nTamCPOs  := 0
Local nTamNumSer:= 0
Local nTamLocFis:= 0
Local nTamLocal := 0
Local nPos      := 0
Local cLocProc  := GetMvNNR('MV_LOCPROC','99')
Local cDistaut  := SuperGetMV('MV_DISTAUT',.F.,'')
Local cLocCQ    := GetMvNNR('MV_CQ','98')
Local lSelLote  := (SuperGetMV("MV_SELLOTE") == "1")
Local lFoundSDA := .F.
Local lEmpPrev  := If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)
Local aDistAu   := {}
//-- Variaveis utilizadas pela funcao wmsexedcf
Local cProduto	:= ''
Local cServic	:= ''
Local nPosDCF	:= 0
Local aLibDCF  	:= WmsLibDCF() // Busca referencia do array WMS
Local cEventID  := 0   // Variavel usada para armazenar o ID do EventViewer
Local cMensagem := " " // Variavel para armazenar a mensagem utilizada no eventviewer

DEFAULT lCriaNew:= .F.
DEFAULT cNovosLote:=CriaVar("B8_NUMLOTE",.F.)
DEFAULT cLotedef:=""
DEFAULT cNumLoteDef:=""

cLocaliz   := If(cLocaliz==Nil,CriaVar('DB_LOCALIZ'),cLocaliz)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Preenche parametros nao recebidos pela funcao         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lExclui    :=If(lExclui == NIL,.F.,lExclui)
lEmpenho   :=If(lEmpenho == NIL,.F.,lEmpenho)
lApropri   :=If(lApropri==Nil,.F.,lApropri)
lIntegracao:=If(!Type('lIntegracao')=='L',(GetMV('MV_EASY')=='S'),lIntegracao)

dbSelectArea("SDA")
dbSetOrder(1)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Cria registro quando inclui Saldo Inicial             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cAlias == "SB9"
	nQuant:=IF(nQuant == NIL,SB9->B9_QINI,nQuant)
	If !lExclui
		RecLock("SDA",.T.)
		Replace DA_FILIAL    With xFilial()
		Replace DA_PRODUTO   With SB9->B9_COD
		Replace DA_LOCAL     With SB9->B9_LOCAL
		Replace DA_ORIGEM    With cAlias
		Replace DA_DATA      With dDataBase
		Replace DA_NUMSEQ    With ProxNum()
		Replace DA_QTDORI    With DA_QTDORI + nQuant
		Replace DA_SALDO     With DA_SALDO + nQuant
		nQuant2:=IF(nQuant2 == NIL,ConvUm(SDA->DA_PRODUTO,nQuant,SB9->B9_QISEGUM,2),nQuant2)
		Replace DA_QTDORI2 With DA_QTDORI2 + nQuant2
		Replace DA_QTSEGUM With DA_QTSEGUM + nQuant2
		If lEmpenho
			Replace DA_EMPENHO   With DA_EMPENHO + nQuant
			Replace DA_EMP2      With DA_EMP2    + nQuant2
		EndIf
	Else
		RecLock("SDA",.F.)
		dbDelete()
	EndIf
	MsUnlock()
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Cria registro quando inclui NF de entrada             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ElseIf cAlias == "SD1"
	nQuant:=IF(nQuant == NIL, SD1->D1_QUANT,nQuant)
	cSeek:=xFilial()+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_NUMSEQ+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA
	cProduto:=SD1->D1_COD
	If IntWMS(cProduto)
		cServic := SD1->D1_SERVIC
	EndIf
	If !dbSeek(cSeek) .And. !lExclui
		RecLock("SDA",.T.)
		Replace DA_FILIAL    With xFilial()
		Replace DA_PRODUTO   With SD1->D1_COD
		Replace DA_LOCAL     With SD1->D1_LOCAL
		Replace DA_DOC       With SD1->D1_DOC
		Replace DA_SERIE     With SD1->D1_SERIE
		Replace DA_CLIFOR    With SD1->D1_FORNECE
		Replace DA_LOJA      With SD1->D1_LOJA
		Replace DA_TIPONF    With SD1->D1_TIPO
		Replace DA_ORIGEM    With cAlias
		Replace DA_DATA      With SD1->D1_DTDIGIT
		If Rastro(DA_PRODUTO)
			cLotedef:=If(Empty(SD1->D1_LOTECTL),cLoteDef,SD1->D1_LOTECTL)
			Replace DA_LOTECTL   With cLoteDef
		EndIf
		If Rastro(DA_PRODUTO,"S")
			cNumLoteDef:=If(Empty(SD1->D1_NUMLOTE),cNumLoteDef,SD1->D1_NUMLOTE)
			Replace DA_NUMLOTE   With cNumLoteDef
		EndIf
		Replace DA_NUMSEQ    With SD1->D1_NUMSEQ
		Replace DA_QTDORI    With DA_QTDORI + nQuant
		Replace DA_SALDO     With DA_SALDO + nQuant
		nQuant2:=IF(nQuant2 == NIL,ConvUm(SDA->DA_PRODUTO,nQuant,SD1->D1_QTSEGUM,2),nQuant2)
		Replace DA_QTDORI2 With DA_QTDORI2 + nQuant2
		Replace DA_QTSEGUM With DA_QTSEGUM + nQuant2
		If lEmpenho
			Replace DA_EMPENHO   With DA_EMPENHO + nQuant
			Replace DA_EMP2      With DA_EMP2    + nQuant2
		EndIf
		If cPaisLoc $ "ARG" .And. (Alltrim(FunName()) $ "MATA102N|MATA101N")
			Replace DA_NUMSERI With SD1->D1_NUMSERI
		EndIf
		MsUnlock()
	ElseIf Found()
		RecLock("SDA",.F.)
		If lExclui
			dbDelete()
		Else
			Replace DA_QTDORI    With DA_QTDORI + nQuant
			Replace DA_SALDO     With DA_SALDO + nQuant
			nQuant2:=IF(nQuant2 == NIL,ConvUm(SDA->DA_PRODUTO,nQuant,SD1->D1_QTSEGUM,2),nQuant2)
			Replace DA_QTDORI2 With DA_QTDORI2 + nQuant2
			Replace DA_QTSEGUM With DA_QTSEGUM + nQuant2
			If lEmpenho
				Replace DA_EMPENHO   With DA_EMPENHO + nQuant
				Replace DA_EMP2      With DA_EMP2    + nQuant2
			EndIf
		EndIf
		MsUnlock()
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Cria registro quando exclui NF de Venda               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ElseIf cAlias == "SD2"
	nQuant:=IF(nQuant == NIL, SDB->DB_QUANT,nQuant)
	cSeek:=xFilial()+SD2->D2_COD+SD2->D2_LOCAL+SD2->D2_NUMSEQ+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA
	If !dbSeek(cSeek) .And. !lExclui
		RecLock("SDA",.T.)
		Replace DA_FILIAL    With xFilial()
		Replace DA_PRODUTO   With SD2->D2_COD
		Replace DA_LOCAL     With SD2->D2_LOCAL
		Replace DA_DOC       With SD2->D2_DOC
		Replace DA_SERIE     With SD2->D2_SERIE
		Replace DA_CLIFOR    With SD2->D2_CLIENTE
		Replace DA_LOJA      With SD2->D2_LOJA
		Replace DA_TIPONF    With SD2->D2_TIPO
		Replace DA_ORIGEM    With cAlias
		Replace DA_DATA      With SD2->D2_EMISSAO
		If Rastro(DA_PRODUTO)
			cLotedef:=If(Empty(SD2->D2_LOTECTL),cLoteDef,SD2->D2_LOTECTL)
			Replace DA_LOTECTL   With cLoteDef
		EndIf
		If Rastro(DA_PRODUTO,"S")
			cNumLoteDef:=If(Empty(SD2->D2_NUMLOTE),cNumLoteDef,SD2->D2_NUMLOTE)
			Replace DA_NUMLOTE   With cNumLoteDef
		EndIf
		Replace DA_NUMSEQ    With SD2->D2_NUMSEQ
		Replace DA_QTDORI    With DA_QTDORI + nQuant
		Replace DA_SALDO     With DA_SALDO + nQuant
		nQuant2:=IF(nQuant2 == NIL,ConvUm(SDA->DA_PRODUTO,nQuant,SDB->DB_QTSEGUM,2),nQuant2)
		Replace DA_QTDORI2   With DA_QTDORI2 + nQuant2
		Replace DA_QTSEGUM   With DA_QTSEGUM + nQuant2
		If lEmpenho
			Replace DA_EMPENHO   With DA_EMPENHO + nQuant
			Replace DA_EMP2      With DA_EMP2    + nQuant2
		EndIf
		MsUnlock()
	ElseIf Found()
		RecLock("SDA",.F.)
		If lExclui
			dbDelete()
		Else
			Replace DA_QTDORI    With DA_QTDORI + nQuant
			Replace DA_SALDO     With DA_SALDO + nQuant
			nQuant2:=IF(nQuant2 == NIL,ConvUm(SDA->DA_PRODUTO,nQuant,SDB->DB_QTSEGUM,2),nQuant2)
			Replace DA_QTDORI2 With DA_QTDORI2 + nQuant2
			Replace DA_QTSEGUM With DA_QTSEGUM + nQuant2
			If lEmpenho
				Replace DA_EMPENHO   With DA_EMPENHO + nQuant
				Replace DA_EMP2      With DA_EMP2    + nQuant2
			EndIf
		EndIf
		MsUnlock()
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Cria registro quando inclui mov. internos             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ElseIf cAlias == "SD3"
	nQuant:=IF(nQuant == NIL, SD3->D3_QUANT,nQuant)
	cSeek:=xFilial()+SD3->D3_COD+If(lApropri,cLocProc,SD3->D3_LOCAL)+SD3->D3_NUMSEQ+SD3->D3_DOC
	lFoundSDA := .F.
	If (Rastro(SD3->D3_COD) .And. Empty(SD3->D3_LOTECTL+SD3->D3_NUMLOTE)) .Or. (lIntegracao .And. SD3->D3_CF=='DE8' .And. SF1->F1_IMPORT=='S')
		If (lFoundSDA:=dbSeek(cSeek, .F.)) .And. Rastro(SD3->D3_COD)
			lFoundSDA := .F.
			Do While !SDA->(Eof()) .And. AllTrim(cSeek)==AllTrim(SDA->DA_FILIAL+SDA->DA_PRODUTO+SDA->DA_LOCAL+SDA->DA_NUMSEQ+SDA->DA_DOC+SDA->DA_SERIE+SDA->DA_CLIFOR+SDA->DA_LOJA)
				If If(Empty(SD3->D3_LOTECTL),cLoteDef,SD3->D3_LOTECTL)+If(Empty(SD3->D3_NUMLOTE),cNumLoteDef,SD3->D3_NUMLOTE)==SDA->DA_LOTECTL+SDA->DA_NUMLOTE
					lFoundSDA := .T.
					Exit
				EndIf
				SDA->(dbSkip())
			EndDo
		EndIf
	Else
		lFoundSDA := dbSeek(cSeek) .And. SDA->(DA_LOTECTL+DA_NUMLOTE) == SD3->(D3_LOTECTL+D3_NUMLOTE)

		//-- Tratamento para Estornos das Movimentacoes de CQ
		If !lFoundSDA .And. !Empty(SD3->D3_ESTORNO) .And. (alltrim(SD3->D3_LOCAL)==alltrim(cLocCQ)) .And. (SD3->D3_TM<='500')
			lFoundSDA := SDACQOrig(nQuant)
		EndIf
	EndIf
	cProduto:=SD3->D3_COD
	If IntWMS(cProduto)
		cServic := SD3->D3_SERVIC
	EndIf
	If !lFoundSDA .And. !lExclui
		RecLock("SDA",.T.)
		Replace DA_FILIAL    With xFilial()
		Replace DA_PRODUTO   With SD3->D3_COD
		Replace DA_LOCAL     With If(lApropri,cLocProc,SD3->D3_LOCAL)
		Replace DA_DOC       With SD3->D3_DOC
		Replace DA_ORIGEM    With cAlias
		Replace DA_DATA      With SD3->D3_EMISSAO
		If Rastro(DA_PRODUTO)
			cLotedef:=If(Empty(SD3->D3_LOTECTL),cLoteDef,SD3->D3_LOTECTL)
			Replace DA_LOTECTL   With cLoteDef
		EndIf
		If Rastro(DA_PRODUTO,"S")
			cNumLoteDef:=If(Empty(SD3->D3_NUMLOTE),cNumLoteDef,SD3->D3_NUMLOTE)
			Replace DA_NUMLOTE   With cNumLoteDef
		EndIf
		Replace DA_NUMSEQ    With SD3->D3_NUMSEQ
		Replace DA_QTDORI    With DA_QTDORI + nQuant
		Replace DA_SALDO     With DA_SALDO + nQuant
		nQuant2:=IF(nQuant2 == NIL,ConvUm(SDA->DA_PRODUTO,nQuant,SD3->D3_QTSEGUM,2),nQuant2)
		Replace DA_QTDORI2 With DA_QTDORI2 + nQuant2
		Replace DA_QTSEGUM With DA_QTSEGUM + nQuant2
		If lEmpenho
			Replace DA_EMPENHO   With DA_EMPENHO + nQuant
			Replace DA_EMP2      With DA_EMP2    + nQuant2
		EndIf
		MsUnlock()
	ElseIf lFoundSDA
		RecLock("SDA",.F.)
		If lExclui
			// ********* ATENCAO: ************
			// Verifica se ha registro na tabela SDB, somente para caso de estorno de devolucao para produtos
			// com apropriacao indireta. Se esse registro nao for deletado, afetara o saldo a classificar na
			// tabela SB8 e o calculo de saldo em estoque. Este problema ocorre com produtos com controle de
			// lote, enderecamento e apropriacao indireta.

			SDB->(DbSetOrder(1)) // Indice 1 - DB_FILIAL+DB_PRODUTO+DB_LOCAL+DB_NUMSEQ+DB_DOC+DB_SERIE+DB_CLIFOR+DB_LOJA+DB_ITEM

			If SDB->(DbSeek(xFilial('SDB')+SDA->DA_PRODUTO+cLocProc+SDA->DA_NUMSEQ+SDA->DA_DOC+SDA->DA_SERIE+SDA->DA_CLIFOR+SDA->DA_LOJA))

				// Somente atualiza a quantidade a classificar se for nao for informado endereco na devolucao de produto com apropriacao indireta.
				If Empty(SD3->D3_LOCALIZ)

					SB8->(DbSetOrder(3)) // Indice 3 - B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL+B8_NUMLOTE+DTOS(B8_DTVALID)
					If SB8->(DbSeek(xFilial('SB8')+SDB->DB_PRODUTO+SDB->DB_LOCAL+SDB->DB_LOTECTL+SDB->DB_NUMLOTE))

						// Ajuste na quantidade a classificar, uma vez que houve um estorno de devolucao no armazem de processo.
						// Armazem 99.
						RecLock('SB8', .F.)

							SB8->B8_QACLASS := SB8->B8_QACLASS + (SDB->DB_QUANT * -1)
							SB8->B8_QACLAS2 := SB8->B8_QACLAS2 + (ConvUM(SDB->DB_PRODUTO, SDB->DB_QUANT, 0 , 2) * -1)

						SB8->(MsUnlock())

					EndIf

				Else
					If SDB->DB_LOCAL == cLocProc

						// Armazem original.
						SB8->(DbSetOrder(3)) // Indice 3 - B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL+B8_NUMLOTE+DTOS(B8_DTVALID)
						If SB8->(DbSeek(xFilial('SB8')+SDB->DB_PRODUTO+SDA->DA_LOCAL+SDB->DB_LOTECTL+SDB->DB_NUMLOTE))

							// Ajuste na quantidade a classificar, uma vez que houve um estorno de devolucao no armazem de processo.
							RecLock('SB8', .F.)

								SB8->B8_QACLASS := SB8->B8_QACLASS + (SDB->DB_QUANT * -1)
								SB8->B8_QACLAS2 := SB8->B8_QACLAS2 + (ConvUM(SDB->DB_PRODUTO, SDB->DB_QUANT, 0 , 2) * -1)

							SB8->(MsUnlock())

						EndIf

					EndIf

				EndIf

				SBE->(DbSetOrder(1)) // Indice 1 - BE_FILIAL+BE_LOCAL+BE_LOCALIZ
				If SBE->(DbSeek(xFilial('SBE')+SDB->DB_LOCAL+SDB->DB_LOCALIZ))

					cEstFis := SBE->BE_ESTFIS


				EndIf

				// Estorna o saldo na tabela de Saldos por Endereco. Nao foi possivel utilizar a funcao GRAVASBF().
				SBF->(DbSetOrder(6)) // Indice 6 - BF_FILIAL+BF_LOCAL+BF_LOCALIZ+BF_ESTFIS+BF_PRODUTO+BF_NUMSERI+BF_LOTECTL+BF_NUMLOTE
				If SBF->(DbSeek(xFilial('SBF')+SDB->DB_LOCAL+SDB->DB_LOCALIZ+cEstFis+SDB->DB_PRODUTO+SDB->DB_NUMSERI+SDB->DB_LOTECTL+SDB->DB_NUMLOTE))

					RecLock("SBF",.F.)

						SBF->BF_QUANT := SBF->BF_QUANT + SDB->DB_QUANT

					SBF->(MsUnlock())

				EndIf

				// Delecao do registro de requisicao do armazem de processo, isto faz com que a rotina Refaz Saldo calcule corretamente o saldo por
				// enderecamento, tabela SBF.
				RecLock('SDB', .F.)

					SDB->(DbDelete())

				SDB->(MsUnlock())

			EndIf

			nQuant := SDA->DA_SALDO

			SDA->(DbDelete())
		Else
			Replace DA_QTDORI    With DA_QTDORI + nQuant
			Replace DA_SALDO     With DA_SALDO + nQuant
			nQuant2:=IF(nQuant2 == NIL,ConvUm(SDA->DA_PRODUTO,nQuant,SD3->D3_QTSEGUM,2),nQuant2)
			Replace DA_QTDORI2 With DA_QTDORI2 + nQuant2
			Replace DA_QTSEGUM With DA_QTSEGUM + nQuant2
			If lEmpenho
				Replace DA_EMPENHO   With DA_EMPENHO + nQuant
				Replace DA_EMP2      With DA_EMP2    + nQuant2
			EndIf
		EndIf
		MsUnlock()
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Cria registro quando inclui manut. lotes              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ElseIf cAlias == "SD5"
	nQuant:=IF(nQuant == NIL, SD5->D5_QUANT,nQuant)
	cSeek:=xFilial()+SD5->D5_PRODUTO+SD5->D5_LOCAL+SD5->D5_NUMSEQ+SD5->D5_DOC+SD5->D5_SERIE
	If !dbSeek(cSeek) .And. !lExclui
		RecLock("SDA",.T.)
		Replace DA_FILIAL    With xFilial()
		Replace DA_PRODUTO   With SD5->D5_PRODUTO
		Replace DA_LOCAL     With SD5->D5_LOCAL
		Replace DA_DOC       With SD5->D5_DOC
		Replace DA_SERIE     With SD5->D5_SERIE
		Replace DA_ORIGEM    With cAlias
		Replace DA_DATA      With SD5->D5_DATA
		Replace DA_LOTECTL   With SD5->D5_LOTECTL
		If Rastro(DA_PRODUTO,"S")
			Replace DA_NUMLOTE   With SD5->D5_NUMLOTE
		EndIf
		Replace DA_NUMSEQ    With SD5->D5_NUMSEQ
		Replace DA_QTDORI    With DA_QTDORI + nQuant
		Replace DA_SALDO     With DA_SALDO + nQuant
		nQuant2:=IF(nQuant2 == NIL,ConvUm(SDA->DA_PRODUTO,nQuant,SD5->D5_QTSEGUM,2),nQuant2)
		Replace DA_QTDORI2 With DA_QTDORI2 + nQuant2
		Replace DA_QTSEGUM With DA_QTSEGUM + nQuant2
		If lEmpenho
			Replace DA_EMPENHO   With DA_EMPENHO + nQuant
			Replace DA_EMP2      With DA_EMP2    + nQuant2
		EndIf
		MsUnlock()
	ElseIf Found()
		RecLock("SDA",.F.)
		If lExclui
			dbDelete()
		Else
			Replace DA_QTDORI    With DA_QTDORI + nQuant
			Replace DA_SALDO     With DA_SALDO + nQuant
			nQuant2:=IF(nQuant2 == NIL,ConvUm(SDA->DA_PRODUTO,nQuant,SD5->D5_QTSEGUM,2),nQuant2)
			Replace DA_QTDORI2 With DA_QTDORI2 + nQuant2
			Replace DA_QTSEGUM With DA_QTSEGUM + nQuant2
			If lEmpenho
				Replace DA_EMPENHO   With DA_EMPENHO + nQuant
				Replace DA_EMP2      With DA_EMP2    + nQuant2
			EndIf
		EndIf
		MsUnlock()
	EndIf
EndIf

If ExistBlock("MTGRVSDA")
	ExecBlock("MTGRVSDA",.F.,.F.,{cAlias})
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Caso seja uma inclusao envia e-mail com dados da      ³
//³ distribuicao                                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lExclui
	SB1->(dbSetOrder(1))
	SB1->(dbSeek(xFilial("SB1")+SDA->DA_PRODUTO))
	lRet:=Empty(cDistaut)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Encontra a LOCALIZA€AO de acordo com o LOCAL parametrizado      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(cDistaut)
    	aAreaSAN:= SAN->(GetArea())
		SAN->(dbSetOrder(3))
		If SAN->(MsSeek(xFilial('SAN')+'007',.F.))
			//-- Calcula o Tamanho dos Segmentos contendo Local/Localiza‡Æo/N.S‚rie,
			//-- e o numero de ocorrˆncias destes segmentos cadastrados no SX6.
			nTamLocal  := TamSX3('DB_LOCAL')[1]
			nTamLocFis := TamSX3('DB_LOCALIZ')[1]
			nTamNumSer := TamSX3('DB_NUMSERI')[1]
			nTamCPOs   := (nTamLocal+nTamLocFis+nTamNumSer)
			nTamContX6 := Len(SX6->X6_CONTEUD)
			nForTimes  := Max(Int(nTamContX6/nTamCPOs)*nTamCPOs,1)

			//-- Formato do Array aDistAut:
			//-- [n, 1] = Local
			//-- [n, 2] = Localiza‡Æo Fisica
			//-- [n, 3] = Numero de S‚rie
			For nX := 1 to nForTimes Step nTamCPOs
				AAdd(aDistAu, {})
				AAdd(aDistAu[Len(aDistAu)], SubStr(cDistAut, nX, nTamLocal))
				AAdd(aDistAu[Len(aDistAu)], SubStr(cDistAut, nX+nTamLocal, nTamLocFis))
				AAdd(aDistAu[Len(aDistAu)], SubStr(cDistAut, nX+nTamLocal+nTamLocFis, nTamNumSer ))
			Next nX

			//-- Encontra a LOCALIZA€AO de acordo com o LOCAL parƒmetrizado
			If (nPos:=aScan(aDistAu, {|x| x[1] == SDA->DA_LOCAL}))>0
				cLocaliz  := If(Empty(cLocaliz) ,aDistAu[nPos, 2],cLocaliz)
			Else
				cLocaliz  := SPACE(TamSX3('DB_LOCAL')[1])
			EndIf

	        SBE->(dbSetorder(1))
			If !SBE->(dbSeek(xFilial('SBE')+SDA->DA_LOCAL+cLocaliz, .F.))
				lRet := .T.
			EndIf
		EndIf
		SAN->(RestArea(aAreaSAN))
	Else
  		lRet := .T.
	EndIf

	If lRet
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Messenger						  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		MEnviaMail("007",{SDA->DA_PRODUTO,SB1->B1_DESC,SDA->DA_DOC,SDA->DA_SERIE,SDA->DA_LOCAL})

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ EventViewer						  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cEventID  := "007"
		cMensagem := OemToAnsi(STR0022)+SDA->DA_PRODUTO+" - "+SB1->B1_DESC+OemToAnsi(STR0267)	//"O produto "###" aguarda distribuicao do documento/serie "
		cMensagem += SDA->DA_DOC+"/"+SDA->DA_SERIE+OemToAnsi(STR0259)+SDA->DA_LOCAL+")" 		//" (armazém ##) "
		EventInsert(FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID, FW_EV_LEVEL_INFO, "", STR0268, cMensagem, .T. )
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Caso use rastreabilidade, GRAVA a quantidade do SDA   ³
//³ no SB8 para que o Saldo por Sub-Lote fique bloqueado  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Rastro(SDA->DA_PRODUTO) .And. !lExclui
	dbSelectArea("SB8")
	nOrdSB8:=IndexOrd()
	nRecSB8:=Recno()
	dbSetOrder(3)
	If Rastro(SDA->DA_PRODUTO,"S")
		cSeek:=xFilial()+SDA->DA_PRODUTO+SDA->DA_LOCAL+SDA->DA_LOTECTL+SDA->DA_NUMLOTE
		cCompara:="B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL+B8_NUMLOTE"
	ElseIf lCriaNew .And. !Empty(cNovoSLote) .And. !lSelLote
		cSeek:=xFilial()+SDA->DA_PRODUTO+SDA->DA_LOCAL+SDA->DA_LOTECTL+cNovoSLote
		cCompara:="B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL+B8_NUMLOTE"
	Else
		cSeek:=xFilial()+SDA->DA_PRODUTO+SDA->DA_LOCAL+SDA->DA_LOTECTL
		cCompara:="B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL"
	EndIf

	dbSeek(cSeek)
	nEmpenho:=nQuant
	nEmpenh2:=nQuant2
	Do While !Eof() .And. QtdComp(nEmpenho,.t.) > QtdComp(0) .And. cSeek == &(cCompara)
		If B8_DOC+B8_SERIE+B8_CLIFOR+B8_LOJA == SDA->DA_DOC+SDA->DA_SERIE+SDA->DA_CLIFOR+SDA->DA_LOJA
			nBaixaEmp :=Min(nEmpenho,SB8Saldo(lEmpenho,,,,,lEmpPrev))
			nBaixaEmp2:=Min(nEmpenh2,SB8Saldo(lEmpenho,NIL,NIL,.T.,,lEmpPrev))
			RecLock("SB8",.F.)
			Replace B8_QACLASS With B8_QACLASS + nBaixaEmp
			Replace B8_QACLAS2 With B8_QACLAS2 + ConvUM(B8_PRODUTO,nBaixaEmp,nBaixaEmp2,2)
			nEmpenho -= nBaixaEmp
			MsUnlock()
		EndIf
		dbSkip()
	EndDo
	dbSeek(cSeek)
	Do While !Eof() .And. QtdComp(nEmpenho,.t.) > QtdComp(0) .And. cSeek == &(cCompara)
		nBaixaEmp :=Min(nEmpenho,SB8Saldo(lEmpenho,,,,,lEmpPrev))
		nBaixaEmp2:=Min(nEmpenh2,SB8Saldo(lEmpenho,NIL,NIL,.T.,,lEmpPrev))
		RecLock("SB8",.F.)
		Replace B8_QACLASS With B8_QACLASS + nBaixaEmp
		Replace B8_QACLAS2 With B8_QACLAS2 + ConvUM(B8_PRODUTO,nBaixaEmp,nBaixaEmp2,2)
		nEmpenho -= nBaixaEmp
		MsUnlock()
		dbSkip()
	EndDo
	dbSetOrder(nOrdSB8)
	dbGoto(nRecSB8)
EndIf
dbSelectArea("SB2")
If dbSeek(xFilial()+SDA->DA_PRODUTO+SDA->DA_LOCAL)
	Reclock("SB2",.F.)
	Replace B2_QACLASS With B2_QACLASS + If(lExclui,-nQuant,nQuant)
EndIf

// Caso seja uma inclusão e possua integração com o WMS
If !lExclui .And. IntWMS(cProduto) .And. (!(SDA->DA_ORIGEM == 'SD1') .Or. Empty(SD1->D1_OP))
	// Cria a ordem de serviço WMS
	CriaDCF('SDA',,,,,@nPosDCF)
	// Se for um serviço de execução automática, adiciona no array de OS geradas
	If !Empty(cServic) .And. !Empty(nPosDCF) .And. WmsVldSrv('4',cServic)
		AAdd(aLibDCF,nPosDCF)
	EndIf
EndIf

RestArea(aAreaSBE)
dbSelectArea(cOldAlias)
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ CriaSDB  ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 05/11/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Cria registro de movimentacao por Localizacao (SDB)        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CriaSDB(cProduto,cLocal,nQuant,cLocaliza,cDoc,cSerie,      ³±±
±±³          ³ cCliFor,cLoja,cTipoNf,cOrigem,dData,cLoteCtl,cNumLote,     ³±±
±±³          ³ cNumSeq,cTm,cTipo,cItem,lEstorno,nQtdEmp,nQuant2UM,cEstFis,³±±
±±³          ³ cServico,cTarefa,cAtividade,cAnomalia,cEstDest,cEndDest,   ³±±
±±³          ³ cHrInicio,cAtuEst,cCarga,cUnitiza,cOrdTar,cOrdAti,cRHumano,³±±
±±³          ³ cRFisico)                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cProduto     - Codigo do Produto                           ³±±
±±³          ³ cLocal       - Almoxarifado                                ³±±
±±³          ³ nQuant       - Quantidade                                  ³±±
±±³          ³ cLocaliza    - Localizacao                                 ³±±
±±³          ³ cDoc         - Documento                                   ³±±
±±³          ³ cSerie       - Serie do Documento                          ³±±
±±³          ³ cClifor      - Cliente / Fornecedor                        ³±±
±±³          ³ cLoja        - Loja do Cliente / Fornecedor                ³±±
±±³          ³ cTipoNF      - Tipo da NF                                  ³±±
±±³          ³ cOrigem      - Origem do Movimento                         ³±±
±±³          ³ dData        - Data                                        ³±±
±±³          ³ cLoteCtl     - Lote                                        ³±±
±±³          ³ cNumLote     - Sub-Lote                                    ³±±
±±³          ³ cNumSeq      - Numero Sequencial                           ³±±
±±³          ³ cTm          - Tipo do Movimento                           ³±±
±±³          ³ cTipo        - Tipo do Movimento (Distribuicao/Movimento)  ³±±
±±³          ³ cItem        - Item                                        ³±±
±±³          ³ lEstorno     - Flag que indica se e' mov. estorno          ³±±
±±³          ³ nQtdEmp      - Quantidade a ser empenhada                  ³±±
±±³          ³ nQuant2UM    - Quantidade na segunda UM                    ³±±
±±³          ³ cEstFis      - Estrutura Fisica           (APDL)           ³±±
±±³          ³ cServico     - Servico                    (APDL)           ³±±
±±³          ³ cTarefa      - Tarefa                     (APDL)           ³±±
±±³          ³ cAtividade   - Atividade                  (APDL)           ³±±
±±³          ³ cAnomalia    - Houve Anomalia? (S/N)      (APDL)           ³±±
±±³          ³ cEstDest     - Estrututa Fisica Destino   (APDL)           ³±±
±±³          ³ cEndDest     - Endereco Destino           (APDL)           ³±±
±±³          ³ cHrInicio    - Hora Inicio                (APDL)           ³±±
±±³          ³ cAtuEst      - Atualiza Estoque? (S/N)    (APDL)           ³±±
±±³          ³ cCarga       - N. da Carga                (APDL)           ³±±
±±³          ³ cUnitiza     - N. da Unitizacao           (APDL)           ³±±
±±³          ³ cOrdTar      - Ordem da Tarerefa          (APDL)           ³±±
±±³          ³ cOrdAti      - Ordem da Atividade         (APDL)           ³±±
±±³          ³ cRHumano     - Codigo do Recurso Humano   (APDL)           ³±±
±±³          ³ cRFisico     - Codigo do Recurso Fisico   (APDL)           ³±±
±±³          ³ cSeqCar      - Sequencia da carga         (APDL)           ³±±
±±³          ³ cIdDCF       - Identificador do DCF DCF_ID(APDL)           ³±±
±±³          ³ nRecnoSDB    - Retorna RecNo SDB          (APDL)           ³±±
±±³          ³ cIdMovto     - Identificador do SDB DB_IDMOVTO (APDL)      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ EST/PCP/FAT/COM/WMS                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function CriaSDB(cProduto,cLocal,nQuant,cLocaliza,cNumSerie,cDoc,cSerie,cCliFor,cLoja,cTipoNf,cOrigem,dData,cLoteCtl,cNumLote,cNumSeq,cTm,cTipo,cItem,lEstorno,nQtdEmp,nQuant2UM,nQtdEmp2UM,cEstFis,cServico,cTarefa,cAtividade,cAnomalia,cEstDest,cEndDest,cHrInicio,cAtuEst,cCarga,cUnitiza,cOrdTar,cOrdAti,cRHumano,cRFisico,cSeqCar,cIdDCF,nRecnoSDB,cIdMovto,cOpProd)

Static lCriaSDBD  := Nil

Local aArea      := GetArea()
Local aAreaSD3   := {}
Local aAreaSDC   := {}
Local aAreaSBE   := {}
Local aAreaDC5   := {}
Local aAreaDC6   := {}
Local cOldAlias  := Alias()
Local cNumIDOper := ''
Local cSeek      := ''
Local cEstruO    := ''
Local cEstruD    := ''
Local cFunExe    := ''
Local cStatRF    := Space(1)
Local nRecno     := 0
Local nTipoAglut := 0
Local lAglutina  := .F.
Local cServWMSE  := SuperGetMV('MV_SRVWMSE', .F., '499') //-- Servico de WMS Generico para Entradas
Local cServWMSS  := SuperGetMV('MV_SRVWMSS', .F., '999') //-- Servico de WMS Generico para Saidas
Local lWMSCNAG   := SuperGetMV('MV_WMSCNAG', .F., .T.  ) //-- Considera a norma do endereço na aglutinação dos movimentos
Local lIntWMS    := IntWMS(cProduto)
Local lSubLote   := Rastro(cProduto,'S')
Local cQuery     := ''
Local cQueryPe   := ''
Local cAliasSDB  := 'SDB'
Local nNorma     := 0
Local nI         := 0
Local nOrdTar    := 0
Local nQtdTotal  := 0

Private cCompSDB   := ''

Default cProduto   := ''
Default cLocal     := ''
Default nQuant     := 0
Default cLocaliza  := ''
Default cNumSerie  := ''
Default cDoc       := ''
Default cSerie     := ''
Default cCliFor    := ''
Default cLoja      := ''
Default cTipoNf    := ''
Default cOrigem    := ''
Default dData      := CtoD('  /  /  ')
Default cLoteCtl   := ''
Default cNumLote   := ''
Default cNumSeq    := ''
Default cTm        := ''
Default cTipo      := ''
Default cItem      := ''
Default lEstorno   := .F.
Default nQtdEmp    := 0
Default nQuant2UM  := ConvUm(cProduto,nQuant,0,2)
Default nQtdEmp2UM := ConvUm(cProduto,nQtdEmp,0,2)
Default cEstFis    := ''
Default cServico   := ''
Default cTarefa    := ''
Default cAtividade := ''
Default cAnomalia  := ''
Default cEstDest   := ''
Default cEndDest   := ''
Default cHrInicio  := Time()
Default cAtuEst    := 'S'
Default cCarga     := ''
Default cUnitiza   := ''
Default cOrdTar    := ''
Default cOrdAti    := ''
Default cRHumano   := ''
Default cRFisico   := ''
Default cSeqCar    := ''
Default cIdDCF     := ''
Default cIdMovto   := ''
Default cOpProd    := ''
Default nRecnoSDB  := 0

lCriaSDBD := If(lCriaSDBD==Nil, ExistBlock('CRIASDBD'), lCriaSDBD)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variaveis utilizadas pelo WMS ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cServico   := Iif(Empty(cServico),If(cTM<='500',cServWMSE,cServWMSS),cServico)
cAtuEst    := Iif(Empty(cAtuEst),'S',cAtuEst)
cStatRF    := Iif(DLAtiUsaRF(SuperGetMV('MV_RADIOF',.F.,'N')=='S', cTarefa, If(Empty(cAtividade).And.cAtuEst=='S','ZZZ',cAtividade)),SuperGetMV('MV_RFSTAEX', .F., '4'),SuperGetMV('MV_RFSTMAN', .F., 'M'))
cHrInicio  := Iif(Empty(cHrInicio),Time(),cHrInicio)
cNumIDOper := GetSx8Num('SDB','DB_IDOPERA'); ConfirmSX8()
dbSelectArea("SDB")
lExistOP := If (SDB->(ColumnPos("DB_OP")) >  0, .T., .F.)

If Empty(cSerie) .And. Type('cSerieSDB') == 'C' .And. !Empty(cSerieSDB)
	cSerie := cSerieSDB
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define a Estrutura Fisica de Origem no WMS ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cEstruO := ''
If lIntWMS
	If !(cAtuEst=='S') .Or. (cServico==cServWMSE.Or.cServico==cServWMSS)
		cEstruO := cEstFis
	ElseIf cOrigem == 'SD1'
		If cTM<='500'
			cEstruO := cEstFis
		Else
			cEstruO := cEstDest
		EndIf
	EndIf
	If Empty(cEstruO)
		aAreaSBE := SBE->(GetArea())
		SBE->(dbSetOrder(1))
		If SBE->(MsSeek(xFilial('SBE')+cLocal+cLocaliza, .F.))
			cEstruO := SBE->BE_ESTFIS
		EndIf
		RestArea(aAreaSBE)
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define a Estrutura Fisica de Destino no WMS ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cEstruD := ''
If lIntWMS
	If !(cAtuEst=='S')
		cEstruD := cEstDest
		If Empty(cEstruD)
			aAreaSBE := SBE->(GetArea())
			SBE->(dbSetOrder(1))
			If SBE->(MsSeek(xFilial('SBE')+cLocal+cEndDest, .F.))
				cEstruD := SBE->BE_ESTFIS
			EndIf
			SBE->(dbSetOrder(aAreaSBE[2]))
			SBE->(dbGoto(aAreaSBE[3]))
		EndIf
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Preenche a Sequencia da Carga ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(cCarga) .And. Empty(cSeqCar)
	DAK->(dbSetOrder(1))
	If DAK->(MsSeek(xFilial('DAK')+cCarga, .F.))
		cSeqCar := DAK->DAK_SEQCAR
	EndIf
EndIf

If lIntWMS
	If !(cAtuEst=='S')
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se a Atividade WMS deve ser Aglutinada ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !(cServico==cServWMSE.Or.cServico==cServWMSS) .And. !Empty(cTarefa) .And. !Empty(cAtividade)
			aAreaDC5 := DC5->(GetArea())
			aAreaDC6 := DC6->(GetArea())
			DC6->(dbSetOrder(2))
			If DC6->(MsSeek(xFilial('DC6')+cTarefa+cAtividade, .F.))
				nTipoAglut := Val(DC6->DC6_TPAGLU)
				// Se estiver configurado com aglutinação por carga,
				// porém os pedidos não pertecerem a nenhuma carga
				If (nTipoAglut == 4 .Or. nTipoAglut == 5) .And. !WmsCarga(cCarga)
					nTipoAglut := 1
				EndIf
			EndIf
			DC5->(DbSetOrder(1)) // DC5_FILIAL+DC5_SERVIC+DC5_ORDEM
			DC5->(MsSeek(xFilial('DC5')+cServico+cOrdTar))
			SX5->(DbSetOrder(1)) // X5_FILIAL+X5_TABELA+X5_CHAVE
			SX5->(MsSeek(xFilial('SX5')+'L6'+DC5->DC5_FUNEXE))
			cFunExe := AllTrim(Upper(SX5->(X5Descri())))
			RestArea(aAreaDC5)
			RestArea(aAreaDC6)
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posiciona no Registro para Aglutinacao ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea('SDB')
		nNorma := DLQtdNorma(cProduto,cLocal,cEstruD,,.F.)
		If nTipoAglut > 1 .And. !lEstorno .And. cStatRF != 'M' .And. !(AllTrim(cFunExe) $ "DLCONFEREN()|DLCONFSAI()|DLCONFENT()")
			cQuery := "SELECT SDB.R_E_C_N_O_ RECNOSDB"
			cQuery +=  " FROM "+RetSqlName("SDB")+" SDB"
			cQuery += " WHERE SDB.DB_FILIAL  = '"+xFilial("SDB")+"'"
			cQuery +=   " AND SDB.DB_PRODUTO = '"+cProduto+"'"
			cQuery +=   " AND SDB.DB_LOCAL   = '"+cLocal+"'"
			cQuery +=   " AND SDB.DB_LOTECTL = '"+cLoteCtl+"'"
			cQuery +=   " AND SDB.DB_NUMLOTE = '"+cNumLote+"'"
			cQuery +=   " AND SDB.DB_NUMSERI = '"+Space(TamSx3("DB_NUMSERI")[1])+"'"
			cQuery +=   " AND SDB.DB_LOCALIZ = '"+cLocaliza+"'"
			cQuery +=   " AND SDB.DB_ENDDES  = '"+cEndDest+"'"
			cQuery +=   " AND SDB.DB_UNITIZ  = '"+cUnitiza+"'"
			cQuery +=   " AND SDB.DB_SERVIC  = '"+cServico+"'"
			cQuery +=   " AND SDB.DB_TAREFA  = '"+cTarefa+"'"
			cQuery +=   " AND SDB.DB_ATIVID  = '"+cAtividade+"'"
			cQuery +=   " AND SDB.DB_TIPO    = '"+cTipo+"'"
			cQuery +=   " AND SDB.DB_ESTORNO = ' '"
			cQuery +=   " AND SDB.DB_ATUEST  = 'N'"
			cQuery +=   " AND SDB.DB_STATUS  IN ('"+cStatRF+"','-')"
			cQuery +=   " AND SDB.D_E_L_E_T_ = ' '"
			If lWMSCNAG
			   cQuery += " AND SDB.DB_QUANT  +  " + AllTrim(Str(nQuant)) + " <= " + AllTrim(Str(nNorma))
			EndIf
			If nTipoAglut == 2 //-- 2 = Aglutina por Documento+Serie
				cQuery += " AND SDB.DB_DOC    = '"+cDoc+"'"
			If 'DLENDERECA' $ cFunExe .Or. 'DLCROSSDOC' $ cFunExe
				cQuery += " AND SDB.DB_SERIE = '"+cSerie+"'"
			EndIf
			ElseIf nTipoAglut == 3 //-- 3 = Aglutina por Cliente/Fornecedor+Loja
				cQuery += " AND SDB.DB_CLIFOR = '"+cCliFor+"'"
				cQuery += " AND SDB.DB_LOJA   = '"+cLoja+"'"
			ElseIf nTipoAglut == 4 //-- 4 = Aglutina por Carga+Serquencia de Carga
				cQuery += " AND SDB.DB_CARGA  = '"+cCarga+"'"
				cQuery += " AND SDB.DB_SEQCAR = '"+cSeqCar+"'"
			ElseIf nTipoAglut == 5 //-- 5 = Aglutina por Carga+Sequencia da Carga+Cliente+loja
				cQuery += " AND SDB.DB_CARGA  = '"+cCarga+"'"
				cQuery += " AND SDB.DB_SEQCAR = '"+cSeqCar+"'"
				cQuery += " AND SDB.DB_CLIFOR = '"+cCliFor+"'"
				cQuery += " AND SDB.DB_LOJA   = '"+cLoja+"'"
			EndIf
			// Permite atraves do ponto de entrada munipular o controle de aglutinação
			If ExistBlock('WMSAGLU')
				cQueryPe := ExecBlock('WMSAGLU', .F., .F., {nTipoAglut, cOrigem, cCarga})
				If Valtype(cQueryPe) == 'C'
					cQuery += cQueryPe
				EndIf
			EndIf
			cQuery := ChangeQuery(cQuery)
			cAliasSDB := GetNextAlias()
			DbUseArea(.T.,'TOPCONN',TcGenQry(,,cQuery),cAliasSDB,.F.,.T.)
			If (cAliasSDB)->(!Eof())
				lAglutina := .T.
				// Verifica se aglutina e posiciona no registro aglutinador
				SDB->(DbGoTo((cAliasSDB)->RECNOSDB))
			EndIf
			(cAliasSDB)->(DbCloseArea())
			dbSelectArea('SDB')
		EndIf
		If AliasInDic('DCR') .And. !Empty(cIdDCF)
			//Grava relacionamento SDB e SDA para estorno
			dbSelectArea('DCR')
			DCR->( dbSetOrder(1) ) //DCR_FILIAL+DCR_IDORI+DCR_IDDCF+DCR_IDMOV+DCR_IDOPER
			//Rateio para a gravação da DCR levando em conta serviços aglutinados.
			If Type("aAgluDCF") == "A" .And. !Empty(aAgluDCF) .And. 'DLGXABAST()' != Upper(cFunExe)
				nOrdTar:= Len(aAgluDCF[1][4]) //A ordem da tarefa é a útilma adicionada no array.
				For nI := 1 To Len(aAgluDCF)
					If aAgluDCF[nI][4][nOrdTar][4] > 0
						cIdDCF  := IIf(lAglutina,SDB->DB_IDDCF, aAgluDCF[nI][4][nOrdTar][3])

						//Preenche com as informação do IDDCF origem da atividade
						If cDoc != aAgluDCF[nI][5] .And. aAgluDCF[nI][1] == aAgluDCF[nI][4][nOrdTar][3]
							cDoc    := IIf(lAglutina,SDB->DB_DOC,   aAgluDCF[nI][5])
							cSerie  := IIf(lAglutina,SDB->DB_SERIE, aAgluDCF[nI][6])
							cClifor := IIf(lAglutina,SDB->DB_CLIFOR,aAgluDCF[nI][7])
							cLoja   := IIf(lAglutina,SDB->DB_LOJA,  aAgluDCF[nI][8])
							cNumSeq := IIf(lAglutina,SDB->DB_NUMSEQ,aAgluDCF[nI][9])
						EndIf

					   nQuant  := aAgluDCF[nI][4][nOrdTar][4]
					   nQuant2UM := ConvUm(cProduto,nQuant,0,2)
					   If lAglutina .And. DCR->(DbSeek(xFilial('DCR')+cIdDCF+aAgluDCF[nI][1]+SDB->DB_IDMOVTO+SDB->DB_IDOPERA))
							Reclock('DCR',.F.)
							DCR->DCR_QUANT  += nQuant
							DCR->DCR_QTSEUM += nQuant2UM
					   Else
							Reclock('DCR', .T.)
							DCR->DCR_FILIAL := xFilial('DCR')
							DCR->DCR_IDORI  := cIdDCF
							DCR->DCR_IDDCF  := aAgluDCF[nI][1]
							DCR->DCR_IDMOV  := IIf(lAglutina,SDB->DB_IDMOVTO,cIdMovto)
							DCR->DCR_IDOPER := IIf(lAglutina,SDB->DB_IDOPERA,cNumIDOper)
							DCR->DCR_QUANT  := nQuant
							DCR->DCR_QTSEUM := nQuant2UM
					   EndIf
					   DCR->( MsUnlock() )
					   nQtdTotal += nQuant
					EndIf
				Next nI
				nQuant := nQtdTotal
				nQuant2UM := ConvUm(cProduto,nQuant,0,2)
			Else
				If lAglutina .And. DCR->(DbSeek(xFilial('DCR')+SDB->DB_IDDCF+cIdDCF+SDB->DB_IDMOVTO+SDB->DB_IDOPERA))
					Reclock('DCR',.F.)
					DCR->DCR_QUANT  += nQuant
					DCR->DCR_QTSEUM += nQuant2UM
				Else
					Reclock('DCR', .T.)
					DCR->DCR_FILIAL := xFilial('DCR')
					DCR->DCR_IDORI  := IIf(lAglutina,SDB->DB_IDDCF,cIdDCF)
					DCR->DCR_IDDCF  := cIDDCF
					DCR->DCR_IDMOV  := IIf(lAglutina,SDB->DB_IDMOVTO,cIdMovto)
					DCR->DCR_IDOPER := IIf(lAglutina,SDB->DB_IDOPERA,cNumIDOper)
					DCR->DCR_QUANT  := nQuant
					DCR->DCR_QTSEUM := nQuant2UM
				EndIf
				DCR->( MsUnlock() )
			EndIf
		EndIf
		If	lAglutina
			//Somatorias
			nQuant     := SDB->DB_QUANT   + nQuant
			nQtdEmp    := SDB->DB_EMPENHO + nQtdEmp
			nQtdEmp2UM := SDB->DB_EMP2    + nQtdEmp2UM
			nQuant2UM  := SDB->DB_QTSEGUM + nQuant2UM
		EndIf
	EndIf
EndIf

Reclock('SDB', !lAglutina)
Replace DB_FILIAL    With xFilial('SDB')
Replace DB_PRODUTO   With cProduto
Replace DB_LOCAL     With cLocal
Replace DB_QUANT     With nQuant
Replace DB_EMPENHO   With nQtdEmp
Replace DB_EMP2      With nQtdEmp2UM
Replace DB_QTSEGUM   With nQuant2UM
If !lAglutina
	Replace DB_LOCALIZ   With cLocaliza
	Replace DB_NUMSERI   With cNumSerie
	Replace DB_DOC       With cDoc
	Replace DB_SERIE     With cSerie
	Replace DB_CLIFOR    With cClifor
	Replace DB_LOJA      With cLoja
	Replace DB_TIPONF    With cTipoNf
	Replace DB_ORIGEM    With cOrigem
	Replace DB_DATA      With dData
	Replace DB_LOTECTL   With cLoteCtl
	If lSubLote
		Replace DB_NUMLOTE   With cNumLote
	EndIf
	Replace DB_NUMSEQ    With cNumSeq
	Replace DB_TM        With cTm
	Replace DB_TIPO      With cTipo
	Replace DB_ITEM      With cItem
	Replace DB_ESTORNO   With If(lEstorno,'S','')
	Replace DB_ESTFIS    With cEstruO
	Replace DB_SERVIC    With cServico
	Replace DB_TAREFA    With cTarefa
	Replace DB_ATIVID    With If(Empty(cAtividade).And.cAtuEst=='S','ZZZ',cAtividade)
	Replace DB_RHFUNC    With cRHumano
	Replace DB_RECFIS    With cRFisico
	Replace DB_ANOMAL    With cAnomalia
	Replace DB_ESTDES    With cEstruD
	Replace DB_ENDDES    With If(!(cAtuEst=='S'),cEndDest,'')
	Replace DB_HRINI     With cHrInicio
	Replace DB_ATUEST    With cAtuEst
	Replace DB_CARGA     With cCarga
	Replace DB_SEQCAR    With cSeqCar
	Replace DB_UNITIZ    With cUnitiza
	Replace DB_ORDTARE   With cOrdTar
	Replace DB_ORDATIV   With If(Empty(cOrdAti).And.cAtuEst=='S','ZZ',cOrdAti)
	Replace DB_IDOPERA   With cNumIDOper
	If Type("aLibSDB")=="A" .And. cAtuEst == 'N'
		If cStatRF != 'M'
			Replace DB_STATUS  With "-"
		Else
			Replace DB_STATUS  With cStatRF
			Replace DB_DATAFIM With dData
			Replace DB_HRFIM   With cHrInicio
		EndIf
	Else
		Replace DB_STATUS  With cStatRF
	EndIf
	If lIntWMS
		Replace DB_PRIORI With 'ZZ'
	EndIf
	SDB->DB_IDDCF := cIdDCF
	SDB->DB_IDMOVTO := cIdMovto

	If lExistOP
		Replace DB_OP With cOpProd
	EndIf

EndIf
SDB->( MsUnlock() )
nRecnoSDB := SDB->(Recno())

If Type("aLibSDB")=="A" .And. cAtuEst == 'N'
	AAdd(aLibSDB,{cStatRF,SDB->(Recno()),cLocal,cServico})
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de Entrada DEPOIS da gravacao do SDB ³
//³ Parametro Passado:                         ³
//³ PARAMIXB = RECNO do SDB                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lCriaSDBD
	ExecBlock('CRIASDBD', .F., .F., SDB->(Recno()))
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Procura o outro registro do estorno                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If SDB->DB_ESTORNO=='S'
	nRecno := Recno()
	cSeek  := xFilial('SDB')+SDB->DB_PRODUTO+SDB->DB_LOCAL+SDB->DB_NUMSEQ+SDB->DB_DOC+SDB->DB_SERIE+SDB->DB_CLIFOR+SDB->DB_LOJA+SDB->DB_ITEM
	dbSetOrder(1)
	If dbSeek(cSeek, .F.)
		Do While !Eof() .And. cSeek==SDB->DB_FILIAL+SDB->DB_PRODUTO+SDB->DB_LOCAL+SDB->DB_NUMSEQ+SDB->DB_DOC+SDB->DB_SERIE+SDB->DB_CLIFOR+SDB->DB_LOJA+SDB->DB_ITEM
			If !(Recno()==nRecno) .And. QtdComp(SDB->DB_QUANT)==QtdComp(nQuant) .And. SDB->DB_LOCALIZ == cLocaliza .And. SDB->DB_ESTORNO # "S"
				Reclock('SDB', .F.)
				Replace SDB->DB_ESTORNO With 'S' //-- Marca registro tambem com Estorno
				SDB->( MsUnlock())
				Exit
			EndIf
			dbSkip()
		EndDo
	EndIf
	dbGoto(nRecno) //-- Restaura registro original
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Tratamento de registros do SDC quando a qtd. Empenhada ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If QtdComp(SDB->DB_EMPENHO,.t.)>QtdComp(0) .And. SDB->DB_ORIGEM=='SD3'
	dbSelectArea('SD3')
	aAreaSD3 := GetArea()
	dbSetOrder(3)
	If dbSeek(xFilial('SDB')+SDB->DB_PRODUTO+SDB->DB_LOCAL+SDB->DB_NUMSEQ, .F.)
		If SDB->DB_ESTORNO == 'S'
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Apaga registro no SDC                                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea('SDC')
			aAreaSDC := GetArea()
			dbSetOrder(2)
			If dbSeek(xFilial('SDC')+SDB->DB_PRODUTO+SDB->DB_LOCAL+SD3->D3_OP+SD3->D3_TRT+SDB->DB_LOTECTL+SDB->DB_NUMLOTE+SDB->DB_LOCALIZ+SDB->DB_NUMSERI, .F.)
				Reclock('SDC', .F.)
				dbDelete()
				SDC->(MsUnlock())
			EndIf
			RestArea(aAreaSDC)
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria SDC quando quantidade de empenho veio do SD3     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			Reclock('SDC',.T.)
			Replace DC_FILIAL   With xFilial('SDC')
			Replace DC_ORIGEM   With 'SC2'
			Replace DC_PRODUTO  With SDB->DB_PRODUTO
			Replace DC_LOCAL    With SDB->DB_LOCAL
			Replace DC_LOTECTL  With SDB->DB_LOTECTL
			If lSubLote
				Replace DC_NUMLOTE   With SDB->DB_NUMLOTE
			EndIf
			Replace DC_LOCALIZ  With SDB->DB_LOCALIZ
			Replace DC_NUMSERI  With SDB->DB_NUMSERI
			Replace DC_QTDORIG  With SDB->DB_EMPENHO
			Replace DC_QUANT    With SDB->DB_EMPENHO
			Replace DC_QTSEGUM  With SDB->DB_EMP2
			Replace DC_OP       With SD3->D3_OP
			Replace DC_TRT      With SD3->D3_TRT
			Replace DC_ESTFIS   With SDB->DB_ESTFIS
			SDC->( MsUnlock())
		EndIf
	EndIf
	RestArea(aAreaSD3)
EndIf

If !(cOldAlias=='SDB')
	RestArea(aArea)
EndIf
If lEstorno
	SDB->(dbGoto(nRecno))
EndIf

Return Nil
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ GravaSBF ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 06/11/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava registro de Saldos por Localizacao (SBF)             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ GravaSBF(cAlias)                                           ³±±
±±³          ³ cAlias := Alias do arquivo que esta criando o registro.    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ EST/PCP/FAT/COM                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GravaSBF(cAlias,lBaixaEmp,lDelZero,nRecnoSDB,nQtdLog,lUsaB8Emp,lAtuEmpSDC)
STATIC lExistRDM:= NIL

Local aAreaAnt   := GetArea()
Local aAreaSBE   := SBE->(GetArea())
Local aAreaSBF   := SBF->(GetArea())
Local nMultiplic :=1
Local lNewReg    :=.F.
Local cEstFis    := Space(Len(SBF->BF_ESTFIS))

Default lDelZero   := .T.
Default nRecnoSDB  := 0
Default nQtdLog    := 0
Default lUsaB8Emp  := .F.
Default lAtuEmpSDC := .T.

lExistRDM := If(lExistRDM == NIL,ExistBlock("ATUSBF"),lExistRDM)
lBaixaEmp := If(lBaixaEmp == NIL,.F.,lBaixaEmp)

// Nota Fiscal de Entrada
If cAlias == "SDB"
	If nRecnoSDB > 0
		SDB->(MsGoto(nRecnoSDB))
	EndIf
	If SDB->DB_TM > "500"
		nMultiplic:=-1
	EndIf
	If IntWMS(SDB->DB_PRODUTO)
		SBE->(dbSetOrder(1))
		If SBE->(MsSeek(xFilial('SBE')+SDB->DB_LOCAL+SDB->DB_LOCALIZ, .F.))
			cEstFis := SBE->BE_ESTFIS
		EndIf
	EndIf
	dbSelectArea("SBF")
	dbSetOrder(6)
	If MsSeek(xFilial('SBF')+SDB->DB_LOCAL+SDB->DB_LOCALIZ+cEstFis+SDB->DB_PRODUTO+SDB->DB_NUMSERI+SDB->DB_LOTECTL+SDB->DB_NUMLOTE, .F.)
		RecLock("SBF",.F.)
	Else
		SBE->(dbSetOrder(1))
		SBE->(MsSeek(xFilial("SBE")+SDB->DB_LOCAL+SDB->DB_LOCALIZ))
		lNewReg  :=.T.
		RecLock("SBF",.T.)
		Replace BF_FILIAL    With xFilial('SBF')
		Replace BF_PRODUTO   With SDB->DB_PRODUTO
		Replace BF_LOCAL     With SDB->DB_LOCAL
		Replace BF_LOCALIZ   With SDB->DB_LOCALIZ
		Replace BF_NUMSERI   With SDB->DB_NUMSERI
		If Rastro(BF_PRODUTO,"S")
			Replace BF_NUMLOTE   With SDB->DB_NUMLOTE
		EndIf
		Replace BF_LOTECTL   With SDB->DB_LOTECTL
		Replace BF_PRIOR     With If(Empty(SBE->BE_PRIOR),"",SBE->BE_PRIOR)
	EndIf
	Replace BF_QUANT   With BF_QUANT  +(SDB->DB_QUANT  *nMultiplic)
	Replace BF_QTSEGUM With BF_QTSEGUM+(SDB->DB_QTSEGUM*nMultiplic)
	nQtdLog += SDB->DB_QUANT

	If (lBaixaEmp .Or. lUsaB8Emp) .And. lAtuEmpSDC
		Replace BF_EMPENHO With BF_EMPENHO+(SDB->DB_QUANT  *nMultiplic)
		Replace BF_EMPEN2  With BF_EMPEN2 +(SDB->DB_QTSEGUM*nMultiplic)
	ElseIf QtdComp(SDB->DB_EMPENHO,.t.) > QtdComp(0)
		Replace BF_EMPENHO With BF_EMPENHO+(SDB->DB_EMPENHO*nMultiplic)
		Replace BF_EMPEN2  With BF_EMPEN2 +(SDB->DB_EMP2   *nMultiplic)
	EndIf

	Replace BF_ESTFIS With cEstFis
	SBF->(MsUnlock())
ElseIf cAlias == "SBK"
	//-- Forca a Gravacao da Estrutura Fisica
	If IntWMS(SBK->BK_COD)
		SBE->(dbSetOrder(1))
		If SBE->(MsSeek(xFilial('SBE')+SBK->BK_LOCAL+SBK->BK_LOCALIZ, .F.))
			cEstFis := SBE->BE_ESTFIS
		EndIf
	EndIf
	dbSelectArea("SBF")
	dbSetOrder(6)
	If MsSeek(xFilial('SBF')+SBK->BK_LOCAL+SBK->BK_LOCALIZ+cEstFis+SBK->BK_COD+SBK->BK_NUMSERI+SBK->BK_LOTECTL+SBK->BK_NUMLOTE)
		RecLock("SBF",.F.)
	Else
		lNewReg  :=.T.
		RecLock("SBF",.T.)
		Replace BF_FILIAL    With xFilial('SBF')
		Replace BF_PRODUTO   With SBK->BK_COD
		Replace BF_LOCAL     With SBK->BK_LOCAL
		Replace BF_LOCALIZ   With SBK->BK_LOCALIZ
		Replace BF_NUMSERI   With SBK->BK_NUMSERI
		Replace BF_ESTFIS    With cEstFis
		If Rastro(BF_PRODUTO,"S")
			Replace BF_NUMLOTE   With SBK->BK_NUMLOTE
		EndIf
		Replace BF_LOTECTL   With SBK->BK_LOTECTL
		Replace BF_PRIOR With If(Empty(SBE->BE_PRIOR),"",SBE->BE_PRIOR)
	EndIf
	Replace BF_QUANT   With BF_QUANT  +(SBK->BK_QINI   *nMultiplic)
	Replace BF_QTSEGUM With BF_QTSEGUM+(SBK->BK_QISEGUM*nMultiplic)
	SBF->(MsUnlock())
EndIf
// Chamada do ExecBlock
If lExistRDM
	ExecBlock("ATUSBF",.F.,.F.,{nMultiplic,lNewReg,lBaixaEmp})
EndIf
If QtdComp(BF_QUANT,.t.) <= 0 .And. IIF(IntWMS(),.T.,QtdComp(BF_EMPENHO,.t.) <= 0)
	If lDelZero //-- Utilizado quando for compor o saldo pelas Movimentacoes - no final do processo deve-se varrer o SBF e deletar os reg. Zerados
		// Se vai eliminar, é preciso salvar informações para PPI saber
		if Type('aPPIDelete') != 'U'
			aPPIDelete := {SBF->(Recno()), SBF->BF_QUANT, SBF->BF_EMPENHO}
		Endif
		DeletSBF()
	EndIf
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Altera o Status do Endereco no SBE para Ocupado caso este possua saldo no SBF ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea('SBE')
	dbSetOrder(1) //-- BE_FILIAL+BE_LOCAL+BE_LOCALIZ+BE_ESTFIS
	If MsSeek(xFilial('SBE')+SBF->BF_LOCAL+SBF->BF_LOCALIZ+SBF->BF_ESTFIS, .F.) .And. !(SBE->BE_STATUS=='2') .And. !(SBE->BE_STATUS=='3')
		If !IsCrossDoc(SBE->BE_ESTFIS)
			RecLock('SBE', .F.)
			Replace BE_STATUS With '2'
			MsUnlock()
		EndIf
	EndIf
EndIf
RestArea(aAreaSBF)
RestArea(aAreaSBE)
RestArea(aAreaAnt)

Return Nil
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ QuantSBF ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 07/11/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna saldo do almoxarifado+localizacao (SBF)            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ QuantSBF(cLocal,cLocaliza,cProduto,[lSegUM])               ³±±
±±³          ³ cLocal    := Almoxarifado a ser pesquisado                 ³±±
±±³          ³ cLocaliza := Localizacao fisica a ser pesquisada           ³±±
±±³          ³ cProduto  := Produto a ser utilizado na soma               ³±±
±±³          ³ lSegUM    := Indica se considera a segunda Unidade / Medida³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ EST/PCP/FAT/COM                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function QuantSBF(cLocal,cLocaliza,cProduto,lSegUM)
Local aArea:=GetArea()
Local aAreaSBF:=SBF->(GetArea())
Local nRet:=0
Local cAliasSBF:="SBF",cQuery:=""

lSegUM := If( ValType( lSegUM ) == "L", lSegUM, .F. )

// Caso nao selecione o produto, soma todos
cProduto:=If(cProduto==NIL,"",cProduto)

dbSelectArea("SBF")
dbSetOrder(1)
	SBF->(dbCommit())
	cAliasSBF := "QUANTSBF"
	cQuery    := "SELECT * FROM "+RetSqlName("SBF")+" SBF WHERE SBF.BF_FILIAL ='"+xFilial("SBF")+"' AND "
	// Caso nao selecione o produto, soma todos
	If !Empty(cProduto)
		cQuery += "SBF.BF_PRODUTO ='"+cProduto+"' AND "
	EndIf
	cQuery += "SBF.BF_LOCAL='"+cLocal+"' AND SBF.BF_LOCALIZ='"+cLocaliza+"' AND SBF.D_E_L_E_T_=' ' ORDER BY "+SqlOrder(SBF->(IndexKey()))
	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSBF,.T.,.T.)
	aEval(SBF->(dbStruct()), {|x| If(x[2] <> "C", TcSetField(cAliasSBF,x[1],x[2],x[3],x[4]),Nil)})

While !Eof() .And. IF(Empty(cQuery),xFilial('SBF')+cLocal+cLocaliza+cProduto == BF_FILIAL+BF_LOCAL+BF_LOCALIZ+If(!Empty(cProduto),BF_PRODUTO,""),.T.)
	If lSegUM
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Saldo na segunda unidade de medida                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nRet+=(cAliasSBF)->BF_QTSEGUM-((cAliasSBF)->BF_EMPEN2+AvalQtdPre("SBF",1,.T.,cAliasSBF))
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Saldo na primeira unidade de medida                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nRet+=(cAliasSBF)->BF_QUANT-((cAliasSBF)->BF_EMPENHO+AvalQtdPre("SBF",1,NIL,cAliasSBF))
	EndIf
	dbSkip()
EndDo
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fecha query criada                                                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(cQuery)
	dbSelectArea(cAliasSBF)
	dbCloseArea()
EndIf
SBF->(RestArea(aAreaSBF))
RestArea(aArea)
Return nRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ DeletSBF ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 24/11/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Deleta registro do SBF e incrementa marcador no SX2        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ DeletSBF()                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ EST/PCP/FAT/COM/WMS                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function DeletSBF()

Local cAlias     := Alias()
Local aAreaAnt   := {}
Local cSeekSBE   := xFilial('SBE')+SBF->BF_LOCAL+SBF->BF_LOCALIZ+SBF->BF_ESTFIS
Local cSeekSBF   := xFilial('SBF')+SBF->BF_LOCAL+SBF->BF_LOCALIZ+SBF->BF_ESTFIS
Local cProduto   := ''

cProduto := SBF->BF_PRODUTO
RecLock('SBF', .F., .T.)
dbDelete()
MsUnlock()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Altera o Status do Endereco no SBE para Livre caso este NAO possua saldo no SBF ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aAreaAnt := GetArea()
dbSelectArea('SBF')
dbSetOrder(6) //-- BF_FILIAL+BF_LOCAL+BF_LOCALIZ+BF_ESTFIS+BF_PRODUTO+BF_NUMSERI+BF_LOTECTL+BF_NUMLOTE
If !MsSeek(cSeekSBF, .F.) //-- Verifica se nao existem mais registros no SBF para este Endereco
	dbSelectArea('SBE')
	dbSetOrder(1) //-- BE_FILIAL+BE_LOCAL+BE_LOCALIZ+BE_ESTFIS
	If MsSeek(cSeekSBE, .F.) .And. !(BE_STATUS=='1')
		If !(BE_STATUS=='3')
			RecLock('SBE', .F.)
			Replace BE_STATUS With '1'
			MsUnlock()
		EndIf
	EndIf
EndIf
RestArea(aAreaAnt)

dbSelectArea(cAlias)

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ LoteVenc ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 25/11/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se o lote esta vencido caso usu rio use controle  ³±±
±±³          ³ de data de validade.                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ LoteVenc(cLote,cLoteCtl,cProduto,cLocal)                   ³±±
±±³          ³ cLote   := Sub-Lote a ser pequisado                        ³±±
±±³          ³ cLoteCtl:= Lote a ser pesquisado                           ³±±
±±³          ³ cProduto:= Produto a ser pesquisado                        ³±±
±±³          ³ cLocal  := Local a ser pesquisado                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ EST/PCP/FAT/COM                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LoteVenc(cLote,cLoteCtl,cProduto,cLocal)
LOCAL cAlias:=Alias(),nOrder:=IndexOrd(),nRecno:=Recno()
LOCAL cLotVenc:=GETMV("MV_LOTVENC")
LOCAL lRet:=.T.
dbSelectArea("SB8")
If !Empty(cLote)
	dbSetOrder(2)
	If dbSeek(xFilial('SB8')+cLote+cLoteCtl+cProduto+cLocal)
		If B8_DTVALID < dDataBase .And. cLotVenc == "N"
			Help(" ",1,"LOTEVENC")
			lRet:=.F.
		EndIf
	EndIf
Else
	dbSetOrder(3)
	If dbSeek(xFilial('SB8')+cProduto+cLocal+cLoteCtl)
		If B8_DTVALID < dDataBase .And. cLotVenc == "N"
			Help(" ",1,"LOTEVENC")
			lRet:=.F.
		EndIf
	EndIf
EndIf
dbSelectArea(cAlias)
dbSetOrder(nOrder)
MsGoto(nRecno)
Return lRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ F4Localiz³ Autor ³ Sergio Silveira       ³ Data ³ 24/11/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Faz a consulta de localizacoes por produto                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ F4Localiz(a,b,c)                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ a,b,c = parametros padroes quando utiliza-se o SetKey()    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function F4Localiz( a, b, c, cProg, cProd, cLoc, nQtd, cReadVar, lEndOrig, cOP, lNumSerie)

LOCAL aArrayF4  :={}, aArrayF4NS:={}, nX, cVar
LOCAL cProduto  :="", nPosProd:=0, cLocal:="", nPosLocal:=0, nPosLocaliz:=0, nPosQuant:=0,nPosNumSer:=0,nPosSerie:=0,nPosQt2U:=0, nPrcVen:= 0
LOCAL nQuant    := 0
LOCAL nQuantLoc := 0
LOCAL nQtLoc2U  := 0
LOCAL nEndereco
LOCAL cChave2
LOCAL cLocEnd    := ""
Local cIdUnit    := ""
LOCAL lGetDados  := .F.
LOCAL aUsado     := {}
LOCAL nPosNumLote
LOCAL nPosLoteCtl
LOCAL lLote      := .F.
LOCAL cQuant, cQtSegU, nOAT
LOCAL lSaida     := .F.
LOCAL oDlg
LOCAL nOpcA      := 0
LOCAL aPosSBF 	 := {}
LOCAL aArea		 :=GetArea()
LOCAL lShowNSeri := .F.
LOCAL lRet       := .T.
LOCAL cNumSeri   := CriaVar( "BF_NUMSERI", .F. )
Local cLoteCtl   := ""
Local cNumLote   := ""
LOCAL nNumSerie  := 0
LOCAL lSelLote   := (SuperGetMV("MV_SELLOTE") == "1")
Local lWmsNew    := .F.
Local lWms       := .F.
LOCAL nLoop      := 0
LOCAL dDtValid   := CTOD('  /  /  ')
LOCAL nPotencia	 := 0
LOCAL aAreaSB8   := SB8->(GetArea())
LOCAL aDelArrF4  := {}
LOCAL nPos 		 := 0
LOCAL lMTF4LOC   := ExistBlock("MTF4LOC")
LOCAL aArrayAux  := Nil
LOCAL nHdl       := GetFocus()
LOCAL aSldEmp	 := {0,0}
LOCAL cCadastro  := ""
LOCAL nI		:= 0
LOCAL cLocProc	:= GetMvNNR('MV_LOCPROC','99')
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ MV_VLDLOTE - Utilizado para visualizar somente os lotes que  |
//| possuem o campo B8_DATA com o valor menor ou igual a database|
//| do sistema                                                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LOCAL lVldDtLote := SuperGetMV("MV_VLDLOTE",.F.,.T.)
Local nSeriSDD   := 0

DEFAULT lNumSerie := .F.
DEFAULT lEndorig  := .T.
DEFAULT cOP := ""

nQtd      := If( ValType( nQtd ) <> "N", 0, nQtd )
lWmsNew   := SuperGetMV("MV_WMSNEW",.F.,.F.) .And. IntWMS()

If cProg $ "A430/A440/A410/A467/A468/A462/A241/A265"
	For nX := 1 To Len(aHeader)
		If "_PRODUTO" $ AllTrim( aHeader[ nX, 2 ] ) .Or. ;
				"_COD"     $ Right( AllTrim( aHeader[ nX, 2 ] ), 4 )
			cProduto    := aCols[ n, nX ]
			nPosProd    := nX
		ElseIf "_LOCAL" == Right( AllTrim( aHeader[ nX, 2 ] ), 6 )
			cLocal      := aCols[ n, nX ]
			nPosLocal   := nX
		ElseIf "_LOCALIZ" $ AllTrim( aHeader[ nX, 2 ] )
			nPosLocaliz := nX
		ElseIf "_NUMLOTE" $ AllTrim( aHeader[ nX, 2 ] )
			nPosNumLote := nX
			cNumLote    := aCols[ n, nX ]
		ElseIf "_LOTECTL" $ AllTrim( aHeader[ nX, 2 ] )
			nPosLoteCtl := nX
			cLoteCtl    := aCols[ n, nX ]
		ElseIf ("_QUANT" == Right( AllTrim( aHeader[ nX, 2 ] ), 6 ) .Or. ;
				"_QTDVEN" $ AllTrim( aHeader[ nX, 2 ] )) .And. cProg $ "A430/A410/A467/A468/A462/A241/A265"
			nQuant      := aCols[ n, nX ]
			nPosQuant   := nX
		ElseIf "_QTDLIB" $ AllTrim( aHeader[ nX, 2 ] ) .And. cProg == "A440"
			nQuant      := aCols[ n, nX ]
			nPosQuant   := nX
		ElseIf "_PRCVEN" $ AllTrim( aHeader[ nX, 2 ] ) .And. cProg == "A410"
			nPrcVen := aCols[ n, nX ]
		ElseIf "_NUMSERI" $ AllTrim( aHeader[ nX, 2 ] )
			nPosNumSer := nX
			cNumSeri   := aCols[ n, nX ]
		EndIf

	Next nX

	lGetDados := .T.

	For nLoop := 1 To Len( aCols )
		If nLoop <> n .And. If(ValType(aCols[nLoop,Len(aCols[nLoop])]) == "L",!aCols[nLoop,Len(aCols[nLoop])],.T.)
			If cProg # "A265" .And. !(cProg == 'A410' .and. Altera)
				If aCols[ nLoop, nPosProd ] == cProduto .And. aCols[nLoop,nPosLocal] == cLocal .And. aCols[nLoop,nPosLoteCtl] == cLoteCtl .And. aCols[nLoop,nPosNumLote] == cNumLote
					nScan := aScan( aUsado, { |x| x[1] == aCols[nLoop,nPosLocaliz]  .And. x[3] == aCols[nLoop,nPosLoteCtl] .And. x[4] == aCols[nLoop,nPosNumLote] .And. x[5] == If(nPosNumSer>0,aCols[nLoop,nPosNumSer],"")} )
					If nScan == 0
						AAdd(aUsado,{aCols[nLoop,nPosLocaliz],aCols[nLoop,nPosQuant],aCols[nLoop,nPosLoteCtl],aCols[nLoop,nPosNumLote],If(nPosNumSer>0,aCols[nLoop,nPosNumSer],"")} )
					Else
						aUsado[ nScan ,2] += aCols[ nLoop, nPosQuant ]
					EndIf
				EndIf
			EndIf
		EndIf
	Next nLoop
	If cProg $ "A241"
		lSaida   := ( cTM > "500" ) .Or. (cTm <= "500" .and. SF5->F5_APROPR != "S" .And. SB1->B1_APROPRI == "I")
		IF cTm <= "500" .and. SF5->F5_APROPR != "S" .And. SB1->B1_APROPRI == "I"
			cLocal := cLocProc
		Endif
	ElseIf cProg == "A265"
		cProduto:=cProd
		cLocal  :=cLoc
	EndIf
ElseIf cProg $ "A175"
	cProduto := cA175Prod
	cLocal   := cA175Loc
	nPosQuant:= aScan(aHeader, {|x| AllTRim(x[2]) == 'D7_QTDE'})
	nPosQt2U := aScan(aHeader, {|x| AllTRim(x[2]) == 'D7_QTSEGUM'})
	nQuant   := aCols[n,nPosQuant]
	cNumLote := cA175LoteC
	cLoteCtl := cA175LotCt
ElseIf cProg $ "A260"
	cProduto := cProd
	cLocal   := cLoc
	nQuant   := nQtd
	cNumLote := ""
	cLoteCtl := ""
ElseIf cProg $ "A261"
	cProduto   := cProd
	cLocal     := cLoc
	nQuant     := nQtd
	cNumLote   := ""
	cLoteCtl   := ""
	nPos261Loc := O:COLPOS
ElseIf cProg $ "A240"
	lSaida   := ( M->D3_TM > "500" ) .Or. (M->D3_TM <= "500" .and. SF5->F5_APROPR != "S" .And. SB1->B1_APROPRI == "I")
	cProduto := M->D3_COD
	IF  M->D3_TM <= "500" .and. SF5->F5_APROPR != "S" .And. SB1->B1_APROPRI == "I"
		cLocal := cLocProc
	Else
		cLocal   := M->D3_LOCAL
	Endif
	nQuant   := M->D3_QUANT
	cNumLote := M->D3_NUMLOTE
	cLoteCtl := M->D3_LOTECTL
ElseIf cProg $ "A270"
	lSaida   := .T.
	cProduto := M->B7_COD
	cLocal   := M->B7_LOCAL
	nQuant   := M->B7_QUANT
	cNumLote := M->B7_NUMLOTE
	cLoteCtl := M->B7_LOTECTL
ElseIf cProg $ "A242" .Or. cProg $ "A242C"
	cProduto := cProd
	cLocal   := cLoc
	nQuant   := nQtd
	cNumLote := ""
	cLoteCtl := ""
ElseIf cProg $ "A275"
	cProduto := M->DD_PRODUTO
	cLocal   := M->DD_LOCAL
	nQuant   := M->DD_QUANT
	cNumLote := M->DD_NUMLOTE
	cLoteCtl := M->DD_LOTECTL
ElseIf cProg $ "A380"
	cProduto := cProd
	cLocal   := cLoc
	nQuant   := nQtd
	cNumLote := SD4->D4_NUMLOTE
	cLoteCtl := SD4->D4_LOTECTL
ElseIf cProg $ "A381"
	cProduto := cProd
	cLocal   := cLoc
	nQuant   := nQtd
	cLoteCtl := cEndLCtl
	cNumLote := cEndLote
ElseIf cProg $ 'DLA220'
	cProduto := cProd
	cLocal   := cLoc
	nQuant   := nQtd
	cNumLote := M->DCF_NUMLOT
	cLoteCtl := M->DCF_LOTECT
ElseIf cProg $ "WMSA332A"
	cProduto := cProd
	cLocal   := cLoc
	nQuant   := nQtd
ElseIf cProg $ "ATEC"
	cProduto := cProd
	cLocal   := cLoc
	nQuant   := nQtd
	cNumLote := ""
	cLoteCtl := ""
ElseIf cProg $ "A310"
	cProduto := cProduto1
	cLocal   := cLocOrig
	nQuant   := nQtd
	cNumLote := cNumLote
	cLoteCtl := cLoteDigi
ElseIf cProg $ "A311"
	cProduto := cProd
	cLocal   := cLoc
	nQuant   := nQtd
	cNumLote := ""
	cLoteCtl := ""
ElseIf cProg $ "A314"
	cProduto := cProd
	cLocal   := cLoc
	nQuant   := nQtd
	cNumLote := ""
	cLoteCtl := ""
ElseIf cProg $ "AGR900"
	cProduto := FwFldGet("NPH_CODPRO")
	cLocal   := FwFldGet("NPH_LOCAL")
	nQuant   := FwFldGet("NPN_QUANT")
	cNumLote := ""
	cLoteCtl := FwFldGet("NPN_LOTE")
ElseIf cProg $ "ACDI011"
	cProduto := cProd
	cLocal   := cLoc
	nQuant   := nQtd
	cNumLote := ""
	cLoteCtl := ""
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Faz o F4 apenas se o produto tiver controle de localizacao  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Localiza( cProduto,.T.) .And. If( cProg $ "A240úA241", lSaida, .T. )
	If Rastro( cProduto )
		If !Empty( If( Rastro( cProduto, "S" ), cNumLote, cLoteCtl ) )
			lLote := .T.
		EndIf
	EndIf

	If lWmsNew .And. IntWMS(cProduto)
		lWms      := .T.
		oSaldoWMS := WMSDTCEstoqueEndereco():New()
		If cProg $ "A380úA381" .Or. FwIsInCallStack("MATA650")
			oSaldoWMS:SetProducao(.T.)
		EndIf
		If Rastro(cProduto,"S")
			aSaldo := oSaldoWMS:GetSldEnd(cProduto,cLocal,,cLoteCtl,cNumLote,,1)

		Else
			aSaldo := oSaldoWMS:GetSldEnd(cProduto,cLocal,,cLoteCtl,,,1)

		EndIf
		SB8->(dbSetOrder(3))
		For nI := 1 To Len(aSaldo)
			aSaldo[nI,6] := TransForm(aSaldo[nI,6],PesqPict("D14","D14_QTDEST",TamSX3("D14_QTDEST")[1]))
			aSaldo[nI,7] := TransForm(aSaldo[nI,7],PesqPict("D14","D14_QTDES2",TamSX3("D14_QTDES2")[1]))
			If !Empty(aSaldo[nI,3])	//-- Se possui lote, busca potencia para poder gatilhar
				SB8->(MsSeek(xFilial("SB8")+cProduto+aSaldo[nI,1]+aSaldo[nI,3]+If(Rastro(cProduto,"S"),aSaldo[nI,4],"")))
				aAdd(aSaldo[nI],SB8->B8_POTENCI)
			Else
				aAdd(aSaldo[nI],0)
			EndIf
		Next nI
		aArrayF4 	:= Aclone(aSaldo)
		If !Empty(aArrayF4)
			If !Empty(aArrayF4[1][5])
				lShowNSeri := .T.
			EndIf
		EndIf
	Else
		aPosSBF := SBF->(GetArea())
		dbSelectArea("SBF")
		cChave2 := xFilial( "SBF" ) + cProduto + cLocal
		cCompara:= "BF_FILIAL+BF_PRODUTO+BF_LOCAL"
		dbSetOrder(2)
		If lLote
			If Rastro(cProduto,"S")
				cCompara+="+BF_LOTECTL+BF_NUMLOTE"
				cChave2 +=cLoteCtl + cNumLote
			Else
				cCompara+="+BF_LOTECTL"
				cChave2 +=cLoteCtl
			EndIf
		EndIf
		dbSeek(cChave2)
		While !SBF->( Eof() ) .And. cChave2 == &(cCompara)
			If !Empty(cOP)
				aSldEmp := SldEmpOP(SBF->BF_PRODUTO,SBF->BF_LOCAL,SBF->BF_LOTECTL,SBF->BF_NUMLOTE,cOP,SBF->BF_LOCALIZ,SBF->BF_NUMSERI,"L")
			EndIf
			nSaldoLoc  := SBF->BF_QUANT - (SBF->BF_EMPENHO-aSldEmp[1]+AvalQtdPre("SBF",1))
			nSaldoLoc2 := SBF->BF_QTSEGUM - (SBF->BF_EMPEN2-aSldEmp[2]+AvalQtdPre("SBF",1,.T.))
			If QtdComp(nSaldoLoc,.t.) > QtdComp(0)
				nScan := AScan( aUsado, { |x| x[1] == SBF->BF_LOCALIZ .And. If(lLote,If(Rastro(cProduto,"S"),x[3]==SBF->BF_LOTECTL.And.x[4]==SBF->BF_NUMLOTE,x[3]==SBF->BF_LOTECTL),.T.) .And. x[5] == If(nPosNumSer>0,SBF->BF_NUMSERI,"")} )
				If nScan <> 0
					nSaldoLoc  -= aUsado[ nScan, 2 ]
					nSaldoLoc2 -= ConvUM(cProduto, aUsado[ nScan, 2 ], 0, 2)
				EndIf
			EndIf
			If QtdComp(nSaldoLoc,.t.) > 0
				dDtValid   := CTOD('  /  /  ')
				nPotencia  := 0
				If Rastro(cProduto)
					dbSelectArea("SB8")
					dbSetOrder(3)
					If dbSeek(xFilial("SB8")+cProduto+SBF->BF_LOCAL+SBF->BF_LOTECTL+If(Rastro(cProduto,"S"),SBF->BF_NUMLOTE,""))
						If lVldDtLote .And. SB8->B8_DATA > dDataBase
							dbSelectArea("SBF")
							SBF->( dbSkip() )
							Loop
						EndIf
						dDtValid:=B8_DTVALID
						nPotencia:=B8_POTENCI
					EndIf
				EndIf
				dbSelectArea("SBF")
				AAdd(aArrayF4NS,{SBF->BF_LOCALIZ,SBF->BF_NUMSERI,TransForm(nSaldoLoc,PesqPict("SBF","BF_QUANT",13)),TransForm(nSaldoLoc2,PesqPict("SBF","BF_QUANT",13)),SBF->BF_LOTECTL,SBF->BF_NUMLOTE,dDtValid,nPotencia})
				AAdd(aArrayF4,{SBF->BF_LOCALIZ,TransForm(nSaldoLoc,PesqPict("SBF","BF_QUANT",13)),TransForm(nSaldoLoc2,PesqPict("SBF","BF_QUANT",13)),SBF->BF_LOTECTL,SBF->BF_NUMLOTE,dDtValid,nPotencia})
				If !Empty(SBF->BF_NUMSERI)
					lShowNSeri := .T.
				EndIf
			EndIf
			SBF->( dbSkip() )
		EndDo
		RestArea(aPosSBF)
	EndIf
	If lShowNSeri
		aArrayF4:=ACLONE(aArrayF4NS)
	EndIf
	If ExistBlock("MTVLDLOC")
		aDelArrF4 := ExecBlock("MTVLDLOC",.F.,.F.,ACLONE(aArrayF4))
		If ValType(aDelArrF4) == "A" .And. Len(aDelArrF4) > 0
			For nX := 1 To Len(aDelArrF4)
				If lShowNSeri
					nPos := aScan(aArrayF4,{|x| x[1] == aDelArrF4[nX][1] .And. x[2] == aDelArrF4[nX][2] .And. x[5] == aDelArrF4[nX][5] .And. x[6] == aDelArrF4[nX][6] .And. x[7] == aDelArrF4[nX][7]})
				Else
					nPos := aScan(aArrayF4,{|x| x[1] == aDelArrF4[nX][1] .And. x[4] == aDelArrF4[nX][4] .And. x[5] == aDelArrF4[nX][5] .And. x[6] == aDelArrF4[nX][6]})
				Endif
				If nPos > 0
					Adel(aArrayF4,nPos)
					ASize(aArrayF4,Len(aArrayF4)-1)
				Endif
			Next
		Endif
	EndIf
	If Len( aArrayF4 ) > 0

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ponto de entrada utilizado para manipular a ordem do array aArrayF4 |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lMTF4LOC
			aArrayAux := ExecBlock('MTF4LOC', .F., .F., {aArrayF4})
			If ValType(aArrayAux) == 'A'  .And. Len(aArrayF4) == Len(aArrayAux)
				aArrayF4 := aClone(aArrayAux)
			EndIf
		EndIf

		nOpcA := 0
		cCadastro := OemToAnsi(STR0016)  //"Saldos por Localizacao"
		DEFINE MSDIALOG oDlg TITLE cCadastro From 09,0 To 33,75 OF oMainWnd
		@ 1.1,  .7  Say OemToAnsi(STR0004)  //"Produto :"
		@ 1  , 3.8  MSGet cProduto SIZE 150,10 When .F.
		If lShowNSeri
			If lWms
				If cProg == "WMSA332A" .And. WmsX312118("D14","D14_IDUNIT")
					@ 2.4,.7 LISTBOX oQual VAR cVar Fields HEADER RetTitle("D14_LOCAL"),OemToAnsi(STR0017),RetTitle("D14_LOTECT"),RetTitle("D14_NUMLOT"),OemToAnsi(STR0028),OemToAnsi(STR0018),OemToAnsi(STR0040),RetTitle("D14_DTVALD"),RetTitle("D14_PRODUT"),RetTitle("D14_IDUNIT") SIZE 285,140 ON DBLCLICK (nOpca := 1,oDlg:End()) //"Localizacao"###"Numero de Serie"###"Saldo"###"Saldo 2aUM"
				Else
					@ 2.4,.7 LISTBOX oQual VAR cVar Fields HEADER RetTitle("D14_LOCAL"),OemToAnsi(STR0017),RetTitle("D14_LOTECT"),RetTitle("D14_NUMLOT"),OemToAnsi(STR0028),OemToAnsi(STR0018),OemToAnsi(STR0040),RetTitle("D14_DTVALD"),RetTitle("D14_PRODUT") SIZE 285,140 ON DBLCLICK (nOpca := 1,oDlg:End()) //"Localizacao"###"Numero de Serie"###"Saldo"###"Saldo 2aUM"
				EndIf
			Else
			@ 2.4,.7 LISTBOX oQual VAR cVar Fields HEADER OemToAnsi(STR0017),OemToAnsi(STR0028),OemToAnsi(STR0018),OemToAnsi(STR0040),RetTitle("BF_LOTECTL"),RetTitle("BF_NUMLOTE"),RetTitle("B8_DTVALID") SIZE 285,140 ON DBLCLICK (nOpca := 1,oDlg:End()) //"Localizacao"###"Numero de Serie"###"Saldo"###"Saldo 2aUM"
			EndIf
		Else
			If lWms
				If cProg == "WMSA332A" .And. WmsX312118("D14","D14_IDUNIT")
					@ 2.4,.7 LISTBOX oQual VAR cVar Fields HEADER RetTitle("D14_LOCAL"),OemToAnsi(STR0017),RetTitle("D14_LOTECT"),RetTitle("D14_NUMLOT"),OemToAnsi(STR0018),OemToAnsi(STR0040),RetTitle("D14_DTVALD"),RetTitle("D14_PRODUT"),RetTitle("D14_IDUNIT") SIZE 285,140 ON DBLCLICK (nOpca := 1,oDlg:End()) //"Localizacao"###"Numero de Serie"###"Saldo"###"Saldo 2aUM"
				Else
					@ 2.4,.7 LISTBOX oQual VAR cVar Fields HEADER RetTitle("D14_LOCAL"),OemToAnsi(STR0017),RetTitle("D14_LOTECT"),RetTitle("D14_NUMLOT"),OemToAnsi(STR0018),OemToAnsi(STR0040),RetTitle("D14_DTVALD"),RetTitle("D14_PRODUT") SIZE 285,140 ON DBLCLICK (nOpca := 1,oDlg:End()) //"Localizacao"###"Numero de Serie"###"Saldo"###"Saldo 2aUM"
				EndIf
			Else
			@ 2.4,.7 LISTBOX oQual VAR cVar Fields HEADER OemToAnsi(STR0017),OemToAnsi(STR0018),OemToAnsi(STR0040),RetTitle("BF_LOTECTL"),RetTitle("BF_NUMLOTE"),RetTitle("B8_DTVALID") SIZE 285,140 ON DBLCLICK (nOpca := 1,oDlg:End()) //"Localizacao"###"Saldo"###"Saldo 2aUM"
		EndIf
	EndIf
	oQual:SetArray(aArrayF4)
	If lShowNSeri
		If lWms
			If cProg == "WMSA332A" .And. WmsX312118("D14","D14_IDUNIT")
				oQual:bLine:={ ||{aArrayF4[oQual:nAT,1],aArrayF4[oQual:nAT,2],aArrayF4[oQual:nAT,3],aArrayF4[oQual:nAT,4],aArrayF4[oQual:nAT,5],aArrayF4[oQual:nAT,6],aArrayF4[oQual:nAT,7],aArrayF4[oQual:nAT,8],aArrayF4[oQual:nAT,9],aArrayF4[oQual:nAT,11]}}
			Else
				oQual:bLine:={ ||{aArrayF4[oQual:nAT,1],aArrayF4[oQual:nAT,2],aArrayF4[oQual:nAT,3],aArrayF4[oQual:nAT,4],aArrayF4[oQual:nAT,5],aArrayF4[oQual:nAT,6],aArrayF4[oQual:nAT,7],aArrayF4[oQual:nAT,8],aArrayF4[oQual:nAT,9]}}
			EndIF
		Else
		oQual:bLine:={ ||{aArrayF4[oQual:nAT,1],aArrayF4[oQual:nAT,2],aArrayF4[oQual:nAT,3],aArrayF4[oQual:nAT,4],aArrayF4[oQual:nAT,5],aArrayF4[oQual:nAT,6],aArrayF4[oQual:nAT,7]}}
		EndIf
	Else
		If lWms
			If cProg == "WMSA332A" .And. WmsX312118("D14","D14_IDUNIT")
				oQual:bLine:={ ||{aArrayF4[oQual:nAT,1],aArrayF4[oQual:nAT,2],aArrayF4[oQual:nAT,3],aArrayF4[oQual:nAT,4],aArrayF4[oQual:nAT,6],aArrayF4[oQual:nAT,7],aArrayF4[oQual:nAT,8],aArrayF4[oQual:nAT,9],aArrayF4[oQual:nAT,11]}}
			Else
				oQual:bLine:={ ||{aArrayF4[oQual:nAT,1],aArrayF4[oQual:nAT,2],aArrayF4[oQual:nAT,3],aArrayF4[oQual:nAT,4],aArrayF4[oQual:nAT,6],aArrayF4[oQual:nAT,7],aArrayF4[oQual:nAT,8],aArrayF4[oQual:nAT,9]}}
			EndIf
		Else
		oQual:bLine:={ ||{aArrayF4[oQual:nAT,1],aArrayF4[oQual:nAT,2],aArrayF4[oQual:nAT,3],aArrayF4[oQual:nAT,4],aArrayF4[oQual:nAT,5],aArrayF4[oQual:nAT,6]}}
		EndIf
	EndIf
	DEFINE SBUTTON FROM 06  ,264  TYPE 1 ACTION (nOpca := 1,oDlg:End()) ENABLE OF oDlg
	DEFINE SBUTTON FROM 18.5,264  TYPE 2 ACTION oDlg:End() ENABLE OF oDlg
	ACTIVATE MSDIALOG oDlg VALID (nOAT := oQual:nAT,.T.) CENTERED

	If nOpca == 1
		If lShowNSeri
			If lWms
				cLocEnd := aArrayF4[ nOAT, 2 ]
				cNumSeri  := aArrayF4[ nOAT, 5 ]
				cLoteCtl  := aArrayF4[ nOAT, 3 ]
				cNUMLote  := aArrayF4[ nOAT, 4 ]
				dDtValid  := aArrayF4[ nOAT, 8 ]
				nPotencia := aTail(aArrayF4[ nOAT ])
				cQuant    := aArrayF4[ nOAT, 6 ]
				If  WmsX312118("D14","D14_IDUNIT")
					cIdUnit   := aArrayF4[ nOAT, 11 ]
					cCodUnit  := aArrayF4[ nOAT, 12 ]
				EndIf
			Else
				cLocEnd := aArrayF4[ nOAT, 1 ]
				cNumSeri  := aArrayF4[ nOAT, 2 ]
				cLoteCtl  := aArrayF4[ nOAT, 5 ]
				cNUMLote  := aArrayF4[ nOAT, 6 ]
				dDtValid  := aArrayF4[ nOAT, 7 ]
				nPotencia := aArrayF4[ nOAT, 8 ]
				cQuant    := aArrayF4[ nOAT, 3 ]
				cQuant    := StrTran( cQuant, ".", ""  )
				cQuant    := StrTran( cQuant, ",", "." )
				nQuantLoc := Val( cQuant )
			EndIf
		Else
			If lWms
				cLocEnd := aArrayF4[ nOAT, 2 ]
				cLoteCtl  := aArrayF4[ nOAT, 3 ]
				cNUMLote  := aArrayF4[ nOAT, 4 ]
				dDtValid  := aArrayF4[ nOAT, 8 ]
				nPotencia := aTail(aArrayF4[ nOAT ])
				cQuant    := aArrayF4[ nOAT, 6 ]
				cQtSegU   := aArrayF4[ nOAT, 7 ]
				If  WmsX312118("D14","D14_IDUNIT")
					cIdUnit   := aArrayF4[ nOAT, 11 ]
				EndIf
			Else
				cLocEnd := aArrayF4[ nOAT, 1 ]
				cLoteCtl  := aArrayF4[ nOAT, 4 ]
				cNUMLote  := aArrayF4[ nOAT, 5 ]
				dDtValid  := aArrayF4[ nOAT, 6 ]
				nPotencia := aArrayF4[ nOAT, 7 ]
				cQuant    := aArrayF4[ nOAT, 2 ]
				cQtSegU   := aArrayF4[ nOAT, 3 ]
			EndIf
			If UPPER(AllTrim(GetSrvProfString("PictFormat", ""))) == "AMERICAN"
			 	cQuant    := StrTran( cQuant, ",", ""  )
			 	cQtSegU   := StrTran( cQtSegU, ",", ""  )
				nQuantLoc :=  Val( cQuant )
			Else
				cQuant    := StrTran( cQuant, ".", ""  )
				cQuant    := StrTran( cQuant, ",", "." )
				cQtSegU   := StrTran( cQtSegU, ".", ""  )
				cQtSegU   := StrTran( cQtSegU, ",", "." )
				nQuantLoc := Val( cQuant )
				nQtLoc2U  := Val( cQtSegU )
			EndIf
		EndIf
	EndIf
Else
	Help( " ", 1, "F4LOCALIZ" )
EndIf

	If !Empty(cLocEnd) .Or. !Empty(cNumSeri)
		If cProg == "A175" .And. nPosLocLz > 0
			&cReadVar := IIF("D7_LOCALIZ"$cReadVar,cLocEnd,cNumSeri)
			aCols[n,nPosLocLz] := cLocEnd
			nPosSerie:= Ascan(aHeader,{|x| AllTrim(x[2])=="D7_NUMSERI" })
			If nPosSerie > 0
				aCols[n,nPosSerie] := cNumSeri
			Endif
		ElseIf cProg == "A260"
			&cReadVar := cLocEnd
			If Type("cNumSerie") == "C" .And. !Empty(cNumSeri)
				cNumSerie := cNumSeri
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Carrega o numero de serie caso esteja no browse - MATA685   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Type("aCols") == "A" .And. !Empty(cNumSeri)
				If lShowNSeri .And. aScan(aHeader,{|x|AllTrim(x[2])=='BC_NUMSERI'}) > 0
					aCols[n, aScan(aHeader,{|x|AllTrim(x[2])=='BC_NUMSERI'}) ] := cNumSeri
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Carrega o numero de serie caso esteja no browse - MATA650   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Type("aCols") == "A" .And. !Empty(cNumSeri)
				If lShowNSeri .And. aScan(aHeader,{|x|AllTrim(x[2])=='DC_NUMSERI'}) > 0
					aCols[n, aScan(aHeader,{|x|AllTrim(x[2])=='DC_NUMSERI'}) ] := cNumSeri
				EndIf
			EndIf
		ElseIf cProg == "A261"
			aCols[n, nPosLote]   := cNumLote
			If lEndOrig
				aCols[n, nPosLotCtl] := cLoteCtl
				aCols[n, nPosDValid] := dDtValid
				aCols[n, nPosDtVldD] := dDtValid
			Else
				aCols[n, nPosLotDes] := cLoteCtl
				aCols[n, nPosDtVldD] := dDtValid
			Endif
			aCols[n, nPos261Pot] := nPotencia
			If Type("nPosnSer") == "N" .And. nPosnSer > 0
				aCols[n, nPosnSer]   := cNumSeri
			EndIf
			If nPos261Loc > 0
				If lNumSerie
					aCols[n, 5] := cLocEnd
				Else
					aCols[n, nPos261Loc] := cLocEnd
				EndIf
			EndIf
			If lNumSerie
				&cReadVar := cNumSeri
			Else
				&cReadVar := cLocEnd
			EndIf
		ElseIf cProg == "A265"
			aCols[n, nPosNumSer] := cNumSeri
			aCols[n, nPosLocali] := cLocEnd
			If Valtype("cReadVar") == "C"
				If SubStr(cReadVar,4,10) == "DB_LOCALIZ"
					&cReadVar := cLocEnd
				ElseIf SubStr(cReadVar,4,10) == "DB_NUMSERI"
					&cReadVar := cNumSeri
				EndIf
			EndIf
		ElseIf cProg $ "A430"
			aCols[ n, nPosLocaliza ] := cLocEnd
			M->C0_LOCALIZ            := cLocEnd
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Carrega o numero de serie caso esteja no browse             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lShowNSeri .And. !Empty( nPosNumSer )
				aCols[ n, nPosNumSer ] := cNumSeri
				M->C0_NUMSERI := cNumSeri
			EndIf
		ElseIf cProg $ "A440/A410"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Carrega o lote e sublote                                    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lWmsNew .And. IntWMS(cProduto)
				If Rastro(cProduto,"S")
					aCols[n, nPosNumLote] := cNumLote
					M->C6_NUMLOTE         := cNumLote
				EndIf
				If Rastro(cProduto,"L")
					aCols[n, nPosLoteCtl] := cLoteCtl
					M->C6_LOTECTL         := cLoteCtl
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Carrega o numero de serie caso esteja no browse             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lShowNSeri
				If !Empty( nPosNumSer )
					aCols[ n, nPosNumSer ] := cNumSeri
					M->C6_NUMSERI := cNumSeri 
				Elseif Empty( nPosNumSer ) .And. !Empty( cNumSeri )
					Help("",1,"A410ESTUSADO",,STR0273,1,0)
					lRet := .F.
				EndIf
			EndIf
			If lRet
				aCols[ n, nPosLocaliza ] := cLocEnd
				M->C6_LOCALIZ            := cLocEnd
			EndIf
		ElseIf cProg $ "A467/A468"
			aCols[ n, nPosLocaliza ] := cLocEnd
			M->D2_LOCALIZ            := cLocEnd
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Carrega o numero de serie caso esteja no browse             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lShowNSeri .And. !Empty( nPosNumSer )
				aCols[ n, nPosNumSer ] := cNumSeri
				M->D2_NUMSERI := cNumSeri
			EndIf

		ElseIf cProg $ "A462"
			aCols[ n, nPosLocaliza ] := cLocEnd
			M->CN_LOCALIZ            := cLocEnd
		ElseIf cProg == "A240"
			nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "D3_LOCALIZ" } )
			If nEndereco > 0
				aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := cLocEnd
				M->D3_LOCALIZ := cLocEnd
				If !Empty(dDtValid)
					M->D3_DTVALID := dDtValid
				EndIf
			EndIf
			If ExistTrigger("D3_LOCALIZ")
				RunTrigger(1,NIL,NIL,"D3_LOCALIZ")
			Endif
			If lShowNSeri
				nNumSerie := Ascan(aGets,{ |x| Subs(x,9,10) == 'D3_NUMSERI' } )
				If nNumSerie > 0
					aTela[Val(Subs(aGets[nNumSerie],1,2))][Val(Subs(aGets[nNumSerie],3,1))*2] := cNumSeri
					M->D3_NUMSERI := cNumSeri
				EndIf
				If ExistTrigger('D3_NUMSERI')
					RunTrigger(1,NIL,NIL,'D3_NUMSERI')
				Endif
			EndIf
			nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "D3_LOTECTL" } )
			If nEndereco > 0
				aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := cLoteCtl
				M->D3_LOTECTL := cLoteCtl
			EndIf
			nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "D3_NUMLOTE" } )
			If nEndereco > 0
				aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := cNumLote
				M->D3_NUMLOTE := cNumLote
			EndIf
		ElseIf cProg == "A241"
			If nPos241Loc > 0
				aCols[n, nPos241Loc] := cLocEnd
			EndIf
			If nPosLote > 0
				aCols[n,nPosLote] := cNumLote
			EndIf
			If nPosLotCTL > 0
				aCols[n,nPosLotCTL] := cLoteCtl
			EndIf
			&cReadVar := cLocEnd
			If lShowNSeri
				If nPosNumSer > 0
					aCols[n, nPosNumSer] := cNumSeri
				EndIf
			EndIf
			If Type("nPosDValid") == "N" .And. nPosDValid > 0
				aCols[n,nPosDValid] := dDtValid
			EndIf
		ElseIf cProg == "A270"
			nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_LOCALIZ" } )
			If nEndereco > 0
				aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := cLocEnd
				M->B7_LOCALIZ := cLocEnd
			EndIf
			If lShowNSeri
				nNumSerie := Ascan(aGets,{ |x| Subs(x,9,10) == 'B7_NUMSERI' } )
				If nNumSerie > 0
					aTela[Val(Subs(aGets[nNumSerie],1,2))][Val(Subs(aGets[nNumSerie],3,1))*2] := cNumSeri
					M->B7_NUMSERI := cNumSeri
				EndIf
			EndIf
		ElseIf cProg == "A242"
			&cReadVar := cLocEnd
			If Type("cNumSerie") == "C"
				cNumSerie := cNumSeri
			EndIf
			If Type("cNumLote") == "C"
				cNumLote  := cNumLote
			EndIf
			If Type("cLoteDigi") == "C"
				cLoteDigi := cLoteCtl
			EndIf
			If Type("dDtValid2") == "D"
				dDtValid2  := dDtValid
			EndIf
		ElseIf cProg == "A242C"
			&cReadVar := cLocEnd
			If Type("cNumSerie") == "C"
				aCols[n,aScan(aHeader,{|x|AllTrim(x[2])=='D3_NUMSERI'})] := cNumSeri
			EndIf
			If Type("cNumLote") == "C"
				aCols[n,aScan(aHeader,{|x|AllTrim(x[2])=='D3_NUMLOTE'})]  := cNumLote
			EndIf
			If Type("cLoteDigi") == "C"
				aCols[n,aScan(aHeader,{|x|AllTrim(x[2])=='D3_LOTECTL'})] := cLoteCtl
			EndIf
			If Type("dDtValid2") == "D"
				aCols[n,aScan(aHeader,{|x|AllTrim(x[2])=='D3_DTVALID'})]  := dDtValid
			EndIf
		ElseIf cProg == "A275"
			nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "DD_LOCALIZ" } )
			If nEndereco > 0
				aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := cLocEnd
				M->DD_LOCALIZ := cLocEnd
			EndIf
			nSeriSDD := Ascan(aGets,{ |x| Subs(x,9,10) == "DD_NUMSERI" } )
			If nSeriSDD > 0
				aTela[Val(Subs(aGets[nSeriSDD],1,2))][Val(Subs(aGets[nSeriSDD],3,1))*2] := cNumSeri
				M->DD_NUMSERI := cNumSeri	
			EndIf
		ElseIf cProg == "A380"
			&cReadVar := cLocEnd
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Carrega o numero de serie caso esteja no browse             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lShowNSeri .And. aScan(aHeader,{|x|AllTrim(x[2])=='DC_NUMSERI'}) > 0
				aCols[ n, aScan(aHeader,{|x|AllTrim(x[2])=='DC_NUMSERI'}) ] := cNumSeri
				M->DC_NUMSERI := cNumSeri
			EndIf
		ElseIf cProg == "A381"
			&cReadVar := cLocEnd
			aCols[n,aScan(aHeader,{|x|AllTrim(x[2])=='DC_LOCALIZ'})] := cLocEnd
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Carrega o numero de serie caso esteja no browse             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lShowNSeri .And. aScan(aHeader,{|x|AllTrim(x[2])=='DC_NUMSERI'}) > 0
				aCols[n, aScan(aHeader,{|x|AllTrim(x[2])=='DC_NUMSERI'}) ] := cNumSeri
			EndIf
		ElseIf cProg == "ATEC"
			nEndereco:= Ascan(aHeader,{|x| AllTrim(x[2])=="ABA_LOCALI" })
			aCols[n,nEndereco] := cLocEnd
			&cReadVar          := cLocEnd
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Carrega o numero de serie caso esteja no browse             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nPosNumSer:= Ascan(aHeader,{|x| AllTrim(x[2])=="ABA_NUMSER" })
			If lShowNSeri .And. !Empty( nPosNumSer )
				aCols[ n, nPosNumSer ] := cNumSeri
				M->ABA_NUMSER := cNumSeri
			EndIf
   		ElseIf cProg == "A310"
	   		&cReadVar := cLocEnd
			If Type("cNumSerie") == "C"
				cNumSerie := cNumSeri
			EndIf
			If Type("cNumLote") == "C"
				cNumLote  := cNumLote
			EndIf
			If Type("cLoteDigi") == "C"
				cLoteDigi := cLoteCtl
			EndIf
			If Type("dDtValid2") == "D"
				dDtValid2  := dDtValid
			EndIf
		ElseIf cProg == "A311"
			l311Gtl := .F.
			FwFldPut("NNT_LOCALI","")
			FwFldPut("NNT_NSERIE","")
			c311Lote   := cLoteCtl
			c311SLote  := cNUMLote
			d311DtVld  := dDtValid
			c311NumSer := cNumSeri
			c311LocEnd := cLocEnd

			FwFldPut("NNT_LOCALI",c311LocEnd)

			If !Empty(c311NumSer)
				M->NNT_NSERIE := c311NumSer
			EndIf

			l311Gtl := .T.

		ElseIf cProg == "A314"
			FwFldPut("CZP_CDLC",cLocEnd)
			IF !Empty(cNumSeri)
				FwFldPut("CZP_SERIE",cNumSeri)
			EndIF
			IF !Empty(cLoteCtl)
				FwFldPut("CZP_CDLO",cLoteCtl)
			EndIF
		ElseIf cProg == 'DLA220'
			&cReadVar := cLocEnd
		ElseIf cProg == 'WMSA332A'
			&cReadVar := cLocEnd
			If WmsX312118("D12","D12_IDUNIT")
				M->D12_IDUNIT := cIdUnit
			EndIf
			M->D12_LOTECTL:= cLoteCtl
			M->D12_NUMLOT := cNumLote
		ElseIf cProg == 'AGR900'
			&(ReadVar()) := cLocEnd
		ElseIf cProg == "ACDI011"
			MV_PAR02 := cQuant
			MV_PAR07 := dDtValid
			MV_PAR09 := cLocEnd
		EndIf

		If nQuant > nQuantLoc
			If cProg == "A175"
				aCols[n,nPosQuant]:= nQuantLoc
				aCols[n,nPosQt2U] := nQtLoc2U
			ElseIf cProg == "A260"
				&cReadVar := cLocEnd
			ElseIf cProg == "A261"
				If nPos261Qtd > 0
					aCols[n, nPosQuant] := nQuantLoc
				EndIf
				M->D3_QUANT := nQuantLoc
			ElseIf cProg $ "A430"
				aCols[ n, nPosQuant ] := nQuantLoc
				M->C0_QUANT           := nQuantLoc
			ElseIf cProg $ "A440/A410"
				If !lSelLote
					If cProg == "A410"
						If aCols[ n, nPosQuant ] <> nQuantLoc
							aCols[ n, nPosQuant ] := nQuantLoc
							A410Multt("M->C6_PRCVEN", nPrcVen)
						EndIf
						M->C6_QUANT           := nQuantLoc
					Else
						aCols[ n, nPosQuant ] := nQuantLoc
						M->C6_QTDLIB          := nQuantLoc
					EndIf
				EndIf
			ElseIf cProg == "A240"
				nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "D3_QUANT" } )
				If nEndereco > 0
					aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := nQuantLoc
					M->D3_QUANT := nQuantLoc
				EndIf
			ElseIf cProg == "A241"
				// Somente altera a coluna da quantidade se o programa for
				// diferente do MATA185 - Baixa de Pre-requisicoes
				If (nPos241Qtd > 0) .And. !l185
					aCols[n, nPos241Qtd] := nQuantLoc
				EndIf
				M->D3_QUANT := nQuantLoc
			ElseIf cProg == "A270"
				nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_QUANT" } )
				If nEndereco > 0
					aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := nQuantLoc
					M->B7_QUANT := nQuantLoc
				EndIf
			ElseIf cProg == "A242" .Or. cProg == "A242C"
				&cReadVar := cLocEnd
			ElseIf cProg == "A310"
				&cReadVar := cLocEnd
				nQuant:= nQuantLoc
			ElseIf cProg == "A275"
				nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "DD_QUANT" } )
				If nEndereco > 0
					aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := nQuantLoc
					M->DD_QUANT := nQuantLoc
				EndIf
			ElseIf cProg == "ATEC"
				nEndereco := Ascan(aHeader,{|x| AllTrim(x[2])=="ABA_QUANT" })
				If ( nEndereco > 0 )
					aCols[n,nEndereco] := nQuantLoc
				EndIf
			EndIf
		EndIf
	EndIf

	RestArea(aAreaSB8)
EndIf
RestArea(aArea)
SetFocus(nHdl)
Return .T.

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³VldLocaliz³ Autor ³Sergio Silveira        ³ Data ³ 24/11/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Validacao do campo Localizacao                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpL1 := VldLocaliz( ExpC1 )                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 -> Programa origem                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpL1 -> .T. -> valido / .F. -> nao valido                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function VldLocaliz( cProg )

LOCAL cProduto
LOCAL cLocaliza
LOCAL cLocal
LOCAL cIni     := "C6"
LOCAL cNumSeri
LOCAL cLoteCtl
LOCAL cNumLote
LOCAL cChave
LOCAL cLoteAux
LOCAL cNLoteAux
LOCAL nX         := 0

LOCAL nPosLocaliz
LOCAL nPosQuant
LOCAL nPosValor
LOCAL nPosNumSer
LOCAL nPosProd
LOCAL nPosNumLot

LOCAL nQuant
LOCAL nSaldo   := 0
LOCAL nFindEnd	:= 0
LOCAL nQtdVen
LOCAL lRet     := .F.
LOCAL lRetPE   := .F.
LOCAL lWmsNew  := .F.
LOCAL bComp
Local aSaldos		:= {}
Local aAreaAnt
Local oSaldoWMS

Static __cIniNSer
cLocaliza := &( ReadVar() )
cProg     := If( ValType( cProg ) <> "C", "A430", cProg )
lWmsNew	:= SuperGetMV("MV_WMSNEW",.F.,.F.) .And. IntWMS()

If cProg == "A430"
	cIni := "C0"
ElseIf cProg $ "A467/A468"
	cIni:="D2"
Elseif cProg=="A462"
	cIni:="CN"
ElseIf cProg $ "A410/A440"
	cProg := "A440"
	cIni := "C6"
	If __cIniNSer == NIL
		__cIniNSer := Space(TamSX3("C6_NUMSERI")[1])
	EndIf
	cNumSeri := __cIniNSer
ElseIf cProg $  "O011" // GC - Gestão de Concessionárias
	cIni := "VS3"
EndIf

For nX := 1 To Len( aHeader )
	If AllTrim( aHeader[ nX, 2 ] )     == cIni + "_PRODUTO" .Or. ;
		AllTrim( aHeader[ nX, 2 ] )     == cIni + "_COD"
		cProduto     := aCols[ n, nX ]
		nPosProd     := nX
	ElseIf AllTrim( aHeader[ nX, 2 ] ) == cIni + "_LOCALIZ" .Or. ;
		(cProg $ "O011" .And. Alltrim(aHeader[nx,2]) == cIni + "_LOCALI") // GC - Gestão de Concessionárias
		nPosLocaliz  := nX
	ElseIf AllTrim( aHeader[ nX, 2 ] ) == cIni + "_LOCAL"
		cLocal       := aCols[ n, nX ]
	ElseIf AllTrim( aHeader[ nX, 2 ] ) == cIni + "_QTDVEN"
		nQtdVen       := aCols[ n, nX ]
	ElseIf AllTrim( aHeader[ nX, 2 ] ) == cIni + "_QUANT" .Or. ;
		(cProg $ "O011" .And. Alltrim(aHeader[nx,2]) == cIni + "_QTDITE") // GC - Gestão de Concessionárias
		nQuant       := aCols[ n, nX ]
		nPosQuant    := nX
	ElseIf AllTrim( aHeader[ nX, 2 ] ) == cIni + "_QTDLIB" .And. cProg == "A440"
		nQuant       := aCols[ n, nX ]
		nPosQuant    := nX
	ElseIf AllTrim( aHeader[ nX, 2 ] ) == cIni + "_NUMSERI" .Or. ;
		(cProg $ "O011" .And. Alltrim(aHeader[nx,2]) == cIni + "_NUMSER") // GC - Gestão de Concessionárias
		cNumSeri     := aCols[ n, nX ]
		nPosNumSer   := nX
	ElseIf AllTrim( aHeader[ nX, 2 ] ) == cIni + "_LOTECTL" .Or. ;
		(cProg $ "O011" .And. Alltrim(aHeader[nx,2]) == cIni + "_LOTECT") // GC - Gestão de Concessionárias
		cLoteCtl     := aCols[ n, nX ]
		nPosLotCt    := nX
	ElseIf AllTrim( aHeader[ nX, 2 ] ) == cIni + "_NUMLOTE" .Or. ;
		(cProg $ "O011" .And. Alltrim(aHeader[nx,2]) == cIni + "_NUMLOT") // GC - Gestão de Concessionárias
		cNumLote     := aCols[ n, nX ]
		nPosNumLot   := nX
	ElseIf AllTrim( aHeader[ nX, 2 ] ) == "C6_VALOR"
		nPosValor    := nX
	EndIf
Next nX

// GC - Gestão de Concessionárias
If cProg $ "O011"
	SB1->(DBSetOrder(7)) // GC não trabalha com _COD ou _PRODUTO. No caso, utiliza-se GRUPO+CODITE
	If (SB1->(DBSeek(xFilial("SB1")+M->VS3_GRUITE + M->VS3_CODITE)))
		cProduto := SB1->B1_COD
	EndIf
EndIf

If Localiza( cProduto,.T.)
	If Empty( cLocaliza )
		lRet := .T.
	Else
		If lWmsNew .And. IntWMS(cProduto)
			//Protege o Alias antes da chamada do método WMS
			aAreaAnt := GetArea()
			oSaldoWMS := WMSDTCEstoqueEndereco():New()
			//Consulta o Saldo do Endereço no WMS
			aSaldos  := oSaldoWMS:GetSldEnd(cProduto,cLocal,cLocaliza,cLoteCtl,cNumLote,cNumSeri,1)//cPrdOri,cLocal,cEnder,cLote,cSubLote,cNumSer,nOrdem
			nFindEnd := aScan(aSaldos,  {|x| x[2] == cLocaliza})
			nSaldo   := IIf( nFindEnd == 0,0,aSaldos[nFindEnd][6])
			cLoteAux := IIf( nFindEnd == 0,"",aSaldos[nFindEnd][3])
			cNLoteAux:= IIf( nFindEnd == 0,"",aSaldos[nFindEnd][4])
			//Recupera o Alias
			RestArea(aAreaAnt)
			If nSaldo < nQtdVen
				Help(" ",1,"SALDOLOCLZ")
				nSaldo := 0
				lRet:=.F.
			EndIf
		Else
		SBF->( dbSetOrder( 1 ) )

		If Rastro( cProduto, "S" )
			cVar  := cLoteCtl + cNumLote
			bComp := { || SBF->BF_LOTECTL + SBF->BF_NUMLOTE }
		Else
			cVar  := cLoteCtl
			bComp := { || SBF->BF_LOTECTL }
		EndIf

		If Empty( cVar )
			cChave := xFilial( "SBF" ) + cLocal + cLocaliza + cProduto ;
				+ cNumSeri
		Else
			cChave := xFilial( "SBF" ) + cLocal + cLocaliza + cProduto ;
				+ cNumSeri + cVar
		EndIf

		If SBF->( dbSeek( cChave ) )

			nSaldo := 0

			If Empty( cVar )
				While !SBF->( Eof() ) .And. cChave == SBF->BF_FILIAL + SBF->BF_LOCAL+;
						SBF->BF_LOCALIZ + SBF->BF_PRODUTO + SBF->BF_NUMSERI
					nSaldo += SBF->BF_QUANT - (SBF->BF_EMPENHO+AvalQtdPre("SBF",1))
					SBF->( dbSkip() )
				EndDo
			Else
				While !SBF->( Eof() ) .And. cChave == SBF->BF_FILIAL + SBF->BF_LOCAL+;
						SBF->BF_LOCALIZ + SBF->BF_PRODUTO + SBF->BF_NUMSERI + ;
						Eval( bComp )
					nSaldo += SBF->BF_QUANT - (SBF->BF_EMPENHO+AvalQtdPre("SBF",1))
					SBF->( dbSkip() )
				EndDo
			EndIf
			EndIf
		EndIf
			If !Empty( nSaldo )
				lRet   := .T.
				If nQuant > nSaldo
					aCols[ n, nPosQuant ] := nSaldo
					If cIni == "C0"
						M->C0_QUANT  := nSaldo
					ElseIf cIni == "C6"
						If cProg == "A440"
							M->C6_QTDLIB := nSaldo
						EndIf
				EndIf
			ElseIf cIni = "C6"
				aCols[ n, nPosLocaliz ] := cLocaliza
				M->C6_LOCALIZ            := cLocaliza
				If lWmsNew .And. IntWMS(cProduto)
					If Empty(aCols[ n, nPosLotCt ])
						aCols[ n, nPosLotCt ]    := cLoteAux
						M->C6_LOTECTL            := cLoteAux
					EndIf
					If Empty(aCols[ n, nPosNumLot ])
						aCols[ n, nPosNumLot ]   := cNLoteAux
						M->C6_NUMLOTE            := cNLoteAux
					EndIf
				EndIf
	EndIf
Else
	If cIni == "C0"
		aCols[ n, nPosLocaliz ] := CriaVar( "C0_LOCALIZ" )
		M->C0_LOCALIZ           := CriaVar( "C0_LOCALIZ" )
	ElseIf cIni == "C6"
		aCols[ n, nPosLocaliz ] := CriaVar( "C6_LOCALIZ" )
		M->C6_LOCALIZ           := CriaVar( "C6_LOCALIZ" )
	EndIf
EndIf
	EndIf
Else
	If cIni == "C0"
		aCols[ n, nPosLocaliz ] := CriaVar( "C0_LOCALIZ" )
		M->C0_LOCALIZ           := CriaVar( "C0_LOCALIZ" )
	ElseIf cIni == "C6"
		aCols[ n, nPosLocaliz ] := CriaVar( "C6_LOCALIZ" )
		M->C6_LOCALIZ           := CriaVar( "C6_LOCALIZ" )
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³    !!! ATENCAO !!! O PONTO DE ENTRADA A SEGUIR NAO DEVE SER DOCUMENTADO !!!    ³
//³ A UTILIZACAO INDEVIDA DESTE PONTO DE ENTRADA PODE CAUSAR DIVERGENCIA DE SALDOS ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de entrada para possibilitar manipulacao na validacao do Endereço no momento da Liberação do Pedido de Vendas ³
//³ Parametros:                                                                                                         ³
//³ PARAMIXB[1] = Retorno logico atual                                                                                  ³
//³ PARAMIXB[2] = cProg (programa origem de onde a funcao foi chamada. Pode ser A430, A467, A468, A462, A410 ou A440)   ³
//³ Retorno:                                                                                                            ³
//³ lRet     = Retorno logico que sera utilizado como retorno da funcao de validacao de Enderecos.                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock('VLDENDFA') //-- Valida Endereco para Faturamento
	lRetPE := ExecBlock('VLDENDFA', .F., .F., {lRet, cProg})
	If Valtype(lRetPE) == 'L'
		lRet := lRetPE
	EndIf
EndIf

Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ BloqData ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 28/11/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Programa de Bloqueio de Lotes por Data de Validade         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ BloqData(ExpL1)                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpL1 = Flag que indica se deve bloquear independentemente ³±±
±±³          ³         da data preenchida no parametro                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function BloqData(lBloqueia, lAuto)
Static lMTBLQLOT := ExistBlock("MTBLQLOT")
Static lMTDTLOT  := ExistBlock( 'MTDTLOT' )
Local aAreaAnt	:= GetArea()
Local aAreaSB8	:= {}
Local aAreaSB8a	:= {}
Local cProduto	:= ''
Local cSeekSB8	:= ''
Local cCompSB8	:= ''
Local cCondPE	:= ''
Local cCondBloq	:= ''
Local cPrdWMS   := ''
Local cFilSB8	:= ''
Local cLocaliz  := ''
Local cNumSeri  := ''
Local dDataUltV  := StoD( '' )
Local nDoc		:= 0
Local nQtdBloq	:= 0
Local nQtdBloq2	:= 0
Local nRecSB8	:= 0
Local aDadosMail := {}
Local lRetPE	:= .T.
Local nTipoData	:= SuperGetMV("MV_TDATALO",.F.,1)
Local lEmpPrev	:= If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)
Local cNumLote	:= ""
Local cSubLt    := Space(TamSX3('B8_NUMLOTE')[1])
Local cQuery	:= ""
Local cQrySDD   := ''
Local cAlSDD    := ''
Local aQrySDD   := {}
Local nRecSDD   := 0
Local cAliasTmp	:= ""
Local lRastro	:= .F.
Local lWmsNew   := SuperGetMV('MV_WMSNEW', .F., .F.)
Local nY := 0

Private dDataConf  := If(nTipoData==1,dDataBase,Date())

Default lAuto := .F.

aAreaSB8  := SB8->(GetArea())
cFilSB8   := xFilial('SB8')
lBloqueia := If(lBloqueia==Nil, .F., lBloqueia)

//-- Se necessario, atualiza a Data da éltima Verifica‡Æo
If (dDataUltV:=GetMV('MV_DATALOT'))<dDataConf
	PutMV('MV_DATALOT',DtoC(dDataConf))
EndIf

If dDataUltV<dDataConf .Or. lBloqueia

	//-- Ponto de Entrada para permitir a Altera‡Æo da Condi‡Æo de Bloqueio
	If lMTDTLOT
		cCondBloq := 'B8_DTVALID<dDataConf'
		cCondPE := ExecBlock('MTDTLOT', .F., .F., cCondBloq)
		If ValType(cCondPE)=='C'
			cCondBloq := cCondPE
		EndIf
	Else
		cCondBloq := "B8_DTVALID<'"+dtos(dDataConf)+"' "
	EndIf

	dbSelectArea('SB8')
	dbSetOrder(3)
	If !lAuto
		ProcRegua(LastRec())
	EndIf
	cAliasTmp := GetNextAlias()
	cQuery := ""
	cQuery += " SELECT B8_PRODUTO "
	cQuery += " 	,B8_LOCAL "
	cQuery += " 	,B8_LOTECTL "
	cQuery += " 	,B8_NUMLOTE "
	cQuery += " 	,B8_DATA "
	cQuery += " 	,B8_DTVALID "
	cQuery += "     ,Coalesce(BF_LOCALIZ, '"+Space(TamSX3('BF_LOCALIZ')[1])+"') BF_LOCALIZ "
	cQuery += "     ,Coalesce(BF_NUMSERI, '"+Space(TamSX3('BF_NUMSERI')[1])+"') BF_NUMSERI "
	cQuery += " 	,SUM(B8_QTDORI) B8_QTDORI "
	cQuery += " 	,SUM(B8_SALDO) B8_SALDO "
	cQuery += " 	,SUM(B8_EMPENHO) B8_EMPENHO "
	cQuery += " 	,SUM(B8_QEMPPRE) B8_QEMPPRE "
	cQuery += " 	,SUM(B8_QACLASS) B8_QACLASS "
	cQuery += " 	,SUM(B8_SALDO2) B8_SALDO2 "
	cQuery += " 	,SUM(B8_QTDORI2) B8_QTDORI2 "
	cQuery += " 	,SUM(B8_EMPENH2) B8_EMPENH2 "
	cQuery += " 	,SUM(B8_QEPRE2) B8_QEPRE2 "
	cQuery += " 	,SUM(B8_QACLAS2) B8_QACLAS2 "
	cQuery += " 	,MIN(SB8.R_E_C_N_O_) B8RECNO "
	cQuery += " FROM "+RetSQLName("SB8")+ " SB8 "
	cQuery += " Left Join "+RetSQLName("SBF")+" SBF On "
	cQuery += " SBF.BF_FILIAL  = '"+xFilial("SBF")+"' And "
	cQuery += " SBF.BF_PRODUTO = B8_PRODUTO And "
	cQuery += " SBF.BF_LOCAL   = B8_LOCAL   And "
	cQuery += " SBF.BF_LOTECTL = B8_LOTECTL And "
	cQuery += " SBF.BF_NUMLOTE = B8_NUMLOTE And "
	cQuery += " SBF.D_E_L_E_T_ = ' ' "
	cQuery += " WHERE B8_FILIAL = '"+xFilial("SB8")+"' "
	If !lMTDTLOT
		cQuery += " 	AND " + cCondBloq
	EndIf
	cQuery += " 	AND SB8.D_E_L_E_T_ = ' ' "
	cQuery += " GROUP BY B8_PRODUTO "
	cQuery += " 	,B8_LOCAL "
	cQuery += " 	,B8_LOTECTL "
	cQuery += " 	,B8_NUMLOTE "
	cQuery += " 	,B8_DATA "
	cQuery += " 	,B8_DTVALID "
	cQuery += "     ,BF_LOCALIZ "
	cQuery += "     ,BF_NUMSERI "
	cQuery += " ORDER BY B8_PRODUTO "
	cQuery += " 	,B8_LOCAL "
	cQuery += " 	,B8_LOTECTL "
	cQuery += " 	,B8_NUMLOTE "
	cQuery := ChangeQuery(cQuery)
	dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery) , cAliasTmp, .T., .F. )
	TcSetField(cAliasTmp, "B8_DATA","D",8,0)
	TcSetField(cAliasTmp, "B8_DTVALID","D",8,0)

	//Usado abaixo para localizar SDD
	cQrySDD := " Select R_E_C_N_O_ DDREC From "+RetSqlName('SDD')+" "
	cQrySDD += "  Where DD_FILIAL  = ? "
	cQrySDD += "    And DD_PRODUTO = ? "
	cQrySDD += "    And DD_LOCAL   = ? "
	cQrySDD += "    And DD_LOTECTL = ? "
	cQrySDD += "    And DD_NUMLOTE = ? "
	cQrySDD += "    And DD_MOTIVO  = ? "
	cQrySDD += "    And DD_LOCALIZ = ? "
	cQrySDD += "    And DD_NUMSERI = ? "
	cQrySDD += "    And D_E_L_E_T_ = ' ' "
	cQrySDD := ChangeQuery(cQrySDD)

	Do While !(cAliasTmp)->(Eof())
		// Verifica produto para envio de e-mail
		If (cAliasTmp)->B8_PRODUTO # cProduto
			If !Empty(cProduto) .And. Len(aDadosMail) > 0
				SB1->(dbSetOrder(1))
				SB1->(MsSeek(xFilial("SB1")+cProduto))
				MEnviaMail("008",{cProduto,SB1->B1_DESC,aDadosMail})
				cEventID  := "008"
				cMensagem := STR0261 + AllTrim(cProduto) +" - "+ AllTrim(SB1->B1_DESC) + STR0271 //" teve o(s) seguinte(s) lote(s) bloqueado(s) por vencimento:"
				For nY:=1 to Len(aDadosMail)		
					cMensagem +=  CRLF
					cMensagem += STR0157 //"Lote: " 
					cMensagem += AllTrim(aDadosMail[nY,1]) + If(!Empty(aDadosMail[nY,2])," - "+STR0158+ AllTrim(aDadosMail[nY,2]),"") 
				Next nY
				EventInsert( FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID, FW_EV_LEVEL_INFO, "", STR0272, cMensagem, .T. )
				aDadosMail := {}
			EndIf
			cProduto := (cAliasTmp)->B8_PRODUTO
			lRastro := Rastro((cAliasTmp)->B8_PRODUTO,'S')
		EndIf
		nQtdBloq   := 0
		nQtdBloq2  := 0
		nRecSB8    := (cAliasTmp)->B8RECNO

		If lRastro
			cNumLote := (cAliasTmp)->B8_NUMLOTE
		Else
			cNumLote := cSubLt
		EndIf
		cLocaliz := (cAliasTmp)->BF_LOCALIZ
		cNumSeri := (cAliasTmp)->BF_NUMSERI

		cSeekSB8   := (cAliasTmp)->B8_PRODUTO+(cAliasTmp)->B8_LOCAL+(cAliasTmp)->B8_LOTECTL+cNumLote
		cCompSB8   := "B8_PRODUTO+B8_LOCAL+B8_LOTECTL+If(Rastro(B8_PRODUTO,'S'),B8_NUMLOTE,'"+cSubLt+"')"
		
		cPrdWMS := SB8->B8_PRODUTO
		If !(lWmsNew .And. IntWms(cPrdWMS))
			cSeekSB8   += cLocaliz+cNumSeri
			cCompSB8   += "+BF_LOCALIZ+BF_NUMSERI"
		EndIf

		Do While !(cAliasTmp)->(Eof()) .And. cSeekSB8==(cAliasTmp)->(&cCompSB8)
			If !lAuto
				IncProc()
			EndIf
			//-- Caso deva ser bloqueado soma a quantidade disponivel
			If !lMTDTLOT .OR. (lMTDTLOT .and. &(cCondBloq))
				If (Empty(cLocaliz) .And. Empty(cNumSeri)) .Or. (lWmsNew .And. IntWms(cPrdWMS))
					nQtdBloq += SB8Saldo(.F.,.T.,NIL,,cAliasTmp,lEmpPrev)
					nQtdBloq2+= SB8Saldo(.F.,.T.,NIL,.T.,cAliasTmp,lEmpPrev)
				Else
					nQtdBloq += SB8SBFSld((cAliasTmp)->B8_PRODUTO, (cAliasTmp)->B8_LOCAL, (cAliasTmp)->B8_LOTECTL, cNumLote, cLocaliz, cNumSeri, .F., lEmpPrev, dDataConf)
					nQtdBloq2+= SB8SBFSld((cAliasTmp)->B8_PRODUTO, (cAliasTmp)->B8_LOCAL, (cAliasTmp)->B8_LOTECTL, cNumLote, cLocaliz, cNumSeri, .T., lEmpPrev, dDataConf)
				EndIf
			EndIf
			(cAliasTmp)->(dbSkip())
		EndDo
		//-- Ponto de entrada antes do bloqueio de lotes por data de validade
		lRetPE := .T.
		If lMTBLQLOT
			lRetPE := ExecBlock( "MTBLQLOT", .F., .F., {nRecSB8} )
			lRetPE := If(ValType(lRetPE)=="L",lRetPE,.T.)
		EndIf

		If lRetPE .And. QtdComp(nQtdBloq)>QtdComp(0)
			aAreaSB8a := SB8->(GetArea())
			SB8->(MsGoto(nRecSB8))
			If lWmsNew .And. IntWms(SB8->B8_PRODUTO)
				PrcWMSBloq(nRecSB8, nQtdBloq)
				AADD(aDadosMail,{SB8->B8_LOTECTL,cNumLote})			
			Else	
				nDoc := CntNumSDD("SDD","DD_DOC")
				
				dbSelectArea('SDD')
				dbSetOrder(2) //DD_FILIAL+DD_PRODUTO+DD_LOCAL+DD_LOTECTL+DD_NUMLOTE+DD_MOTIVO
				If Rastro(SB8->B8_PRODUTO,'S')
					cRastro := SB8->B8_NUMLOTE
				Else
					cRastro := CriaVar('B8_NUMLOTE')
				EndIF

				aQrySDD := {}
				AAdd(aQrySDD, FWXFilial('SDD'))
				AAdd(aQrySDD, SB8->B8_PRODUTO)
				AAdd(aQrySDD, SB8->B8_LOCAL)
				AAdd(aQrySDD, SB8->B8_LOTECTL)
				AAdd(aQrySDD, cRastro)
				AAdd(aQrySDD, 'VV')
				AAdd(aQrySDD, cLocaliz)
				AAdd(aQrySDD, cNumSeri)

				cAlSDD := GetNextAlias()

				DBUseArea(.T., "TOPCONN", TCGenQry2(NIL,NIL, cQrySDD, aQrySDD ), (cAlSDD) , .F., .T. )

				nRecSDD := 0
				If !(cAlSDD)->(EoF())
					nRecSDD := (cAlSDD)->DDREC
				EndIf

				(cAlSDD)->(DbCloseArea())
				ASize(aQrySDD, 0)

				dbSelectArea('SDD')
				dbSetOrder(2) //DD_FILIAL+DD_PRODUTO+DD_LOCAL+DD_LOTECTL+DD_NUMLOTE+DD_MOTIVO

				//If dbSeek(xFilial('SDD')+SB8->B8_PRODUTO+SB8->B8_LOCAL+SB8->B8_LOTECTL+cRastro+'VV'+cLocaliz+cNumSeri, .F.)
				If nRecSDD > 0
					SDD->(DbGoto(nRecSDD))
					nQtdBloq += DD_SALDO
					nQtdBloq2+= DD_SALDO2
					Reclock('SDD', .F.)
					If QtdComp(nQtdBloq)>QtdComp(DD_QTDORIG)
						Replace DD_QTDORIG With nQtdBloq
					EndIf
				Else
					Reclock('SDD', .T.)
					Replace DD_FILIAL  With xFilial('SDD')
					Replace DD_DOC     With nDoc
					Replace DD_PRODUTO With SB8->B8_PRODUTO
					Replace DD_LOCAL   With SB8->B8_LOCAL
					Replace DD_LOTECTL With SB8->B8_LOTECTL
					Replace DD_NUMLOTE With cRastro
					Replace DD_DTVALID With SB8->B8_DTVALID
					Replace DD_MOTIVO  With 'VV'
					Replace DD_QTDORIG With nQtdBloq
					Replace DD_LOCALIZ With cLocaliz
					Replace DD_NUMSERI With cNumSeri
				EndIf
				Replace DD_SALDO   With nQtdBloq
				Replace DD_QUANT   With nQtdBloq
				Replace DD_SALDO2  With ConvUM(SDD->DD_PRODUTO,nQtdBloq,nQtdBloq2,2)
				Replace DD_QTSEGUM With ConvUM(SDD->DD_PRODUTO,nQtdBloq,nQtdBloq2,2)
				MsUnlock()
				// Array utilizado para envio de e-mail
				AADD(aDadosMail,{DD_LOTECTL,DD_NUMLOTE})
				ProcSDD(.F.)
			EndIf
			RestArea(aAreaSB8a)
		EndIf
	EndDo
	(cAliasTmp)->(dbCloseArea())
	dbSelectArea('SB8')

	// Verifica produto para envio de e-mail
	If !Empty(cProduto) .And. Len(aDadosMail) > 0
		SB1->(dbSetOrder(1))
		SB1->(MsSeek(xFilial("SB1")+cProduto))
		MEnviaMail("008",{cProduto,SB1->B1_DESC,aDadosMail})
		cEventID  := "008"
		cMensagem := STR0261 + AllTrim(cProduto) +" - "+ AllTrim(SB1->B1_DESC) + STR0271 //" teve o(s) seguinte(s) lote(s) bloqueado(s) por vencimento:"
		For nY:=1 to Len(aDadosMail)		
			cMensagem +=  CRLF
			cMensagem += STR0157 //"Lote: " 
			cMensagem += AllTrim(aDadosMail[nY,1])+If(!Empty(aDadosMail[nY,2])," - "+STR0158+AllTrim(aDadosMail[nY,2]),"") 
		Next nY
		EventInsert( FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID, FW_EV_LEVEL_INFO, "", STR0272, cMensagem, .T. )
		aDadosMail := {}
	EndIf
EndIf
RestArea(aAreaSB8)
RestArea(aAreaAnt)
Return .T.

/*/{Protheus.doc} SB8SBFSld
	Retorna o Saldo a bloquear (empenhar) da SBF, para gravação na SDD (bloqueios por lote)
	@type  Function
	@author Gianluca Moreira
	@since 18/12/2021
	/*/
Static Function SB8SBFSld(cProduto, cLocal, cLote, cSubLote, cLocaliz, cNumSeri, lSegUM, lEmpPrevisto, dDataRef)
	Local aArea     := GetArea()
	Local aAreaSB8  := SB8->(GetArea())
	Local aAreaSBF  := SBF->(GetArea())
	Local aAreas    := {aAreaSB8, aAreaSBF, aArea}
	Local nSaldo    := 0
	Local aSaldoOP  := {0, 0}
	Local cAliasSB8 := "SB8"
	Local cAliasSBF := "SBF"
	Local nTipoData	:= SuperGetMV("MV_TDATALO",.F.,1)

	Default dDataRef     := If(nTipoData==1,dDataBase,Date())
	Default lSegUM       := .F.
	Default lEmpPrevisto := .F.
	
	//Validar se vencido
	
	SB8->(DbSetOrder(3)) //B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL+B8_NUMLOTE+DTOS(B8_DTVALID)
	If SB8->(DbSeek(FWXFilial('SB8')+cProduto+cLocal+cLote+cSubLote))
		If SB8->B8_DTVALID < dDataRef //Lote Vencido
			SBF->(DbSetOrder(1)) //BF_FILIAL+BF_LOCAL+BF_LOCALIZ+BF_PRODUTO+BF_NUMSERI+BF_LOTECTL+BF_NUMLOTE
			If SBF->(DbSeek(FWXFilial('SBF')+cLocal+cLocaliz+cProduto+cNumSeri+cLote+cSubLote))
				If lSegUM
					nSaldo	:= (cAliasSBF)->BF_QTSEGUM-((cAliasSBF)->BF_EMPEN2+AvalQtdPre("SBF",1,.T.,cAliasSBF,lEmpPrevisto))
				Else
					nSaldo	:= (cAliasSBF)->BF_QUANT-((cAliasSBF)->BF_EMPENHO+AvalQtdPre("SBF",1,NIL,cAliasSBF,lEmpPrevisto))
				EndIf
			EndIf
		EndIf
	EndIf
	
	AEVal(aAreas, {|x| RestArea(x)})
Return(nSaldo)

/*/{Protheus.doc} PergDLTVal
	Retorna a validação do conteudo preenchido do parametro MV_PERGDLT
	@type  Function
	@author SQUAD Entradas
	@since 13/06/2022
/*/
Function PergDLTVal()

Local lRetorno as logical

lRetorno := .F.

	IF Val(M->X6_CONTEUD) >= 0
		IF Val(M->X6_CONTSPA) >= 0
			IF Val(M->X6_CONTENG) >= 0
				lRetorno := .T.
			else
				HELP(" ",1,STR0257,,STR0256,02,01)
			ENDIF
		else
			HELP(" ",1,STR0257,,STR0254,02,01)
		EndIf
	else
		HELP(" ",1,STR0257,,STR0255,02,01)
	ENDIF

Return lRetorno
                                                                                                 
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o   ³PergDevLoc³Autor³Rodrigo de A. Sartorio ³ Data ³ 02/12/97         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o³ Pergunta se deve devolver para as localizacoes ou se deve        ³±±
±±³         ³ voltar para distribuicao                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe  ³ExpL1:=PergDevLoc(ExpC1,ExpC2,ExpN1,ExpC3,ExpC4,ExpC5,ExpC6,ExpC7)³±±
±±ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro³ ExpL1 = Flag que indica se deve devolver para a localizacao      ³±±
±±³         ³ ExpC1 = Alias origem do movimento                                ³±±
±±³         ³ ExpC2 = Codigo do Produto                                        ³±±
±±³         ³ ExpN1 = Quantidade do movimento                                  ³±±
±±³         ³ ExpC3 = Documento do movimento                                   ³±±
±±³         ³ ExpC4 = Item do movimento                                        ³±±
±±³         ³ ExpC5 = Localizacao do movimento                                 ³±±
±±³         ³ ExpC6 = Numero de Serie                                          ³±±
±±³         ³ ExpC7 = Almoxarifado do movimento                                ³±±
±±³         ³ ExpN2 = Forca a acao para tomar quando se apaga uma saida        ³±±
±±³         ³         com localizacao fisica (Sobrepoe o parametro             ³±±
±±³         ³         MV_PDEVLOC)                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso     ³ Estoque/PCP/Compras/Faturamento                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function PergDevLoc(cAlias,cProd,nQuant,cDoc,cItem,cLocaliza,cNumSerie,cAlmox,nDefault, lRmOrdSep )
LOCAL lRet := .F.
LOCAL cLinha1:="",cLinha2:="",cLinha3:="",cLinha4:="",cLinha5:=""
LOCAL cOldAlias:=Alias(),nOldRecno:=Recno(),nOldOrder:=IndexOrd()
LOCAL oDlg, cRetTitle
LOCAL nTimeOut  := GetMV("MV_PERGDLT",.F.,0)*1000
LOCAL oTimer,oSay
LOCAL aAreasd3:={}
LOCAL lRelibWMS  := (SuperGetMV('MV_WMSRELI', .F., '1')=='2')

DEFAULT nDefault  := GetMV("MV_PDEVLOC")
DEFAULT lRmOrdSep := .F.

If Type("lResDevLoc") == "U"
	Private lResDevLoc := .F.
EndIf

If Type('l685Auto')=="L"
	//Não ocorrer abertura de tela quando o item controla endereço e o mata685 foi executado pelo autoexec
	if l685Auto
		Default := 0
	else
		DEFAULT nDefault := GetMV("MV_PDEVLOC")
	EndIf
else
	DEFAULT nDefault := GetMV("MV_PDEVLOC")
EndIf

//Se houver a execucao do MATA261, MATA250 ou MATA241 por execauto, utilizar o parametro para definir a acao
If (Type('lAutoma261')=="L"  .AND. lAutoma261) .OR. (Type('l250Auto')=="L"  .AND. l250Auto) .OR. (Type('l241Auto')=="L"  .AND. l241Auto)
	If nDefault >= 1

		nDefault := 1

	Else
		nDefault := 0
	EndIf
EndIf

// Se a devolucao for de RE5 OU se utilizar WMS para o Produto usar localizacao original (nDefaul==1)
If cAlias == "SD3"
	If IntWMS(cProd)
		nDefault := 1
	Else
		cNumSeq := SD3->D3_NUMSEQ
		aAreaSD3:=SD3->(GetArea())
		SD3->(dbSetOrder(2))
		SD3->(MsSeek(xFilial("SD3")+cDoc+cProd))
		While !Eof() .And. xFilial("SD3")+cDoc+cProd == SD3->D3_FILIAL+SD3->D3_DOC+SD3->D3_COD
			If SD3->D3_CF == "RE5" .And. !Empty(SD3->D3_OP) .And. cNumSeq == SD3->D3_NUMSEQ .And. nQuant == SD3->D3_QUANT
				nDefault := 1
				Exit
			EndIf
			SD3->(dbSkip())
		EndDo
		RestArea(aAreaSD3)
	EndIf
ElseIf cAlias == 'SD2'
	If IntWMS(cProd) .And. (lRelibWMS .OR. (IsInCallStack('MaDelNfs') .And. MV_PAR04==2))
		nDefault := 1
	EndIf
EndIf

If cPaisLoc <> "BRA"
	If (AllTrim(FunName()) $ "MATA521|MATA462N") .Or.;
		(Type('lLocxAuto') <> "U" .And. lLocxAuto) //Se for rotina aut. distribui para a loc. original. (LOCXNF)
		If !lCarteira
			nDefault:=1
		EndIf
	Endif
Endif

// Verifica se o produto pode utilizar a localizacao
If nDefault != 0
	nDefault:=If(ProdLocali(cProd,cAlmox,cLocaliza),nDefault,0)
EndIf

// Verifica se o produto tem capacidade para utilizar a localizacao
If nDefault != 0
	nDefault:=If(Capacidade(cAlmox,cLocaliza,nQuant,cProd),nDefault,0)
EndIf

If nDefault == 2
	// Movimentos Internos
	If cAlias == "SD3"
		cLinha1:= OemToAnsi(STR0022+Alltrim(cProd)+STR0023)   //"O produto "###" usa controle de localiza‡„o e teve o"
		cLinha2:= OemToAnsi(STR0024+cDoc+STR0025+Alltrim(Str(nQuant,10,2))+STR0026)   //"movimento do Documento "###" de "###" estornado. Deve voltar …"
		cLinha3:= OemToAnsi(STR0027+Alltrim(cLocaliza)+STR0028+Alltrim(cNumserie))  //"localizacao original "###" Numero de S‚rie "
		cLinha4:= OemToAnsi(STR0029)  //"ou ser redistribuido ?"
		// Estorno da Producao
	ElseIf cAlias == "SC2"
		cLinha1:= OemToAnsi(STR0022+Alltrim(cProd)+STR0023)   //"O produto "###" usa controle de localiza‡„o e teve o"
		cLinha2:= OemToAnsi(STR0030+cDoc+STR0025+Alltrim(Str(nQuant,10,2))+STR0026)   //"movimento da OP "###" de "###" estornado. Deve voltar …"
		cLinha3:= OemToAnsi(STR0027+Alltrim(cLocaliza)+STR0028+Alltrim(cNumserie))  //"localizacao original "###" Numero de S‚rie "
		cLinha4:= OemToAnsi(STR0029)  //"ou ser redistribuido ?"
		// Nota Fiscal de Saida
	ElseIf cAlias == "SD2"
		cLinha1:= OemToAnsi(STR0022+Alltrim(cProd)+STR0023)   //"O produto "###" usa controle de localiza‡„o e teve o"
		cLinha2:= OemToAnsi(STR0031+cDoc+STR0032+cItem+STR0025+Alltrim(Str(nQuant,10,2))+STR0026) //"movimento da Nota Fiscal "###" Item "###" de "###" estornado. Deve voltar …"
		cLinha3:= OemToAnsi(STR0027+Alltrim(cLocaliza)+STR0028+Alltrim(cNumserie))  //"localizacao original "###" Numero de S‚rie "
		cLinha4:= OemToAnsi(STR0029)  //"ou ser redistribuido ?"
		// Remision
	ElseIf cAlias == "SCN"
		cRetTitle := Rtrim(RetTitle("CN_REMITO"))
		cLinha1:= OemToAnsi(STR0022+Alltrim(cProd)+STR0023)   //"O produto "###" usa controle de localiza‡„o e teve o"
		cLinha2:= OemToAnsi(STR0051+cRetTitle+cDoc+STR0032+cItem+STR0025+Alltrim(Str(nQuant,10,2))+STR0026) //"movimento da Nota Fiscal "###" Item "###" de "###" estornado. Deve voltar …"
		cLinha3:= OemToAnsi(STR0027+Alltrim(cLocaliza)+STR0028+Alltrim(cNumserie))  //"localizacao original "###" Numero de S‚rie "
		cLinha4:= OemToAnsi(STR0029)  //"ou ser redistribuido ?"
	EndIf
	If nTimeOut > 0
		cLinha5:=STR0106+StrZero(nTimeOut/1000,3,0)+STR0107 //"O sistema aguardara "###" segundos antes de fechar a janela"
	EndIf

	If ( IsBlind() ) //Tratamento para Nao Abrir a Dialog Quando Estiver Sendo Executada via Rotina Automatica
		lRet := .T.
	Else
		DEFINE MSDIALOG oDlg FROM  100,100 TO 275,580 TITLE OemToAnsi(STR0033) PIXEL STYLE DS_MODALFRAME OF oMainWnd   //"Tratamento de Estorno"
		@ 05,015 TO 63,230 LABEL "" OF oDlg  PIXEL
		oTimer:= TTimer():New(nTimeOut,{|| oDlg:End() },oDlg)
		oTimer:Activate()
		@ 14,025 SAY cLinha1 SIZE 180,8 OF oDlg PIXEL
		@ 24,025 SAY cLinha2 SIZE 180,8 OF oDlg PIXEL
		@ 34,025 SAY cLinha3 SIZE 180,8 OF oDlg PIXEL
		@ 44,025 SAY cLinha4 SIZE 180,8 OF oDlg PIXEL
		@ 54,025 SAY oSay VAR cLinha5 SIZE 180,8 OF oDlg PIXEL
		oSay:SetColor(CLR_HRED,GetSysColor(15))
		@ 70,120 BUTTON OemToAnsi(STR0035) ACTION IF(Capacidade(cAlmox,cLocaliza,nQuant,cProd),(oDlg:End()),) SIZE 100,11 OF oDlg PIXEL //"&Localiza‡„o Original"
		@ 70,030 BUTTON OemToAnsi(STR0034) ACTION (lRet:=.T.,oDlg:End()) SIZE 48,11 OF oDlg PIXEL  //"&Redistribuir"
		ACTIVATE MSDIALOG oDlg VALID (oTimer:End(),.T.) CENTERED
	EndIf
Else
	lRet := If(nDefault==0,.T.,.F.)
EndIf

//Variavel que Indica se o Usuario vai Redistribuir ou Nao o Saldo
//do Produto
lRmOrdSep := lRet
lResDevLoc:= lRet 

dbSelectArea(cOldAlias)
dbSetOrder(nOldOrder)
MsGoto(nOldRecno)
Return lRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ SaldoSBF ³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 12/11/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calcula o saldo do arquivo SBF                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpN1:= SaldoSBF(ExpC1,ExpC2,ExpC3,ExpC4,ExpC5,ExpC6,ExpL1,³±±
±±³          ³         ExpC7,ExpL2)                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Saldo devolvido pela funcao                        ³±±
±±³          ³ ExpC1 = Local a ter o saldo pesquisado                     ³±±
±±³          ³ ExpC2 = Localizacao a ter o saldo pesquisado               ³±±
±±³          ³ ExpC3 = Produto a ter o saldo pesquisado                   ³±±
±±³          ³ ExpC4 = Numero de Serie do produto                         ³±±
±±³          ³ ExpC5 = Lote do Produto a ter o saldo pesquisado           ³±±
±±³          ³ ExpC6 = Sub-Lote do Produto a ter o saldo pesquisado       ³±±
±±³          ³ ExpL1 = Indica se baixa ou nao o empenho                   ³±±
±±³          ³ ExpC7 = Codigo da Estrutura Fisica de Armazenagem          ³±±
±±³          ³ ExpL2 = Indica se calcula o saldo em potencia maxima ou nao³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function SaldoSBF(cAlmox,cLocaliza,cCod,cNumSerie,cLoteCtl,cLote,lBaixaEmp,cEstFis,lPotMax,cOP)
Local cAlias:=Alias(),nRecno:=Recno(),nOrder:=IndexOrd(),nRecnoSBF
Local aAreaSB8:=SB8->(GetArea())
Local nRet:=0,cSeek:="",cCompara:="",nOrderSbf
Local cAliasSBF:="SBF",cQuery:=""
Local lQuery := .F.
Local aSldEmp := {}

DEFAULT cEstFis := ""
DEFAULT lPotMax := .F.
DEFAULT cOP     := ""

cLocaliza  := If(cLocaliza==Nil.Or.Empty(cLocaliza), CriaVar('BF_LOCALIZ', .F.), cLocaliza)
cNumSerie  := If(cNumSerie==Nil.Or.Empty(cNumSerie), CriaVar('BF_NUMSERI', .F.), cNumSerie)
cLoteCtl   := If(cLoteCtl==Nil .Or.Empty(cLoteCtl) , CriaVar('BF_LOTECTL', .F.), cLoteCtl)
cLote      := If(cLote==Nil    .Or.Empty(cLote)    , CriaVar('BF_NUMLOTE', .F.), cLote)
lBaixaEmp  := If(!(ValType(lBaixaEmp)=='L'), .F., lBaixaEmp)
lPotMax    := (lPotMax.And.PotencLote(cCod))

dbSelectArea("SBF")
nRecnoSbF:=Recno()
nOrderSbf:=IndexOrd()
	lQuery    :=.T.
	SBF->(dbCommit())
	cAliasSBF := "SALDOSBF"
	cQuery    := "SELECT * FROM "+RetSqlName("SBF")+" SBF WHERE SBF.BF_FILIAL ='"+xFilial("SBF")+"' AND "
	// Considera endereco e numero de serie no filtro
	If !Empty(cLocaliza+cNumSerie)
		cQuery += "SBF.BF_LOCALIZ ='"+cLocaliza+"' AND SBF.BF_NUMSERI='"+cNumSerie+"' AND "
	EndIf
	// Considera Lote no filtro
	If !Empty(cLoteCtl)
		cQuery += "SBF.BF_LOTECTL ='"+cLoteCtl+"' AND "
	EndIf
	// Considera sub-lote no filtro
	If !Empty(cLote)
		cQuery += "SBF.BF_NUMLOTE ='"+cLote+"' AND "
	EndIf
	// Considera Estrutura fisica no filtro
	If !Empty(cEstFis)
		cQuery +="SBF.BF_ESTFIS ='"+cEstFis+"' AND "
	EndIf
	cQuery += "SBF.BF_PRODUTO ='"+cCod+"' AND SBF.BF_LOCAL='"+cAlmox+"' AND SBF.D_E_L_E_T_=' ' ORDER BY "+SqlOrder(SBF->(IndexKey()))
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSBF,.T.,.T.)
	aEval(SBF->(dbStruct()), {|x| If(x[2] <> "C", TcSetField(cAliasSBF,x[1],x[2],x[3],x[4]),Nil)})

Do While !Eof() .And. If(!lQuery,cSeek == &(cCompara),.T.)
	If !lQuery .And. (!Empty(cEstFis) .And. !(cEstFis == (cAliasSBF)->BF_ESTFIS))
		dbSkip()
		Loop
	EndIf
	If !Empty(cOP)
		aSldEmp := (cAliasSBF)->(SldEmpOP(BF_PRODUTO,BF_LOCAL,BF_LOTECTL,BF_NUMLOTE,cOP,BF_LOCALIZ,BF_NUMSERI,"L"))
	EndIf
	If lPotMax
		SB8->(dbSetOrder(3))
		If Rastro((cAliasSBF)->BF_PRODUTO,"L")
			SB8->(dbSeek(xFilial("SB8")+(cAliasSBF)->BF_PRODUTO+(cAliasSBF)->BF_LOCAL+(cAliasSBF)->BF_LOTECTL))
		ElseIf Rastro((cAliasSBF)->BF_PRODUTO,"S")
			SB8->(dbSeek(xFilial("SB8")+(cAliasSBF)->BF_PRODUTO+(cAliasSBF)->BF_LOCAL+(cAliasSBF)->BF_LOTECTL+(cAliasSBF)->BF_NUMLOTE))
		EndIf
		nRet+=A250PotMax((cAliasSBF)->BF_PRODUTO,SB8->B8_POTENCI,SBFSaldo(lBaixaEmp,cAliasSBF))
	Else
		nRet+=SBFSaldo(lBaixaEmp,cAliasSBF) + If(!Empty(cOP) .and. lBaixaEmp,aSldEmp[1],0)
	EndIf
	dbSkip()
EndDo
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fecha query criada                                                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lQuery
	dbSelectArea(cAliasSBF)
	dbCloseArea()
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Restaura areas originais                                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SBF")
MsGoto(nRecnoSBF)
dbSetOrder(nOrderSbf)
SB8->(RestArea(aAreaSB8))
dbSelectArea(cAlias)
dbSetOrder(nOrder)
MsGoto(nRecno)
Return nRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡„o    ³ SaldoSDA                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Autor     ³ Lucas                                    ³ Data ³ 02/12/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Busca o saldo a distribuir                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe    ³ ExpN1:=SaldoSDA(ExpC1,ExpC2,ExpC3)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³ ExpC1 = String com o codigo do produto                     ³±±
±±³           ³ ExpC2 = String com o local a ser pesquisado                ³±±
±±³           ³ ExpC3 = String com o lote de Controle                      ³±±
±±³           ³ ExpC4 = String com o Numero do lote                        ³±±
±±³           ³ ExpL5 = Considera Empenho                                  ³±±
±±³           ³ ExpL7 = Considera saldo a classificar                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Uso      ³ Generico Rastreabilidade                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function SaldoSDA(cProduto,cLocal,cLoteCTL,cNumLote,lBaixaEmp,lConsClas)
Local aArea := GetArea()
Local nSaldo	:= 0
Local cQuery   := ""
Local	cAliasSDA:= "SDA"

If Rastro(cProduto,"L")
	DbSelectArea("SDA")
	DbSetOrder(1)
	SDA->(dbCommit())
	cAliasSDA := "SALDOSDA"
	cQuery := "SELECT SUM(SDA.DA_SALDO) DA_SALDO, SUM(SDA.DA_EMPENHO) DA_EMPENHO FROM "+RetSqlName("SDA")+" SDA WHERE SDA.DA_FILIAL ='"+xFilial("SDA")+"' AND "
	cQuery += "SDA.DA_PRODUTO ='"+cProduto+"' AND SDA.DA_LOCAL='"+cLocal+"' AND "
	cQuery += "SDA.DA_LOTECTL='"+cLoteCtl+"' AND "
	cQuery += "SDA.D_E_L_E_T_ =' ' "
	cQuery := ChangeQuery(cQuery)
	DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSDA,.T.,.T.)
	aEval(SDA->(dbStruct()), {|x| If(x[2] <> "C", TcSetField(cAliasSDA,x[1],x[2],x[3],x[4]),Nil)})
	While ( !Eof() )
		nSaldo += ( (cAliasSDA)->DA_SALDO - If(lBaixaEmp,(cAliasSDA)->DA_EMPENHO,0) )
		DbSelectArea(cAliasSDA)
		DbSkip()
	EndDo
	//Fecha query criada                                                      ³
	(cAliasSDA)->(DbCloseArea())

ElseIf ( Rastro(cProduto,"S" ) )
	DbSelectArea("SDA")
	DbSetOrder(1)
	If ( DbSeek(xFilial("SDA")+cProduto+cLocal) )
		While !Eof() .and. DA_FILIAL == xFilial("SDA") .And. DA_PRODUTO == cProduto .and. DA_LOCAL == cLocal
			If ( DA_LOTECTL == cLoteCtl .and. DA_NUMLOTE == cNumLote )
				nSaldo += ( SDA->DA_SALDO - If(lBaixaEmp,SDA->DA_EMPENHO,0) )
			EndIf
			DbSelectArea("SDA")
			DbSkip()
		End
	EndIf
EndIf
RestArea(aArea)
Return nSaldo

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³RetCusSBD ³ Autor ³Stiefano / Rosane      ³ Data ³ 15/09/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna custo da n.f.de origem para efetuar devolucao compra³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function RetCusSBD()
LOCAL nQtdSBD:= 0
LOCAL aVFimFF:={0,0,0,0,0}
LOCAL aSBDFim[2]
LOCAL lFirst := .T.
dbSelectArea("SC6")
dbSetOrder(1)
dbSeek(xFilial("SC6")+SD2->D2_PEDIDO+SD2->D2_ITEMPV+SD2->D2_COD)
If !Empty(SD2->D2_IDENTB6)
	dbSelectArea("SD1")
	dbSetOrder(4)
	If MsSeek(xFilial("SD1")+SD2->D2_IDENTB6)
		dbSelectArea("SD8")
		dbSetOrder(3)
		dbSeek(xFilial("SD8")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_ITEM)
	EndIf
Else
	dbSelectArea("SD8")
	dbSetOrder(3)
	dbSeek(xFilial("SD8")+SD2->D2_NFORI+SD2->D2_SERIORI+SD2->D2_ITEMORI)
EndIf
If Found()
	dbSelectArea("SBD")
	dbSetOrder(2)
	If dbSeek(xFilial("SBD")+SD8->D8_SEQ)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se o item a ser devolvido ainda tem saldo    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SBD->BD_STATUS != "Z"
			lFirst:= .T.
		Else
			lFirst:= .F.
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o saldo final FIFO                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aSBDFim := BaixaSBD("SD2",lFirst)
		aVFimFF := aSBDFim[01]
		nQtdSBD := aSBDFim[02]
	EndIf
EndIf
Return aVFimFF

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GravaSBD  ³ Autor ³ Marcos / Rosane       ³ Data ³ 19/08/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava SBD com Movimentacoes                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GravaSBD(cArquivo,aCusto,cTipo,nQuant,nQuant2Um,lOnLine)

Local cTM        := ''
Local cCF        := ''
Local cTipoNF    := ''
Local cDoc       := ''
Local cSerie     := ''
Local cItem      := ''
Local cOP        := ''
Local cDocSWN    := ''
Local cItemSWN   := ''
Local cSeek      := ''
Local cSeekSD3   := ''
Local cSeekSD8   := ''
Local cFilRet    := ''

Local nOldOrder  := 0
Local nOldRecno  := 0
Local nRecSBD    := 0
Local nQtdCompl  := 0
Local nTotDev    := 0
Local nQtdDev  	 := 0
Local nQtd2UM	 := 0
Local nX		 := 0
Local nProp		 := 0
Local nDec       := 0
Local nLote		 := 1
Local nMultiplic := 1

Local lNewReg    := .T.
Local lCustoDev  := .F.
Local lEstorno   := .F.

Local aNFCompl   := {}
Local aAreaAnt   := {}
Local aAreaSD1   := {}
Local aAreaSD3   := {}
Local aAreaTRB   := {}
Local aAreaSD8   := {}
Local aAreaSBD	 := {}
Local aCustoDev  := {}
Local aCustoFF   := {}
Local aEstornoSD3:= {}

Local dPerIni    := CtoD('  /  /  ')
Local dPerFim    := CtoD('  /  /  ')
Local dData      := CtoD('  /  /  ')

Local cAlias     := Alias()
Local cNumero    := Soma1(GetMv("MV_SEQFIFO"))
Local cMoedaCM   := SuperGetMv('MV_MOEDACM',.F.,"2345")
Local cProd		 := SD1->D1_COD
Local cNfOri	 := SD1->D1_NFORI
Local cSeriOri	 := SD1->D1_SERIORI
Local cItemOri	 := SD1->D1_ITEMORI
Local ctipoOri	 := ' '
Local aDecCFFD3 := {TamSX3('D3_CUSFF1')[2], TamSX3('D3_CUSFF2')[2], TamSX3('D3_CUSFF3')[2], TamSX3('D3_CUSFF4')[2], TamSX3('D3_CUSFF5')[2]}
Local lMV_LOTCOST
Local cSeqTRB
Local cLocCQ
Local cQuery
Local cAliasSBD

Default lOnLine  := .F.

nDec := Set(3,8)

If cArquivo == "SD1"

	If SD1->D1_TES > "500"
		nMultiplic := -1
	EndIf

	If !Empty(cNfOri) .and. !Empty(cSeriOri) .and. !Empty(cItemOri)
		SD2->(dbsetorder(3))
		If SD2->(Dbseek(xfilial("SD2")+cNfOri+cSeriOri+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD+cItemOri))
			ctipoOri:= SD2->D2_TIPO
		EndIF
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona Arq. caso NF seja complementar (IPI/ICM/Despesa/Preco) ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SD1->D1_TIPO $ "CIP"
		If Empty(SD1->D1_NFORI) .And. !lOnLine
			SF8->(dbSetOrder(3))
			If SF8->(dbSeek(xFilial("SF8")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA))
				dbSelectArea("TRB")
				nOldOrder:=IndexOrd()
				nOldRecno:=Recno()
				dbSetOrder(2)
				cSeqTRB := TRB->TRB_SEQ
				If dbSeek(cFilAnt+"SD1"+cSeqTRB)
					cLocCQ := AlmoxCq()
					If TRB->TRB_LOCAL == cLocCQ
						Do While TRB_FILIAL+"SD1"+TRB_SEQ == cFilAnt+"SD1"+cSeqTRB 
							If TRB_DOC == SD1->D1_DOC .And. TRB_ITEM == SD1->D1_ITEM
								nRecSBD:=TRB->TRB_RECSBD
								If nRecSBD > 0
									lNewReg:=.F.
								EndIf
							EndIf
							Dbskip()
						EndDo
					Else
						nRecSBD:=TRB->TRB_RECSBD
						If nRecSBD > 0
							lNewReg:=.F.
						EndIf
					EndIf
				EndIf
				dbSetOrder(nOldOrder)
				MsGoto(nOldRecno)
			EndIf
		Else
			aAreaSD8 := SD8->(GetArea())
			aAreaSBD := SBD->(GetArea())
			cSeek    := SD1->D1_NFORI+SD1->D1_SERIORI+SD1->D1_ITEMORI
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//| Verifica se a FACTURA de origem vinculada a nota de complemento   |
			//| possui REMITO, pois o custo deve ser gravado no lote do documento |
			//| original, que neste caso e o remito e nao a factura               |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cPaisLoc <> "BRA"
				aAreaSD1 := SD1->(GetArea())
				dbSelectArea("SD1")
				dbSetOrder(1) // D1_FILIAL+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_COD+D1_ITEM
				// Localiza factura de origem
				SF8->(DbSetOrder(3))
				If SF8->(dbSeek(xFilial("SD1")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA))
					Do While SF8->(!Eof()) .And. SF8->F8_NFDIFRE == SD1->D1_DOC .And. SF8->F8_SEDIFRE == SD1->D1_SERIE .And. ;
					SF8->F8_TRANSP == SD1->D1_FORNECE .And. SF8->F8_LOJTRAN == SD1->D1_LOJA
						If SF8->F8_NFORIG == cNfOri .And. SF8->F8_SERORIG == cSeriOri
							Exit
						Else
							SF8->(DbSkip())
						EndIf
					EndDo
					If dbSeek(xFilial("SD1")+SF8->F8_NFORIG+SF8->F8_SERORIG+SF8->F8_FORNECE+SF8->F8_LOJA+cProd+cItemOri)
						If !Empty(SD1->D1_REMITO)
							// Dados do remito vinculado a factura de origem
							cSeek := SD1->D1_REMITO+SD1->D1_SERIREM+SD1->D1_ITEMREM
						EndIf
					EndIf
				EndIf
				RestArea(aAreaSD1)
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//| Pesquisa no SD8 pelo Lote de origem da nota de complemento para   |
			//| gravar o custo do complemento no lote correto.                    |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !Empty(cSeek)
				dbSelectArea("SD8")
				dbSetOrder(3)
				If dbSeek(xFilial("SD8")+cSeek)
					dbSelectArea("SBD")
					dbSetOrder(1) //BD_FILIAL+BD_PRODUTO+BD_LOCAL+BD_STATUS+BD_SEQ
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//| Quando BD_STATUS == ' ' existe saldo no lote      |
					//| Quando BD_STATUS == 'Z' nao existe saldo no lote  |
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If dbSeek(xFilial("SBD")+SD8->D8_PRODUTO+SD8->D8_LOCAL+' '+SD8->D8_SEQ)
						nRecSBD := SBD->(Recno())
						lNewReg:=.F.
					EndIf
				EndIf
			Else 
				dbSelectArea("SBD")
				dbSetOrder(1) //BD_FILIAL+BD_PRODUTO+BD_LOCAL+BD_STATUS+BD_SEQ
				If dbSeek(xFilial("SBD")+SD1->D1_COD+SD1->D1_LOCAL+' ')
					nRecSBD := SBD->(Recno())
					lNewReg:=.F.
				EndIf
			EndIf
			RestArea(aAreaSD8)
			RestArea(aAreaSBD)
		EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Prepara lotes Fifo/Lifo para devolucao de vendas                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	ElseIf (SD1->D1_TIPO == "D" .And. cTipo == "D") .or. ;
			((SD1->D1_TIPO == "B" .And. cTipo == "B") .or. (SD1->D1_TIPO == "N" .And. cTipo == "N" .and. ctipoOri == "B") .and. !Empty(SD1->D1_NFORI) .and. !empty(SD1->D1_SERIORI) .and. SF4->F4_PODER3 == 'D' .and. IsFifoOnLine()) // caso use a opção retornar beneficiamento
		aAreaAnt := GetArea()
		nTotDev  := SD1->D1_QUANT
		dbSelectArea("SD8")
		dbSetOrder(3)  //D8_FILIAL+D8_DOC+D8_SERIE+D8_ITEM
		dbSeek(cSeek:=xFilial("SD8")+SD1->(D1_NFORI+D1_SERIORI+D1_ITEMORI))
		Do While !Eof() .And. cSeek == xFilial("SD8")+SD8->(D8_DOC+D8_SERIE+D8_ITEM)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Nao permitida quantidades ja devolvidas                         |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SD8->D8_TM <= "500" .Or. Empty(SD8->D8_ITEM)
				dbSelectArea("SD8")
				dbSkip()
				Loop
			EndIf

			If SD8->D8_QUANT <= SD8->D8_SD1DEV
				dbSelectArea("SD8")
				dbSkip()
				Loop
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Quebra a quantidade total de devolucao de acordo com os lotes   |
			//| de entrada para respeitar o custo de cada lote Fifo/Lifo        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If QtdComp(nTotDev) > QtdComp(0)

				If QtdComp(nTotDev) > QtdComp( SD8->D8_QUANT - SD8->D8_SD1DEV )
					nQtdDev := ( SD8->D8_QUANT - SD8->D8_SD1DEV )
					nQtd2UM := ConvUm(SD8->D8_PRODUTO,nQtdDev,0,2)
					nProp	:= nQtdDev/SD8->D8_QUANT
				Else
					nQtdDev := nTotDev
					nQtd2UM := ConvUm(SD8->D8_PRODUTO,nTotDev,0,2)
					nProp	:= nQtdDev/SD8->D8_QUANT
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ aCustoDev - Array contendo as quebras e seus respectivos custos |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aAdd(aCustoDev,{SD8->D8_CUSTO1 * nProp,;
								SD8->D8_CUSTO2 * nProp,;
								SD8->D8_CUSTO3 * nProp,;
								SD8->D8_CUSTO4 * nProp,;
								SD8->D8_CUSTO5 * nProp,;
								nQtdDev,;
								nQtd2UM})

				nTotDev	  := nTotDev - ( SD8->D8_QUANT - SD8->D8_SD1DEV )
				lCustoDev := .T.

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava a quantidade de devolucao no campo D8_SD1DEV para   ³
				//| controlar as devolucoes parciais.                         |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				RecLock("SD8",.F.)
				Replace D8_SD1DEV With D8_SD1DEV + nQtdDev
				MsUnLock()

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava a quantidade de devolucao no campo D8_QFIMDEV para  ³
				//| realizar controles no fechamento Fifo.                    |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					RecLock("SD8",.F.)
					Replace D8_QFIMDEV With D8_QFIMDEV + nQtdDev
					MsUnLock()

			Else
				Exit
			EndIf
			dbSelectArea("SD8")
			dbSkip()
		EndDo

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ nLote - Define a qtde de lotes a serem gerados pela devolucao |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(aCustoDev) > 0
			nLote := Len(aCustoDev)
		EndIf

		RestArea(aAreaAnt)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Tratamento para Remito de Transferencia de Entrada            |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    ElseIf cPaisLoc <> "BRA" .And. AllTrim(SD1->D1_ESPECIE) = "RTE"

		aAreaAnt := GetArea()

		SF1->(dbSetOrder(1))
		If SF1->(dbSeek(xFilial("SF1")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA))

			cFilRet := SF1->F1_FILORIG

			dbSelectArea("SD8")
			dbSetOrder(3)  //D8_FILIAL+D8_DOC+D8_SERIE+D8_ITEM
			dbSeek(cSeek:=IIf(Empty(xFilial("SD8")),Space(2),cFilRet)+SD1->(D1_DOC+D1_SERIE+SubStr(D1_ITEM,3,2)+Space(2)))
			Do While !Eof() .And. cSeek == xFilial("SD8")+SD8->(D8_DOC+D8_SERIE+D8_ITEM)

				If SD8->D8_TM <= "500" .Or. Empty(SD8->D8_ITEM)
					dbSelectArea("SD8")
					dbSkip()
					Loop
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ aCustoDev - Array contendo as quebras e seus respectivos custos |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aAdd(aCustoDev,{	SD8->D8_CUSTO1	,;
							   		SD8->D8_CUSTO2	,;
									SD8->D8_CUSTO3	,;
									SD8->D8_CUSTO4	,;
									SD8->D8_CUSTO5	,;
									SD8->D8_QUANT	,;
									SD8->D8_QT2UM})

				dbSelectArea("SD8")
				dbSkip()
			EndDo
	    EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ nLote - Define a qtde de lotes a serem gerados pela devolucao |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(aCustoDev) > 0
			nLote 	  := Len(aCustoDev)
			lCustoDev := .T.
		EndIf

		RestArea(aAreaAnt)

	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona Arq. de moedas pela data de digitacao ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SM2")
	dbSeek(SD1->D1_DTDIGIT,.T.)
	If !Found()
		dbSkip(-1)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Pesquisa no SBD se existe Lote Fifo com qtde igual zero e com custo  |
	//| gerado por nota de complemento, caso exista nao gerar novo lote o  	 ³
	//| sistema devera agregar esta nova entrada ao mesmo lote localizado.   |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lNewReg
		aAreaSBD:=SBD->(GetArea())
		aAreaSD8:=SD8->(GetArea())
		If cPaisLoc=='RUS' .and. SuperGetMv("MV_LOTCOST ",.F.,"0")=="1"
			dbSelectArea("SBD")
			dbSetOrder(4)
			dbSeek(cSeek:=xFilial("SBD")+SD1->D1_COD+SD1->D1_LOCAL+" "+SD1->D1_LOTECTL+SD1->D1_NUMLOTE)
			Do While !Eof() .And. cSeek ==xFilial("SBD")+SBD->BD_PRODUTO+SBD->BD_LOCAL+SBD->BD_STATUS+SBD->BD_LOTECTL+SBD->BD_NUMLOTE
				If SBD->BD_QFIM == 0 .And. SBD->BD_QINI == 0
					nRecSBD  := SBD->(Recno())
					lNewReg  := .F.
					nQtdCompl:= SD1->D1_QUANT * nMultiplic
					Exit
				EndIf
				dbSelectArea("SBD")
				dbSkip()
			EndDo
		else
			cAliasSBD  := GetNextAlias()
			cQuery := "SELECT R_E_C_N_O_ RECNOSBD "
			cQuery += "FROM " + RetSqlName("SBD") + " WHERE "
			cQuery += "BD_FILIAL ='" + xFilial("SBD") + "' AND "
			cQuery += "BD_PRODUTO ='" + SD1->D1_COD	+ "' AND BD_LOCAL ='" + SD1->D1_LOCAL	+ "' AND "
			cQuery += "BD_STATUS =' ' AND BD_QINI = 0 AND BD_QFIM = 0 AND " 
			cQuery += "D_E_L_E_T_ = ' ' "
			cQuery += "ORDER BY  "+ SqlOrder( SBD->(IndexKey(1)) )
			
			cQuery := ChangeQuery( cQuery )
			dbUseArea( .T., "TOPCONN", TcGenQry( ,,cQuery ), cAliasSBD, .F., .T. )
			Do While !(cAliasSBD)->(Eof()) 
				nRecSBD  := (cAliasSBD)->RECNOSBD
				lNewReg  := .F.
				nQtdCompl:= SD1->D1_QUANT * nMultiplic
				(cAliasSBD)->(dbSkip())
			EndDo
			(cAliasSBD)->(dbCloseArea())
		endif
		RestArea(aAreaSBD)
		RestArea(aAreaSD8)
	EndIf

	lMV_LOTCOST := cPaisLoc=='RUS' .and. SuperGetMv("MV_LOTCOST ",.F.,"0")=="1"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Processa os Lotes Fifo/Lifo                              |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nX := 1 to nLote

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posiciona no local a ser atualizado                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SBD")

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posiciona no registro correto caso seja complemento   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lNewreg .And. nRecSBD > 0
			MsGoto(nRecSBD)
		EndIf

		RecLock("SBD",lNewReg)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Pega o custo do campo e soma o custo da entrada       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lNewReg
			Replace BD_FILIAL  With xFilial("SBD")
			Replace BD_PRODUTO With SD1->D1_COD
			Replace BD_LOCAL   With SD1->D1_LOCAL
			Replace BD_QUANT   With IIf(lCustoDev,aCustoDev[nX,6],SD1->D1_QUANT)   * nMultiplic
			Replace BD_QT2UM   With IIf(lCustoDev,aCustoDev[nX,7],SD1->D1_QTSEGUM) * nMultiplic
			Replace BD_DATA    With SD1->D1_DTDIGIT
			Replace BD_SEQ     With cNumero
			Replace BD_DTPROC  With IIf(lOnLine,dDataBase,a330ParamZX[01])
			Replace BD_DTCALC  With IIf(lOnLine,dDataBase,a330ParamZX[01])
			If lMV_LOTCOST
				Replace BD_LOTECTL    With SD1->D1_LOTECTL
				Replace BD_NUMLOTE    With SD1->D1_NUMLOTE
			EndIf
		EndIf

		If cTipo == NIL .And. Empty(aCustoDev)
			Replace BD_CUSFIM1 With BD_CUSFIM1 + Round(NoRound(SD1->D1_CUSTO  * nMultiplic,aDecCFFD3[1]+1),aDecCFFD3[1])
			If("2" $ cMoedaCM)
				Replace BD_CUSFIM2 With BD_CUSFIM2 + Round(NoRound(SD1->D1_CUSTO2 * nMultiplic,aDecCFFD3[2]+1),aDecCFFD3[2])
			EndIf
			If("3" $ cMoedaCM)
				Replace BD_CUSFIM3 With BD_CUSFIM3 + Round(NoRound(SD1->D1_CUSTO3 * nMultiplic,aDecCFFD3[3]+1),aDecCFFD3[3])
			EndIf
			If("4" $ cMoedaCM)
				Replace BD_CUSFIM4 With BD_CUSFIM4 + Round(NoRound(SD1->D1_CUSTO4 * nMultiplic,aDecCFFD3[4]+1),aDecCFFD3[4])
			EndIf
			If("5" $ cMoedaCM)
				Replace BD_CUSFIM5 With BD_CUSFIM5 + Round(NoRound(SD1->D1_CUSTO5 * nMultiplic,aDecCFFD3[5]+1),aDecCFFD3[5])
			EndIf
			aNFCompl   := {	Round(NoRound(SD1->D1_CUSTO  * nMultiplic,aDecCFFD3[1]+1),aDecCFFD3[1]),;
							Round(NoRound(SD1->D1_CUSTO2 * nMultiplic,aDecCFFD3[2]+1),aDecCFFD3[2]),;
							Round(NoRound(SD1->D1_CUSTO3 * nMultiplic,aDecCFFD3[3]+1),aDecCFFD3[3]),;
							Round(NoRound(SD1->D1_CUSTO4 * nMultiplic,aDecCFFD3[4]+1),aDecCFFD3[4]),;
							Round(NoRound(SD1->D1_CUSTO5 * nMultiplic,aDecCFFD3[5]+1),aDecCFFD3[5])}
		Else
			Replace BD_CUSFIM1 With BD_CUSFIM1 + Round(NoRound(IIf(lCustoDev,aCustoDev[nX,1],aCusto[1]) * nMultiplic,aDecCFFD3[1]+1),aDecCFFD3[1])
			If("2" $ cMoedaCM)
				Replace BD_CUSFIM2 With BD_CUSFIM2 + Round(NoRound(IIf(lCustoDev,aCustoDev[nX,2],aCusto[2]) * nMultiplic,aDecCFFD3[2]+1),aDecCFFD3[2])
			EndIf
			If("3" $ cMoedaCM)
				Replace BD_CUSFIM3 With BD_CUSFIM3 + Round(NoRound(IIf(lCustoDev,aCustoDev[nX,3],aCusto[3]) * nMultiplic,aDecCFFD3[3]+1),aDecCFFD3[3])
			EndIf
			If("4" $ cMoedaCM)
				Replace BD_CUSFIM4 With BD_CUSFIM4 + Round(NoRound(IIf(lCustoDev,aCustoDev[nX,4],aCusto[4]) * nMultiplic,aDecCFFD3[4]+1),aDecCFFD3[4])
			EndIf
			If("5" $ cMoedaCM)
				Replace BD_CUSFIM5 With BD_CUSFIM5 + Round(NoRound(IIf(lCustoDev,aCustoDev[nX,5],aCusto[5]) * nMultiplic,aDecCFFD3[5]+1),aDecCFFD3[5])
			EndIf
			aNFCompl   := {Round(NoRound(IIf(lCustoDev,aCustoDev[nX,1],aCusto[1])  * nMultiplic,aDecCFFD3[1]+1),aDecCFFD3[1]),;
							Round(NoRound(IIf(lCustoDev,aCustoDev[nX,2],aCusto[2])  * nMultiplic,aDecCFFD3[2]+1),aDecCFFD3[2]),;
							Round(NoRound(IIf(lCustoDev,aCustoDev[nX,3],aCusto[3])  * nMultiplic,aDecCFFD3[3]+1),aDecCFFD3[3]),;
							Round(NoRound(IIf(lCustoDev,aCustoDev[nX,4],aCusto[4])  * nMultiplic,aDecCFFD3[4]+1),aDecCFFD3[4]),;
							Round(NoRound(IIf(lCustoDev,aCustoDev[nX,5],aCusto[5])  * nMultiplic,aDecCFFD3[5]+1),aDecCFFD3[5])}
		EndIf

		Replace BD_QFIM    With BD_QFIM    + IIf(lCustoDev,aCustoDev[nX,6],SD1->D1_QUANT)   * nMultiplic
		Replace BD_QFIM2UM With BD_QFIM2UM + IIf(lCustoDev,aCustoDev[nX,7],SD1->D1_QTSEGUM) * nMultiplic
		MsUnlock()

		cTM     := SD1->D1_TES
		cCF     := SD1->D1_TES
		cTipoNF := SD1->D1_TIPO
		cDoc    := SD1->D1_DOC
		cSerie  := SD1->D1_SERIE
		cItem   := SD1->D1_ITEM
		dData   := SD1->D1_DTDIGIT

		//-- Somente utilizado na rotina MATA330
		If !lOnLine
			dbSelectArea("TRB")
			RecLock("TRB",.F.)
			Replace TRB->TRB_RECSBD With SBD->(RecNo())
			MsUnlock()
		EndIf

		dbSelectArea("SX6")
		GetMv("MV_SEQFIFO")
		PutMv("MV_SEQFIFO",cNumero)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava Movimentacao dos Lotes FIFO na tabela SD8       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lNewreg
			GravaSD8(cCF,cTipoNF,cDoc,cOP,,SBD->BD_CUSFIM1,SBD->BD_CUSFIM2,SBD->BD_CUSFIM3,SBD->BD_CUSFIM4,SBD->BD_CUSFIM5,SBD->BD_SEQ,dData,cTM,cSerie,cItem,NIL,NIL,"SD1",SD1->D1_NUMSEQ,lOnLine)
		ElseIf (!lNewreg .And. nRecSBD > 0)
			GravaSD8(cCF,cTipoNF,cDoc,cOP,If(nQtdCompl>0,nQtdCompl,0),aNFCompl[1],aNFCompl[2],aNFCompl[3],aNFCompl[4],aNFCompl[5],SBD->BD_SEQ,dData,cTM,cSerie,cItem,NIL,NIL,"SD1",SD1->D1_NUMSEQ,lOnLine)
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava o custo fifo on-line nas tabelas SD1/SB2           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lOnLine
			RecLock("SD1")
			Replace D1_CUSFF1 With D1_CUSFF1 + IIf(lNewReg,SBD->BD_CUSFIM1,If(!lNewreg .And. nRecSBD > 0,aNFCompl[1],0))
			If("2" $ cMoedaCM)
				Replace D1_CUSFF2 With D1_CUSFF2 + IIf(lNewReg,SBD->BD_CUSFIM2,If(!lNewreg .And. nRecSBD > 0,aNFCompl[2],0))
			EndIf
			If("3" $ cMoedaCM)
				Replace D1_CUSFF3 With D1_CUSFF3 + IIf(lNewReg,SBD->BD_CUSFIM3,If(!lNewreg .And. nRecSBD > 0,aNFCompl[3],0))
			EndIf
			If("4" $ cMoedaCM)
				Replace D1_CUSFF4 With D1_CUSFF4 + IIf(lNewReg,SBD->BD_CUSFIM4,If(!lNewreg .And. nRecSBD > 0,aNFCompl[4],0))
			EndIf
			If("5" $ cMoedaCM)
				Replace D1_CUSFF5 With D1_CUSFF5 + IIf(lNewReg,SBD->BD_CUSFIM5,If(!lNewreg .And. nRecSBD > 0,aNFCompl[5],0))
			EndIf
			MsUnLock()
			dbSelectArea("SB2")
			dbSetOrder(1)
			If MsSeek(xFilial("SB2")+SBD->BD_PRODUTO+SBD->BD_LOCAL)
				RecLock("SB2")
				Replace B2_QFIMFF  With B2_QFIMFF  + IIf(lNewReg,SBD->BD_QFIM   , 0 )
				Replace B2_VFIMFF1 With B2_VFIMFF1 + IIf(lNewReg,SBD->BD_CUSFIM1,If(!lNewreg .And. nRecSBD > 0,aNFCompl[1],0))
				If("2" $ cMoedaCM)
					Replace B2_VFIMFF2 With B2_VFIMFF2 + IIf(lNewReg,SBD->BD_CUSFIM2,If(!lNewreg .And. nRecSBD > 0,aNFCompl[2],0))
				EndIf
				If("3" $ cMoedaCM)
					Replace B2_VFIMFF3 With B2_VFIMFF3 + IIf(lNewReg,SBD->BD_CUSFIM3,If(!lNewreg .And. nRecSBD > 0,aNFCompl[3],0))
				EndIf
				If("4" $ cMoedaCM)
					Replace B2_VFIMFF4 With B2_VFIMFF4 + IIf(lNewReg,SBD->BD_CUSFIM4,If(!lNewreg .And. nRecSBD > 0,aNFCompl[4],0))
				EndIf
				If("5" $ cMoedaCM)
					Replace B2_VFIMFF5 With B2_VFIMFF5 + IIf(lNewReg,SBD->BD_CUSFIM5,If(!lNewreg .And. nRecSBD > 0,aNFCompl[5],0))
				EndIf
				Replace B2_CMFF1   With B2_VFIMFF1 / B2_QFIMFF
				If("2" $ cMoedaCM)
					Replace B2_CMFF2   With B2_VFIMFF2 / B2_QFIMFF
				EndIf
				If("3" $ cMoedaCM)
					Replace B2_CMFF3   With B2_VFIMFF3 / B2_QFIMFF
				EndIf
				If("4" $ cMoedaCM)
					Replace B2_CMFF4   With B2_VFIMFF4 / B2_QFIMFF
				EndIf
				If("5" $ cMoedaCM)
					Replace B2_CMFF5   With B2_VFIMFF5 / B2_QFIMFF
				EndIf
				MsUnLock()
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ajusta a numeracao de lote quando for devolucao de venda ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lCustoDev
			cNumero := Soma1(GetMv("MV_SEQFIFO"))
			lNewReg := .T.
		EndIf

	Next nX

ElseIf cArquivo == "SD2"

	If SD2->D2_TES > "500"
		nMultiplic := -1
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona no local a ser atualizado                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SBD")
	RecLock("SBD",.T.)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Pega o custo do campo e soma o custo da entrada       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Replace BD_FILIAL  With xFilial("SBD")
	Replace BD_PRODUTO With SD2->D2_COD
	Replace BD_LOCAL   With SD2->D2_LOCAL
	Replace BD_QUANT   With SD2->D2_QUANT   * nMultiplic
	Replace BD_QT2UM   With SD2->D2_QTSEGUM * nMultiplic
	Replace BD_DATA    With SD2->D2_EMISSAO
	Replace BD_CUSFIM1 With Round(NoRound(aCusto[01] * nMultiplic,aDecCFFD3[1]+1),aDecCFFD3[1])
	Replace BD_CUSFIM2 With Round(NoRound(aCusto[02] * nMultiplic,aDecCFFD3[2]+1),aDecCFFD3[2])
	Replace BD_CUSFIM3 With Round(NoRound(aCusto[03] * nMultiplic,aDecCFFD3[3]+1),aDecCFFD3[3])
	Replace BD_CUSFIM4 With Round(NoRound(aCusto[04] * nMultiplic,aDecCFFD3[4]+1),aDecCFFD3[4])
	Replace BD_CUSFIM5 With Round(NoRound(aCusto[05] * nMultiplic,aDecCFFD3[5]+1),aDecCFFD3[5])
	Replace BD_QFIM    With SD2->D2_QUANT   * nMultiplic
	Replace BD_QFIM2UM With SD2->D2_QTSEGUM * nMultiplic
	Replace BD_SEQ     With cNumero
	Replace BD_DTPROC  With IIf(lOnLine,dDataBase,a330ParamZX[01])
	Replace BD_DTCALC  With IIf(lOnLine,dDataBase,a330ParamZX[01])
	If cPaisLoc=='RUS' .and. SuperGetMv("MV_LOTCOST ",.F.,"0")=="1"
		Replace BD_LOTECTL    With SD2->D2_LOTECTL
		Replace BD_NUMLOTE    With SD2->D2_NUMLOTE
	EndIf
	MsUnlock()

	cTM     := SD2->D2_TES
	cCF     := SD2->D2_TES
	cTipoNF := SD2->D2_TIPO
	cDoc    := SD2->D2_DOC
	cSerie  := SD2->D2_SERIE
	cItem   := SD2->D2_ITEM
	dData   := SD2->D2_EMISSAO

	dbSelectArea("SX6")
	GetMv("MV_SEQFIFO")
	PutMv("MV_SEQFIFO",cNumero)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava Movimentacao dos Lotes FIFO no "SD8"            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	GravaSD8(cCF,cTipoNF,cDoc,cOP,,SBD->BD_CUSFIM1,SBD->BD_CUSFIM2,SBD->BD_CUSFIM3,SBD->BD_CUSFIM4,SBD->BD_CUSFIM5,SBD->BD_SEQ,dData,cTM,cSerie,cItem,NIL,NIL,"SD2",SD2->D2_NUMSEQ,lOnLine)

ElseIf cArquivo == "SD3" .And. !IsProdMod(SD3->D3_COD)

	If SD3->D3_TM > "500"
		nMultiplic := -1
	EndIf

	nQuant   := IIf(nQuant==Nil,SD3->D3_QUANT,nQuant)
	nQuant2Um:= IIf(nQuant2Um==Nil,SD3->D3_QTSEGUM,nQuant2Um)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Tratamento para Complemento de Importacao via EIC - Somente utilizado na rotina MATA330 |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lOnLine .And. SubStr(SD3->D3_CF, 2, 2) == 'E8' .And. QtdComp(nQuant) == QtdComp(0)
		aAreaAnt := GetArea()
		aAreaSD3 := SD3->(GetArea())
		aAreaTRB := TRB->(GetArea())
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Usa D3_DOCSWN+D3_ITEMSWN p/procurar pela NF original  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cDocSWN  := SD3->D3_DOCSWN
			cItemSWN := SD3->D3_ITEMSWN
			cSeekSD3 := xFilial('SD3')+SD3->D3_COD+SD3->D3_LOCAL
			dPerIni  := SuperGetMV('MV_ULMES')
			dPerFim  := a330ParamZX[01]
			dbSelectArea('SD3')
			dbSetOrder(3) //-- D3_FILIAL+D3_COD+D3_LOCAL+D3_NUMSEQ
			If dbSeek(cSeekSD3, .F.)
				Do While !SD3->(Eof()) .And. cSeekSD3 == SD3->D3_FILIAL+SD3->D3_COD+SD3->D3_LOCAL
					If SD3->D3_EMISSAO < dPerIni .Or. SD3->D3_EMISSAO > dPerFim
						dbSkip()
						Loop
					EndIf
					If SD3->D3_DOCSWN+SD3->D3_ITEMSWN == cDocSWN+cItemSWN .And. SD3->D3_QUANT > 0 .And. SD3->D3_CF == 'DE8'
						dbSelectArea('TRB')
						dbSetOrder(4) //-- TRB_ALIAS+TRB_DOC+TRB_COD+TRB_LOCAL
						If dbSeek(cFilAnt+'SD3'+SD3->D3_DOC+SD3->D3_COD+SD3->D3_LOCAL, .F.)
							lNewReg := (TRB->TRB_RECSBD==0)
							nRecSBD := TRB->TRB_RECSBD
							Exit
						EndIf
					EndIf
					dbSelectArea('SD3')
					dbSkip()
				EndDo
			EndIf
		RestArea(aAreaTRB)
		RestArea(aAreaSD3)
		RestArea(aAreaAnt)
		cTipoNF  := 'C' //-- Itens de NF de Complemento (EIC)
		aNFCompl := {	(Round(NoRound(aCusto[01]*nMultiplic, 3), 2)), ;
						(Round(NoRound(aCusto[02]*nMultiplic, 3), 2)), ;
						(Round(NoRound(aCusto[03]*nMultiplic, 3), 2)), ;
						(Round(NoRound(aCusto[04]*nMultiplic, 3), 2)), ;
						(Round(NoRound(aCusto[05]*nMultiplic, 3), 2)) }
	Else
		cTipoNF  := 'N'
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Prepara lotes Fifo/Lifo para Transferencia Interna                   |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If AllTrim(SD3->D3_CF) == 'DE4' .And. !(SD3->D3_ESTORNO == 'S')
		aAreaAnt := GetArea()
		nTotDev  := SD3->D3_QUANT
		dbSelectArea("SD8")
		dbSetOrder(3)  //D8_FILIAL+D8_DOC+D8_SERIE+D8_ITEM
		dbSeek(cSeek:=xFilial("SD8")+SD3->D3_DOC+''+'')
		Do While !Eof() .And. cSeek == xFilial("SD8")+SD8->D8_DOC+''+''

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Nao permitida quantidades ja devolvidas                         |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !(SD8->D8_TM == "999") .Or. !Empty(D8_ITEM) .Or. !(SD8->D8_CF == "RE4") .Or.;
				SD8->D8_QUANT <= SD8->D8_SD1DEV
				dbSkip()
				Loop
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Quebra a quantidade total de devolucao de acordo com os lotes   |
			//| de entrada para respeitar o custo de cada lote Fifo/Lifo        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If QtdComp(nTotDev) > QtdComp(0)

				If QtdComp(nTotDev) > QtdComp( SD8->D8_QUANT - SD8->D8_SD1DEV )
					nQtdDev := ( SD8->D8_QUANT - SD8->D8_SD1DEV )
					nQtd2UM := ConvUm(SD8->D8_PRODUTO,nQtdDev,0,2)
					nProp	:= nQtdDev/SD8->D8_QUANT
				Else
					nQtdDev := nTotDev
					nQtd2UM := ConvUm(SD8->D8_PRODUTO,nTotDev,0,2)
					nProp	:= nQtdDev/SD8->D8_QUANT
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ aCustoDev - Array contendo as quebras e seus respectivos custos |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aAdd(aCustoDev,{SD8->D8_CUSTO1 * nProp,;
								SD8->D8_CUSTO2 * nProp,;
								SD8->D8_CUSTO3 * nProp,;
								SD8->D8_CUSTO4 * nProp,;
								SD8->D8_CUSTO5 * nProp,;
								nQtdDev,;
								nQtd2UM})

				nTotDev	  := nTotDev - ( SD8->D8_QUANT - SD8->D8_SD1DEV )
				lCustoDev := .T.

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava a quantidade de devolucao no campo D8_SD1DEV para   ³
				//| controlar as devolucoes parciais.                         |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				RecLock("SD8",.F.)
				Replace D8_SD1DEV With D8_SD1DEV + nQtdDev
				MsUnLock()

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava a quantidade de devolucao no campo D8_QFIMDEV para  ³
				//| realizar controles no fechamento Fifo.                    |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					RecLock("SD8",.F.)
					Replace D8_QFIMDEV With D8_QFIMDEV + nQtdDev
					MsUnLock()

			Else
				Exit
			EndIf
			dbSelectArea("SD8")
			dbSkip()
		EndDo
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ nLote - Define a qtde de lotes a serem gerados pela devolucao |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(aCustoDev) > 0
			nLote := Len(aCustoDev)
		EndIf
		RestArea(aAreaAnt)
	EndIf

	cTM   := SD3->D3_TM
	cCF   := SD3->D3_CF
	cDoc  := SD3->D3_DOC
	cOP   := SD3->D3_OP
	dData := SD3->D3_EMISSAO

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Caso seja estorno de movimentacao interna verificar lotes a serem    |
	//| devolvidos.                                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lOnLine .And. SD3->D3_ESTORNO == 'S'
		dbSelectArea("SD8")
		dbSetOrder(5)
		dbSeek(cSeekSD8:=xFilial("SD8")+SD3->D3_COD+SD3->D3_LOCAL+SD3->D3_NUMSEQ)
		Do While !Eof() .And. cSeekSD8 == D8_FILIAL+D8_PRODUTO+D8_LOCAL+D8_NUMSEQ
		 	If SD3->D3_CF == SD8->D8_CF
		 		aAdd(aEstornoSD3,{SD8->D8_SEQ,SD8->D8_QUANT,SD8->D8_QT2UM,{SD8->D8_CUSTO1,SD8->D8_CUSTO2,SD8->D8_CUSTO3,SD8->D8_CUSTO4,SD8->D8_CUSTO5}})
			EndIf
			dbSkip()
		EndDo
		If Len(aEstornoSD3) > 0
			lNewReg := .F.
			lEstorno:= .T.
			nLote   := Len(aEstornoSD3)
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Caso seja uma movimentacao do armazem de controle de qualidade e     |
	//| seja uma liberacao/rejeicao de documento de entrada de complemento   |
	//| devolver o custo para o lote origem.                                 |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If	SD3->D3_CF == "DE6" .And. SubStr(SD3->D3_DOC,1,2) == 'SK' .And. QtdComp(SD3->D3_QUANT) == QtdComp(0)
      	dbSelectArea("SD8")
	    dbSetOrder(3)
    	dbSeek(cSeekSD8:=xFilial("SD8")+SD3->D3_DOC)
	    Do While !Eof() .And. cSeekSd8 == D8_FILIAL+D8_DOC
    		If SD8->D8_CF == 'DE6' .And. QtdComp(SD8->D8_QUANT) # QtdComp(0) .And. ;
    		   SD8->D8_PRODUTO == SD3->D3_COD .And. SD8->D8_LOCAL == SD3->D3_LOCAL
				dbSelectArea("SBD")
				dbSetOrder(2)
				If dbSeek(xFilial("SBD")+SD8->D8_SEQ) .And. SBD->BD_STATUS # 'Z'
				 	aAdd(aEstornoSD3,{SBD->BD_SEQ,SD3->D3_QUANT,SD3->D3_QTSEGUM,{SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5}})
					lNewReg := .F.
					lEstorno:= .T.
					Exit
				EndIf
        	EndIf
			dbSelectArea("SD8")
	      	dbSkip()
    	EndDo
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Pesquisa no SBD se existe Lote Fifo com qtde igual zero e com custo  |
	//| gerado por nota de complemento, caso exista nao gerar novo lote o    ³
	//| sistema devera agregar esta nova entrada ao mesmo lote localizado.   |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lNewReg .And. Len(aEstornoSD3) == 0
		aAreaSBD:=SBD->(GetArea())
		aAreaSD8:=SD8->(GetArea())
		dbSelectArea("SBD")
		dbSetOrder(1)
		dbSeek(cSeek:=xFilial("SBD")+SD3->D3_COD+SD3->D3_LOCAL+" ")
		Do While !Eof() .And. cSeek ==xFilial("SBD")+SBD->BD_PRODUTO+SBD->BD_LOCAL+SBD->BD_STATUS
			If SBD->BD_QFIM == 0 .And. SBD->BD_QINI == 0
				nRecSBD   := SBD->(Recno())
				If SD3->D3_CF = "DE4" .And. nlote > 1
					lNewReg   := .T.
				Else
					lNewReg   := .F.
				EndIF
				nQtdCompl := SD3->D3_QUANT * nMultiplic
				aNFCompl  := {Round(NoRound(aCusto[1]  * nMultiplic,aDecCFFD3[1]+1),aDecCFFD3[1]),;
							  Round(NoRound(aCusto[2]  * nMultiplic,aDecCFFD3[2]+1),aDecCFFD3[2]),;
							  Round(NoRound(aCusto[3]  * nMultiplic,aDecCFFD3[3]+1),aDecCFFD3[3]),;
							  Round(NoRound(aCusto[4]  * nMultiplic,aDecCFFD3[4]+1),aDecCFFD3[4]),;
							  Round(NoRound(aCusto[5]  * nMultiplic,aDecCFFD3[5]+1),aDecCFFD3[5])}
				Exit
			EndIf
			dbSelectArea("SBD")
			dbSkip()
		EndDo
		RestArea(aAreaSBD)
		RestArea(aAreaSD8)
	EndIf
	lMV_LOTCOST := cPaisLoc=='RUS' .and. SuperGetMv("MV_LOTCOST ",.F.,"0")=="1"

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Processa os Lotes Fifo/Lifo                              |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nX := 1 to nLote

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posiciona no local a ser atualizado                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(aEstornoSD3) > 0
			dbSelectArea('SBD')
			dbSetOrder(2)
			dbSeek(xFilial('SBD')+aEstornoSD3[nX,1])
		Else
			dbSelectArea('SBD')
			If !lNewReg .And. nRecSBD>0
				MsGoto(nRecSBD)
			EndIf
		EndIf
		If !((isincallstack('MATA260') .or. isincallstack('MATA261')).and. SD3->D3_FILIAL = SBD->BD_FILIAL .and. SD3->D3_COD = SBD->BD_PRODUTO .and. SD3->D3_LOCAL = SBD->BD_LOCAL)
			RecLock('SBD', lNewReg)

			If lNewReg
				Replace BD_FILIAL  With xFilial("SBD")
				Replace BD_PRODUTO With SD3->D3_COD
				Replace BD_LOCAL   With SD3->D3_LOCAL
				Replace BD_QUANT   With IIf(lCustoDev,aCustoDev[nX,6],nQuant)    * nMultiplic
				Replace BD_QT2UM   With IIf(lCustoDev,aCustoDev[nX,7],nQuant2Um) * nMultiplic
				Replace BD_DATA    With dData
				Replace BD_SEQ     With cNumero
				Replace BD_DTPROC  With IIf(lOnLine,dDataBase,a330ParamZX[01])
				Replace BD_DTCALC  With IIf(lOnLine,dDataBase,a330ParamZX[01])
				Replace BD_OP      With cOP
				If lMV_LOTCOST
					Replace BD_LOTECTL    With SD3->D3_LOTECTL
					Replace BD_NUMLOTE    With SD3->D3_NUMLOTE
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Pega o custo do campo e soma o custo da entrada       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			Replace BD_CUSFIM1     With BD_CUSFIM1 + Round(NoRound(IIf(lCustoDev,aCustoDev[nX,1],IIf(lEstorno,aEstornoSD3[nX,4,1],aCusto[1])) * nMultiplic,aDecCFFD3[1]+1),aDecCFFD3[1])
			If("2" $ cMoedaCM)
				Replace BD_CUSFIM2 With BD_CUSFIM2 + Round(NoRound(IIf(lCustoDev,aCustoDev[nX,2],IIf(lEstorno,aEstornoSD3[nX,4,2],aCusto[2])) * nMultiplic,aDecCFFD3[2]+1),aDecCFFD3[2])
			EndIf
			If("3" $ cMoedaCM)
				Replace BD_CUSFIM3 With BD_CUSFIM3 + Round(NoRound(IIf(lCustoDev,aCustoDev[nX,3],IIf(lEstorno,aEstornoSD3[nX,4,3],aCusto[3])) * nMultiplic,aDecCFFD3[3]+1),aDecCFFD3[3])
			EndIf
			If("4" $ cMoedaCM)
				Replace BD_CUSFIM4 With BD_CUSFIM4 + Round(NoRound(IIf(lCustoDev,aCustoDev[nX,4],IIf(lEstorno,aEstornoSD3[nX,4,4],aCusto[4])) * nMultiplic,aDecCFFD3[4]+1),aDecCFFD3[4])
			EndIf
			If("5" $ cMoedaCM)
				Replace BD_CUSFIM5 With BD_CUSFIM5 + Round(NoRound(IIf(lCustoDev,aCustoDev[nX,5],IIf(lEstorno,aEstornoSD3[nX,4,5],aCusto[5])) * nMultiplic,aDecCFFD3[5]+1),aDecCFFD3[5])
			EndIf
			Replace BD_QFIM    With BD_QFIM    + IIf(lCustoDev,aCustoDev[nX,6],IIf(lEstorno,aEstornoSD3[nX,2],nQuant    ) ) * nMultiplic
			Replace BD_QFIM2UM With BD_QFIM2UM + IIf(lCustoDev,aCustoDev[nX,7],IIf(lEstorno,aEstornoSD3[nX,3],nQuant2Um ) ) * nMultiplic
			If BD_QFIM > 0
				Replace BD_STATUS With ' '
			EndIf
			MsUnlock()
		EndIF

		//-- Somente utilizado na rotina MATA330
		If !lOnLine
			RecLock('TRB', .F.)
			Replace TRB_RECSBD With SBD->(Recno())
			MsUnlock()
		EndIf

		dbSelectArea("SX6")
		GetMv("MV_SEQFIFO")
		PutMv("MV_SEQFIFO",cNumero)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ aCustoFF - Array com o custo FIFO a ser atualizado    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lNewReg
			aCustoFF := {SBD->BD_SEQ,SBD->BD_QUANT,{SBD->BD_CUSFIM1,SBD->BD_CUSFIM2,SBD->BD_CUSFIM3,SBD->BD_CUSFIM4,SBD->BD_CUSFIM5}}
		ElseIf !lNewReg .And. nRecSBD > 0
			aCustoFF := {SBD->BD_SEQ,If(nQtdCompl>0,nQtdCompl,0),{aNFCompl[1],aNFCompl[2],aNFCompl[3],aNFCompl[4],aNFCompl[5]}}
		ElseIf lEstorno
			aCustoFF := {aEstornoSD3[nX,1],aEstornoSD3[nX,2],{aEstornoSD3[nX,4,1],aEstornoSD3[nX,4,2],aEstornoSD3[nX,4,3],aEstornoSD3[nX,4,4],aEstornoSD3[nX,4,5]}}
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava Movimentacao dos Lotes FIFO no "SD8"            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		GravaSD8(cCF,cTipoNF,cDoc,cOP,aCustoFF[2],aCustoFF[3,1],aCustoFF[3,2],aCustoFF[3,3],aCustoFF[3,4],aCustoFF[3,5],SBD->BD_SEQ,dData,cTM,cSerie,cItem,NIL,NIL,'SD3',SD3->D3_NUMSEQ,lOnLine)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava o custo fifo on-line nas tabelas SD3/SB2           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lOnLine
			RecLock("SD3")
			IF D3_ESTORNO <> 'S'
				Replace D3_CUSFF1     With D3_CUSFF1 + aCustoFF[3,1]
				If("2" $ cMoedaCM)
					Replace D3_CUSFF2 With aCustoFF[3,2]
				EndIf
				If("3" $ cMoedaCM)
					Replace D3_CUSFF3 With D3_CUSFF2 + aCustoFF[3,3]
				EndIf
				If("4" $ cMoedaCM)
					Replace D3_CUSFF4 With D3_CUSFF4 + aCustoFF[3,4]
				EndIf
				If("5" $ cMoedaCM)
					Replace D3_CUSFF5 With D3_CUSFF5 + aCustoFF[3,5]
				EndIf
			EndIf
			MsUnLock()
			dbSelectArea("SB2")
			dbSetOrder(1)
			If MsSeek(xFilial("SB2")+SBD->BD_PRODUTO+SBD->BD_LOCAL)
				RecLock("SB2")
				Replace B2_QFIMFF  With B2_QFIMFF  + IIf(lEstorno,aCustoFF[2],IIf(lNewReg,SBD->BD_QFIM,0))
				Replace B2_VFIMFF1 With B2_VFIMFF1 + aCustoFF[3,1]
				If("2" $ cMoedaCM)
					Replace B2_VFIMFF2 With B2_VFIMFF2 + aCustoFF[3,2]
				EndIf
				If("3" $ cMoedaCM)
					Replace B2_VFIMFF3 With B2_VFIMFF3 + aCustoFF[3,3]
				EndIf
				If("4" $ cMoedaCM)
					Replace B2_VFIMFF4 With B2_VFIMFF4 + aCustoFF[3,4]
				EndIf
				If("5" $ cMoedaCM)
					Replace B2_VFIMFF5 With B2_VFIMFF5 + aCustoFF[3,5]
				EndIf
				Replace B2_CMFF1   With B2_VFIMFF1 / B2_QFIMFF
				If("2" $ cMoedaCM)
					Replace B2_CMFF2   With B2_VFIMFF2 / B2_QFIMFF
				EndIf
				If("3" $ cMoedaCM)
					Replace B2_CMFF3   With B2_VFIMFF3 / B2_QFIMFF
				EndIf
				If("4" $ cMoedaCM)
					Replace B2_CMFF4   With B2_VFIMFF4 / B2_QFIMFF
				EndIf
				If("5" $ cMoedaCM)
					Replace B2_CMFF5   With B2_VFIMFF5 / B2_QFIMFF
				EndIf
				MsUnLock()
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ajusta a numeracao de lote quando for devolucao de venda ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lCustoDev
			cNumero := Soma1(GetMv("MV_SEQFIFO"))
			lNewReg := .T.
		EndIf

	Next nX

EndIf

dbSelectArea( cAlias )

Set(3,nDec)

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³BaixaSBD  ³ Autor ³ Marcos / Rosane       ³ Data ³ 20/08/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³ Baixa dos Saldos do SBD as movimentacoes FIFO              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cArquivo -> arquivo responsavel pela chamado da BaixaSBD   ³±±
±±³          ³ lFirst   -> controla se o arquivo SBD deve ser posicionado ³±±
±±³          ³             no primeiro que tiver saldo ou nao.Se negativo ³±±
±±³          ³             nao posiciona, se positivo posiciona. Ele ‚    ³±±
±±³          ³             negativo no caso da devolucao de compra.       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function BaixaSBD(cArquivo,lFirst,lRE5,lRE6,lOnLine,aCustoFF,cLocCQ)
Local nMultiplic  := 1
Local nProp       := 1
Local nQtdBai     := 0
Local nQtdBai2    := 0
Local nQuant      := 0
Local nQuant2     := 0
Local nQtdFim     := 0
Local cAlias      := Alias()
Local cProduto    := ""
Local cLocal      := ""
Local cCF         := ""
Local cTipoNF     := ""
Local cSerie      := ""
Local cItem       := ""
Local cDoc        := ""
Local cOP         := ""
Local cTM         := ""
Local dData       := CtoD("  /  /  ")
Local nOldRec     := 0
Local nCountRE6   := 0
Local lNfDebCred  := .F.
Local lAuxRE6     := .F.
Local lLifo       := SuperGetMv('MV_CUSLIFO',.F.,.F.)
Local lFifo       := SuperGetMv('MV_CUSFIFO',.F.,.F.)
Local cMoedaCM    := SuperGetMv('MV_MOEDACM',.F.,"2345")
Local aCusto[05], aSBDFim[02],aAux[05],aAuxRE6[05]

Local cSeek		  := ""
Local lRE6QtZero  := .F.
Local aDecCFFD3 := {TamSX3('D3_CUSFF1')[2], TamSX3('D3_CUSFF2')[2], TamSX3('D3_CUSFF3')[2], TamSX3('D3_CUSFF4')[2], TamSX3('D3_CUSFF5')[2]}

Local cLotCtl := ''
Local cNumLot := ''
Local lMV_LOTCOST
Local dIniRec := SuperGetMv("MV_ULMES",.F.,SToD("19961231"))+1
Local aAreaSD3 := {}
Local nIdent := 0

Default cLocCQ := '98'

nDec := Set(3,8)
Afill(aCusto ,0)
Afill(aAux   ,0)
Afill(aAuxRE6,0)

lRE5     := IIF(lRE5    == Nil,.F.,lRE5)
lRE6     := IIF(lRE6    == Nil,.F.,lRE6)
lOnLine  := IIF(lOnLine == Nil,.F.,lOnLine)
aCustoFF := IIF(aCustoFF== Nil,{0,0,0,0,0},aCustoFF)

If cArquivo == "SD3"
	If SD3->D3_TM > "500"
		nMultiplic := -1
	EndIf
	cProduto := SD3->D3_COD
	nQuant   := SD3->D3_QUANT
	nQuant2  := SD3->D3_QTSEGUM
	cLocal   := SD3->D3_LOCAL
	cCF      := SD3->D3_CF
	cTM      := SD3->D3_TM
	cTipoNF  := "N"
	cDoc     := SD3->D3_DOC
	cOP      := SD3->D3_OP
	dData    := SD3->D3_EMISSAO
	If lRE6
		lRE6QtZero := QtdComp(nQuant) == QtdComp(0)
	EndIf
	If cPaisLoc == 'RUS' .and. SuperGetMv("MV_LOTCOST ",.F.,"0")=="1"
		cLotCtl	:= SD3->D3_LOTECTL
		cNumLot := SD3->D3_NUMLOTE
	Endif
ElseIf cArquivo == "SD2"
	If SD2->D2_TES > "500"
		nMultiplic := -1
	EndIf
	cProduto := SD2->D2_COD
	nQuant   := SD2->D2_QUANT
	nQuant2  := SD2->D2_QTSEGUM
	cLocal   := SD2->D2_LOCAL
	cCF      := SD2->D2_TES
	cTM      := SD2->D2_TES
	cTipoNF  := SD2->D2_TIPO
	cDoc     := SD2->D2_DOC
	cSerie   := SD2->D2_SERIE
	cItem    := SD2->D2_ITEM
	cOP      := SD2->D2_OP
	dData    := SD2->D2_EMISSAO
	If cPaisLoc <> "BRA"
		lNfDebCred := AllTrim(SD2->D2_ESPECIE) == "NCP" .And. QtdComp(SD2->D2_QUANT) == QtdComp(0) .And. !Empty(SD2->D2_NFORI)
	EndIf
	If cPaisLoc == 'RUS' .and. SuperGetMv("MV_LOTCOST ",.F.,"0")=="1"
		cLotCtl	:= SD2->D2_LOTECTL
		cNumLot := SD2->D2_NUMLOTE
	Endif
ElseIf cArquivo == "SD1"
	If SD1->D1_TES > "500"
		nMultiplic := -1
	EndIf
	cProduto := SD1->D1_COD
	nQuant   := SD1->D1_QUANT
	nQuant2  := SD1->D1_QTSEGUM
	cLocal   := SD1->D1_LOCAL
	cCF      := SD1->D1_TES
	cTM      := SD1->D1_TES
	cTipoNF  := SD1->D1_TIPO
	cDoc     := SD1->D1_DOC
	cSerie   := SD1->D1_SERIE
	cItem    := SD1->D1_ITEM
	cOP      := SD1->D1_OP
	dData    := SD1->D1_DTDIGIT
	If cPaisLoc == 'RUS' .and. SuperGetMv("MV_LOTCOST ",.F.,"0")=="1"
		cLotCtl	:= SD1->D1_LOTECTL
		cNumLot := SD1->D1_NUMLOTE
	Endif
EndIf

If GetMV("MV_NGMNTES") == "S"
   If  !NGCHKCUSF(cProduto)
      aSBDFim[01] := aCusto
      aSBDFim[02] := nQtdFim
      Set(3,nDec)
      dbSelectArea(cAlias)
      Return aSBDFim
   EndIf
Endif

If !lRE5 .Or. lRE6
	lMV_LOTCOST := cPaisLoc=='RUS' .and. SuperGetMv("MV_LOTCOST ",.F.,"0")=="1"
	While .T.
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posiciona no local a ser atualizado:                     |
		//| MV_CUSFIFO = T -  posiciona no primeiro que tiver saldo  |
		//| MV_CUSLIFO = T -  posiciona no ultimo que tiver saldo    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cArquivo != "SD2"

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Localiza Lote FIFO Disponivel                                        |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SBD")
			dbSetOrder(1)
			If lLIFO .And. !lFIFO
				//Posiciona na ultima ocorrencia encontrada
				If dbSeek(cSeek:=xFilial("SBD")+cProduto+cLocal+" ")
					Do While !Eof() .And. cSeek == BD_FILIAL+BD_PRODUTO+BD_LOCAL+BD_STATUS
						dbSkip()
					EndDo
					dbSkip(-1)
				EndIf
			Else
				//-- Caso seja estorno posicionar no lote correto
				If lOnLine .And. cArquivo == "SD3" .And. SD3->D3_ESTORNO == 'S'
					SD8->(dbSetOrder(5))
					SD8->(dbSeek(xFilial("SD8")+SD3->D3_COD+SD3->D3_LOCAL+SD3->D3_NUMSEQ))
					dbSelectArea("SBD")
					dbSetOrder(2)
					dbSeek(xFilial("SBD")+SD8->D8_SEQ)
				Else
					If lAuxRE6
						SBD->(dbSkip())
						If cProduto+cLocal # SBD->BD_PRODUTO+SBD->BD_LOCAL
							Exit
						EndIf
					Else
						If IsInCallStack('MATA330') .and. cArquivo == "SD3" .And. cLocal == cLocCQ 
							SD8->(dbSetOrder(5))
							If SD8->(dbSeek(xFilial("SD8")+SD3->D3_COD+SD3->D3_LOCAL+SD3->D3_IDENT))							
								dbSelectArea("SBD")
								dbSetOrder(2)
								dbSeek(xFilial("SBD")+SD8->D8_SEQ)		
							Else
								If cCF == 'RE6'
									SD1->(DbSetOrder(4))
									If SD1->(dbseek(xFilial("SD1")+SD3->D3_IDENT)) .And. SD1->D1_DTDIGIT < dIniRec
										GravaSBD('SD1',{SD1->D1_CUSTO,SD1->D1_CUSTO2,SD1->D1_CUSTO3,SD1->D1_CUSTO4,SD1->D1_CUSTO5},SD1->D1_TIPO,Nil,Nil,lOnLine)	
									Else
										aAreaSD3 := SD3->(GetArea())
										nIdent := SD3->D3_IDENT
										SD3->(DbSetOrder(4))
										If SD3->(dbseek(xFilial("SD3")+nIdent))
											Do While !SD3->(EOF()) .and. SD3->(D3_FILIAL+D3_NUMSEQ) == xFilial("SD3")+nIdent 
												If SD3->D3_CF == 'DE4' .and. SD3->D3_EMISSAO < dIniRec .And. SD3->D3_LOCAL == cLocCQ
													GravaSBD('SD3',{SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5},SD3->D3_TIPO,Nil,Nil,lOnLine)	
													Exit
												EndIf
												SD3->(DBskip())
											EndDo
										EndIf
										RestArea(aAreaSD3)
									EndIf
								Else
									dbSeek(xFilial("SBD")+cProduto+cLocal+" ")	
								EndIf
							Endif				
						Else
							dbSeek(xFilial("SBD")+cProduto+cLocal+" ")
						Endif
					EndIf
				EndIf
			EndIf
			If Eof()
				If lOnLine
					Help(" ",1,"DIVFIFO")
				Else
					GravaDif(cProduto,cLocal,nQuant,cCF,cTM,cDoc,cSerie,cOP,dData)
				EndIf
				Exit
			EndIf
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//| Para notas de credito e debito com quantidade zerada e que possuem amarracao com |
			//| a nota original, procurar lote origem.                                           |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lNfDebCred
				dbSelectArea("SD8")
				dbSetOrder(3)
				If dbSeek(xFilial("SD8")+SD2->D2_NFORI+SD2->D2_SERIORI+SD2->D2_ITEMORI)
					dbSelectArea("SBD")
					dbSetOrder(1) //BD_FILIAL+BD_PRODUTO+BD_LOCAL+BD_STATUS+BD_SEQ
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//| Quando BD_STATUS == ' ' existe saldo no lote      |
					//| Quando BD_STATUS == 'Z' nao existe saldo no lote  |
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !dbSeek(xFilial("SBD")+SD8->D8_PRODUTO+SD8->D8_LOCAL+' '+SD8->D8_SEQ)
						If lOnLine
							Help(" ",1,"DIVFIFO")
						Else
							GravaDif(cProduto,cLocal,nQuant,cCF,cTM,cDoc,cSerie,cOP,dData)
						EndIf
					EndIf
				Else
					If lOnLine
						Help(" ",1,"DIVFIFO")
					Else
						GravaDif(cProduto,cLocal,nQuant,cCF,cTM,cDoc,cSerie,cOP,dData)
					EndIf
				EndIf
			Else
				If !lFirst
					dbSelectArea("SBD")
					dbSetOrder(1)
					If lLIFO .And. !lFIFO
						//Posiciona na ultima ocorrencia encontrada
						If dbSeek(cSeek:=xFilial("SBD")+cProduto+cLocal+" ")
							Do While !Eof() .And. cSeek == BD_FILIAL+BD_PRODUTO+BD_LOCAL+BD_STATUS
								dbSkip()
							EndDo
							dbSkip(-1)
						EndIf
					Else
						If lMV_LOTCOST
							dbSetOrder(4)
							dbSeek(xFilial("SBD")+cProduto+cLocal+" "+cLotCtl+cNumLot)
						else
							dbSeek(xFilial("SBD")+cProduto+cLocal+" ")
						endif
					EndIf
					If Eof()
						If lOnLine
							Help(" ",1,"DIVFIFO")
						Else
							GravaDif(cProduto,cLocal,nQuant,cCF,cTM,cDoc,cSerie,cOP,dData)
						EndIf
						Exit
					EndIf
				EndIf
			EndIf
		EndIf
		// Calculo de Proporcao para realizar a Baixa
		If SBD->BD_QFIM >= nQuant
			nQtdBai := nQuant
			nQtdBai2:= nQuant2
			If QtdComp(nQuant) == QtdComp(0) .And. (lRE6 .Or. lNfDebCred)
				nProp := 1
			Else
				nProp   := (nQtdBai / SBD->BD_QFIM) // * nMultiplic
			EndIf
		Else
			nQtdBai := SBD->BD_QFIM
			nQtdBai2:= SBD->BD_QFIM2UM
			nProp   := 1 // * nMultiplic
		EndIf

		If QtdComp(nQtdBai) > QtdComp(0) .Or. (QtdComp(nQuant) == QtdComp(0) .And. lRE6) .Or. (QtdComp(nQuant) == QtdComp(0) .And. lNfDebCred)
			If cArquivo == "SD3"
				// aAux[NN] -> Array utilizado para calculo do custo fifo do movimento
				aAux[01]   := IIf(lRE6QtZero,Min(IIf(lAuxRE6,aAuxRE6[01],SD3->D3_CUSTO1),SBD->BD_CUSFIM1),SBD->BD_CUSFIM1)
				aAux[02]   := IIf(lRE6QtZero,Min(IIf(lAuxRE6,aAuxRE6[02],SD3->D3_CUSTO2),SBD->BD_CUSFIM2),SBD->BD_CUSFIM2)
				aAux[03]   := IIf(lRE6QtZero,Min(IIf(lAuxRE6,aAuxRE6[03],SD3->D3_CUSTO3),SBD->BD_CUSFIM3),SBD->BD_CUSFIM3)
				aAux[04]   := IIf(lRE6QtZero,Min(IIf(lAuxRE6,aAuxRE6[04],SD3->D3_CUSTO4),SBD->BD_CUSFIM4),SBD->BD_CUSFIM4)
				aAux[05]   := IIf(lRE6QtZero,Min(IIf(lAuxRE6,aAuxRE6[05],SD3->D3_CUSTO5),SBD->BD_CUSFIM5),SBD->BD_CUSFIM5)
				// aCusto[NN] -> Array utilizado para calculo do custo fifo unificado
				aCusto[01] := aCusto[01] + Round(NoRound(aAux[01] * nProp,aDecCFFD3[1]+1),aDecCFFD3[1])
				aCusto[02] := aCusto[02] + Round(NoRound(aAux[02] * nProp,aDecCFFD3[2]+1),aDecCFFD3[2])
				aCusto[03] := aCusto[03] + Round(NoRound(aAux[03] * nProp,aDecCFFD3[3]+1),aDecCFFD3[3])
				aCusto[04] := aCusto[04] + Round(NoRound(aAux[04] * nProp,aDecCFFD3[4]+1),aDecCFFD3[4])
				aCusto[05] := aCusto[05] + Round(NoRound(aAux[05] * nProp,aDecCFFD3[5]+1),aDecCFFD3[5])
				nQtdFim    := nQtdFim + nQtdBai
				// aAuxRE6[NN] -> Array de controle de movimentos valorizados com quantidade zerada.
				If lRE6QtZero
					aAuxRE6[01] := IIf(lAuxRE6,aAuxRE6[01] - aAux[01],SD3->D3_CUSTO1 - aAux[01])
					aAuxRE6[02] := IIf(lAuxRE6,aAuxRE6[02] - aAux[02],SD3->D3_CUSTO2 - aAux[02])
					aAuxRE6[03] := IIf(lAuxRE6,aAuxRE6[03] - aAux[03],SD3->D3_CUSTO3 - aAux[03])
					aAuxRE6[04] := IIf(lAuxRE6,aAuxRE6[04] - aAux[04],SD3->D3_CUSTO4 - aAux[04])
					aAuxRE6[05] := IIf(lAuxRE6,aAuxRE6[05] - aAux[05],SD3->D3_CUSTO5 - aAux[05])
					lAuxRE6     := .T.
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava o custo fifo on-line nas tabelas SD3/SB2           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lOnLine
					If SD3->D3_ESTORNO <> 'S'
						RecLock("SD3")
						Replace D3_CUSFF1     With D3_CUSFF1 + Round(NoRound(aAux[01] * nProp,aDecCFFD3[1]+1),aDecCFFD3[1])
						If("2" $ cMoedaCM)
							Replace D3_CUSFF2 With D3_CUSFF2 + Round(NoRound(aAux[02] * nProp,aDecCFFD3[2]+1),aDecCFFD3[2])
						EndIf
						If("3" $ cMoedaCM)
							Replace D3_CUSFF3 With D3_CUSFF3 + Round(NoRound(aAux[03] * nProp,aDecCFFD3[3]+1),aDecCFFD3[3])
						EndIf
						If("4" $ cMoedaCM)
							Replace D3_CUSFF4 With D3_CUSFF4 + Round(NoRound(aAux[04] * nProp,aDecCFFD3[4]+1),aDecCFFD3[4])
						EndIf
						If("5" $ cMoedaCM)
							Replace D3_CUSFF5 With D3_CUSFF5 + Round(NoRound(aAux[05] * nProp,aDecCFFD3[5]+1),aDecCFFD3[5])
						EndIf
						MsUnLock()
					EndIf
					//-- Atualiza a variavel aCustoFF
					aCustoFF[01] := aCustoFF[01]+Round(NoRound(aAux[01] * nProp,aDecCFFD3[1]+1),aDecCFFD3[1])
					aCustoFF[02] := aCustoFF[02]+Round(NoRound(aAux[02] * nProp,aDecCFFD3[2]+1),aDecCFFD3[2])
					aCustoFF[03] := aCustoFF[03]+Round(NoRound(aAux[03] * nProp,aDecCFFD3[3]+1),aDecCFFD3[3])
					aCustoFF[04] := aCustoFF[04]+Round(NoRound(aAux[04] * nProp,aDecCFFD3[4]+1),aDecCFFD3[4])
					aCustoFF[05] := aCustoFF[05]+Round(NoRound(aAux[05] * nProp,aDecCFFD3[5]+1),aDecCFFD3[5])

					dbSelectArea("SB2")
					dbSetOrder(1)
					If MsSeek(xFilial("SB2")+SBD->BD_PRODUTO+SBD->BD_LOCAL)
						RecLock("SB2")
						Replace B2_QFIMFF      With B2_QFIMFF  - Round(NoRound(IIf(lRE6QtZero,0,SBD->BD_QFIM) * nProp,aDecCFFD3[1]+1),aDecCFFD3[1])
						Replace B2_VFIMFF1     With B2_VFIMFF1 - Round(NoRound(aAux[01] * nProp,aDecCFFD3[1]+1),aDecCFFD3[1])
						If("2" $ cMoedaCM)
							Replace B2_VFIMFF2 With B2_VFIMFF2 - Round(NoRound(aAux[02] * nProp,aDecCFFD3[2]+1),aDecCFFD3[2])
						EndIf
						If("3" $ cMoedaCM)
							Replace B2_VFIMFF3 With B2_VFIMFF3 - Round(NoRound(aAux[03] * nProp,aDecCFFD3[3]+1),aDecCFFD3[3])
						EndIf
						If("4" $ cMoedaCM)
							Replace B2_VFIMFF4 With B2_VFIMFF4 - Round(NoRound(aAux[04] * nProp,aDecCFFD3[4]+1),aDecCFFD3[4])
						EndIf
						If("5" $ cMoedaCM)
							Replace B2_VFIMFF5 With B2_VFIMFF5 - Round(NoRound(aAux[05] * nProp,aDecCFFD3[5]+1),aDecCFFD3[5])
						EndIf
						Replace B2_CMFF1       With B2_VFIMFF1 / B2_QFIMFF
						If("2" $ cMoedaCM)
							Replace B2_CMFF2   With B2_VFIMFF2 / B2_QFIMFF
						EndIf
						If("3" $ cMoedaCM)
							Replace B2_CMFF3   With B2_VFIMFF3 / B2_QFIMFF
						EndIf
						If("4" $ cMoedaCM)
							Replace B2_CMFF4   With B2_VFIMFF4 / B2_QFIMFF
						EndIf
						If("5" $ cMoedaCM)
							Replace B2_CMFF5   With B2_VFIMFF5 / B2_QFIMFF
						EndIf
						MsUnLock()
					EndIf
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava Movimentacao dos Lotes FIFO no "SD8"            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				GravaSD8(cCF,cTipoNF,cDoc,cOP,nQtdBai,Round(NoRound(aAux[01] * nProp,aDecCFFD3[1]+1),aDecCFFD3[1]),Round(NoRound(aAux[02] * nProp,aDecCFFD3[2]+1),aDecCFFD3[2]),Round(NoRound(aAux[03] * nProp,aDecCFFD3[3]+1),aDecCFFD3[3]),Round(NoRound(aAux[04] * nProp,aDecCFFD3[4]+1),aDecCFFD3[4]),Round(NoRound(aAux[05] * nProp,aDecCFFD3[5]+1),aDecCFFD3[5]),SBD->BD_SEQ,dData,cTM,cSerie,cItem,NIL,nQtdBai2,"SD3",SD3->D3_NUMSEQ,lOnLine)
				RecLock("SBD",.F.)
				If !((isincallstack('MATA260') .or. isincallstack('MATA261')).and. SD3->D3_FILIAL = SBD->BD_FILIAL .and. SD3->D3_COD = SBD->BD_PRODUTO .and. SD3->D3_LOCAL = SBD->BD_LOCAL)
					Replace  BD_QFIM        With BD_QFIM - nQtdBai
					Replace  BD_QFIM2UM     With ConvUm(BD_PRODUTO,BD_QFIM,nQtdBai2,2)
					Replace  BD_CUSFIM1     With BD_CUSFIM1 - Round(NoRound(aAux[01] * nProp,aDecCFFD3[1]+1),aDecCFFD3[1])
					If("2" $ cMoedaCM)
						Replace  BD_CUSFIM2 With BD_CUSFIM2 - Round(NoRound(aAux[02] * nProp,aDecCFFD3[2]+1),aDecCFFD3[2])
					EndIf
					If("3" $ cMoedaCM)
						Replace  BD_CUSFIM3 With BD_CUSFIM3 - Round(NoRound(aAux[03] * nProp,aDecCFFD3[3]+1),aDecCFFD3[3])
					EndIf
					If("4" $ cMoedaCM)
						Replace  BD_CUSFIM4 With BD_CUSFIM4 - Round(NoRound(aAux[04] * nProp,aDecCFFD3[4]+1),aDecCFFD3[4])
					EndIf
					If("5" $ cMoedaCM)
						Replace  BD_CUSFIM5 With BD_CUSFIM5 - Round(NoRound(aAux[05] * nProp,aDecCFFD3[5]+1),aDecCFFD3[5])
					EndIf
				EndIf

			ElseIf cArquivo == "SD2"
				// aAux[NN] -> Array utilizado para calculo do custo fifo do movimento
				aAux[01]   := IIf(lNfDebCred,SD2->D2_CUSTO1,SBD->BD_CUSFIM1)
				aAux[02]   := IIf(lNfDebCred,SD2->D2_CUSTO2,SBD->BD_CUSFIM2)
				aAux[03]   := IIf(lNfDebCred,SD2->D2_CUSTO3,SBD->BD_CUSFIM3)
				aAux[04]   := IIf(lNfDebCred,SD2->D2_CUSTO4,SBD->BD_CUSFIM4)
				aAux[05]   := IIf(lNfDebCred,SD2->D2_CUSTO5,SBD->BD_CUSFIM5)
				// aCusto[NN] -> Array utilizado para calculo do custo fifo unificado
				aCusto[01] := aCusto[01] + Round(NoRound( aAux[01] * nProp,aDecCFFD3[1]+1),aDecCFFD3[1])
				aCusto[02] := aCusto[02] + Round(NoRound( aAux[02] * nProp,aDecCFFD3[2]+1),aDecCFFD3[2])
				aCusto[03] := aCusto[03] + Round(NoRound( aAux[03] * nProp,aDecCFFD3[3]+1),aDecCFFD3[3])
				aCusto[04] := aCusto[04] + Round(NoRound( aAux[04] * nProp,aDecCFFD3[4]+1),aDecCFFD3[4])
				aCusto[05] := aCusto[05] + Round(NoRound( aAux[05] * nProp,aDecCFFD3[5]+1),aDecCFFD3[5])
				nQtdFim    := nQtdFim + nQtdBai

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava o custo fifo on-line nas tabelas SD2/SB2           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lOnLine
					RecLock("SD2")
					Replace D2_CUSFF1     With D2_CUSFF1 + Round(NoRound( aAux[01] * nProp,aDecCFFD3[1]+1),aDecCFFD3[1])
					If("2" $ cMoedaCM)
						Replace D2_CUSFF2 With D2_CUSFF2 + Round(NoRound( aAux[02] * nProp,aDecCFFD3[2]+1),aDecCFFD3[2])
					EndIf
					If("3" $ cMoedaCM)
						Replace D2_CUSFF3 With D2_CUSFF3 + Round(NoRound( aAux[03] * nProp,aDecCFFD3[3]+1),aDecCFFD3[3])
					EndIf
					If("4" $ cMoedaCM)
						Replace D2_CUSFF4 With D2_CUSFF4 + Round(NoRound( aAux[04] * nProp,aDecCFFD3[4]+1),aDecCFFD3[4])
					EndIf
					If("5" $ cMoedaCM)
						Replace D2_CUSFF5 With D2_CUSFF5 + Round(NoRound( aAux[05] * nProp,aDecCFFD3[5]+1),aDecCFFD3[5])
					EndIf
					MsUnLock()
					dbSelectArea("SB2")
					dbSetOrder(1)
					If MsSeek(xFilial("SB2")+SBD->BD_PRODUTO+SBD->BD_LOCAL)
						RecLock("SB2")
						Replace B2_QFIMFF      With B2_QFIMFF  - Round(NoRound( IIf(lNfDebCred,0,SBD->BD_QFIM) * nProp,aDecCFFD3[1]+1),aDecCFFD3[1])
						Replace B2_VFIMFF1 	   With B2_VFIMFF1 - Round(NoRound( aAux[01] * nProp,aDecCFFD3[1]+1),aDecCFFD3[1])
						If("2" $ cMoedaCM)
							Replace B2_VFIMFF2 With B2_VFIMFF2 - Round(NoRound( aAux[02] * nProp,aDecCFFD3[2]+1),aDecCFFD3[2])
						EndIf
						If("3" $ cMoedaCM)
							Replace B2_VFIMFF3 With B2_VFIMFF3 - Round(NoRound( aAux[03] * nProp,aDecCFFD3[3]+1),aDecCFFD3[3])
						EndIf
						If("4" $ cMoedaCM)
							Replace B2_VFIMFF4 With B2_VFIMFF4 - Round(NoRound( aAux[04] * nProp,aDecCFFD3[4]+1),aDecCFFD3[4])
						EndIf
						If("5" $ cMoedaCM)
							Replace B2_VFIMFF5 With B2_VFIMFF5 - Round(NoRound( aAux[05] * nProp,aDecCFFD3[5]+1),aDecCFFD3[5])
						EndIf
						Replace B2_CMFF1       With B2_VFIMFF1 / B2_QFIMFF
						If("2" $ cMoedaCM)
							Replace B2_CMFF2   With B2_VFIMFF2 / B2_QFIMFF
						EndIf
						If("3" $ cMoedaCM)
							Replace B2_CMFF3   With B2_VFIMFF3 / B2_QFIMFF
						EndIf
						If("4" $ cMoedaCM)
							Replace B2_CMFF4   With B2_VFIMFF4 / B2_QFIMFF
						EndIf
						If("5" $ cMoedaCM)
							Replace B2_CMFF5   With B2_VFIMFF5 / B2_QFIMFF
						EndIf
						MsUnLock()
					EndIf
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava Movimentacao dos Lotes FIFO no "SD8"            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				GravaSD8(cCF,cTipoNF,cDoc,cOP,nQtdBai,Round(NoRound(aAux[01] * nProp,3),2),Round(NoRound(aAux[02] * nProp,3),2),Round(NoRound(aAux[03] * nProp,3),2),Round(NoRound(aAux[04] * nProp,3),2),Round(NoRound(aAux[05] * nProp,3),2),SBD->BD_SEQ,dData,cTM,cSerie,cItem,NIL,nQtdBai2,"SD2",SD2->D2_NUMSEQ,lOnLine)
				RecLock("SBD",.F.)
				Replace  BD_QFIM    	With BD_QFIM - nQtdBai
				Replace  BD_QFIM2UM 	With ConvUm(BD_PRODUTO,BD_QFIM,nQtdBai2,2)
				Replace  BD_CUSFIM1 	With BD_CUSFIM1 - Round(NoRound( aAux[01] * nProp,aDecCFFD3[1]+1),aDecCFFD3[1])
				If("2" $ cMoedaCM)
					Replace  BD_CUSFIM2 With BD_CUSFIM2 - Round(NoRound( aAux[02] * nProp,aDecCFFD3[2]+1),aDecCFFD3[2])
				EndIf
				If("3" $ cMoedaCM)
					Replace  BD_CUSFIM3 With BD_CUSFIM3 - Round(NoRound( aAux[03] * nProp,aDecCFFD3[3]+1),aDecCFFD3[3])
				EndIf
				If("4" $ cMoedaCM)
					Replace  BD_CUSFIM4 With BD_CUSFIM4 - Round(NoRound( aAux[04] * nProp,aDecCFFD3[4]+1),aDecCFFD3[4])
				EndIf
				If("5" $ cMoedaCM)
					Replace  BD_CUSFIM5 With BD_CUSFIM5 - Round(NoRound( aAux[05] * nProp,aDecCFFD3[5]+1),aDecCFFD3[5])
				EndIf
			EndIf
		Else
			RecLock("SBD",.F.)
		EndIf
		If SBD->BD_QFIM == 0
			Replace BD_STATUS With "Z" //-- Lote Fifo Encerrado
		ElseIf SBD->BD_QFIM > 0
			Replace BD_STATUS With " " //-- Lote Fifo em Aberto
		EndIf
		Replace  BD_DTCALC  With IIf(lOnLine,dDataBase,a330ParamZX[01])
		MsUnlock()
		nQuant  := nQuant - nQtdBai
		If lRE6QtZero
			nCountRE6++
			If aAuxRE6[01] <= 0 .Or. nCountRE6 > 20
				Exit
			Else
				lAuxRE6 := .T.
			Endif
		Else
			If nQuant <= 0 .or. (lOnLine .And. cArquivo == "SD3" .And. SD3->D3_ESTORNO == 'S' .and. SBD->BD_QFIM == 0) .or.;
			   IsInCallStack('MATA330') .and. cArquivo == "SD3" .And. cLocal == cLocCQ 
				Exit
			Endif
		EndIf
		lFirst:= .F.
	End
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona no registro correspondente ao SD1           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lOnLine
		SD8->(dbSetOrder(5))
		SD8->(dbSeek(xFilial("SD8")+SD3->D3_COD+SD3->D3_LOCAL+SD3->D3_NUMSEQ))
		dbSelectArea("SBD")
		dbSetOrder(2)
		dbSeek(xFilial("SBD")+SD8->D8_SEQ)
	Else
		dbSelectArea("TRB")
		nOldRec := Recno()
		MsGoto(TRB->TRB_RECTRB)
		dbSelectArea("SBD")
		MsGoto(TRB->TRB_RECSBD)
		dbSelectArea("TRB")
		MsGoto(nOldRec)
		dbSelectArea("SBD")
	EndIf
	If Eof()
		If lOnLine
			Help(" ",1,"DIVFIFO")
		Else
			GravaDif(cProduto,cLocal,nQuant,cCF,cTM,cDoc,cSerie,cOP,dData)
		EndIf
	Else
		If SBD->BD_QFIM >= nQuant
			nQtdBai := nQuant
			nQtdBai2:= nQuant2
			nProp   := (nQtdBai / SBD->BD_QFIM) // * nMultiplic
		Else
			nQtdBai := SBD->BD_QFIM
			nQtdBai2:= SBD->BD_QFIM2UM
			nProp   := 1 // * nMultiplic
		EndIf
		aCusto[01] := aCusto[01] + Round(NoRound(BD_CUSFIM1 * nProp,aDecCFFD3[1]+1),aDecCFFD3[1])
		aCusto[02] := aCusto[02] + Round(NoRound(BD_CUSFIM2 * nProp,aDecCFFD3[2]+1),aDecCFFD3[2])
		aCusto[03] := aCusto[03] + Round(NoRound(BD_CUSFIM3 * nProp,aDecCFFD3[3]+1),aDecCFFD3[3])
		aCusto[04] := aCusto[04] + Round(NoRound(BD_CUSFIM4 * nProp,aDecCFFD3[4]+1),aDecCFFD3[4])
		aCusto[05] := aCusto[05] + Round(NoRound(BD_CUSFIM5 * nProp,aDecCFFD3[5]+1),aDecCFFD3[5])
		nQtdFim    := nQtdFim + nQtdBai

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava Movimentacao dos Lotes FIFO no "SD8"            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		GravaSD8(cCF,cTipoNF,cDoc,cOP,nQtdBai,Round(NoRound(BD_CUSFIM1 * nProp,aDecCFFD3[1]+1),aDecCFFD3[1]),Round(NoRound(BD_CUSFIM2 * nProp,aDecCFFD3[2]+1),aDecCFFD3[2]),Round(NoRound(BD_CUSFIM3 * nProp,aDecCFFD3[3]+1),aDecCFFD3[3]),Round(NoRound(BD_CUSFIM4 * nProp,aDecCFFD3[4]+1),aDecCFFD3[4]),Round(NoRound(BD_CUSFIM5 * nProp,aDecCFFD3[5]+1),aDecCFFD3[5]),SBD->BD_SEQ,dData,cTM,cSerie,cItem,NIL,nQtdBai2,"SD3",SD3->D3_NUMSEQ,lOnLine)

		RecLock("SBD",.F.)
		Replace  BD_QFIM        With BD_QFIM - nQtdBai
		Replace  BD_QFIM2UM     With ConvUm(BD_PRODUTO,BD_QFIM,nQtdBai2,2)
		Replace  BD_CUSFIM1     With BD_CUSFIM1 - Round(NoRound(BD_CUSFIM1 * nProp,aDecCFFD3[1]+1),aDecCFFD3[1])
		If("2" $ cMoedaCM)
			Replace  BD_CUSFIM2 With BD_CUSFIM2 - Round(NoRound(BD_CUSFIM2 * nProp,aDecCFFD3[2]+1),aDecCFFD3[2])
		EndIf
		If("3" $ cMoedaCM)
			Replace  BD_CUSFIM3 With BD_CUSFIM3 - Round(NoRound(BD_CUSFIM3 * nProp,aDecCFFD3[3]+1),aDecCFFD3[3])
		EndIf
		If("4" $ cMoedaCM)
			Replace  BD_CUSFIM4 With BD_CUSFIM4 - Round(NoRound(BD_CUSFIM4 * nProp,aDecCFFD3[4]+1),aDecCFFD3[4])
		EndIf
		If("5" $ cMoedaCM)
			Replace  BD_CUSFIM5 With BD_CUSFIM5 - Round(NoRound(BD_CUSFIM5 * nProp,aDecCFFD3[5]+1),aDecCFFD3[5])
		EndIf
		If SBD->BD_QFIM == 0
			Replace BD_STATUS  With "Z"
		EndIf
		Replace  BD_DTCALC     With IIf(lOnLine,dDataBase,a330ParamZX[01])
		MsUnlock()
	EndIf
EndIf

aSBDFim[01] := aCusto
aSBDFim[02] := nQtdFim
Set(3,nDec)
dbSelectArea(cAlias)
Return aSBDFim

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³PegaCusSBD³ Autor ³ Marcos / Rosane       ³ Data ³ 20/08/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Pega ultimo custo do SBD                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function PegaCusSBD(cCod,cLocal,cAlias,cFilOri)
LOCAL aAreaAnt	:= GetArea()
LOCAL aAreaSF1  := SF1->(GetArea())
LOCAL aAreaSF4	:= SF4->(GetArea())
LOCAL nQuant	:= IIf(cAlias == "SD1",SD1->D1_QUANT,0)
LOCAL aSaldoFF	:= { 0,0,0,0,0 }
LOCAL aCusEntFF	:= {}
LOCAL aCusDevFF := {}
LOCAL lContinua := .T.
LOCAL nTotItemFF:= 0
LOCAL nDescFF	:= 0
LOCAL nValIpiFF := 0
LOCAL nValIcmFF := 0
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| MV_CUSNFED - Parametro utilizado para verifica se o      |
//| recalculo do custo medio devera calcular o custo fifo da |
//| nota de entrada de devolucao pelo custo medio ou pelo    |
//| proprio custo da  nota de entrada, nos casos onde a nota |
//| original nao eh localizada pelo sistema.			     |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LOCAL lCusNfeDev:= SuperGetMV("MV_CUSNFED",.F.,.F.)

DEFAULT cAlias	:= ""
DEFAULT cFilOri := cFilAnt

If cAlias == "SD1" .And. SD1->D1_TIPO == "D" .And. lCusNfeDev
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//|	Nos casos de notas de devolucao de vendas onde a nota de   |
	//| origem nao e localizada, gravar o proprio custo de entrada |
	//| da nota de devolucao. (Custo FIFO)                         |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SF4")
	dbSetOrder(1)
	MsSeek(xFilial("SF4")+SD1->D1_TES)

	lContinua	:= .F.
	nTotItemFF	:= SD1->D1_TOTAL
	nDescFF		:= IIf(SD1->D1_DESC > 0,SD1->D1_DESC,(SD1->D1_VALDESC/nTotItemFF)*100)
	nValIpiFF   := IIf(SF4->F4_IPI == "S",SD1->D1_VALIPI,0)
	nValIcmFF	:= IIf(SF4->F4_ICM != 'N',SD1->D1_VALICM,0)

	Aadd(aCusDevFF,{	nTotItemFF*(1-nDescFF/100) ,;
						nValIpiFF ,;
						nValIcmFF ,;
						SF4->F4_CREDIPI ,;
						SF4->F4_CREDICM ,;
						SD1->D1_NFORI,;
						SD1->D1_SERIORI,;
						SD1->D1_COD,;
						SD1->D1_LOCAL,;
						SD1->D1_QTDEDEV,;
						0 })
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Retorna o Custo de Entrada nas 5 moedas                    |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SF1")
	dbSetOrder(1)
	dbSeek(xFilial("SF1")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_TIPO)

	aCusEntFF := RetCusEnt( Nil, aCusDevFF )

	aSaldoFF[01] := aCusEntFF[1,1]/nQuant
	aSaldoFF[02] := aCusEntFF[1,2]/nQuant
	aSaldoFF[03] := aCusEntFF[1,3]/nQuant
	aSaldoFF[04] := aCusEntFF[1,4]/nQuant
	aSaldoFF[05] := aCusEntFF[1,5]/nQuant
	RestArea(aAreaSF1)
	RestArea(aAreaSF4)
EndIf

If lContinua
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona no ultimo registro para fazer a devolucao   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SBD")
	dbSeek( xFilial("SBD", cFilOri) + cCod + cLocal + " " + "999999" , .T. )
	dbSkip(-1)

	If (SBD->BD_FILIAL+SBD->BD_PRODUTO+SBD->BD_LOCAL+SBD->BD_STATUS == xFilial("SBD", cFilOri)+cCod+cLocal+' ')
		aSaldoFF[01] := SBD->BD_CUSFIM1
		aSaldoFF[02] := SBD->BD_CUSFIM2
		aSaldoFF[03] := SBD->BD_CUSFIM3
		aSaldoFF[04] := SBD->BD_CUSFIM4
		aSaldoFF[05] := SBD->BD_CUSFIM5
		If (SBD->BD_QFIM > 0)
			aSaldoFF[01] := SBD->BD_CUSFIM1 / SBD->BD_QFIM
			aSaldoFF[02] := SBD->BD_CUSFIM2 / SBD->BD_QFIM
			aSaldoFF[03] := SBD->BD_CUSFIM3 / SBD->BD_QFIM
			aSaldoFF[04] := SBD->BD_CUSFIM4 / SBD->BD_QFIM
			aSaldoFF[05] := SBD->BD_CUSFIM5 / SBD->BD_QFIM
		Endif
	ElseIf GetMV("MV_CUSZERO") # "S"
		SB2->(dbSetOrder(1))
		If SB2->(MsSeek(xFilial("SB2", cFilOri)+cCod+cLocal))
			If SB2->B2_QFIM > 0
				aSaldoFF[01] :=  SB2->B2_VFIMFF1/SB2->B2_QFIM
				aSaldoFF[02] :=  SB2->B2_VFIMFF2/SB2->B2_QFIM
				aSaldoFF[03] :=  SB2->B2_VFIMFF3/SB2->B2_QFIM
				aSaldoFF[04] :=  SB2->B2_VFIMFF4/SB2->B2_QFIM
				aSaldoFF[05] :=  SB2->B2_VFIMFF5/SB2->B2_QFIM
				// Caso seja devolucao e nao achou custo busca custo medio
				If aSaldoFF[01] == 0
					aSaldoFF[01] :=  SB2->B2_VFIM1/SB2->B2_QFIM
					aSaldoFF[02] :=  SB2->B2_VFIM2/SB2->B2_QFIM
					aSaldoFF[03] :=  SB2->B2_VFIM3/SB2->B2_QFIM
					aSaldoFF[04] :=  SB2->B2_VFIM4/SB2->B2_QFIM
					aSaldoFF[05] :=  SB2->B2_VFIM5/SB2->B2_QFIM
				EndIf
			Else
				aSaldoFF[01] :=  SB2->B2_CM1
				aSaldoFF[02] :=  SB2->B2_CM2
				aSaldoFF[03] :=  SB2->B2_CM3
				aSaldoFF[04] :=  SB2->B2_CM4
				aSaldoFF[05] :=  SB2->B2_CM5
			EndIf
		EndIf
	EndIf
EndIf
RestArea(aAreaAnt)
Return( aSaldoFF )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GravaSD8  ³ Autor ³ Marcos / Rosane       ³ Data ³ 28/08/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava SD8 com Movimentacoes Lotes FIFO                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GravaSD8(cCF,cTipoNF,cDoc,cOP,nQtdBai,nCusto1,nCusto2,nCusto3,nCusto4,nCusto5,nSeq,dData,cTM,cSerie,cItem,lMOD,nQtdBai2,cOrigem,cNumSeq,lOnLine)
Local cAlias      := Alias()
Local aAreaSD8    := SD8->(GetArea())
Local cMoedaCM    := SuperGetMv('MV_MOEDACM',.F.,"2345")
Local cSeek	      := ''

lMOD    := IIf(lMOD   ==Nil,.F.,lMOD)
cOrigem := IIf(cOrigem==Nil,'',cOrigem)
cNumSeq := IIf(cNumSeq==Nil,'',cNumSeq)
lOnLine := IIf(lOnLine==Nil,.F.,lOnLine)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Posiciona no local a ser atualizado, ajustando a variavel nSeqFiFo ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SD8")
dbSetOrder(1)
dbSeek(cSeek:=xFilial("SD8")+SBD->BD_PRODUTO+SBD->BD_LOCAL+nSeq)
nSeqFIFO := Val(SD8->D8_SEQCALC)
nSeqFIFO := iif(nSeqFIFO==0,nSeqFIFO++,nSeqFIFO)
Do While !Eof() .And. cSeek == xFilial("SD8")+SD8->D8_PRODUTO+SD8->D8_LOCAL+SD8->D8_SEQ
	If Val(SD8->D8_SEQCALC) >= nSeqFIFO
		nSeqFIFO := Val(SD8->D8_SEQCALC)+1
	Endif
	dbSkip()
EndDo
RestArea(aAreaSD8)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Grava tabela SD8 baseada no FIFO On-Line                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lOnLine
	RecLock("SD8",.T.)
	Replace D8_FILIAL  With xFilial("SD8")
	Replace D8_PRODUTO With SBD->BD_PRODUTO
	Replace D8_LOCAL   With SBD->BD_LOCAL
	Replace D8_QUANT   With IIf(nQtdBai==Nil,SBD->BD_QUANT,nQtdBai)
	Replace D8_QT2UM   With ConvUm(SBD->BD_PRODUTO,SD8->D8_QUANT,IIf(nQtdBai2==Nil,SBD->BD_QT2UM,nQtdBai2),2)
	Replace D8_DATA    With dData
	Replace D8_CUSTO1  With nCusto1
	If ("2" $ cMoedaCM)
		Replace D8_CUSTO2  With nCusto2
	EndIf
	If ("3" $ cMoedaCM)
		Replace D8_CUSTO3  With nCusto3
	EndIf
	If ("4" $ cMoedaCM)
		Replace D8_CUSTO4  With nCusto4
	EndIf
	If ("5" $ cMoedaCM)
		Replace D8_CUSTO5  With nCusto5
	EndIf
	Replace D8_SEQ     With nSeq
	Replace D8_CF      With cCF
	Replace D8_TIPONF  With cTipoNF
	Replace D8_DOC     With cDoc
	Replace D8_OP      With cOP
	Replace D8_TM      With cTM
	Replace D8_SERIE   With cSerie
	Replace D8_ITEM    With cItem
	Replace D8_ORIGEM  With cOrigem
	Replace D8_NUMSEQ  With cNumSeq
	Replace D8_SEQCALC With StrZero(nSeqFIFO,6)
	Replace D8_DTCALC  With dDataBase
	Replace D8_DTPROC  With dDataBase
	MsUnlock()

Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava tabela SD8 baseada no FIFO Off-Line                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	RecLock("SD8",.T.)
	If lMod
		Replace D8_PRODUTO With SD3->D3_COD
		Replace D8_LOCAL   With SD3->D3_LOCAL
		Replace D8_QUANT   With SD3->D3_QUANT
		Replace D8_QT2UM   With SD3->D3_QTSEGUM
	Else
		Replace D8_PRODUTO With SBD->BD_PRODUTO
		Replace D8_LOCAL   With SBD->BD_LOCAL
		Replace D8_QUANT   With IIf(nQtdBai==Nil,SBD->BD_QUANT,nQtdBai)
		Replace D8_QT2UM   With ConvUm(SBD->BD_PRODUTO,SD8->D8_QUANT,IIf(nQtdBai2==Nil,SBD->BD_QT2UM,nQtdBai2),2)
	Endif
	Replace D8_FILIAL  With xFilial("SD8")
	Replace D8_DATA    With dData
	Replace D8_CUSTO1  With nCusto1
	If ("2" $ cMoedaCM)
		Replace D8_CUSTO2  With nCusto2
	EndIf
	If ("3" $ cMoedaCM)
		Replace D8_CUSTO3  With nCusto3
	EndIf
	If ("4" $ cMoedaCM)
		Replace D8_CUSTO4  With nCusto4
	EndIf
	If ("5" $ cMoedaCM)
		Replace D8_CUSTO5  With nCusto5
	EndIf
	Replace D8_SEQ     With nSeq
	Replace D8_CF      With cCF
	Replace D8_TIPONF  With cTipoNF
	Replace D8_DOC     With cDoc
	Replace D8_OP      With cOP
	Replace D8_SEQCALC With StrZero(nSeqFIFO,6)
	Replace D8_DTCALC  With a330ParamZX[01]
	Replace D8_DTPROC  With a330ParamZX[01]
	Replace D8_TM      With cTM
	Replace D8_SERIE   With cSerie
	Replace D8_ITEM    With cItem
	Replace D8_ORIGEM  With cOrigem
	Replace D8_NUMSEQ  With cNumSeq
	MsUnlock()
EndIf
dbSelectArea( cAlias )
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ GravaDIF ³ Autor ³ Stiefano / Rosane     ³ Data ³ 11/01/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Faz a grava‡ao de um LOG de ocorrencias                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GravaDif(cProduto,cLocal,nQuant,cCF,cTM,cDoc,cSerie,cOP,dData)
Local c0Pos001,c0Pos003,c0Pos018,c0Pos020,c0Pos045,c0Pos061
Local c0Pos064,c0Pos067,c0Pos073,c0Pos076,c0Pos087

c0Pos001 := xFilial("SBD")
c0Pos003 := cProduto
c0Pos018 := cLocal

dbSelectArea("SB1")
dbSeek( xFilial("SBD") + cProduto + cLocal )
If Found()
	c0Pos020 := SubStr(SB1->B1_DESC,1,25)
Else
	c0Pos020 := Space(25)
Endif
dbSelectArea("SBD")

c0Pos045 := StrZero( nQuant , 16 )
c0Pos061 := cCF
c0Pos064 := cTM
c0Pos067 := cDoc
c0Pos073 := If(Empty(cSerie),cSerie:=Space(03),cSerie)
c0Pos076 := cOP
c0Pos087 := DtoC(dData)

c0Contem := c0Pos001 + c0Pos003 + c0Pos018 + c0Pos020 + c0Pos045 + c0Pos061 + ;
	        c0Pos064 + c0Pos067 + c0Pos073 + c0Pos076 + c0Pos087
Grava( c0Contem )

Return( Nil )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ Grava    ³ Autor ³ Stiefano / Rosane     ³ Data ³ 11/01/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Utilizada pela fun‡Æo GravaDIF                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Grava( cCampo )

Local cAliasTMP:= STRTRAN(AllTrim("TMP"+cEmpAnt+cFilAnt)," ","_")

dbSelectArea( cAliasTMP )
RecLock(cAliasTMP,.T.)
Replace T_CONTEUDO With cCampo
dbUnlock()
Return( Nil )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ A690ChkFlag ³ Autor ³ Waldemiro Lustosa  ³ Data ³ 13/02/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Fun‡„o que verifica Flag espec¡fico em MV_FLAGPCP.         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA690                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A690ChkFlag(nFlag)
Return Val(Substr(GetMV("MV_FLAGPCP"),nFlag,1))

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ClosFile  ³ Autor ³ Gilson do Nascimento  ³ Data ³ 28/11/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Fechar arquivos abertos pela ChkFile()                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ClosFile(cExpr1)                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cExpr1 = Alias do arquivo aberto pelo ChkFile()            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ClosFile(cAlias)
LOCAL cFilter
dbSelectArea("SX2")
cFopened := Subs(cFopened,1,AT(cAlias,cFopened)-1)
cFilter := dbFilter()
Set Filter to &(cFilter)
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ A690CheckSC2³ Autor ³ Waldemiro Lustosa  ³ Data ³ 22/01/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Fun‡Æo de Controle de Atualiza‡Æo dos Arq. SC1, SC2 e SD4. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA690                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A690CheckSC2(lOpc)
// Atualiza ou verifica primeira Flag do parametro MV_FLAGPCP que indica:
// 1 - Foi rodada a Carga M quina mas n„o foram atualizados os Arquivos SC2, etc.
// 0 - Foi rodada a Carga M quina e foram atualizados os Arquivos SC2, ou n„o foi
//     rodada a Carga M quina.
If lOpc == NIL
	If A690ChkFlag(1) == 1
		Return .T.
	Else
		Return .F.
	EndIf
EndIf
If lOpc
	A690AtuFlag(1,1)
Else
	A690AtuFlag(1,0)
EndIf
Return NIL

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ A690AtuFlag ³ Autor ³ Waldemiro Lustosa  ³ Data ³ 13/02/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Fun‡„o que atualiza Flag espec¡fico em MV_FLAGPCP.         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA690                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A690AtuFlag(nFlag,nValor)
Local cParam := GetMV("MV_FLAGPCP")

If cParam # NIL
	If Len(cParam) < 2
		cParam := StrTran(Pad(cParam,2), " ", "0")
	Endif
	PutMV("MV_FLAGPCP",Stuff(cParam, nFlag, 1, Str(nValor,1,0)))
EndIf

Return NIL

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ SaldoMov ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 17/03/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o saldo disponivel para movimentacao de acordo com ³±±
±±³          ³ o parametro MV_TPSALDO, que pode ser preenchido com:       ³±±
±±³          ³ C = Utiliza o saldo proveniente da funcao Calcest,subtrain ³±±
±±³          ³ do tambem as informacoes de empenho caso parametrizado     ³±±
±±³          ³ S = Utiliza o saldo proveniente da funcao SALDOSB2         ³±±
±±³          ³ Q = Utiliza o saldo resultante da expressao                ³±±
±±³          ³     B2_QATU-B2_QACLASS-B2_RESERVA                          ³±±
±±³          ³ ATENCAO: o arquivo SB2 SEMPRE DEVE estar posicionado no    ³±±
±±³          ³          registro correto!                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpN1:= SaldoMov(ExpL1,ExpL2,ExpD1,ExpL3,ExpN1,ExpN2,ExpL3)³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpL1 = Flag  que  indica se chamada da funcao ‚ utilizada ³±±
±±³          ³         para  calculo de Necessidade. Neste caso o Saldo a ³±±
±±³          ³         Distribuir  serah somado ao Saldo a ser Retornado, ³±±
±±³          ³         pois  esta  quantidade  jah consta em estoque, soh ³±±
±±³          ³         nao pode ser utilizada porque ainda nao foi        ³±±
±±³          ³         distribuida.                                       ³±±
±±³          ³ ExpL2 = Subtrai o Empenho do Saldo a ser Retornado?        ³±±
±±³          ³         Obs.: Soh funciona se o MV_TPSALDO for "S".        ³±±
±±³          ³ ExpD1 = Somente empenhos ateh esta data serao considerados ³±±
±±³          ³         no  caso  de  leitura  do SD4 (que eh ativada pelo ³±±
±±³          ³         parametro MV_CONDEMP na funcao SALDOSB2).          ³±±
±±³          ³         Obs.: Soh funciona se o MV_TPSALDO for "S".        ³±±
±±³          ³ ExpL3 = Soma o [Saldo de Terceiros em nosso Poder] ao      ³±±
±±³          ³         Saldo a ser Retornado?                             ³±±
±±³          ³ ExpN1 = Quantidade Empenhada que NAO deve ser considerada  ³±±
±±³          ³         no Saldo Empenhado a ser Retornado                 ³±±
±±³          ³         Obs.: Soh funciona se o MV_TPSALDO for "S" ou "C". ³±±
±±³          ³ ExpN2 = Quantidade Empenhada de Projetos que NAO deve ser  ³±±
±±³          ³         considerada no Saldo Empenhado a ser Retornado     ³±±
±±³          ³         Obs.: Soh funciona se o MV_TPSALDO for "S".        ³±±
±±³          ³ ExpL4 = Subtrai a Reserva do Saldo a ser Retornado?        ³±±
±±³          ³ ExpL5 = Subtrai a Quantidade Prevista no SA a ser Retornado³±±
±±³          ³         Obs.: Somente funciona se o MV_TPSALDO for "C"     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpN1 = Saldo devolvido pela funcao                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function SaldoMov(lNecessida, lEmpenho, dDataFim, lConsTerc, nQtdEmp, nQtdPrj, lSaldoSemR, dDtRefSld,lConsEmpSA)
Static cSaldoSB2  := Nil

Local nRetorno    := 0

Default nQtdEmp   := 0
Default nQtdPrj   := 0
Default lConsEmpSA:= .T.
Default dDtRefSld := dDataBase

If !(SB2->B2_STATUS=='2') //-- 1=Saldo Disponivel / 2=Saldo Indisponivel
	If cSaldoSB2 == Nil
		cSaldoSB2 := GetMV('MV_TPSALDO') //-- o SUPERGETMV NAO foi usado para forcar a leitura do parametro no SX6 (que ocorrera somente 1 vez)
	EndIf
	lNecessida := If(ValType(lNecessida)=='L', lNecessida, .F.)
	lEmpenho   := If(ValType(lEmpenho)  =='L', lEmpenho  , .T.)
	lConsTerc  := If(ValType(lConsTerc) =='L', lConsTerc , .T.)

	If cSaldoSB2 == "S" .Or. cSaldoSB2 == "C"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ MV_SLDRESE - utilizado para verificar se deve subtrair a reserva do saldo |
		//| disponivel. Somente utilizado quando MV_TPSALDO for preenchido com 'S/C'  |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		lSaldoSemR := If(ValType(lSaldoSemR)=='L', lSaldoSemR, SuperGetMV('MV_SLDRESE', .F., 'N') == "S" )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ MV_SLDEMPE - utilizado para verificar se deve subtrair o empenho do saldo |
		//| disponivel. Somente utilizado quando MV_TPSALDO for preenchido com 'C'    |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cSaldoSB2 == "C" .And. AllTrim(SuperGetMV('MV_SLDEMPE', .F., 'N'))=="S"
			lEmpenho := .F.
		EndIf
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Para manter a compatibilidade: se este parametro nao for passado serah    |
		//| inicializado com True SOMENTE se o MV_TPSALDO for preenchido com "Q"      |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		lSaldoSemR := If(ValType(lSaldoSemR)=='L', lSaldoSemR,(cSaldoSB2=='Q'))
	EndIf

	If cSaldoSB2 == "S"
		//-- Calcula o saldo disponivel atual
		nRetorno := SaldoSB2(lNecessida, lEmpenho, dDataFim, lConsTerc, Nil, Nil, nQtdEmp, nQtdPrj, lSaldoSemR,,lConsEmpSA)
	ElseIf cSaldoSB2 == "C"
		//-- Calcula o saldo disponivel na data informada //
		nRetorno := SaldoSB2(lNecessida, lEmpenho, dDataFim, lConsTerc, Nil, Nil, nQtdEmp, nQtdPrj, lSaldoSemR, dDtRefSld,lConsEmpSA)
	Else
		nRetorno := SB2->B2_QATU - If(lNecessida, 0, SB2->B2_QACLASS) - If(lSaldoSemR, SB2->B2_RESERVA, 0) - If(lConsTerc, 0, SB2->B2_QTNP)
	EndIf
EndIf

Return nRetorno

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³GetNumSC1 ³ Autor ³Eduardo Riera          ³ Data ³ 22.06.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Inicializa o Numero da Solicitacao de Compra                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Numero da Solicitacao de Compra                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³lConfirma : Confirma a utilizacao do Numero                 ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GetNumSC1(lConfirma)
Static lNewIniSC1
Local aArea    := GetArea()
Local aAreaSC1 := SC1->(GetArea())
Local aAreaSX3 := ""
Local cNumSc   := ""

lConfirma := If(lConfirma==Nil,.F.,lConfirma)

// Verifica se inicializador padrao foi mudado
If lNewIniSC1 == NIL
	aAreaSX3:=SX3->(GetArea())
	lNewIniSC1:=!("GETNUMSC1" $ UPPER(GetSX3Cache("C1_NUM","X3_RELACAO")))
	RestArea(aAreaSX3)
EndIf
// Executa novo inicializador padrao
If lNewIniSC1
	cNumSc:=CriaVar("C1_NUM")
	If Empty(cNumSc)
		lNewIniSC1:=.F.
	EndIf
EndIf
// Executa funcao default
If !lNewIniSC1
	cNumSc:=GetSxENum("SC1","C1_NUM")
	lConfirma := If(lConfirma==Nil,.F.,lConfirma)
EndIf
dbSelectArea("SC1")
dbSetOrder(1)
While SC1->(dbSeek(xFilial("SC1")+cNumSc))
	If ( __lSx8 )
		ConfirmSX8()
	EndIf
	cNumSc := GetSxENum("SC1","C1_NUM")
EndDo
If ( lConfirma )
	If ( __lSx8 )
		ConfirmSX8()
	EndIf
EndIf
RestArea(aAreaSC1)
RestArea(aArea)
Return(cNumSc)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³GetNumSC2 ³ Autor ³Eduardo Riera          ³ Data ³ 22.06.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Inicializa o Numero da Ordem de Producao                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Numero da Ordem de Producao                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³lConfirma : Confirma a utilizacao do Numero                 ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³03-08-00  ³Marcelo Iuspa  ³Criacao do Ponto de entrada MTNumSC2        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GetNumSC2(lConfirma)
Static lNewIniSC2
Static lMtNumSC2 := NIL
Local aArea    := GetArea()
Local aAreaSC2 := SC2->(GetArea())
Local aAreaSX3 := ""
Local cNumOp   := ""
Local xNumOp   := ""
Local lUsuSC2  := .F.
Local nPos     := 0
Local lContinua:= .T.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Tratamento incluido para compatibilizar com a chamada ³
//³ da MBrowseAuto e AxInclui na rotina automatica do     |
//| MATA650 e nao pular nros nos arquivos SXE e SXF.      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type('l650Auto')=="L" .And. l650Auto .And. Type("aRotProd")=="A"
	nPos := aScan(aRotProd,{|x| x[1] == "C2_NUM"})
	If nPos > 0 .And. !Empty(aRotProd[nPos,2])
			lContinua := .F.
	EndIf
EndIf

If lContinua
	lMtNumSC2 := If(ValType(lMtNumSC2)#"L",ExistBlock("MTNUMSC2"),lMtNumSC2)
	lConfirma := If(lConfirma==Nil,.F.,lConfirma)

	// Verifica se inicializador padrao foi mudado
	If lNewIniSC2 == NIL
		aAreaSX3:=SX3->(GetArea())
		lNewIniSC2:=!("GETNUMSC2" $ UPPER(GetSX3Cache("C2_NUM","X3_RELACAO")))
		RestArea(aAreaSX3)
	EndIf

	// Executa novo inicializador padrao
	If lNewIniSC2
		cNumOp:=CriaVar("C2_NUM")
		If Empty(cNumOp)
			lNewIniSC2:=.F.
		EndIf
	EndIf

	// Executa funcao default
	If !lNewIniSC2
		cNumOp:=GetSxENum("SC2","C2_NUM")
		lConfirma := If(lConfirma==Nil,.F.,lConfirma)
	EndIf

	dbSelectArea("SC2")
	dbSetOrder(1)
	While SC2->(dbSeek(xFilial("SC2")+cNumOp))
		If ( __lSx8 )
			ConfirmSX8()
		EndIf
		cNumOp := GetSxENum("SC2","C2_NUM")
	EndDo

	If lMtNumSC2
		xNumOp := ExecBlock("MTNUMSC2",.F.,.F.,cNumOp)
		If ValType(xNumOp) = "C" .And. ! Empty(xNumOp) .And. ! (xNumOp == cNumOp)
			cNumOp  := xNumOp
			lUsuSC2 := .T.
			If __lSx8
				RollBackSx8()
			Endif
		Endif
	Endif

	If ( lConfirma ) .And. ( ! lUsuSC2 )
		If ( __lSx8 )
			ConfirmSX8()
		EndIf
	EndIf
	RestArea(aAreaSC2)
	RestArea(aArea)
EndIf
Return(cNumOp)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³GetNumSC7 ³ Autor ³Eduardo Riera          ³ Data ³ 22.06.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Inicializa o Numero do Pedido de Compra                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Numero do Pedido de Compra                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³lConfirma : Confirma a utilizacao do Numero                 ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GetNumSC7(lConfirma)
Static lNewIniSC7
Local aArea    := GetArea()
Local aAreaSC7 := SC7->(GetArea())
Local aAreaSX3 := ""
Local cNumPc   := ""
Local lIntegra := (GetMv("MV_EASY") == "S") //Compras Integrado c/ Importacao.
Local lPcFilEnt:= GetMV("MV_PCFILEN")
Local cAliasSX8
Local cPcFilEnt := ""

If lPcFilEnt
	cAliasSX8:= Padr(FWCodEmp("SC7"),FWSizeFilial())+x2path("SC7")
Else
	cAliasSX8:= Nil
EndIf

lConfirma := If(lConfirma==Nil,.F.,lConfirma)

// Verifica se inicializador padrao foi mudado
If lNewIniSC7 == NIL
	If lIntegra
		If !("SW2"$cFOPENed)
			ChkFile("SW2",.F.)
		EndIf
	EndIf
	aAreaSX3:=SX3->(GetArea())
	lNewIniSC7:=!("GETNUMSC7" $ UPPER(GetSX3Cache("C7_NUM","X3_RELACAO")))
	RestArea(aAreaSX3)
EndIf

// Executa novo inicializador padrao
If lNewIniSC7
	cNumPc:=CriaVar("C7_NUM")
	If Empty(cNumPc)
		lNewIniSC7:=.F.
	EndIf
EndIf

// Executa funcao default
If !lNewIniSC7
	cNumPc:=GetSxENum("SC7","C7_NUM",cAliasSX8)
	lConfirma := If(lConfirma==Nil,.F.,lConfirma)
EndIf

dbSelectArea("SC7")
dbSetOrder(1)
If lIntegra
	dbSelectArea("SW2")
	dbSetOrder(1)
EndIf

While ChkChaveSC7(cNumPc) .Or. If(lIntegra,SW2->(dbSeek(xFilial("SW2")+cNumPc)),.F.)

	If !lPcFilEnt
		cPcFilEnt := " AND SC7.C7_FILIAL='"+xFilial("SC7")+"'"
	Else
		cPcFilEnt := " AND SC7.C7_FILIAL like '"+AllTrim(FWCodEmp("SC7"))+"%'"
	EndIf

	If UPPER(tcgetdb()) == "ORACLE"
		cQuery := "SELECT DISTINCT C7_NUM"
		cQuery += " FROM "+RetSqlName("SC7")+" SC7"
		cQuery += " WHERE SC7.C7_NUM > '"+cNumPc+"'"
		cQuery += " AND SC7.D_E_L_E_T_=' '"
		cQuery += " AND ROWNUM <= 500"
		cQuery += cPcFilEnt

	Elseif UPPER(tcgetdb()) == "POSTGRES" .Or. UPPER(tcgetdb()) == "MYSQL"
		cQuery := "SELECT DISTINCT C7_NUM"
		cQuery += " FROM "+RetSqlName("SC7")+" SC7"
		cQuery += " WHERE SC7.C7_NUM > '"+cNumPc+"'"
		cQuery += " AND SC7.D_E_L_E_T_ = ' '"
		cQuery += cPcFilEnt
		cQuery += " LIMIT 500"

	Elseif UPPER(tcgetdb()) == "DB2"
		cQuery := "SELECT DISTINCT C7_NUM"
		cQuery += " FROM "+RetSqlName("SC7")+" SC7"
		cQuery += " WHERE SC7.C7_NUM > '"+cNumPc+"'"
		cQuery += " AND SC7.D_E_L_E_T_=' '"
		cQuery += cPcFilEnt
		cQuery += " FETCH FIRST 500 ROWS ONLY"

	Elseif UPPER(tcgetdb()) == "INFORMIX"
		cQuery := "SELECT FIRST 500 DISTINCT C7_NUM"
		cQuery += " FROM "+RetSqlName("SC7")+" SC7"
		cQuery += " WHERE SC7.C7_NUM > '"+cNumPc+"'"
		cQuery += " AND SC7.D_E_L_E_T_=' '"
		cQuery += cPcFilEnt

	Else
		cQuery := "SELECT DISTINCT TOP 500 C7_NUM"
		cQuery += " FROM "+RetSqlName("SC7")+" SC7"
		cQuery += " WHERE SC7.C7_NUM > '"+cNumPc+"'"
		cQuery += " AND SC7.D_E_L_E_T_=' '"
		cQuery += cPcFilEnt
	Endif

	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"CHKSC7_",.T.,.T.)

	lContinua := .T.
	While lContinua
		If CHKSC7_->(EOF())
			lContinua := .F.
		Endif
		If ( __lSx8 )
			ConfirmSX8()
		EndIf
		cNumPc:=GetSxENum("SC7","C7_NUM",cAliasSX8)
		If cNumPc < CHKSC7_->C7_NUM
			If !ChkChaveSC7(cNumPc)
				lContinua := .F.
			EndIf
		ElseIf cNumPc == CHKSC7_->C7_NUM
			CHKSC7_->(dbSkip())
		Else
			lContinua := .F.
		EndIf
	EndDo
	CHKSC7_->(dbCloseArea())

EndDo

If ( lConfirma )
	If ( __lSx8 )
		ConfirmSX8()
	EndIf
EndIf

RestArea(aAreaSC7)
RestArea(aArea)
Return(cNumPc)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³ChkChaveSC7³ Autor ³Edson Maricate        ³ Data ³11.12.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica a existencia do numero do pedido de Compras        ³±±
±±³          ³O numero do pedido de compras deve ser controlado no modo   ³±±
±±³          ³compartilhado devido ao controle por Filial de Entrega.     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³lRet : .T./.F.                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ChkChaveSC7(cNumPc,lViewHlp,cEntFil)
Local lRet		:= .F.
Local aArea		:= GetArea()
Local aAreaSC7	:= SC7->(GetArea())
Local aAreaSM0	:= SM0->(GetArea())
Local lPcFilEnt := GetMV("MV_PCFILEN")
Local cQuery    := ""

DEFAULT lViewHlp:= .F.
DEFAULT cEntFil	:= ""

//Função do compras (Localizado no COMXGEN)
If FindFunction("ChkNumSC7")
	lRet := ChkNumSC7(cNumPc,lViewHlp,cEntFil)
Else
	If Empty(xFilial("SC7"))
		SC7->(dbSetOrder(1))
		lRet := SC7->(dbSeek(xFilial("SC7")+cNumPc))
		If lViewHlp .And. lRet
			HELP("  ",1,"JAGRAVADO")
		EndIf
	Else
		SC7->(dbSetOrder(1))
		If lPcFilEnt
			If Select("CHKSC7") > 0
				CHKSC7->(DbCloseArea())
			EndIf
			cQuery := "Select COUNT(C7_NUM) SC7PED"
			cQuery += "  From "+RetSqlName("SC7")+" SC7"
			cQuery += " Where SC7.C7_NUM = '"+cNumPc+"'"
			cQuery += "   And SC7.D_E_L_E_T_=' '"

			If Empty(cEntFil)
				cQuery += "   AND SC7.C7_FILIAL like '"+AllTrim(FWCodFil("SC7"))+"%'"
			Else
				cQuery += "   AND ( SC7.C7_FILIAL like '"+AllTrim(FWCodFil("SC7"))+"%'"
				cQuery += " 		OR SC7.C7_FILENT = '" + cEntFil + "')"
			Endif

			cQuery := ChangeQuery(cQuery)
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"CHKSC7",.T.,.T.)

			If CHKSC7->SC7PED > 0
				lRet:= .T.
			EndIf
			CHKSC7->(DbCloseArea())

			If lViewHlp .And. lRet
				Aviso(STR0044,STR0213+STR0046,{STR0047},2) //"Numero ja gravado"###"Este numero de pedido ja foi utilizado em outra Filial. Selecione outro numero de pedido."###"Voltar"
			EndIf
		Else
			lRet := SC7->(dbSeek(xFilial("SC7")+cNumPc))
			If lViewHlp .And. lRet
				Aviso(STR0044,STR0045+SM0->M0_CODFIL+" - "+AllTrim(SM0->M0_FILIAL)+STR0046,{STR0047},2) //"Numero ja gravado"###"Este numero de pedido ja foi utilizado na Filial : "###" . Selecione outro numero de pedido."###"Voltar"
			EndIf
		EndIf
	EndIf
Endif

RestArea(aAreaSM0)
RestArea(aAreaSC7)
RestArea(aArea)
Return lRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o   ³ Estrut2  ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 04/02/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o³ Faz a explosao de uma estrutura a partir do SG1            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe  ³ Estrut(ExpC1,ExpN1,ExpC2,ExpC3)                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do produto a ser explodido                  ³±±
±±³          ³ ExpN1 = Quantidade a ser explodida                         ³±±
±±³          ³ ExpC2 = Alias do arquivo de trabalho                       ³±±
±±³          ³ ExpC3 = Nome do arquivo criado                             ³±±
±±³          ³ ExpL1 = Monta a Estrutura exatamente como se ve na tela    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observa‡„o³ Como e uma funcao recursiva precisa ser criada uma variavel³±±
±±³          ³ private nEstru com valor 0 antes da chamada da fun‡„o.     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function Estrut2(cProduto,nQuant,cAliasEstru,oTempTable,lAsShow,lPreEstru,lVldData,lVldRev,lVlOpc)
LOCAL nRegi:=0,nQuantItem:=0
LOCAL aCampos:={},aTamSX3:={},lAdd:=.F.
LOCAL nRecno
LOCAL cCodigo,cComponente,cTrt,cGrOpc,cOpc
DEFAULT lPreEstru  := .F.
DEFAULT oTempTable := NIL
DEFAULT lVldData   := .T.
DEFAULT lVldRev    := .T.
DEFAULT lVlOpc    := .T.

cAliasEstru:=IF(cAliasEstru == NIL,"ESTRUT",cAliasEstru)
nQuant:=IF(nQuant == NIL,1,nQuant)
lAsShow:=IF(lAsShow==NIL,.F.,lAsShow)
nEstru++
If nEstru == 1
	// Cria arquivo de Trabalho
	AADD(aCampos,{"NIVEL","C",6,0})
	aTamSX3:=TamSX3(If(lPreEstru,"GG_COD","G1_COD"))
	AADD(aCampos,{"CODIGO","C",aTamSX3[1],0})
	aTamSX3:=TamSX3(If(lPreEstru,"GG_COMP","G1_COMP"))
	AADD(aCampos,{"COMP","C",aTamSX3[1],0})
	aTamSX3:=TamSX3(If(lPreEstru,"GG_QUANT","G1_QUANT"))
	AADD(aCampos,{"QUANT","N",Max(aTamSX3[1],18),aTamSX3[2]})
	aTamSX3:=TamSX3(If(lPreEstru,"GG_TRT","G1_TRT"))
	AADD(aCampos,{"TRT","C",aTamSX3[1],0})
	aTamSX3:=TamSX3(If(lPreEstru,"GG_GROPC","G1_GROPC"))
	AADD(aCampos,{"GROPC","C",aTamSX3[1],0})
	aTamSX3:=TamSX3(If(lPreEstru,"GG_OPC","G1_OPC"))
	AADD(aCampos,{"OPC","C",aTamSX3[1],0})
	// NUMERO DO REGISTRO ORIGINAL
	AADD(aCampos,{"REGISTRO","N",14,0})

	oTempTable := FWTemporaryTable():New( cAliasEstru )
	oTempTable:SetFields( aCampos )
	oTempTable:AddIndex("INDICE1", {"NIVEL","CODIGO","COMP","TRT"} )
	oTempTable:Create()
EndIf

dbSelectArea(If(lPreEstru,"SGG","SG1"))
dbSetOrder(1)
dbSeek(xFilial()+cProduto)
While !Eof() .And. If(lPreEstru,GG_FILIAL+GG_COD,G1_FILIAL+G1_COD) == xFilial()+cProduto
	nRegi:=Recno()
	cCodigo    :=If(lPreEstru,GG_COD,G1_COD)
	cComponente:=If(lPreEstru,GG_COMP,G1_COMP)
	cTrt       :=If(lPreEstru,GG_TRT,G1_TRT)
	cGrOpc     :=If(lPreEstru,GG_GROPC,G1_GROPC)
	cOpc       :=If(lPreEstru,GG_OPC,G1_OPC)
	If cCodigo != cComponente
		lAdd:=.F.
		If !(&(cAliasEstru)->(dbSeek(StrZero(nEstru,6)+cCodigo+cComponente+cTrt))) .Or. (lAsShow)
			nQuantItem:=ExplEstr(nQuant,nil,nil,nil,nil,lPreEstru,,,,,,lVldData,lVlOpc,,lVldRev)
			IF nQuantItem != 0
				RecLock(cAliasEstru,.T.)
				Replace NIVEL    With StrZero(nEstru,6)
				Replace CODIGO   With cCodigo
				Replace COMP     With cComponente
				Replace QUANT    With nQuantItem
				Replace TRT      With cTrt
				Replace GROPC    With cGrOpc
				Replace OPC      With cOpc
				Replace REGISTRO With If(lPreEstru,SGG->(Recno()),SG1->(Recno()))
				MsUnlock()
				lAdd:=.T.
			EndIf
			dbSelectArea(If(lPreEstru,"SGG","SG1"))
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se existe sub-estrutura                ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nRecno:=Recno()
		IF dbSeek(xFilial()+cComponente)
			cCodigo:=If(lPreEstru,GG_COD,G1_COD)
			If nQuantItem != 0
				Estrut2(cCodigo,nQuantItem,cAliasEstru,@oTempTable,lAsShow,lPreEstru,lVldData,lVldRev,lVlOpc)
				nEstru --
			EndIf
		Else
			MsGoto(nRecno)
			If !(&(cAliasEstru)->(dbSeek(StrZero(nEstru,6)+cCodigo+cComponente+cTrt))) .Or. (lAsShow.And.!lAdd)
				nQuantItem:=ExplEstr(nQuant,nil,nil,nil,nil,lPreEstru,,,,,,lVldData,lVlOpc,,lVldRev)
				If nQuantItem != 0
					RecLock(cAliasEstru,.T.)
					Replace NIVEL    With StrZero(nEstru,6)
					Replace CODIGO   With cCodigo
					Replace COMP     With cComponente
					Replace QUANT    With nQuantItem
					Replace TRT      With cTrt
					Replace GROPC    With cGrOpc
					Replace OPC      With cOpc
					Replace REGISTRO With If(lPreEstru,SGG->(Recno()),SG1->(Recno()))
					MsUnlock()
			 	EndIf
				dbSelectArea(If(lPreEstru,"SGG","SG1"))
			EndIf
		Endif
	EndIf
	MsGoto(nRegi)
	dbSkip()
Enddo
Return NIL

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o   ³FimEstrut2³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 04/02/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o³ Encerra arquivo utilizado na explosao de uma estrutura     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe  ³ FimEstrut2(ExpC1,ExpC2)                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do Arquivo de Trabalho                       ³±±
±±³          ³ ExpC2 = Nome do Arquivo de Trabalho                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function FimEstrut2(cAliasEstru,oTempTable)
cAliasEstru:=IF(cAliasEstru == NIL,"ESTRUT",cAliasEstru)
dbSelectArea(cAliasEstru)
If ValType(oTempTable) != Nil .And. ValType(oTempTable) != "U"
	oTempTable:Delete()
EndIf
Return

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o   ³MtrAvalOP ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 05/02/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o³ Valida se Op deve ser considerada em relatorio ou nao      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe  ³ MtrAvalOp(ExpN1,ExpC1)                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Variavel com valor do parametro                    ³±±
±±³          ³ ExpC1 = Alias a ser pesquisado                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function MtrAvalOP(nSelecao,cAlias,cAliasTop)
Local lRet:=.T.
Default cAlias    := "SC2"
Default cAliasTop := cAlias
nSelecao:=If(nSelecao == NIL,1,nSelecao)
If &(cAliasTop+"->"+Substr(cAlias,2,2)+"_TPOP") == "P" .And. nSelecao == 1
	lRet:=.F.
ElseIf &(cAliasTop+"->"+Substr(cAlias,2,2)+"_TPOP") $ " F" .And. nSelecao == 2
	lRet:=.F.
EndIf
Return lRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fGeraCQ0  ³ Autor ³ Fernando Joly Siquini ³ Data ³ 05/02/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Gera o Registro Tipo 0 no CQ (SD7).                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fGeraCQ0(ExpC1, ExpC2, ExpC3)                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T. Se a Gera‡„o Tiver ocorrido, .F. em caso contrario.    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias de Origem SD1 ou SD3 (deve estar Posocionado)³±±
±±³          ³ ExpC2 = Codigo do Produto;                                 ³±±
±±³          ³ ExpC3 = Origem do Lancamento.                              ³±±
±±³          ³ ExpC4 = Local sugerido para liberacao do CQ                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Ger‚rico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fGeraCQ0(cAlias, cProduto, cOrigLan, cLocLib)

//-- Inicializa Variaveis Locais
Local lRet		:= .F.
Local aArea 	:= GetArea()
Local nSB1Rec	:= SB1->(Recno())
Local nSB1Ord	:= SB1->(IndexOrd())
Local nSD1Rec	:= (cAlias)->(Recno())
Local nSD1Ord	:= (cAlias)->(IndexOrd())
Local nSD3Rec	:= SD3->(Recno())
Local nSD3Ord	:= SD3->(IndexOrd())
Local nSD7Rec	:= SD7->(Recno())
Local nSD7Ord	:= SD7->(IndexOrd())
Local cDocTran	:= ''
Local cNumSeq	:= ''
Local cLote		:= ''
Local cSLote	:= ''
Local cDoc		:= ''
Local cSerie	:= ''
Local cSdoc		:= ''
Local cFornece	:= ''
Local cLoja		:= ''
Local cMessage  := ''
Local cIDEvent  := "006"
Local cCq		:= GetMvNNR('MV_CQ','98')
Local nQuant1	:= 0
Local nQuant2	:= 0
Local nQuant2UM	:= 0
Local nPotencia	:= 0
Local lEIC		:= IntegraEIC(SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA) //Valida a Integracao com SIGAEIC
Local dDataCQ	:= dDataBase
Local lQualyCQ	:= (SB1->(dbSeek(xFilial('SB1')+cProduto, .F.)) .And. (RetFldProd(SB1->B1_COD,"B1_TIPOCQ")=='Q')) //Valida a Integração com QIE

cLocLib := If(cLocLib==NIL.Or.Empty(cLocLib),RetFldProd(SB1->B1_COD,"B1_LOCPAD"),cLocLib)

SB1->(dbSetOrder(1))
SD7->(dbSetorder(1))

Begin Transaction
	Begin Sequence
		//-- Consiste cAlias
		If cAlias # 'SD1' .And. cAlias # 'SD3'
			Break
		EndIf

		//-- Pegar e gravar o proximo numero da Movimentacao no CQ.
		If (cDocTran := GetMV('MV_DOCTRAN')) # Nil

			cDocTran := Soma1(cDocTran)

			While SD7->(dbSeek(xFilial('SD7')+cDocTran)) .Or. !MayIUseCode(cDocTran)
				cDocTran := Soma1(cDocTran)
			EndDo

			PutMV('MV_DOCTRAN',cDocTran)
		Else
			Break
		EndIf

		//-- Posiciona SB1
		If !SB1->(dbSeek(xFilial('SB1')+cProduto, .F.))
			Break
		EndIf

		//-- Posiciona SD1 e SD3
		(cAlias)->(MsGoto(nSD1Rec))
		SD3->(MsGoto(nSD3Rec))

		If cAlias == 'SD1'
			nQuant1  := SD1->D1_QUANT
			nQuant2  := SD1->D1_QTSEGUM
			cNumSeq  := SD1->D1_NUMSEQ
			cDoc     := SD1->D1_DOC
			cSerie   := SD1->D1_SERIE
			cFornece := SD1->D1_FORNECE
			cLoja    := SD1->D1_LOJA
			cLote    := SD1->D1_LOTECTL
			cSLote   := SD1->D1_NUMLOTE
			cOrigLan := If(cOrigLan==Nil,'CP',cOrigLan)
			nPotencia:= SD1->D1_POTENCI
			// Checa a data de gravacao
			If cAlias == 'SD1'
				dDataCQ:= IIf(GetMv("MV_DATAHOM",NIL,"1") == "1".Or.Empty(SF1->F1_RECBMTO),dDataBase,SF1->F1_RECBMTO)
			EndIf
		Else
			nQuant1  := SD3->D3_QUANT
			nQuant2  := SD3->D3_QTSEGUM
			cNumSeq  := SD3->D3_NUMSEQ
			cLote    := SD3->D3_LOTECTL
			cSLote   := SD3->D3_NUMLOTE
			cOrigLan := If(cOrigLan==Nil,'TR',cOrigLan)
			nPotencia:= SD3->D3_POTENCI
			If lQualyCQ .And. FunName() $ "MATA260|MATA261"
				cDoc     := SD1->D1_DOC
				cSerie   := SD1->D1_SERIE
				cFornece := SD1->D1_FORNECE
				cLoja    := SD1->D1_LOJA
			Endif

		EndIf
		If SerieNfId("SD1",3,"D1_SERIE") == 'D1_SDOC'
			cSdoc := SD1->D1_SDOC
		EndIf
		nQuant2UM := ConvUm(cProduto,nQuant1,nQuant2,2)

		//Validacao para permitir somente quantidade maior que Zero
		If !(nQuant1 > 0)
			break
		Endif

		RecLock('SD7', .T.)
		Replace SD7->D7_FILIAL  With xFilial('SD7'), ;
			SD7->D7_SEQ     With '001', ;
			SD7->D7_PRODUTO With cProduto, ;
			SD7->D7_TIPO    With 0, ;
			SD7->D7_QTDE    With 0, ;
			SD7->D7_SALDO   With nQuant1, ;
			SD7->D7_USUARIO With CUSERNAME, ;
			SD7->D7_QTSEGUM With 0, ;
			SD7->D7_SALDO2  With nQuant2UM, ;
			SD7->D7_NUMSEQ  With cNumSeq, ;
			SD7->D7_LOCAL   With cCq, ;
			SD7->D7_LOCDEST With cLocLib, ;
			SD7->D7_NUMERO  With cDocTran, ;
			SD7->D7_DATA    With dDataCQ, ;
			SD7->D7_LIBERA  With Space(1), ;
			SD7->D7_LOTECTL With cLote, ;
			SD7->D7_NUMLOTE With cSLote, ;
			SD7->D7_ESTORNO With Space(1), ;
			SD7->D7_DOC     With cDoc, ;
			SD7->D7_SERIE   With cSerie, ;
			SD7->D7_FORNECE With cFornece, ;
			SD7->D7_LOJA    With cLoja, ;
			SD7->D7_ORIGLAN With cOrigLan, ;
			SD7->D7_TIPOCQ  With If(Empty(RetFldProd(SB1->B1_COD,"B1_TIPOCQ")),'M',RetFldProd(SB1->B1_COD,"B1_TIPOCQ")), ;
			SD7->D7_MOTREJE With Space(2),;
			SD7->D7_POTENCI With nPotencia
			If SerieNfId("SD7",3,"D7_SERIE") == 'D7_SDOC'
				replace SD7->D7_SDOC With cSdoc
			EndIf
		If lEIC
			Replace SD7->D7_DOCSWN  With SD3->D3_DOCSWN
			Replace SD7->D7_ITEMSWN With SD3->D3_ITEMSWN
		EndIf
		If ExistBlock("FGERACQ0")
			ExecBlock("FGERACQ0",.F.,.F.)
		Endif
		SD7->(MsUnLock())
		lRet    := .T.
		nSD7Rec := SD7->(Recno())

		FreeUsedCode()

	End Sequence
End Transaction

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Envia e-mail ref. a PRODUTO AGUARDANDO AVALIACAO   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
MEnviaMail("006",{SB1->B1_COD,SB1->B1_DESC,SD7->D7_DOC,SD7->D7_SERIE,SD7->D7_LOCAL})

// EventViewer
cMessage:= STR0022 + SB1->B1_COD + " - " + SB1->B1_DESC + STR0258 //O produto ### aguarda avaliação no C.Q. do documento/série
cMessage+= AllTrim(SD7->D7_DOC) + "/" + AllTrim(SD7->D7_SERIE)
cMessage+= STR0259 + SD7->D7_LOCAL + ")"
EventInsert( FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cIDEvent, FW_EV_LEVEL_INFO, "", STR0260, cMessage, .T. )

//-- Retorna a Integridade do Sistema
SB1->(dbSetOrder(nSB1Ord))
SB1->(MsGoto(nSB1Rec))
(cAlias)->(dbSetOrder(nSD1Ord))
(cAlias)->(MsGoto(nSD1Rec))
SD3->(dbSetOrder(nSD3Ord))
SD3->(MsGoto(nSD3Rec))
SD7->(dbSetOrder(nSD7Ord))
SD7->(MsGoto(nSD7Rec))
RestArea(aArea)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³SB8Saldo  ³ Autor ³ Eduardo/Rodrigo       ³ Data ³22.02.99  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calcula o saldo do SB8 Posicionado                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExcN1: Saldo do SB8                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpL1 := Flag que indica se considera EMPENHO               ³±±
±±³          ³ExpL2 := Flag que indica se considera Lotes Vencidos        ³±±
±±³          ³ExpL3 := Flag que indica se considera o saldo a Classificar ³±±
±±³          ³ExpL4 := Flag que indica se calcula na 2a Unidade de Medida ³±±
±±³          ³ExpC1 := Caracter com alias do arquivo de query (OPCIONAL)  ³±±
±±³          ³ExpL5 := Flag que indica se esta baixando empenho previsto  ³±±
±±³          ³ExpL6 := Flag que indica se esta em consulta de saldo       ³±±
±±³          ³ExpD1 := Indica a data de referencia do saldo               ³±±
±±³          ³ExpL7 := Flag que indica se considera somente vlr. B8_SALDO ³±±
±±³          ³ExpC2 := Codigo da Ordem de Producao                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function SB8Saldo(lBaixaEmp,lConsVenc,lConsClas,lSegUM,cAliasSB8,lEmpPrevisto,lConsulta,dDataRef,lSaldo,cOP, nPercPrM, nQtdeOri, cOpEmp)
Static lRDSldSB8Por := NIL
Local nSaldo   := 0
Local nSldEmp  := 0
Local lUtiliza := .T.
Local lSelLote := (SuperGetMV("MV_SELLOTE") == "1")
Local aSaldoOP :={0, 0}
Local aRetSld  :={}

DEFAULT nPercPrM := 0
DEFAULT nQtdeOri := 0

lBaixaEmp:=If(lBaixaEmp == NIL,.F.,lBaixaEmp)
lConsVenc:=If(lConsVenc == NIL,SuperGetMV("MV_LOTVENC",.F.,"S") == "S",lConsVenc)
lConsClas:=If(lConsClas == NIL,.F.,lConsClas)
lSegUM   :=If(lSegUM    == NIL,.F.,lSegUM)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ VERIFICA A EXISTENCIA DO P.E. MTSLDLOT                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lRDSldSB8Por := If(lRDSldSB8Por == NIL,ExistBlock("MTSLDLOT"),lRDSldSB8Por)

DEFAULT cAliasSB8   := "SB8"
DEFAULT lEmpPrevisto:=.F.
DEFAULT lConsulta   :=.F.
DEFAULT lSaldo      :=.F.
DEFAULT cOP         := ""
DEFAULT cOpEmp      := ""

If If(ValType(dDataRef) == "D",(cAliasSB8)->B8_DATA <= dDataRef,.T.) .And. (lConsVenc .Or. (!lConsVenc .And. ((cAliasSB8)->B8_DTVALID >= dDataBase .Or. Empty((cAliasSB8)->B8_DTVALID)))) .And. !lSaldo
	If lBaixaEmp
		If lEmpPrevisto
			If lSegUM
				nSaldo	:= Min((cAliasSB8)->B8_SALDO2,(cAliasSB8)->B8_QEPRE2)-(cAliasSB8)->B8_QACLAS2
			Else
				nSaldo	:= Min((cAliasSB8)->B8_SALDO,(cAliasSB8)->B8_QEMPPRE)-(cAliasSB8)->B8_QACLASS
			EndIf
		Else
			nSldEmp := 0
			If nPercPrM > 0 .And. !Empty(cOpEmp)
				aRetSld := RetSldEmp(cOpEmp, cAliasSB8)
				If Len(aRetSld) > 0
					If lSegUM
						nSldEmp := aRetSld[2]
					Else
						nSldEmp := aRetSld[1]
					EndIf
				EndIf
			EndIf

			If lSegUM
				nSaldo	:= Min((cAliasSB8)->B8_SALDO2-nSldEmp-((cAliasSB8)->B8_QACLAS2+AvalQtdPre("SB8",1,.T.,cAliasSB8)),((cAliasSB8)->B8_EMPENH2 + (Iif((cAliasSB8)->B8_SALDO2 != 0,nQtdeOri,0) * nPercPrM)))
			Else
				nSaldo	:= Min((cAliasSB8)->B8_SALDO-nSldEmp-((cAliasSB8)->B8_QACLASS+AvalQtdPre("SB8",1,NIL,cAliasSB8)),((cAliasSB8)->B8_EMPENHO + A250AvalQt((Iif((cAliasSB8)->B8_SALDO != 0,nQtdeOri,0) * nPercPrM),(cAliasSB8)->B8_PRODUTO )))
			EndIf
		EndIf
	Else
		If !Empty(cOp)
			aSaldoOP := SldEmpOP((cAliasSB8)->B8_PRODUTO,(cAliasSB8)->B8_LOCAL,(cAliasSB8)->B8_LOTECTL,(cAliasSB8)->B8_NUMLOTE,cOP)
		EndIf
		If lSegUM
			nSaldo	:= (cAliasSB8)->B8_SALDO2-(((cAliasSB8)->B8_EMPENH2-aSaldoOP[2])+(cAliasSB8)->B8_QACLAS2+AvalQtdPre("SB8",1,.T.,cAliasSB8,lEmpPrevisto))
		Else
			nSaldo	:= (cAliasSB8)->B8_SALDO-(((cAliasSB8)->B8_EMPENHO-aSaldoOP[1])+(cAliasSB8)->B8_QACLASS+AvalQtdPre("SB8",1,NIL,cAliasSB8,lEmpPrevisto))
		EndIf
	EndIf
	If ( lConsClas )
		If lSegUM
			nSaldo += (cAliasSB8)->B8_QACLAS2
		Else
			nSaldo += (cAliasSB8)->B8_QACLASS
		EndIf
	EndIf
ElseIf lSaldo
	If !lSegUM
		If !lBaixaEmp
			nSaldo := (cAliasSB8)->B8_SALDO
		Else
			nSaldo := (cAliasSB8)->B8_EMPENHO + (Iif((cAliasSB8)->B8_SALDO != 0,nQtdeOri,0) * nPercPrM)
		Endif
	Else
		If !lBaixaEmp
			nSaldo := (cAliasSB8)->B8_SALDO2
		Else
			nSaldo := (cAliasSB8)->B8_EMPENH2 + (Iif((cAliasSB8)->B8_SALDO2 != 0,nQtdeOri,0) * nPercPrM)
		Endif
	Endif
Else
	nSaldo := 0
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Qdo Usuario seleciona Lote manualmente, observar se utiliza registro   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cPaisLoc == "ARG" .and. lSelLote
	If (Empty(SC6->C6_LOCALIZ) .or. Empty(SC6->C6_LOTECTL)) .and.;
		AllTrim(FunName()) $ "MATA440|MATA450|MATA456"
		lUtiliza := .F.
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Executa P.E. MTSLDLOT para verificar se utiliza registro               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If	lRDSldSB8Por
	lUtiliza:= ExecBlock("MTSLDLOT",.F.,.F.,{(cAliasSB8)->B8_PRODUTO,;
	(cAliasSB8)->B8_LOCAL,;
	(cAliasSB8)->B8_LOTECTL,;
	(cAliasSB8)->B8_NUMLOTE,;
	"",;
	"",;
	nSaldo,;
	lConsulta})
	If ValType(lUtiliza) != "L"
		lUtiliza :=.T.
	EndIf
EndIf
If !lUtiliza
	nSaldo:=0
EndIf
Return(nSaldo)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³SBFSaldo  ³ Autor ³ Eduardo/Rodrigo       ³ Data ³22.02.99  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calcula o saldo do SBF Posicionado                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExcN1: Saldo do SBF                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExPL1 := Indica se movimento esta baixando empenho          ³±±
±±³          ³ExpC1 := Caracter com alias do arquivo de query (OPCIONAL)  ³±±
±±³          ³ExpL2 := Flag que indica se esta baixando empenho previsto  ³±±
±±³          ³ExpL3 := Indica se considera a segunda unidade de medida    ³±±
±±³          ³  ( OPCIONAL )                                              ³±±
±±³          ³ExpL4 := Indica se considera a qtde empenhada no calculo    ³±±
±±³          ³         do saldo.                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function SBFSaldo(lBaixaEmp,cAliasSBF,lEmpPrevisto,lSegUM,lSaldo)
Local nSaldo	     := 0

Default cAliasSBF    := "SBF"
Default lEmpPrevisto := .F.
Default lSaldo       := .F.

lSegUM := If( ValType( lSegUM ) == "L", lSegUM, .F. )

lBaixaEmp:=If(lBaixaEmp == NIL,.F.,lBaixaEmp)

If lSegUM
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Considera o saldo da segunda unidade de medida                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lSaldo
		nSaldo	:= (cAliasSBF)->BF_QTSEGUM
	Else
		If lBaixaEmp
			If lEmpPrevisto
				nSaldo	:= Min((cAliasSBF)->BF_QTSEGUM,(cAliasSBF)->BF_QEPRE2)
			Else
				nSaldo	:= Min((cAliasSBF)->BF_QTSEGUM,(cAliasSBF)->BF_EMPEN2)-(AvalQtdPre("SBF",1,.T.,cAliasSBF))
			EndIf
		Else
			nSaldo	:= (cAliasSBF)->BF_QTSEGUM-((cAliasSBF)->BF_EMPEN2+AvalQtdPre("SBF",1,.T.,cAliasSBF,lEmpPrevisto))
		EndIf
	EndIf
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Considera o saldo da primeira unidade de medida ( padrao )             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lSaldo
		nSaldo	:= (cAliasSBF)->BF_QUANT
	Else
		If lBaixaEmp
			If lEmpPrevisto
				nSaldo	:= Min((cAliasSBF)->BF_QUANT,(cAliasSBF)->BF_QEMPPRE)
			Else
				nSaldo	:= Min((cAliasSBF)->BF_QUANT,(cAliasSBF)->BF_EMPENHO)-(AvalQtdPre("SBF",1,NIL,cAliasSBF))
			EndIf
		Else
			nSaldo	:= (cAliasSBF)->BF_QUANT-((cAliasSBF)->BF_EMPENHO+AvalQtdPre("SBF",1,NIL,cAliasSBF,lEmpPrevisto))
		EndIf
	EndIf
EndIf

Return(nSaldo)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³A330PEGASB6³ Autor ³ Marcos Bregantim     ³ Data ³ 07/07/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Pega Custo do Poder de Terceiros                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ A330PEGASB6(xPar1,xPar2)                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A330PegaSB6(cAlias,lCusFIFO,cProg,lCstPart,nRegras,lCusRep)
Static __oSQLSB6 := Nil
Static __oSQLCpB6:= Nil
Static __oSQLOrB6:= Nil
Static __oSQLNoB6:= Nil

Local aRetPartes := {}
Local aRetPOri   := {}
Local aRetPBaixa := {}
Local aCusto     := {0,0,0,0,0}
Local aCustoFF   := {0,0,0,0,0}
Local aCustoOri  := {0,0,0,0,0}
Local aCstOriRep := {0,0,0,0,0}
Local aCustoFFOri:= {0,0,0,0,0}
Local aCustoRep  := {0,0,0,0,0}
Local lOriginal  :=.F.
Local nFator, nRegSb6, nz
Local aRet[4]
Local nRecnoSB6  := 0
Local nCus1SD1	 := 0
Local nCus2SD1	 := 0
Local nCus3SD1	 := 0
Local nCus4SD1	 := 0
Local nCus5SD1	 := 0

//PE M330PSB6
Local nSB6Bkp    := 0
Local nSB6Alt    := 0
Local lM330PSB6  := ExistBlock("M330PSB6")
Local nAjuste    := 0

Local cFilSB6 	 := xFilial('SB6')
Local cFilB1	 := xFilial('SB1')
Local cAliNori   := ''
Local cQuery     := ''

DEFAULT lCstPart := .F.
DEFAULT lCusRep  := .F.
__lCusbVLib := IIf(__lCusbVLib == NIL,FWLibVersion() >= "20211116",__lCusbVLib)

lCusFIFO := IIF(lCusFIFO==Nil,.F.,lCusFIFO)
cProg    := IIF(cProg==Nil,SPACE(03),cProg)

Do Case
Case cAlias == "SD1"
	If __oSQLOrB6 == nil
		cQuery := "SELECT R_E_C_N_O_ FROM "+RetSqlName("SB6") + " "
		cQuery += " WHERE B6_FILIAL = ? "               //- 1
		cQuery += " AND B6_IDENT = ? "               	//- 2
		cQuery += " AND B6_PRODUTO  = ? "               //- 3
		cQuery += " AND B6_TIPO = ? "                   //- 4
		cQuery += " AND B6_DOC = ? "               		//- 5         
		cQuery += " AND B6_SERIE = ? "               	//- 6
		cQuery += " AND B6_TES > ? "                    //- 7
		cQuery += " AND D_E_L_E_T_  = ? "               //- 8
		cQuery += " Order By B6_FILIAL,B6_IDENT,B6_PRODUTO,B6_PODER3 " //Index 3
		cQuery := ChangeQuery(cQuery)
		If __lCusbVLib
			__oSQLOrB6 := FwExecStatement():New(cQuery)
		Else
			__oSQLOrB6 := FWPreparedStatement():New(cQuery)
		EndIf
	EndIf
	__oSQLOrB6:SetString(1, cFilSB6)
	__oSQLOrB6:SetString(2, SD1->D1_IDENTB6)
	__oSQLOrB6:SetString(3, SD1->D1_COD)
	__oSQLOrB6:SetString(4, 'E')
	__oSQLOrB6:SetString(5, SD1->D1_NFORI)
	__oSQLOrB6:SetString(6, SD1->D1_SERIORI)
	__oSQLOrB6:SetString(7, '500')
	__oSQLOrB6:SetString(8, ' ')

	nRecnoSB6 := 0
	If __lCusbVLib
		nRecnoSB6 := __oSQLOrB6:ExecScalar('R_E_C_N_O_')
	Else
		cQuery := __oSQLOrB6:GetFixQuery()
		MpSysOpenQuery(cQuery,'Orig')
		IF Orig->(!Eof())
			nRecnoSB6 := Orig->R_E_C_N_O_
		EndIf
		Orig->(dbCloseArea())
	EndIf
	If nRecnoSB6 > 0
		dbSelectArea("SB6")
		dbSetOrder(3)
		dbgoto (nRecnoSB6)
		nFator :=  SD1->D1_QUANT / SB6->B6_QUANT
		aCusto[1] := SB6->B6_CUSTO1 * nFator
		aCusto[2] := SB6->B6_CUSTO2 * nFator
		aCusto[3] := SB6->B6_CUSTO3 * nFator
		aCusto[4] := SB6->B6_CUSTO4 * nFator
		aCusto[5] := SB6->B6_CUSTO5 * nFator
		If lCusRep
			aCustoRep[1] := SB6->B6_CUSRP1 * nFator
			aCustoRep[2] := SB6->B6_CUSRP2 * nFator
			aCustoRep[3] := SB6->B6_CUSRP3 * nFator
			aCustoRep[4] := SB6->B6_CUSRP4 * nFator
			aCustoRep[5] := SB6->B6_CUSRP5 * nFator
		EndIf
		lOriginal :=.T.
		aCustoOri := {SB6->B6_CUSTO1,SB6->B6_CUSTO2,SB6->B6_CUSTO3,SB6->B6_CUSTO4,SB6->B6_CUSTO5}
		If lCusRep
			aCstOriRep := {SB6->B6_CUSRP1,SB6->B6_CUSRP2,SB6->B6_CUSRP3,SB6->B6_CUSRP4,SB6->B6_CUSRP5}
		EndIf
		If lCusFIFO
			aCustoFF[1] := SB6->B6_CUSFF1 * nFator
			aCustoFF[2] := SB6->B6_CUSFF2 * nFator
			aCustoFF[3] := SB6->B6_CUSFF3 * nFator
			aCustoFF[4] := SB6->B6_CUSFF4 * nFator
			aCustoFF[5] := SB6->B6_CUSFF5 * nFator
			aCustoFFOri := {SB6->B6_CUSFF1,SB6->B6_CUSFF2,SB6->B6_CUSFF3,SB6->B6_CUSFF4,SB6->B6_CUSFF5}
			// Previne custo FIFO zerado ou negativo
			If aCustoFF[1] <= 0
				If aCusto[1] > 0
					aCustoFF   :=ACLONE(aCusto)
					aCustoFFOri:=ACLONE(aCustoOri)
				Else
					aCustoFF:=PegaCusSBD(SB6->B6_PRODUTO,SB6->B6_LOCAL)
					For nz:=1 to Len(aCustoFF)
						aCustoFFOri[nz]:=aCustoFF[nz]*SB6->B6_QUANT
						aCustoFF[nz]   :=(aCustoFF[nz]*SB6->B6_QUANT)*nFator
					Next nz
				EndIf
			EndIf
		Endif
		aRetPartes:=PegaCMPFim("B6_CP",lCstPart,nRegras)
		aRetPOri  :=ACLONE(aRetPartes)
		For nz:=1 to Len(aRetPartes)
			aRetPartes[nz] := aRetPartes[nz]*nFator
		Next nz
	Else
		dbSelectArea("SD1")
		aRetPartes:=PegaCMPFim("D1_CP",lCstPart,nRegras,SD1->D1_QUANT)
		dbSelectArea("SB6")
	EndIf

	nRegSb6 := Recno()  // Atualizar SB6
	If __oSQLNoB6 == nil
		cQuery := "SELECT B6_PRODUTO, B6_DOC, B6_SERIE, B6_TIPO, B6_QUANT,"
		cQuery += " B6_CUSTO1, B6_CUSTO2, B6_CUSTO3, B6_CUSTO4, B6_CUSTO5,"
		cQuery += " B6_CUSRP1, B6_CUSRP2, B6_CUSRP3, B6_CUSRP4, B6_CUSRP5,"
		cQuery += " B6_CUSFF1, B6_CUSFF2, B6_CUSFF3, B6_CUSFF4, B6_CUSFF5," 
		cQuery += " R_E_C_N_O_ FROM "+RetSqlName("SB6") + " "
		cQuery += " WHERE B6_FILIAL = ? "               //- 1
		cQuery += " AND B6_IDENT = ? "               	//- 2
		cQuery += " AND B6_PRODUTO  = ? "               //- 3
		cQuery += " AND B6_TIPO = ? "               	//- 4
		cQuery += " AND B6_DOC = ? "               		//- 5
		cQuery += " AND B6_SERIE = ? "               	//- 6
		cQuery += " AND R_E_C_N_O_ <> ? "				//- 7
		cQuery += " AND D_E_L_E_T_  = ? "               //- 8
		cQuery += " Order By B6_FILIAL,B6_IDENT,B6_PRODUTO,B6_PODER3 " //Index 3
		cQuery := ChangeQuery(cQuery)
		If __lCusbVLib
			__oSQLNoB6 := FwExecStatement():New(cQuery)
		Else
			__oSQLNoB6 := FWPreparedStatement():New(cQuery)
		EndIf
	EndIf
	__oSQLNoB6:SetString(1, cFilSB6)
	__oSQLNoB6:SetString(2, SD1->D1_IDENTB6)
	__oSQLNoB6:SetString(3, SD1->D1_COD)
	__oSQLNoB6:SetString(4, 'E')
	__oSQLNoB6:SetString(5, SD1->D1_DOC)
	__oSQLNoB6:SetString(6, SD1->D1_SERIE)
	__oSQLNoB6:SetNumeric(7, nRegSb6)
	__oSQLNoB6:SetString(8, ' ')

	nRecnoSB6 := 0
	cQuery := __oSQLNoB6:GetFixQuery()
	cAliNori := MpSysOpenQuery(cQuery,'NOrig')
		
	While (cAliNori)->(!EOF())
		IF QtdComp(SD1->D1_QUANT) == QtdComp((cAliNori)->B6_QUANT) 
			dbSelectArea("SB6")
			dbSetOrder(3)
			dbgoto ((cAliNori)->R_E_C_N_O_)			
			RecLock("SB6",.F.)
			Replace B6_CUSTO1 With aCusto[1]
			Replace B6_CUSTO2 With aCusto[2]
			Replace B6_CUSTO3 With aCusto[3]
			Replace B6_CUSTO4 With aCusto[4]
			Replace B6_CUSTO5 With aCusto[5]
			If lCusRep
				Replace B6_CUSRP1 With aCustoRep[1]
				Replace B6_CUSRP2 With aCustoRep[2]
				Replace B6_CUSRP3 With aCustoRep[3]
				Replace B6_CUSRP4 With aCustoRep[4]
				Replace B6_CUSRP5 With aCustoRep[5]
			EndIf
			If lCusFIFO
				Replace B6_CUSFF1 With aCustoFF[1]
				Replace B6_CUSFF2 With aCustoFF[2]
				Replace B6_CUSFF3 With aCustoFF[3]
				Replace B6_CUSFF4 With aCustoFF[4]
				Replace B6_CUSFF5 With aCustoFF[5]
			Endif
			nSB6Alt := SB6->(Recno())
			MsUnlock()
			GravaCusCP(lCstPart,NIL,NIL,"SB6",(cAliNori)->B6_PRODUTO,aRetPartes,NIL,NIL,{B6_CUSTO1,B6_CUSTO2,B6_CUSTO3,B6_CUSTO4,B6_CUSTO5})
			If lOriginal
				aCustoOri[1] -= (cAliNori)->B6_CUSTO1
				aCustoOri[2] -= (cAliNori)->B6_CUSTO2
				aCustoOri[3] -= (cAliNori)->B6_CUSTO3
				aCustoOri[4] -= (cAliNori)->B6_CUSTO4
				aCustoOri[5] -= (cAliNori)->B6_CUSTO5
				If lCusRep
					aCstOriRep[1] -= (cAliNori)->B6_CUSRP1
					aCstOriRep[2] -= (cAliNori)->B6_CUSRP2
					aCstOriRep[3] -= (cAliNori)->B6_CUSRP3
					aCstOriRep[4] -= (cAliNori)->B6_CUSRP4
					aCstOriRep[5] -= (cAliNori)->B6_CUSRP5
				EndIf
				If lCusFIFO
					aCustoFFOri[1] -= (cAliNori)->B6_CUSFF1
					aCustoFFOri[2] -= (cAliNori)->B6_CUSFF2
					aCustoFFOri[3] -= (cAliNori)->B6_CUSFF3
					aCustoFFOri[4] -= (cAliNori)->B6_CUSFF4
					aCustoFFOri[5] -= (cAliNori)->B6_CUSFF5
				EndIf
				aRetPBaixa:=PegaCMPFim("B6_CP",lCstPart,nRegras)
				For nz:=1 to Len(aRetPBaixa)
					aRetPOri[nz] -= aRetPBaixa[nz] 
				Next nz
			EndIf
		EndIf
		(cAliNori)->(dbSkip())
	Enddo
	(cAliNori)->(dbCloseArea())
	dbSelectArea("SB6")
	MsGoto(nRegSB6)
Case cAlias=="SD2"
	dbSelectArea("SB6")
	dbSetOrder(3)
	dbSeek ( xFilial() + SD2->D2_IDENTB6 + SD2->D2_COD + "R")
	While !Eof() .and. B6_FILIAL == xFilial("SB6") .and. B6_IDENT+B6_PRODUTO == SD2->D2_IDENTB6+SD2->D2_COD
		IF SB6->B6_TIPO == "D"
			Exit
		Endif
		dbSkip()
	Enddo
	IF !Eof() .And. B6_FILIAL == xFilial("SB6") .and. B6_IDENT+B6_PRODUTO == SD2->D2_IDENTB6+SD2->D2_COD
		IF !Eof()
			aAreaAnt := GetArea()
			If __oSQLCpB6 == nil
				cQuery := "select sum(SD1.D1_QUANT) D1_QUANT, Sum (SD1.D1_CUSTO) D1_CUSTO, SUm (SD1.D1_CUSTO2) D1_CUSTO2, "
				cQuery += "SUM (SD1.D1_CUSTO3) D1_CUSTO3, SUM (SD1.D1_CUSTO4) D1_CUSTO4, SUM(SD1.D1_CUSTO5) D1_CUSTO5, "
				cQuery += "SUM (SD1.D1_CUSFF1) D1_CUSFF1, SUM (SD1.D1_CUSFF2) D1_CUSFF2, SUM(SD1.D1_CUSFF3) D1_CUSFF3, "
				cQuery += "SUM (SD1.D1_CUSFF4) D1_CUSFF4, SUM (SD1.D1_CUSFF5) D1_CUSFF5, SUM(SB6.B6_SALDO) "
				cQuery += " FROM "+RetSqlName("SD1")+" SD1 "
				cQuery += " INNER JOIN "+RetSqlName("SB6")+" ORI "
				cQuery += " ON "
				cQuery += "  ORI.B6_FILIAL = ? "		// - 1
				cQuery += "  AND SD1.D1_NFORI = ORI.B6_DOC AND SD1.D1_SERIORI = ORI.B6_SERIE "
				cQuery += "  AND SD1.D1_FORNECE = ORI.B6_CLIFOR "
				cQuery += "  AND SD1.D1_LOJA = ORI.B6_LOJA "
				cQuery += "  AND SD1.D1_COD = ORI.B6_PRODUTO "
				cQuery += "  AND ORI.B6_IDENT = ? "		// - 2
				cQuery += "  AND ORI.B6_PRODUTO = ? "		// - 3
				cQuery += "  AND ORI.B6_PODER3 = 'R' "
				cQuery += "  AND ORI.D_E_L_E_T_=' ' "
				cQuery += " INNER JOIN "+RetSqlName("SB6")+" SB6 "
				cQuery += " ON "
				cQuery += "  SB6.B6_FILIAL = ? "		// - 4
				cQuery += "  AND SB6.B6_IDENT = SD1.D1_IDENTB6 "
				cQuery += "  AND SB6.D_E_L_E_T_=' ' "

				cQuery += " WHERE "
				cQuery += " SD1.D1_FILIAL = ? "			// - 5
				cQuery += " AND SD1.D_E_L_E_T_=' ' "
				cQuery := ChangeQuery(cQuery)
				If __lCusbVLib
					__oSQLCpB6 := FwExecStatement():New(cQuery)
				Else
					__oSQLCpB6 := FWPreparedStatement():New(cQuery)
				EndIf
			EndIf
			__oSQLCpB6:SetString(1, cFilSB6)
			__oSQLCpB6:SetString(2, (cAlias)->D2_IDENTB6)
			__oSQLCpB6:SetString(3, (cAlias)->D2_COD)
			__oSQLCpB6:SetString(4, cFilSB6)
			__oSQLCpB6:SetString(5, cFilB1)

			nCus1SD1 := 0
			nCus2SD1 := 0
			nCus3SD1 := 0
			nCus4SD1 := 0
			nCus5SD1 := 0
			If __lCusbVLib
				nCus1SD1 := __oSQLCpB6:ExecScalar('D1_CUSTO')
				nCus2SD1 := __oSQLCpB6:ExecScalar('D1_CUSTO2')
				nCus3SD1 := __oSQLCpB6:ExecScalar('D1_CUSTO3')
				nCus4SD1 := __oSQLCpB6:ExecScalar('D1_CUSTO4')
				nCus5SD1 := __oSQLCpB6:ExecScalar('D1_CUSTO5')
			Else
				cQuery := __oSQLCpB6:GetFixQuery()
				MpSysOpenQuery(cQuery,'SB6COMPL')
				IF SB6COMPL->(!Eof())
					nCus1SD1 := SB6COMPL->D1_CUSTO
					nCus2SD1 := SB6COMPL->D1_CUSTO2
					nCus3SD1 := SB6COMPL->D1_CUSTO3
					nCus4SD1 := SB6COMPL->D1_CUSTO4
					nCus5SD1 := SB6COMPL->D1_CUSTO5
				EndIf
				SB6COMPL->(dbCloseArea())
			EndIf
			Restarea(aAreaAnt)
			nFator := 1 / SB6->B6_QUANT
			aCusto[1] := (SB6->B6_CUSTO1 + nCus1SD1)  * nFator
			aCusto[2] := (SB6->B6_CUSTO2 + nCus2SD1) * nFator
			aCusto[3] := (SB6->B6_CUSTO3 + nCus3SD1) * nFator
			aCusto[4] := (SB6->B6_CUSTO4 + nCus4SD1) * nFator
			aCusto[5] := (SB6->B6_CUSTO5 + nCus5SD1) * nFator
			If lCusRep
				aCustoRep[1] := SB6->B6_CUSRP1 * nFator
				aCustoRep[2] := SB6->B6_CUSRP2 * nFator
				aCustoRep[3] := SB6->B6_CUSRP3 * nFator
				aCustoRep[4] := SB6->B6_CUSRP4 * nFator
				aCustoRep[5] := SB6->B6_CUSRP5 * nFator
			EndIf
			If lCusFIFO
				aCustoFF[1] := SB6->B6_CUSFF1 * nFator
				aCustoFF[2] := SB6->B6_CUSFF2 * nFator
				aCustoFF[3] := SB6->B6_CUSFF3 * nFator
				aCustoFF[4] := SB6->B6_CUSFF4 * nFator
				aCustoFF[5] := SB6->B6_CUSFF5 * nFator
			Endif
			aRetPartes:=PegaCMPFim("B6_CP",lCstPart,nRegras)
			For nz:=1 to Len(aRetPartes)
				aRetPartes[nz] := aRetPartes[nz]*nFator
			Next nz
		Endif
	Else
		dbSelectArea("SD2")
		aRetPartes:=PegaCMPFim("D2_CP",lCstPart,nRegras,SD2->D2_QUANT)
		dbSelectArea("SB6")
	Endif
	nRegSb6 := Recno()  // Atualizar SB6
	If __oSQLSB6 == nil
		cQuery := "SELECT R_E_C_N_O_ FROM "+RetSqlName("SB6") + " "
		cQuery += " WHERE B6_FILIAL = ? "               //- 1
		cQuery += " AND B6_IDENT = ? "               	//- 2
		cQuery += " AND B6_PRODUTO  = ? "               //- 3
		cQuery += " AND B6_TIPO = 'D' "     
		cQuery += " AND B6_DOC = ? "               		//- 4         
		cQuery += " AND B6_SERIE = ? "               	//- 5
		cQuery += " AND D_E_L_E_T_  = ' '"
		cQuery := ChangeQuery(cQuery)
		If __lCusbVLib
			__oSQLSB6 := FwExecStatement():New(cQuery)
		Else
			__oSQLSB6 := FWPreparedStatement():New(cQuery)
		EndIf
	EndIf
	__oSQLSB6:SetString(1, cFilSB6)
	__oSQLSB6:SetString(2, SD2->D2_IDENTB6)
	__oSQLSB6:SetString(3, SD2->D2_COD)
	__oSQLSB6:SetString(4, SD2->D2_DOC)
	__oSQLSB6:SetString(5, SD2->D2_SERIE)

	nRecnoSB6 := 0
	If __lCusbVLib
		nRecnoSB6 := __oSQLSB6:ExecScalar('R_E_C_N_O_')
	Else
		cQuery := __oSQLSB6:GetFixQuery()
		MpSysOpenQuery(cQuery,'QTerc')
		IF QTerc->(!Eof())
			nRecnoSB6 := QTerc->R_E_C_N_O_
		EndIf
		QTerc->(dbCloseArea())
	EndIf
	If nRecnoSB6 > 0
		dbgoto (nRecnoSB6)
		RecLock("SB6")
		Replace B6_PRUNIT	with aCusto[1]
		Replace B6_CUSTO1 With aCusto[1] * SB6->B6_QUANT
		Replace B6_CUSTO2 With aCusto[2] * SB6->B6_QUANT
		Replace B6_CUSTO3 With aCusto[3] * SB6->B6_QUANT
		Replace B6_CUSTO4 With aCusto[4] * SB6->B6_QUANT
		Replace B6_CUSTO5 With aCusto[5] * SB6->B6_QUANT
		If lCusRep
			Replace B6_CUSRP1 With aCustoRep[1] * SB6->B6_QUANT
			Replace B6_CUSRP2 With aCustoRep[2] * SB6->B6_QUANT
			Replace B6_CUSRP3 With aCustoRep[3] * SB6->B6_QUANT
			Replace B6_CUSRP4 With aCustoRep[4] * SB6->B6_QUANT
			Replace B6_CUSRP5 With aCustoRep[5] * SB6->B6_QUANT
		EndIf
		If lCusFIFO
			Replace B6_CUSFF1 With aCustoFF[1] * SB6->B6_QUANT
			Replace B6_CUSFF2 With aCustoFF[2] * SB6->B6_QUANT
			Replace B6_CUSFF3 With aCustoFF[3] * SB6->B6_QUANT
			Replace B6_CUSFF4 With aCustoFF[4] * SB6->B6_QUANT
			Replace B6_CUSFF5 With aCustoFF[5] * SB6->B6_QUANT
		Endif
		nSB6Alt := SB6->(Recno())
		MsUnlock()
		GravaCusCP(lCstPart,NIL,NIL,"SB6",SB6->B6_PRODUTO,ACLONE(aRetPartes),SB6->B6_QUANT,NIL,{B6_CUSTO1,B6_CUSTO2,B6_CUSTO3,B6_CUSTO4,B6_CUSTO5})			
	EndIf
	MsGoto(nRegSB6)
EndCase

//Ponto de entrada para manipular gravação da SB6
If lM330PSB6
	nSB6Bkp := SB6->(Recno())
	SB6->(DbGoTo(nSB6Alt))
	ExecBlock('M330PSB6', .F., .F., {cAlias,lCusFIFO,cProg,lCstPart,nRegras,lCusRep})

	If cAlias == 'SD1'
		nAjuste := 1
	Else
		nAjuste := SB6->B6_QUANT
	EndIf

	aCusto[1]    := SB6->B6_CUSTO1/nAjuste
	aCusto[2]    := SB6->B6_CUSTO2/nAjuste
	aCusto[3]    := SB6->B6_CUSTO3/nAjuste
	aCusto[4]    := SB6->B6_CUSTO4/nAjuste
	aCusto[5]    := SB6->B6_CUSTO5/nAjuste
	aCustoFF[1]  := SB6->B6_CUSFF1/nAjuste
	aCustoFF[2]  := SB6->B6_CUSFF2/nAjuste
	aCustoFF[3]  := SB6->B6_CUSFF3/nAjuste
	aCustoFF[4]  := SB6->B6_CUSFF4/nAjuste
	aCustoFF[5]  := SB6->B6_CUSFF5/nAjuste
	aCustoRep[1] := SB6->B6_CUSRP1/nAjuste
	aCustoRep[2] := SB6->B6_CUSRP2/nAjuste
	aCustoRep[3] := SB6->B6_CUSRP3/nAjuste
	aCustoRep[4] := SB6->B6_CUSRP4/nAjuste
	aCustoRep[5] := SB6->B6_CUSRP5/nAjuste
	aRetPartes   := PegaCMPFim("B6_CP", lCstPart, nRegras,nAjuste)

	SB6->(DbGoTo(nSB6Bkp))
EndIf

If cProg == "330"
	aRet[01] := aCusto
	aRet[02] := aCustoFF
	aRet[03] := aRetPartes
	aRet[04] := aCustoRep
Else
	aRet := aCusto
Endif

Return aRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³SldPorLote³ Autor ³ Eduardo Riera         ³ Data ³ 01.02.99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Avalia os saldo por lote e Localizacao devolvendo um array  ³±±
±±³          ³para movimentacao. Assume que o SB2 esta Travado            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³[01] Lote de Controle                                       ³±±
±±³          ³[02] Sub-Lote                                               ³±±
±±³          ³[03] Localizacao                                            ³±±
±±³          ³[04] Numero de Serie                                        ³±±
±±³          ³[05] Quantidade                                             ³±±
±±³          ³[06] Quantidade 2aUM                                        ³±±
±±³          ³[07] Data de Validade                                       ³±±
±±³          ³[08] Registro do SB2                                        ³±±
±±³          ³[09] Registro do SBF                                        ³±±
±±³          ³[10] Array com Registros do SB8 e qtd                       ³±±
±±³          ³[11] Local                                                  ³±±
±±³          ³[12] Potencia                                               ³±±
±±³          ³[13] Prioridade do endereco (BF_PRIOR)                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do Produto         - Obrigatorio              ³±±
±±³          ³ExpC2: Local                     - Obrigatorio              ³±±
±±³          ³ExpN1: Quantidade                - Obrigatorio              ³±±
±±³          ³ExpN2: Quantidade 2aUM           - Obrigatorio              ³±±
±±³          ³ExpC3: Lote de Controle          - Obrig. se Inf. Sub-Lote  ³±±
±±³          ³ExpC4: Sub-Lote                                             ³±±
±±³          ³ExpC5: Localizacao                                          ³±±
±±³          ³ExpC6: Numero de Serie                                      ³±±
±±³          ³ExpA1: Array para o travamento dos saldos, caso nao seja    ³±±
±±³          ³       informado nao havera travamento.                     ³±±
±±³          ³ExpL1: Flag que indica se esta baixando material empenhado  ³±±
±±³          ³       ou nao                                               ³±±
±±³          ³ExpC7: Local Ate (utilizado para selecao de almoxarifados)  ³±±
±±³          ³ExpL2: Flag que indica se considera lotes vencidos          ³±±
±±³          ³ExpA1: Array com lotes a serem desconsiderados              ³±±
±±³          ³       [1] Lote [2] Sub-Lote [3] Endereco [4] Num. de Serie ³±±
±±³          ³       [5] Qtd 1a UM a ser considerada como indisponivel    ³±±
±±³          ³       (deve ser subtraida do saldo a ser retornado)        ³±±
±±³          ³       [6] Qtd 2a UM a ser considerada como indisponivel    ³±±
±±³          ³       (deve ser subtraida do saldo a ser retornado)        ³±±
±±³          ³ExpL3: Flag que indica se considera empenhos previstos      ³±±
±±³          ³ExpD1: Data de referencia para verificar o saldo            ³±±
±±³          ³ExpL4: .T. = Quando integrado ao WMS considera os saldos    ³±±
±±³          ³             reservados para execucao da radio frequencia   ³±±
±±³          ³ExpL5: .T. = Quando utilizado retorna o saldo fisico sem    ³±±
±±³          ³             descontar o saldo empenhado/reservado          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function SldPorLote(cCodPro,cLocal,nQtd,nQtd2UM,cLoteCtl,cNumLote,cLocaliza,cNumSer,aTravas,lBaixaEmp,cLocalAte,lConsVenc,aLotesFil,lEmpPrevisto,dDataRef,lInfoWms,cOP,lSaldo,nPercPrM,lAtuSB2,nQtdeOri)
Static lRDSldPor  := NIL
Static lQuantRet  := NIL
Static lMontSetBF := .T.
Static lMontSetB8 := .T.
Static aSetPorLot := {}
Static aPrepPorLot:= {}

Local lContSB8    := .T.
Local lContSBF    := .T.
Local lUtiliza    := .T.
Local lOrdValid   := .F.

Local aRetorno    := {}
Local aStruSB8    := {}
Local aStruSBF    := {}
Local aQtdRdmake  := {}
Local aInsert     := {}

Local nx          := 0
Local nAchou      := 0
Local nAchouProd  := 0
Local nEmpenho	  := 0
Local nEmpenho2   := 0
Local nQtdSB8     := 0
Local nQtdSB82    := 0
Local nReserva    := 0
Local nReserva2   := 0
Local nReservaSB8 := 0
Local nReserva2SB8:= 0
Local nRecSB8     := 0
Local nProcura    := 0
Local nSaldSBf    := 0
Local nSaldSBf2   := 0
Local nSldRF	  := 0
Local nPosPrep    := 0

Local cLoteSb8    := ""
Local cNumLSb8    := ""
Local cQuery      := ""
Local cOrder      := ""
Local cOrdBkp     := ""
Local cAliasSB8   := "SB8"
Local cAliasSBF   := "SBF"
Local cMD5        := ""

Local lAglutSub   := Rastro(cCodPro,"L")
Local lMTSLDORD   := ExistBlock("MTSLDORD")
Local lSelLote    := (SuperGetMV("MV_SELLOTE") == "1")
Local lTravas     := If (ValType(aTravas)!="A",.F.,.T.)
Local lMVPerdInf  := If(Type('lPerdInf')#"L",SuperGetMV('MV_PERDINF',.F.,.F.),lPerdInf)
Local lWmsNew     := SuperGetMV("MV_WMSNEW",.F.,.F.)
Local lLocalCQ    := .F.
Local lLocalWMS	  := .F.
Local lLocalNoWMS := .F.
Local lUsaWMS := .F.
Local aAreaSB1	  := SB1->(GetArea())

DEFAULT lEmpPrevisto:= .F.
DEFAULT lInfoWms    := .F.
DEFAULT lSaldo      := .F.
DEFAULT cOP         := Nil
DEFAULT lAtuSB2     := .T.
DEFAULT nPercPrM    := 0
DEFAULT nQtdeOri    := 0

If Type("lPrdProp") == "U"
	Private lPrdProp := .F.
EndIf

If Type("L650") == "U"
	Private L650 := .F.
EndIf

If Type("L650Auto") == "U"
	Private L650Auto := .F.
EndIf

__lCusaVLib := Iif(__lCusaVLib == NIL,FWLibVersion() >= "20211116",__lCusaVLib)

SB1->(DbSetOrder(1))
SB1->(DbSeek(xFilial("SB1") + cCodPro))

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ VERIFICA A EXISTENCIA DO P.E. MTSLDLOT                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lRDSldPor := If(lRDSldPor == NIL,ExistBlock("MTSLDLOT"),lRDSldPor)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ VERIFICA A EXISTENCIA DO P.E. MTRETLOT                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lQuantRet := If(lQuantRet == NIL,ExistBlock("MTRETLOT"),lQuantRet)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Analisa os dados de entrada da funcao                                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cLocalAte := If(cLocalAte == NIL,"",cLocalAte)
cLoteCtl  := If(cLoteCtl  == NIL .Or. Empty(cLoteCtl),"",cLoteCtl)
cNumLote  := If(cNumLote  == NIL .Or. Empty(cNumLote) .Or. Rastro(cCodPro,"L"),"",cNumLote)
cLocaliza := If(cLocaliza == NIL .Or. Empty(cLocaliza),If(!Empty(cNumSer),CriaVar("BF_LOCALIZ"),""),cLocaliza)
cNumSer	  := If(cNumSer   == NIL .Or. Empty(cNumSer) ,"",cNumSer)
lBaixaEmp := If(lBaixaEmp == NIL ,.F.,lBaixaEmp .And. !Empty(cLoteCtl+cNumLote+cLocaliza))
lConsVenc := If(lConsVenc == NIL,SUPERGETMV("MV_LOTVENC",.T.,"S") == "S",lConsVenc)
nQtd2UM   := If(nQtd2UM   == NIL,ConvUm(cCodPro,nQtd,0,2),nQtd2UM)
aLotesFil := If(aLotesFil == NIL,{},aLotesFil)

lLocalWMS	:= Localiza(cCodPro,.T.)
lLocalNoWMS := Localiza(cCodPro)
lUsaWMS     := (lWmsNew .And. IntWMS(cCodPro))

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se considera local de/ate                                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Empty(cLocalAte)
	cLocalAte := cLocal
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica os Saldos por Lote / Sub-Lote / Localizacao                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Rastro(cCodPro)
	dbSelectArea("SB8")
	If !Empty(cLoteCtl+cNumLote)
		lOrdValid := .F.
		dbSetOrder(3)
	Else
		lOrdValid := .T.
		dbSetOrder(1)
	EndIf
	If lLocalNoWMS
		SBF->(dbSetOrder(2))
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Otimizacao para versoes SQL                                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aStruSB8  := SB8->(dbStruct())
	SB8->(dbCommit())
	cAliasSB8 := "SLDPORLOTE"
	cAliasSBF := "SLDPORLOTE"
	If lLocalWMS .And. !lUsaWMS
		cQuery := "SELECT "
		For nX := 1 To Len(aStruSB8)
			cQuery+=aStruSB8[nx,1]+","
			// Montagem do array que sera utilizado no TCSetField
			If lMontSetB8
				If aStruSB8[nX][2]<>"C"
					aAdd(aSetPorLot, {aStruSB8[nX][1],aStruSB8[nX][2],aStruSB8[nX][3],aStruSB8[nX][4]})
				EndIf
			EndIf
		Next nX
		lMontSetB8 := .F.
		aStruSBF:= SBF->(dbStruct())
		SBF->(dbCommit())
		For nX := 1 To Len(aStruSBF)
			cQuery+=aStruSBF[nx,1]+","
			// Montagem do array que sera utilizado no TCSetField
			If lMontSetBF
				If aStruSBF[nX][2]<>"C"
					aAdd(aSetPorLot, {aStruSBF[nX][1],aStruSBF[nX][2],aStruSBF[nX][3],aStruSBF[nX][4]})
				EndIf
			EndIf
		Next nX
		lMontSetBF := .F.
		cQuery += "SB8.R_E_C_N_O_ SB8RECNO,SBF.R_E_C_N_O_ SBFRECNO "
		cQuery += "FROM "+RetSqlName("SB8")+" SB8,"
		cQuery += RetSqlName("SBF")+" SBF "
	Else
		cQuery := "SELECT "
		For nX := 1 To Len(aStruSB8)
			cQuery+=aStruSB8[nx,1]+","
			// Montagem do array que sera utilizado no TCSetField
			If lMontSetB8
				If aStruSB8[nX][2]<>"C"
					aAdd(aSetPorLot, {aStruSB8[nX][1],aStruSB8[nX][2],aStruSB8[nX][3],aStruSB8[nX][4]})
				EndIf
			EndIf
		Next nX
		lMontSetB8 := .F.
		cQuery += "SB8.R_E_C_N_O_ SB8RECNO "
		cQuery += "FROM "+RetSqlName("SB8")+" SB8 "
	EndIf
	cQuery += "WHERE SB8.B8_FILIAL= ? AND "
	cQuery += "SB8.B8_PRODUTO= ? AND "
	aAdd(aInsert, xFilial("SB8"))
	aAdd(aInsert, cCodPro)
	If cLocal == cLocalAte
		cQuery += "SB8.B8_LOCAL= ? AND "
		aAdd(aInsert, cLocal)
	Else
		cQuery += "SB8.B8_LOCAL>= ? AND "
		cQuery += "SB8.B8_LOCAL<= ? AND "
		aAdd(aInsert, cLocal)
		aAdd(aInsert, cLocalAte)
	EndIf
	If !lOrdValid
		cQuery += "SB8.B8_LOTECTL= ? AND "
		aAdd(aInsert, cLoteCtl)
		If !Empty(cNumLote)
			cQuery += "SB8.B8_NUMLOTE= ? AND "
			aAdd(aInsert, cNumLote)
		EndIf
	EndIf
	cQuery += "SB8.B8_SALDO > 0 AND SB8.D_E_L_E_T_=' ' "
	If lLocalWMS .And. !lUsaWMS
		cQuery += "AND SBF.BF_FILIAL= ? AND "
		cQuery += "SBF.BF_PRODUTO= ? AND "
		cQuery += "SBF.BF_LOCAL=SB8.B8_LOCAL AND "
		cQuery += "SBF.BF_LOTECTL=SB8.B8_LOTECTL AND "
		aAdd(aInsert, xFilial("SBF"))
		aAdd(aInsert, cCodPro)
		If !Empty(cLocaliza)
			cQuery += "SBF.BF_LOCALIZ= ? AND "
			aAdd(aInsert, cLocaliza)
		EndIf
		If !Empty(cNumLote)
			cQuery += "SBF.BF_NUMLOTE= ? AND "
			aAdd(aInsert, cNumLote)
		EndIf
		If !Empty(cNumSer)
			cQuery += "SBF.BF_NUMSERI= ? AND "
			aAdd(aInsert, cNumSer)
		EndIf
		cQuery += "SBF.D_E_L_E_T_=' ' "
		If lOrdValid
			cOrder := "ORDER BY "+SqlOrder("B8_FILIAL+B8_PRODUTO+DTOS(B8_DTVALID)+B8_LOCAL+B8_LOTECTL+B8_NUMLOTE")+","+SqlOrder(SBF->(IndexKey()))
		Else
			cOrder := "ORDER BY "+SqlOrder(SB8->(IndexKey()))+","+SqlOrder(SBF->(IndexKey()))
		EndIf
	Else
		If lOrdValid
			cOrder := "ORDER BY "+SqlOrder("B8_FILIAL+B8_PRODUTO+DTOS(B8_DTVALID)+B8_LOCAL+B8_LOTECTL+B8_NUMLOTE")
		Else
			cOrder := "ORDER BY "+SqlOrder(SB8->(IndexKey()))
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ MTSLDORD - Ponto de entrada utilizado para alterar a ordenacao de requisicao de lotes ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lMTSLDORD
		cOrdBkp := ExecBlock("MTSLDORD",.F.,.F.,{cLoteCtl,cNumLote,cCodPro,cLocal,cLocalAte})
		If !Empty(cOrdBkp)
		   cOrder := cOrdBkp
		EndIf
	EndIf

	cQuery:= (cQuery+cOrder)

	// Define um identificador para a query
	cMD5 := MD5(cQuery)
	
	If (nPosPrep := aScan(aPrepPorLot,{|x| x[2] == cMD5})) == 0
		If __lCusaVLib
			// FwExecStatement - realiza o bind de queries diretamente no banco de dados obtendo ganho de performance
			Aadd(aPrepPorLot,{FwExecStatement():New(),cMD5})
		Else
			// Monta FWPreparedStatement e ChangeQuery apenas 1x para cada variacao da query	
			aAdd(aPrepPorLot,{FWPreparedStatement():New(), cMD5})
		EndIf
		nPosPrep := Len(aPrepPorLot)
		aPrepPorLot[nPosPrep][1]:SetQuery(ChangeQuery(cQuery))
	EndIf
	// Seta as variaveis na query
	For nX := 1 To Len(aInsert)
		aPrepPorLot[nPosPrep][1]:SetString(nX, aInsert[nX])
	Next nX

	If __lCusaVLib
		cAliasSB8 := aPrepPorLot[nPosPrep][1]:OpenAlias(cAliasSB8)
		For nX := 1 To Len(aSetPorLot)
			TCSetField(cAliasSB8,aSetPorLot[nX][1],aSetPorLot[nX][2],aSetPorLot[nX][3],aSetPorLot[nX][4])
		Next nX
	Else
		// Recupera a query transformada
		cQuery := aPrepPorLot[nPosPrep][1]:getFixQuery()
		// Abre um alias com a query e ja executa o TCSetField nos campos
		cAliasSB8 := MPSysOpenQuery(cQuery, cAliasSB8, aSetPorLot)
	EndIf
	dbSelectArea(cAliasSB8)

	While ( !Eof() .And. xFilial("SB8")	== (cAliasSB8)->B8_FILIAL .And. ;
			cCodPro			== (cAliasSB8)->B8_PRODUTO .And.;
			(cLoteCtl		== (cAliasSB8)->B8_LOTECTL.Or.Empty(cLoteCtl)).And.;
			(cNumLote		== (cAliasSB8)->B8_NUMLOTE.Or.Empty(cNumLote)).And.;
			lContSB8 )
		lUtiliza := .T.
		nRecSB8:=(cAliasSB8)->SB8RECNO
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Caso tenha travado registro trava tambem o SB2                          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SB2->(dbSetOrder(1))
		If !(SB2->(MsSeek(xFilial("SB2")+cCodPro+(cAliasSB8)->B8_LOCAL)))
			CriaSB2(cCodPro,(cAliasSB8)->B8_LOCAL)
		EndIf
		If ( lTravas .And. lAtuSB2 )
			nAchou   := ASCAN(aTravas,{|x| x[1] == "SB2" .And. x[2] == SB2->(RecNo())})
			If nAchou == 0
				SoftLock("SB2")
				AADD(aTravas,{ "SB2" , SB2->(RecNo()) })
			EndIf
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Caso seja Armázem do CQ desconsidera.
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		lLocalCQ := If((l650 .or. l650Auto) .AND. AlmoxCq() == (cAliasSB8)->B8_LOCAL,.T.,.F.)	
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Avalia os Saldos por Lote e Sub-Lote                                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nReservaSB8 :=0
		nReserva2SB8:=0
		nQtdSB8     :=Min(nQtd-nReserva,SB8Saldo(lBaixaEmp,lConsVenc,NIL,NIL,cAliasSB8,lEmpPrevisto,NIL,dDataRef,lSaldo,IIf(lMVPerdInf,cOP,Nil),nPercPrM,nQtdeOri,cOP))
		nQtdSB82    :=Min(nQtd2UM-nReserva2,SB8Saldo(lBaixaEmp,lConsVenc,NIL,.T.,cAliasSB8,lEmpPrevisto,NIL,dDataRef,lSaldo,IIf(lMVPerdInf,cOP,Nil),nPercPrM,nQtdeOri))
		If QtdComp(nQtdSB8,.t.) > 0 .And. If(ValType(dDataRef) == "D",(cAliasSB8)->B8_DATA <= dDataRef,.T.) .AND. !lLocalCQ
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Avalia os saldos por Localizacao e Nr.Serie                             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lLocalNoWMS .And. !lUsaWMS
				lContSBF := .T.
				cNumLSb8 := If(Rastro(cCodPro,"S"),(cAliasSB8)->B8_NUMLOTE,CriaVar("B8_NUMLOTE",.F.))
				cLoteSb8 := (cAliasSB8)->B8_LOTECTL
				While ( !Eof() .And. xFilial("SBF") == (cAliasSBF)->BF_FILIAL .And.;
							cCodPro	== (cAliasSBF)->BF_PRODUTO  .And.;
							cLoteSb8 == (cAliasSBF)->BF_LOTECTL .And.;
							lContSBF)
					If	( (	(cAliasSBF)->BF_LOCALIZ == cLocaliza .Or. Empty(cLocaliza)) .And.;
						  ( (cAliasSBF)->BF_NUMSERI == cNumSer   .Or. Empty(cNumSer))   .And.;
							(cNumLSb8 == (cAliasSBF)->BF_NUMLOTE .Or. Empty(cNumLSb8)))
						If ( If(lBaixaEmp,(cAliasSBF)->BF_EMPENHO,QtdComp(SBFSaldo(NIL,cAliasSBF,lEmpPrevisto,NIL,lSaldo),.t.)) > 0 )
							nAchou   := ASCAN(aRetorno,{|x| x[1] == (cAliasSBF)->BF_LOTECTL  .And.;
															x[2]  == (cAliasSBF)->BF_NUMLOTE .And.;
															x[3]  == (cAliasSBF)->BF_LOCALIZ .And.;
															x[4]  == (cAliasSBF)->BF_NUMSERI .And.;
															x[11] == (cAliasSBF)->BF_LOCAL })
							nEmpenho := nQtdSB8 - nReservaSB8
							nEmpenho2:= nQtdSB82- nReserva2SB8

							lUtiliza :=.T.
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Qdo Usuario seleciona Lote manualmente, observar se utiliza registro   ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If cPaisLoc == "ARG" .and. lSelLote
								If (Empty(SC6->C6_LOCALIZ) .or. Empty(SC6->C6_LOTECTL)) .and.;
									AllTrim(FunName()) $ "MATA440|MATA450|MATA456"
									lUtiliza := .F.
								EndIf
							EndIf

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Executa P.E. MTSLDLOT para verificar se utiliza registro               ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If lRDSldPor
								lUtiliza:= ExecBlock("MTSLDLOT",.F.,.F.,{	(cAliasSBF)->BF_PRODUTO	,;
																			(cAliasSBF)->BF_LOCAL	,;
																			(cAliasSBF)->BF_LOTECTL	,;
																			(cAliasSBF)->BF_NUMLOTE	,;
																			(cAliasSBF)->BF_LOCALIZ	,;
																			(cAliasSBF)->BF_NUMSERI	,;
																			nEmpenho				,;
																			.F.						})
								If ValType(lUtiliza) != "L"
									lUtiliza :=.T.
								EndIf
							EndIf

							If lPrdProp .And. Empty(cLoteCtl) //Referente ao novo parâmetro MV_ESTPROP
								If Type("aCols") == "A" 
									If Len(aCols) > 0
										nAchouProd:=ASCAN(aCols,{|x| x[1] == (cAliasSBF)->BF_PRODUTO .And. x[2] == (cAliasSBF)->BF_LOCAL .And. x[6] == (cAliasSBF)->BF_LOTECTL .And. x[11] == .F.})
										If nAchouProd > 0
											lUtiliza :=.F.
										EndIf
									EndIf
								EndIf
							EndIf 

							If lUtiliza
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³Verifica se o lote deve ser considerado                                 ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								nProcura:=0
								If lAglutSub
									nProcura:=aScan(aLotesFil,{|x| x[1] == (cAliasSBF)->BF_LOTECTL .And. x[3] == (cAliasSBF)->BF_LOCALIZ .And. x[4] == (cAliasSBF)->BF_NUMSERI})
								Else
									nProcura:=aScan(aLotesFil,{|x| x[1] == (cAliasSBF)->BF_LOTECTL .And. x[2] == (cAliasSBF)->BF_NUMLOTE .And. x[3] == (cAliasSBF)->BF_LOCALIZ .And. x[4] == (cAliasSBF)->BF_NUMSERI})
								EndIf

								If (lAglutSub .And. nAchou == 0) .Or. !lAglutSub
									If lInfoWms
										nSldRF   := WmsSaldoSBF((cAliasSBF)->BF_LOCAL,(cAliasSBF)->BF_LOCALIZ,cCodPro,(cAliasSBF)->BF_NUMSERI,(cAliasSBF)->BF_LOTECTL,(cAliasSBF)->BF_NUMLOTE,.T.,.T.,.F.,.T.)
										nEmpenho := Min(If(lBaixaEmp,(cAliasSBF)->BF_EMPENHO,nSldRF-If(nProcura>0,aLotesFil[nProcura,5],0)),nEmpenho)
										nEmpenho2:= Min(If(lBaixaEmp,(cAliasSBF)->BF_EMPEN2,ConvUm(cCodPro, nSldRF, 0, 2)-If(nProcura>0,aLotesFil[nProcura,6],0)),nEmpenho2)
										If nEmpenho <= 0
											nEmpenho := 0
											nEmpenho2:= 0
										EndIf
									Else
										nEmpenho := Min(If(lBaixaEmp,((cAliasSBF)->BF_EMPENHO+(nQtdeOri*nPercPrM)),SBFSaldo(NIL,cAliasSBF,lEmpPrevisto,NIL,lSaldo)-If(nProcura>0,aLotesFil[nProcura,5],0)),nEmpenho)
										nEmpenho2:= Min(If(lBaixaEmp,((cAliasSBF)->BF_EMPEN2+(nQtdeOri*nPercPrM)),ConvUm(cCodPro, SBFSaldo(NIL,cAliasSBF,lEmpPrevisto,NIL,lSaldo), SBFSaldo(NIL,cAliasSBF,lEmpPrevisto,.T.,lSaldo), 2)-If(nProcura>0,aLotesFil[nProcura,6],0)),nEmpenho2)
									EndIf

									If lQuantRet
										aQtdRdmake:=ExecBlock("MTRETLOT",.F.,.F.,{cCodPro,cLocal,nQtd,nQtd2UM,nEmpenho,nEmpenho2,(cAliasSBF)->BF_LOTECTL,(cAliasSBF)->BF_NUMLOTE,(cAliasSBF)->BF_LOCALIZ,(cAliasSBF)->BF_NUMSERI})
										If Valtype(aQtdRdmake) == "A"
											If (Valtype(aQtdRdmake[1]) == "N") .And. (aQtdRdmake[1] <= nEmpenho) .And. (aQtdRdmake[1] >= 0)
												nEmpenho:=aQtdRdmake[1]
											EndIf
											If (Valtype(aQtdRdmake[2]) == "N") .And. (aQtdRdmake[2] <= nEmpenho2) .And. (aQtdRdmake[2] >= 0)
												nEmpenho2:=aQtdRdmake[2]
											EndIf
										EndIf
									EndIf

									If QtdComp(nEmpenho,.t.) > QtdComp(0) .Or. QtdComp(nEmpenho2,.t.) > QtdComp(0)
										AADD(aRetorno,{	(cAliasSBF)->BF_LOTECTL,;
														(cAliasSBF)->BF_NUMLOTE,;
														(cAliasSBF)->BF_LOCALIZ,;
														(cAliasSBF)->BF_NUMSERI,;
														nEmpenho,;
														nEmpenho2,;
														(cAliasSB8)->B8_DTVALID,;
														SB2->(Recno()),;
														(cAliasSBF)->SBFRECNO,;
														{{(cAliasSB8)->SB8RECNO,nEmpenho,nEmpenho2}},;
														(cAliasSBF)->BF_LOCAL,(cAliasSB8)->B8_POTENCI,(cAliasSBF)->BF_PRIOR})
									EndIf
								Else
									If lInfoWms
										nSldRF   := WmsSaldoSBF((cAliasSBF)->BF_LOCAL,(cAliasSBF)->BF_LOCALIZ,cCodPro,(cAliasSBF)->BF_NUMSERI,(cAliasSBF)->BF_LOTECTL,(cAliasSBF)->BF_NUMLOTE,.T.,.T.,.F.,.T.)
										nEmpenho := Min(If(lBaixaEmp,(cAliasSBF)->BF_EMPENHO,nSldRF-If(nProcura>0,aLotesFil[nProcura,5],0))-aRetorno[nAchou,5],nEmpenho)
										nEmpenho2:= Min(If(lBaixaEmp,(cAliasSBF)->BF_EMPEN2,ConvUm(cCodPro, nSldRF, 0, 2)-If(nProcura>0,aLotesFil[nProcura,6],0))-aRetorno[nAchou,6],nEmpenho2)
										If nEmpenho <= 0
											nEmpenho := 0
											nEmpenho2:= 0
										EndIf
									Else
										nEmpenho := Min(If(lBaixaEmp,((cAliasSBF)->BF_EMPENHO+(nQtdeOri*nPercPrM)),SBFSaldo(NIL,cAliasSBF,lEmpPrevisto,NIL,lSaldo)-If(nProcura>0,aLotesFil[nProcura,5],0))-aRetorno[nAchou,5],nEmpenho)
										nEmpenho2:= Min(If(lBaixaEmp,((cAliasSBF)->BF_EMPEN2+(nQtdeOri*nPercPrM)),ConvUm(cCodPro, SBFSaldo(NIL,cAliasSBF,lEmpPrevisto,NIL,lSaldo), SBFSaldo(NIL,cAliasSBF,lEmpPrevisto,.T.,lSaldo), 2)-If(nProcura>0,aLotesFil[nProcura,6],0))-aRetorno[nAchou,6],nEmpenho2)
									EndIf

									If lQuantRet
										aQtdRdmake:=ExecBlock("MTRETLOT",.F.,.F.,{cCodPro,cLocal,nQtd,nQtd2UM,nEmpenho,nEmpenho2,(cAliasSBF)->BF_LOTECTL,(cAliasSBF)->BF_NUMLOTE,(cAliasSBF)->BF_LOCALIZ,(cAliasSBF)->BF_NUMSERI})
										If Valtype(aQtdRdmake) == "A"
											If (Valtype(aQtdRdmake[1]) == "N") .And. (aQtdRdmake[1] <= nEmpenho) .And. (aQtdRdmake[1] >= 0)
												nEmpenho:=aQtdRdmake[1]
											EndIf
											If (Valtype(aQtdRdmake[2]) == "N") .And. (aQtdRdmake[2] <= nEmpenho2) .And. (aQtdRdmake[2] >= 0)
												nEmpenho2:=aQtdRdmake[2]
											EndIf
										EndIf
									EndIf

									If QtdComp(nEmpenho) > QtdComp(0) .Or. QtdComp(nEmpenho2) > QtdComp(0)
										aRetorno[nAchou,5]+=nEmpenho
										aRetorno[nAchou,6]+=nEmpenho2
										AADD(aRetorno[nAchou,10],{(cAliasSB8)->SB8RECNO,nEmpenho,nEmpenho2})
									EndIf
								EndIf
								nReserva     += nEmpenho
								nReserva2    += nEmpenho2
								nReservaSB8  += nEmpenho
								nReserva2SB8 += nEmpenho2
							EndIf
						EndIf
					EndIf
					If (QtdComp(nReservaSB8,.t.) >= QtdComp(nQtdSB8,.t.))
						lContSBF := .F.
					EndIf
					dbSelectArea(cAliasSBF)
					dbSkip()
				EndDo
			Else
				nAchou   := ASCAN(aRetorno,{|x| x[1]  == (cAliasSB8)->B8_LOTECTL .And.;
												x[2]  == If(lAglutSub,CriaVar("B8_NUMLOTE"),(cAliasSB8)->B8_NUMLOTE) .And.;
												x[11] == (cAliasSB8)->B8_LOCAL })
				nEmpenho := nQtdSB8 - nReservaSB8
				nEmpenho2:= nQtdSB82- nReserva2SB8

				lUtiliza :=.T.
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Qdo Usuario seleciona Lote manualmente, observar se utiliza registro   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If cPaisLoc == "ARG" .and. lSelLote
					If (Empty(SC6->C6_LOCALIZ) .or. Empty(SC6->C6_LOTECTL)) .and.;
						AllTrim(FunName()) $ "MATA440|MATA450|MATA456"
						lUtiliza := .F.
					EndIf
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Executa P.E. MTSLDLOT para verificar se utiliza registro               ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If	lRDSldPor
					lUtiliza:= ExecBlock("MTSLDLOT",.F.,.F.,{	(cAliasSB8)->B8_PRODUTO	,;
																(cAliasSB8)->B8_LOCAL	,;
																(cAliasSB8)->B8_LOTECTL	,;
																(cAliasSB8)->B8_NUMLOTE	,;
																""						,;
																""						,;
																nEmpenho				,;
																.F.						})
					If ValType(lUtiliza) != "L"
						lUtiliza :=.T.
					EndIf
				EndIf

				If lUtiliza
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Verifica se o lote deve ser considerado                                 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					nProcura:=0
					If lAglutSub
						nProcura:=aScan(aLotesFil,{|x| x[1] == (cAliasSB8)->B8_LOTECTL .And. x[7] == (cAliasSB8)->B8_LOCAL})
					Else
						nProcura:=aScan(aLotesFil,{|x| x[1] == (cAliasSB8)->B8_LOTECTL .And. x[2] == (cAliasSB8)->B8_NUMLOTE .And. x[7] == (cAliasSB8)->B8_LOCAL})
					EndIf

					If (lAglutSub .And. nAchou == 0) .Or. !lAglutSub
						nEmpenho := Min(If(lBaixaEmp,If(lEmpPrevisto,(cAliasSB8)->B8_QEMPPRE,SB8SALDO(.T.,,,,cAliasSB8,,,,.T.,IIf(lMVPerdInf,cOp,Nil),nPercPrM,nQtdeOri)),SB8Saldo(NIL,lConsVenc,NIL,NIL,cAliasSB8,lEmpPrevisto,NIL,dDataRef,lSaldo,IIf(lMVPerdInf,cOp,Nil),nPercPrM,nQtdeOri)-If(nProcura>0,aLotesFil[nProcura,5],0)),nEmpenho)
						nEmpenho2:= Min(If(lBaixaEmp,If(lEmpPrevisto,(cAliasSB8)->B8_QEPRE2,SB8SALDO(.T.,,,.T.,cAliasSB8,,,,.T.,IIf(lMVPerdInf,cOp,Nil),nPercPrM,nQtdeOri)),SB8Saldo(NIL,lConsVenc,NIL,.T.,cAliasSB8,lEmpPrevisto,NIL,dDataRef,lSaldo,IIf(lMVPerdInf,cOp,Nil),nPercPrM,nQtdeOri)-If(nProcura>0,aLotesFil[nProcura,6],0)),nEmpenho2)

						If lQuantRet
							aQtdRdmake:=ExecBlock("MTRETLOT",.F.,.F.,{cCodPro,cLocal,nQtd,nQtd2UM,nEmpenho,nEmpenho2,(cAliasSB8)->B8_LOTECTL,(cAliasSB8)->B8_NUMLOTE,NIL,NIL})
							If Valtype(aQtdRdmake) == "A"
								If (Valtype(aQtdRdmake[1]) == "N") .And. (aQtdRdmake[1] <= nEmpenho) .And. (aQtdRdmake[1] >= 0)
									nEmpenho:=aQtdRdmake[1]
								EndIf
								If (Valtype(aQtdRdmake[2]) == "N") .And. (aQtdRdmake[2] <= nEmpenho2) .And. (aQtdRdmake[2] >= 0)
									nEmpenho2:=aQtdRdmake[2]
								EndIf
							EndIf
						EndIf

						If QtdComp(nEmpenho,.T.) > QtdComp(0) .Or. QtdComp(nEmpenho2,.T.) > QtdComp(0)
							AADD(aRetorno,{(cAliasSB8)->B8_LOTECTL,;
											If(lAglutSub,CriaVar("B8_NUMLOTE"),(cAliasSB8)->B8_NUMLOTE),;
											"",;
											"",;
											nEmpenho,;
											nEmpenho2,;
											(cAliasSB8)->B8_DTVALID,;
											SB2->(Recno()),;
											0,;
											{{(cAliasSB8)->SB8RECNO,nEmpenho,nEmpenho2}},;
											(cAliasSB8)->B8_LOCAL,(cAliasSB8)->B8_POTENCI,''})
						EndIf
					Else
						If QtdComp(nEmpenho) > QtdComp(0) .Or. QtdComp(nEmpenho2) > QtdComp(0)
							nEmpenho :=nEmpenho -If(nProcura>0,aLotesFil[nProcura,5],0)
							nEmpenho2:=nEmpenho2-If(nProcura>0,aLotesFil[nProcura,6],0)

							If lQuantRet
								aQtdRdmake:=ExecBlock("MTRETLOT",.F.,.F.,{cCodPro,cLocal,nQtd,nQtd2UM,nEmpenho,nEmpenho2,(cAliasSB8)->B8_LOTECTL,(cAliasSB8)->B8_NUMLOTE,NIL,NIL})
								If Valtype(aQtdRdmake) == "A"
									If (Valtype(aQtdRdmake[1]) == "N") .And. (aQtdRdmake[1] <= nEmpenho) .And. (aQtdRdmake[1] >= 0)
										nEmpenho:=aQtdRdmake[1]
									EndIf
									If (Valtype(aQtdRdmake[2]) == "N") .And. (aQtdRdmake[2] <= nEmpenho2) .And. (aQtdRdmake[2] >= 0)
										nEmpenho2:=aQtdRdmake[2]
									EndIf
								EndIf
							EndIf

							aRetorno[nAchou,5]+=nEmpenho
							aRetorno[nAchou,6]+=nEmpenho2
							AADD(aRetorno[nAchou,10],{(cAliasSB8)->SB8RECNO,nEmpenho,nEmpenho2})
						EndIf
					EndIf
					nReserva     += nEmpenho
					nReserva2    += nEmpenho2
					nReservaSB8  += nEmpenho
					nReserva2SB8 += nEmpenho2
				EndIf
			EndIf
		EndIf
		If (QtdComp(nReserva,.t.) >= QtdComp(nQtd,.t.))
			lContSB8 := .F.
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Caso utilize localizacao nao salta registro novamente , ja saltou no    ³
		//³laco das localizacoes .                                                 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea(cAliasSB8)
		While !Eof() .And. (cAliasSB8)->SB8RECNO == nRecSB8
			dbSkip()
		End
	EndDo
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fecha query criada                                                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea(cAliasSB8)
	dbCloseArea()
	dbSelectArea("SB8")

	aInsert := aSize(aInsert,0)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica os saldo por Localizacao quando nao ha rastro                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ElseIf lLocalNoWMS .And. !lUsaWMS .And. Empty(aRetorno)
	dbSelectArea("SBF")
	dbSetOrder(2)
	cAliasSBF := "SLDPORLOTE"
	aStruSBF  := SBF->(dbStruct())
	SBF->(dbCommit())
	cQuery  := "SELECT "
	For nX := 1 To Len(aStruSBF)
		cQuery+=aStruSBF[nx,1]+","
		// Montagem do array que sera utilizado no TCSetField
		If lMontSetBF
			If aStruSBF[nX][2]<>"C"
				aAdd(aSetPorLot, {aStruSBF[nX][1],aStruSBF[nX][2],aStruSBF[nX][3],aStruSBF[nX][4]})
			EndIf
		EndIf
	Next nX
	lMontSetBF := .F.
	cQuery += "SBF.R_E_C_N_O_ SBFRECNO "
	cQuery += "FROM "+RetSqlName("SBF")+" SBF "
	cQuery += "WHERE SBF.BF_FILIAL= ? AND "
	cQuery += "SBF.BF_PRODUTO= ? AND "
	aAdd(aInsert, xFilial("SBF"))
	aAdd(aInsert, cCodPro)
	If cLocal == cLocalAte
		cQuery += "SBF.BF_LOCAL= ? AND "
		aAdd(aInsert, cLocal)
	Else
		cQuery += "SBF.BF_LOCAL>= ? AND "
		cQuery += "SBF.BF_LOCAL<= ? AND "
		aAdd(aInsert, cLocal)
		aAdd(aInsert, cLocalAte)
	EndIf
	If !Empty(cLocaliza)
		cQuery += "SBF.BF_LOCALIZ= ? AND "
		aAdd(aInsert, cLocaliza)
	EndIf
	If !Empty(cNumSer)
		cQuery += "SBF.BF_NUMSERI= ? AND "
		aAdd(aInsert, cNumSer)
	EndIf
	cQuery += "SBF.D_E_L_E_T_=' ' "
	cQuery += "ORDER BY "+SqlOrder(SBF->(IndexKey()))

	// Define um identificador para a query
	cMD5 := MD5(cQuery)
	
	If (nPosPrep := aScan(aPrepPorLot,{|x| x[2] == cMD5})) == 0
		If __lCusaVLib
			// FwExecStatement - realiza o bind de queries diretamente no banco de dados obtendo ganho de performance
			Aadd(aPrepPorLot,{FwExecStatement():New(),cMD5})
		Else	
			// Monta FWPreparedStatement e ChangeQuery apenas 1x para cada variacao da query
			aAdd(aPrepPorLot,{FWPreparedStatement():New(), cMD5})
		EndIf
		nPosPrep := Len(aPrepPorLot)
		aPrepPorLot[nPosPrep][1]:SetQuery(ChangeQuery(cQuery))
	EndIf
	// Seta as variaveis na query
	For nX := 1 To Len(aInsert)
		aPrepPorLot[nPosPrep][1]:SetString(nX, aInsert[nX])
	Next nX
	
	If __lCusaVLib
		cAliasSBF := aPrepPorLot[nPosPrep][1]:OpenAlias(cAliasSBF)
		For nX := 1 To Len(aSetPorLot)
			TCSetField(cAliasSBF,aSetPorLot[nX][1],aSetPorLot[nX][2],aSetPorLot[nX][3],aSetPorLot[nX][4])
		Next nX
	Else
		// Recupera a query transformada
		cQuery := aPrepPorLot[nPosPrep][1]:getFixQuery()
		// Abre um alias com a query e ja executa o TCSetField nos campos
		cAliasSBF := MPSysOpenQuery(cQuery, cAliasSBF, aSetPorLot)
	EndIf
	dbSelectArea(cAliasSBF)

	While ( !Eof() .And. xFilial("SBF") == (cAliasSBF)->BF_FILIAL .And.;
			cCodPro	== (cAliasSBF)->BF_PRODUTO .And. lContSBF)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Caso tenha travado registro trava tambem o SB2                          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SB2->(dbSetOrder(1))
		If !(SB2->(MsSeek(xFilial("SB2")+cCodPro+(cAliasSBF)->BF_LOCAL)))
			CriaSB2(cCodPro,(cAliasSBF)->BF_LOCAL)
		EndIf
		If ( lTravas .And. lAtuSB2 )
			nAchou   := ASCAN(aTravas,{|x| x[1] == "SB2" .And. x[2] == SB2->(RecNo())})
			If nAchou == 0
				SoftLock("SB2")
				AADD(aTravas,{ "SB2" , SB2->(RecNo()) })
			EndIf
		EndIf
		If	( ((cAliasSBF)->BF_LOCALIZ == cLocaliza  .Or. Empty(cLocaliza) ) .And. ((cAliasSBF)->BF_NUMSERI == cNumSer  .Or. Empty(cNumSer)) )
			If (If(lBaixaEmp,(cAliasSBF)->BF_EMPENHO,SBFSaldo(NIL,cAliasSBF,lEmpPrevisto,NIL,lSaldo)) > 0)
				If lInfoWms
					nSldRF   := WmsSaldoSBF((cAliasSBF)->BF_LOCAL,(cAliasSBF)->BF_LOCALIZ,cCodPro,(cAliasSBF)->BF_NUMSERI,(cAliasSBF)->BF_LOTECTL,(cAliasSBF)->BF_NUMLOTE,.T.,.T.,.F.,.T.)
					nEmpenho := nQtd - nReserva
					nEmpenho := Min(If(lBaixaEmp,(cAliasSBF)->BF_EMPENHO,nSldRF),nEmpenho)
					nEmpenho2:= nQtd2UM - nReserva2
					nEmpenho2:= Min(If(lBaixaEmp,(cAliasSBF)->BF_EMPEN2, ConvUm(cCodPro, nSldRF, 0, 2) ),nEmpenho2)
					If nEmpenho <= 0
						nEmpenho := 0
						nEmpenho2:= 0
					EndIf
				Else
					nEmpenho := nQtd - nReserva
					nSaldSBf := SBFSaldo(NIL,cAliasSBF,lEmpPrevisto,NIL,lSaldo)
					nSaldSBf2 := SBFSaldo(NIL,cAliasSBF,lEmpPrevisto,.T.,lSaldo)

					nProcura :=0
					nProcura :=aScan(aLotesFil,{|x| x[3] == (cAliasSBF)->BF_LOCALIZ .And. x[4] == (cAliasSBF)->BF_NUMSERI .And. x[7] == (cAliasSBF)->BF_LOCAL})
					nSaldSBf :=nSaldSBf -If(nProcura>0,aLotesFil[nProcura,5],0)
					nSaldSBf2:=nSaldSBf2-If(nProcura>0,aLotesFil[nProcura,6],0)

					nEmpenho := Min(If(lBaixaEmp,((cAliasSBF)->BF_EMPENHO+(nQtdeOri*nPercPrM)),nSaldSBf),nEmpenho)
					nEmpenho2:= nQtd2UM - nReserva2
					nEmpenho2:= Min(If(lBaixaEmp,((cAliasSBF)->BF_EMPEN2+(nQtdeOri*nPercPrM)),nSaldSBf2),nEmpenho2)
				EndIf
				lUtiliza :=.T.
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Qdo Usuario seleciona Lote manualmente, observar se utiliza registro   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If cPaisLoc == "ARG" .and. lSelLote
					If (Empty(SC6->C6_LOCALIZ) .or. Empty(SC6->C6_LOTECTL)) .and.;
						AllTrim(FunName()) $ "MATA440|MATA450|MATA456"
						lUtiliza := .F.
					EndIf
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Executa P.E. MTSLDLOT para verificar se utiliza registro               ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lRDSldPor
					lUtiliza:= ExecBlock("MTSLDLOT",.F.,.F.,{	(cAliasSBF)->BF_PRODUTO	,;
																(cAliasSBF)->BF_LOCAL	,;
																""						,;
																""						,;
																(cAliasSBF)->BF_LOCALIZ	,;
																(cAliasSBF)->BF_NUMSERI	,;
																nEmpenho				,;
																.F.						})
					If ValType(lUtiliza) != "L"
						lUtiliza :=.T.
					EndIf
				EndIf

				If lUtiliza
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Verifica se o lote deve ser considerado                                 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lInfoWms
						nProcura :=0
						nProcura :=aScan(aLotesFil,{|x| x[3] == (cAliasSBF)->BF_LOCALIZ .And. x[4] == (cAliasSBF)->BF_NUMSERI .And. x[7] == (cAliasSBF)->BF_LOCAL})
						nEmpenho :=nEmpenho -If(nProcura>0,aLotesFil[nProcura,5],0)
						nEmpenho2:=nEmpenho2-If(nProcura>0,aLotesFil[nProcura,6],0)
					EndIf

					If lQuantRet
						aQtdRdmake:=ExecBlock("MTRETLOT",.F.,.F.,{cCodPro,cLocal,nQtd,nQtd2UM,nEmpenho,nEmpenho2,NIL,NIL,(cAliasSBF)->BF_LOCALIZ,(cAliasSBF)->BF_NUMSERI})
						If Valtype(aQtdRdmake) == "A"
							If (Valtype(aQtdRdmake[1]) == "N") .And. (aQtdRdmake[1] <= nEmpenho) .And. (aQtdRdmake[1] >= 0)
								nEmpenho:=aQtdRdmake[1]
							EndIf
							If (Valtype(aQtdRdmake[2]) == "N") .And. (aQtdRdmake[2] <= nEmpenho2) .And. (aQtdRdmake[2] >= 0)
								nEmpenho2:=aQtdRdmake[2]
							EndIf
						EndIf
					EndIf

					nReserva  += nEmpenho
					nReserva2 += nEmpenho2

					If QtdComp(nEmpenho) > QtdComp(0) .Or. QtdComp(nEmpenho2) > QtdComp(0)
						AADD(aRetorno,{	""						,;
										""						,;
										(cAliasSBF)->BF_LOCALIZ	,;
										(cAliasSBF)->BF_NUMSERI	,;
										nEmpenho				,;
										nEmpenho2				,;
										Ctod("")				,;
										SB2->(Recno())			,;
										(cAliasSBF)->SBFRECNO   ,;
										{}						,;
										(cAliasSBF)->BF_LOCAL,0,(cAliasSBF)->BF_PRIOR})
					EndIf
				EndIf
			EndIf
		EndIf
		dbSelectArea(cAliasSBF)
		dbSkip()
		If ( nReserva >= nQtd )
			lContSBF:= .F.
		EndIf
	EndDo
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fecha query criada                                                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea(cAliasSBF)
	dbCloseArea()
	dbSelectArea("SBF")

	aInsert := aSize(aInsert,0)

EndIf

RestArea(aAreaSB1)
Return(aRetorno)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³GravaEmp  ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 18.03.99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Tratamento na geracao de empenhos                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³[1] Lote de Controle                                        ³±±
±±³          ³[2] Sub-Lote                                                ³±±
±±³          ³[3] Localizacao                                             ³±±
±±³          ³[4] Numero de Serie                                         ³±±
±±³          ³[5] Quantidade                                              ³±±
±±³          ³[6] Data de Validade                                        ³±±
±±³          ³[7] Registro do SB2                                         ³±±
±±³          ³[8] Registro do SBF                                         ³±±
±±³          ³[9] Array com Registros do SB8 e qtd                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC01: Codigo do Produto         - Obrigatorio             ³±±
±±³          ³ExpC02: Local                     - Obrigatorio             ³±±
±±³          ³ExpN01: Quantidade                - Obrigatorio             ³±±
±±³          ³ExpN02: Quantidade 2a UM          - Obrigatorio             ³±±
±±³          ³ExpC03: Lote de Controle          - Obrig. se Inf. Sub-Lote ³±±
±±³          ³ExpC04: Sub-Lote                                            ³±±
±±³          ³ExpC05: Localizacao                                         ³±±
±±³          ³ExpC06: Numero de Serie                                     ³±±
±±³          ³ExpC07: Ordem de Producao                                   ³±±
±±³          ³ExpC08: Sequencia do Empenho / Liberacao do Pedido de Venda ³±±
±±³          ³ExpC09: Pedido de Venda                                     ³±±
±±³          ³ExpC10: Item do Pedido de Venda                             ³±±
±±³          ³ExpC11: Origem do Empenho                                   ³±±
±±³          ³ExpC12: Op original                                         ³±±
±±³          ³ExpD01: Data de Entrega do Empenho                          ³±±
±±³          ³ExpA01: Array para o travamento dos saldos, caso nao seja   ³±±
±±³          ³       informado nao havera travamento.                     ³±±
±±³          ³ExpL01: Flag que indica se estorna empenho                  ³±±
±±³          ³ExpL02: Flag que indica se e chamada da Projecao de Estoques³±±
±±³          ³ExpL03: Flag que indica se empenha material do SB2          ³±±
±±³          ³ExpL04: Flag que indica se grava registro no SD4            ³±±
±±³          ³ExpL05: Flag que indica se considera Lotes Vencidos         ³±±
±±³          ³ExpL06: Flag que indica se empenha material no SB8/SBF      ³±±
±±³          ³ExpL07: Flag que indica se CRIA registros no SDC            ³±±
±±³          ³ExpL08: Flag que indica se encerra empenho de OP            ³±±
±±³          ³ExpC13: Identificador do DCF                                ³±±
±±³          ³ExpA02: Array de campos utilizados no ajuste de empenho SD4 ³±±
±±³          ³ExpN03: Posicao atual do elemento do array de campos        ³±±
±±³          ³ExpL09: Flag que indica se a OP esta Encerrada              ³±±
±±³          ³ExpC14: Tipo OP				                              ³±±
±±³          ³ExpC15: Codigo CAT 83			                              ³±±
±±³          ³ExpD02: Data de emissao		                              ³±±
±±³          ³ExpL10: Flag que indica se grava lote                       ³±±
±±³          ³ExpA03: Array com dados SDC	                              ³±±
±±³          ³ExpL11: Flag que indica se atualiza SBF                     ³±±
±±³          ³ExpN04: Quantidade da necessidade                           ³±±
±±³          ³ExpC16: Numero Sequencial relacionamento SDD X SDC          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GravaEmp(cProduto,cLocal,nQtd,nQtd2UM,cLoteCtl,cNumLote,cLocaliza,cNumSerie,cOp,cTrt,cPedido,cItem,cOrigem,cOpOrig,dEntrega,aTravas,lEstorno,lProj,lEmpSB2,lGravaSD4,lConsVenc,lEmpSB8SBF,lCriaSDC,lEncerrOp,cIdDCF,aSalvCols,nSG1,lOpEncer,cTpOp,cCAT83, dDtEmissao,lGravLote,aSDC,lAtusbf,nQtNeces,cIdSDD)
Local i           := 0
Local z           := 0
Local nBaixa      := 0
Local nQuant      := 0
Local cSeekLoc    := ""
Local cSeek       := ""
Local nBaixa2     := 0
Local nQuant2     := 0
Local nQtdLote    := 0
Local nQtSemLote  := 0
Local nQtdAtEmpN  := 0
Local nQtdDif     := 0
Local nForLote	  := 0
Local aSldLote	  := {}
Local aArea		  := GetArea()
Local aAreaSC2    := {}
Local aAreaSC6    := {}
Local lSelLote
Local lAtuSGJ
Local lACDSer
Local lIntACD
Local lWmsNew
Local aCampoEmp
Local lIntWMS     := .F.
Local lLocaliz    := .F.

Static nTDCPED    := Nil
Static lMvLotevenc:= Nil
Static lMtaltemp  := Nil
Static lMvlibacim := Nil
Static lMvgrvemp  := Nil

DEFAULT aSalvCols := {}
DEFAULT cIdDCF    := ''
DEFAULT lEncerrOp := .F.
DEFAULT nSG1      := 0
DEFAULT cTpOp     := "F"
DEFAULT lGravLote := .T.
DEFAULT aSDC := {}
DEFAULT lAtusbf   := .T. //Esta variável sempre será true menos quando essa função for chamada pelo mata380/mata381 na atualização dos empenhos gerados pelas ordens de produção
                      //Há casos em que o usuário informou lote/endereço de forma erronea na geração do empenho pelo mata650 e entrará no mata380/381 para excluir ou corrigí-los
DEFAULT nQtNeces := 0
DEFAULT cIdSDD   := ""

lSelLote   := (SuperGetMV("MV_SELLOTE") == "1")
lAtuSGJ    := SuperGetMV("MV_PVCOMOP",.F.,.F.)
lACDSer    := SuperGetMV("MV_SUBNSER",.F., '1' ) $ '2|3'
lIntACD    := SuperGetMV("MV_INTACD",.F.,"0") == "1"
lWmsNew    := SuperGetMV("MV_WMSNEW",.F.,.F.)

//Somente ler esses parâmetros uma única vez, para não afetar a performance, quando essa função for chamada dentro de um looping
If lMvlibacim == NIL
	lMvlibacim:= SuperGetMv("MV_LIBACIM")
Endif

If lMtaltemp == NIL
   lMtaltemp:= ExistBlock("MTALTEMP")
Endif

If lMvLotevenc ==  NIL
   lMvLotevenc:= (SuperGetMv('MV_LOTVENC')=='S')
Endif

If lMvgrvemp ==  NIL
   lMvgrvemp:= ExistBlock("MTGRVEMP")
Endif

//Ponto de entranda - Manipula informações para itens de empenho
If lMtaltemp
	aCampoEmp := ExecBlock("MTALTEMP",.F.,.F.,{cProduto,cLocal,nQtd,nQtd2UM,cLoteCtl,cNumLote,cLocaliza,cNumSerie,cOp,cTrt,cPedido,cItem,cOrigem,lEstorno,aSalvCols,nSG1})
	If ValType(aCampoEmp) = 'A'
		cProduto		:= aCampoEmp[1]
		cLocal			:= aCampoEmp[2]
		nQtd			:= aCampoEmp[3]
		nQtd2UM			:= aCampoEmp[4]
		cLoteCtl		:= aCampoEmp[5]
		cNumLote		:= aCampoEmp[6]
		cLocaliza		:= aCampoEmp[7]
		cNumSerie		:= aCampoEmp[8]
		cOp				:= aCampoEmp[9]
		cTrt			:= aCampoEmp[10]
		cPedido			:= aCampoEmp[11]
		cItem			:= aCampoEmp[12]
		cOrigem			:= aCampoEmp[13]
		lEstorno		:= aCampoEmp[14]
		aSalvCols		:= aCampoEmp[15]
		nSG1			:= aCampoEmp[16]
	EndIf
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Preenche parametros nao recebidos pela funcao         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lLocaliz   := Localiza(cProduto)
lIntWMS    := IF(__lIntWMS,IntWMS(cProduto),.F.)  //Esta atribuição deve vir sempre após a função localiza
lProj      := IF(lProj      == NIL, .F., lProj)
lEstorno   := IF(lEstorno   == NIL, .F., lEstorno)
lGravaSD4  := IF(lGravaSD4  == NIL, .F., lGravaSD4)
lEmpSB2    := IF(lEmpSB2    == NIL, .T., lEmpSB2)
lEmpSB8SBF := IF(lEmpSB8SBF == NIL, lEmpSB2, lEmpSB8SBF)
lCriaSDC   := IF(lCriaSDC   == NIL, If(lLocaliz, .T., .F.), lCriaSDC)
cPedido    := IF(cPedido    == NIL, CriaVar("DC_PEDIDO"), cPedido)
cOpOrig    := IF(cOpOrig    == NIL, CriaVar("D4_OPORIG"), cOpOrig)
cLoteCtl   := IF(cLoteCtl   == NIL, CriaVar("BF_LOTECTL"), cLoteCtl)
cNumLote   := IF(cNumLote   == NIL, CriaVar("BF_NUMLOTE", If(SuperGetMV('MV_LOTEUNI', .F., .F.), .F., Nil)),cNumLote)
cLocaliza  := IF(cLocaliza  == NIL, CriaVar("BF_LOCALIZ"), cLocaliza)
cNumSerie  := IF(cNumSerie  == NIL, CriaVar("BF_NUMSERI"), cNumSerie)
cOrigem    := IF(cOrigem    == NIL, CriaVar("DC_ORIGEM"), cOrigem)
cItem      := IF(cItem      == NIL, CriaVar("DC_ITEM"), cItem)
cTrt       := IF(cTrt       == NIL, If(lGravaSD4.And.Empty(cPedido),CriaVar("DC_TRT"),CriaVar("DC_SEQ")),cTrt)
cOp        := IF(cOp        == NIL, CriaVar("DC_OP"), cOp)
lConsVenc  := IF(lEstorno, .T., IF(lConsVenc == NIL,lMvLotevenc,lConsVenc))
nQtd2UM    := IF(nQtd2UM    == NIL, ConvUm(cProduto,nQtd,0,2), nQtd2UM)
lOpEncer   := IF(lOpEncer   == NIL, .F., lOpEncer)
lEncerrOp  := lEncerrOp .And. !Empty(cOP)
cCAT83     := IF(cCAT83     == NIL, "", cCAT83)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Caso nao exista as variaveis l380 e l381 |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type("l380") <> "L"
	l380 := .F.
EndIf

If Type("l381") <> "L"
	l381 := .F.
EndIf

if nTDCPED == NIL
	// se não posicionar o SX3 antes do TAMSX3 causa erro no recalculo
	// na subida da Thread de transferencia de filiais
	nTDCPED := GetSX3Cache('DC_PEDIDO','X3_TAMANHO')
EndIf

// Verifica tipo de empenho a ser atualizado
If !Empty(cOP)
	dbSelectArea("SC2")
	aAreaSC2:=GetArea()
	dbSetOrder(1)
	If dbSeek(xFilial()+cOP)
		cTpOp:=SC2->C2_TPOP
	EndIf
	RestArea(aAreaSC2)
EndIf

If !lEstorno
	//If               (Localiza(cProduto)  .And. (lCriaSDC .Or. !Empty(cLocaliza) .Or. !Empty(cNumSerie))) .Or. (Rastro(cProduto) .And. (!Empty(cLoteCtl) .Or. !Empty(cNumLote)))
	If lGravLote .And. (IIF(lWmsNew,Localiza(cProduto,.T.),lLocaliz) .And.  !(lWmsNew .And. lIntWms) .And. (lCriaSDC .Or. !Empty(cLocaliza) .Or. !Empty(cNumSerie))) .Or. (Rastro(cProduto) .And. (!Empty(cLoteCtl) .Or. !Empty(cNumLote)))
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Faz FIFO Lote/Sub-Lote/Localizacao/Numero de Serie    ³
		//³ caso seja digitado na OP pelo menos um dos quatro ou  ³
		//³ caso seja empenho que nao esteja amarrado ao SD4      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lIntACD .And. lACDSer .And. IsInCallStack("MaDelNFS")
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Ao realizar o processo de exclusão de nota de saida a ³
			//tabela SC9 estara posicionada                           ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aSldLote:= ACDCB9Ser(cProduto,cLocal,nQtd,nQtd2UM,cLoteCtl,cNumLote,cLocaliza,cNumSerie,lConsVenc,dDtEmissao,SC9->C9_ORDSEP,SC9->C9_PEDIDO,@aTravas)
		Else
			aSldLote:=SldPorLote(cProduto,cLocal,nQtd,nQtd2UM,cLoteCtl,cNumLote,cLocaliza,cNumSerie,@aTravas,NIL,NIL,lConsVenc, , cTpOp=="P",dDtEmissao)
		EndIF

		//Controle para empenhar a diferença de quando não há lote/end disponivel.
		nQtdLote := 0
		nQtSemLote := nQtd

		//soma a quantidade disponivel no lote/end.
		For nForLote := 1 to len(aSldLote)
			nQtdLote += aSldLote[nForLote,5]
		Next nForLote

		//Esse será o valor empenhado sem o consumo de empenho lote/end
		nQtSemLote := nQtSemLote - nQtdLote

		For i:=1 to Len(aSldLote)
			If lGravaSD4
				// Gera registro do empenho no SD4
				A650ReplD4(cProduto,cLocal,dEntrega,aSldLote[i,5],cOp,cTrt,aSldLote[i,2],aSldLote[i,1],aSldLote[i,7],cOpOrig,aSldLote[i,6],aSldLote[i,12],lOpEncer,cCAT83,aSalvCols,nSG1,nQtNeces)
			EndIf
			If lEmpSB2
				// Soma empenho no SB2
				dbSelectArea("SB2")
				MsGoto(aSldLote[i,8])
				GravaB2Emp("+",aSldLote[i,5],cTpOp,!Empty(cPedido).And.cOrigem!="SDD",aSldLote[i,6])
			EndIf
			// Caso utilize registros da Rastreabilidade soma empenho no SB8
			If lEmpSB8SBF
 					dbSelectArea("SB8")
					For z:=1 to Len(aSldLote[i,10])
						MsGoto(aSldLote[i,10,z,1])
						GravaB8Emp("+",aSldLote[i,10,z,2],cTpOp,!Empty(cPedido).And.cOrigem!="SDD",aSldLote[i,10,z,3])
					Next z

				// Caso utilize registros da Localizacao Fisica soma empenho no SBF
				If !(lWmsNew .And. lIntWMS)
					If aSldLote[i,9] > 0
						If lAtusbf == .T.
							dbSelectArea("SBF")
							MsGoto(aSldLote[i,9])
							GravaBFEmp("+",aSldLote[i,5],cTpOp,!Empty(cPedido).And.cOrigem!="SDD",aSldLote[i,6])
						Endif
						// Gera registro do empenho no SDC
						If lCriaSDC
							nQtdOrigDC := 0

							If (l380 .Or. l381) .And. Len(aSDC) > 0
								nQtdOrigDC := BuscaQTDOR(xFilial(),;
														cOrigem,;
														cProduto,;
														cLocal,;
														aSldLote[i,3],;
														aSldLote[i,4],;
														aSldLote[i,1],;
					                        			aSldLote[i,2],;
					                        			aSldLote[i,5],;
					                        			cOp,;
					                        			cTrt,;
					                        			cPedido,;
					                        			cItem,;
					                        			Min(SD4->D4_QTDEORI,aSldLote[i,5]),;
					                        			cTrt,;
					                        			ConvUM(SDC->DC_PRODUTO,aSldLote[i,5],aSldLote[i,6],2),;
					                        			cIdDCF,;
					                        			aSDC)
							Else
								If VerEmpSD4(xFilial('SD4'),cProduto,cOp,cTrt,aSldLote[i,1],aSldLote[i,2],cOrigem)
									nQtdOrigDC := aSldLote[i,5]
								Else	
									nQtdOrigDC := Min(SD4->D4_QTDEORI,aSldLote[i,5])
								EndIf 
							EndIF

							Reclock("SDC",.T.)
							Replace DC_FILIAL   With xFilial()
							Replace DC_ORIGEM   With cOrigem
							Replace DC_PRODUTO  With cProduto
							Replace DC_LOCAL    With cLocal
							Replace DC_LOTECTL  With aSldLote[i,1]
							If Rastro(cProduto,"S")
								Replace DC_NUMLOTE   With aSldLote[i,2]
							EndIf
							Replace DC_LOCALIZ  With aSldLote[i,3]
							Replace DC_NUMSERI  With aSldLote[i,4]
							Replace DC_QTDORIG  With nQtdOrigDC
							Replace DC_QUANT    With aSldLote[i,5]
							Replace DC_QTSEGUM  With ConvUM(SDC->DC_PRODUTO,aSldLote[i,5],aSldLote[i,6],2)
							Replace DC_OP       With cOp
							Replace DC_TRT      With cTrt
							Replace DC_IDSDD    With cIdSDD
							If !lGravaSD4 .And. !Empty(cPedido)
								Replace DC_PEDIDO  With cPedido
								Replace DC_ITEM    With cItem
								Replace DC_SEQ  With cTrt
							EndIf
							SDC->DC_IDDCF := cIdDCF
							MsUnlock()
						EndIf
					EndIf
				EndIf
			EndIf
		Next i
		If nQtSemLote > 0 .AND. lEmpSB2
			If !(SB2->(B2_FILIAL+B2_COD+B2_LOCAL) == xFilial("SB2")+cProduto+cLocal) 
				If !SB2->(DbSeek(xFilial("SB2")+cProduto+cLocal))
					CriaSB2(cProduto,cLocal)
				EndIf
			EndIf
			GravaB2Emp("+",nQtSemLote,cTpOp,!Empty(cPedido).And.cOrigem!="SDD",nQtd2UM)
		ElseIf nQtSemLote < 0 .AND. lEmpSB2
			If IsCompENeg(NIL,cProduto,cOp,.F.)
				GravaB2Pre("+",ABS(nQtSemLote),cTpOp)
			EndIf
		EndIf
	Else
		If lGravaSD4
			A650ReplD4(cProduto,cLocal,dEntrega,nQtd,cOp,cTrt,NIL,NIL,NIL,cOpOrig,nQtd2UM,NIL,lOpEncer,cCAT83,aSalvCols,nSG1,nQtNeces)
		EndIf
		If lEmpSB2
			dbSelectArea("SB2")
			If !(B2_FILIAL+B2_COD+B2_LOCAL == xFilial()+cProduto+cLocal)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Posiciona SB2                          ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !dbSeek(xFilial()+cProduto+cLocal)
					CriaSB2(cProduto,cLocal)
				EndIf
			EndIf
			If nQtd > 0
				GravaB2Emp("+",nQtd,cTpOp,!Empty(cPedido).And.cOrigem!="SDD",nQtd2UM)
				If SB2->B2_QEMPN > 0 .And. !Empty(cPedido) .And. cOrigem <> "SDD" .And. ( lAtuSGJ <> NIL .And. !lAtuSGJ )
					nQtdAtEmpN := nQtd
					If ! lMvlibacim
						dbSelectArea("SC6")
						aAreaSC6 := GetArea()
						dbSetOrder(1)
						MsSeek(xFilial("SC6")+cPedido+cItem+cProduto)
						nQtdDif := SC6->(C6_QTDVEN-C6_QTDENT) - nQtdAtEmpN
						// Indica liberacao acima do saldo do pedido e nao grava o excesso liberado em B2_QEMPN
						If QtdComp(nQtdDif) < QtdComp(0)
							nQtdAtEmpN += nQtdDif
						EndIf
						RestArea(aAreaSC6)
					EndIf
				Endif
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o B2_SALPED ou B2_SALPRE, somente se o produto ³
				//³ for negativo na estrutura. Caso nao tenha estrutura ou  ³
				//³ nao seja uma producao, nao executara a funcao GravaB2Pre³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If IsCompENeg(NIL,cProduto,cOp,.F.)
					GravaB2Pre("+",ABS(nQtd),cTpOp)
				EndIf
			EndIf
		EndIf
	EndIf
Else
	dbSelectArea("SB2")
	If !dbSeek(xFilial()+cProduto+cLocal)
		CriaSB2(cProduto,cLocal)
	EndIf
	If nQtd > 0
		If lEmpSB8SBF
			If Rastro(cProduto) .And. !Empty(cLoteCtl+cNumLote) .And. !(lLocaliz,.T.)
				aSldLote:=SldPorLote(cProduto,cLocal,nQtd,nQtd2UM,cLoteCtl,cNumLote,,,,If(cPaisLoc=="BRA",.T.,lEmpSB8SBF),NIL,lConsVenc,NIL,cTpOp=="P",dDtEmissao)
				nQtd:=0
				nQtd2UM:=0
				For i:=1 to Len(aSldLote)
					dbSelectArea("SB8")
					For z:=1 to Len(aSldLote[i,10])
						nQtd+=aSldLote[i,10,z,2]
						nQtd2UM+=aSldLote[i,10,z,3]
					Next z
				Next i
			EndIf
			If !Empty(cLoteCtl+cNumLote) .And. Rastro(cProduto,"S")
				dbSelectArea("SB8")
				dbSetOrder(2)
				cSeek:=xFilial()+cNumLote+cLoteCtl+cProduto+cLocal
				If	dbSeek(cSeek)
					GravaB8Emp("-",nQtd,cTpOp,!Empty(cPedido).And.cOrigem!="SDD",nQtd2UM)
				EndIf
			ElseIf !Empty(cLoteCtl) .And. Rastro(cProduto,"L")
				dbSelectArea("SB8")
				dbSetOrder(3)
				cSeek:=xFilial()+cProduto+cLocal+cLoteCtl
				dbSeek(cSeek)
				nQuant:=nQtd
				nQuant2:=nQtd2UM
				Do While !Eof() .And. B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL == cSeek .And. nQuant > 0
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Baixa o empenho que conseguir neste lote   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If cTpOp=="P"
						nBaixa:=Min(AvalQtdPre("SB8",1,NIL,NIL,.T.),nQuant)
						nBaixa2:=Min(AvalQtdPre("SB8",1,.T.,NIL,.T.),nQuant2)
					Else
						nBaixa:=Min(B8_EMPENHO,nQuant)
						nBaixa2:=Min(B8_EMPENH2,nQuant2)
					EndIf
					nQuant-=nBaixa
					nQuant2-=nBaixa2
					GravaB8Emp("-",nBaixa,cTpOp,!Empty(cPedido).And.cOrigem!="SDD",nBaixa2)
					dbSkip()
				EndDo
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Tratamento referente a localizacao fisica  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If IIF(lWmsNew,Localiza(cProduto,.T.),lLocaliz) .And. lCriaSDC
				dbSelectArea("SDC")
				If !lGravaSD4
					dbSetOrder(1)
					cComparaLoc:="DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_ORIGEM+DC_PEDIDO+DC_ITEM+DC_SEQ+DC_LOTECTL+DC_NUMLOTE"
					cSeekLoc:=xFilial()+cProduto+cLocal+cOrigem+Padr(cPedido,nTDCPED)+cItem+cTrt+cLoteCtl+cNumLote
					If lSelLote
						cComparaLoc:="DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_ORIGEM+DC_PEDIDO+DC_ITEM+DC_SEQ+DC_LOTECTL"
						cSeekLoc:=xFilial()+cProduto+cLocal+cOrigem+Padr(cPedido,nTDCPED)+cItem+cTrt+cLoteCtl
					EndIf
				Else
					dbSetOrder(2)
					cComparaLoc:="DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL+DC_NUMLOTE"
					cSeekLoc:=xFilial()+cProduto+cLocal+cOp+cTrt+cLoteCtl+cNumLote
					If lSelLote
						cComparaLoc:="DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL"
						cSeekLoc:=xFilial()+cProduto+cLocal+cOp+cTrt+cLoteCtl
					EndIf
				EndIf
				dbSeek(cSeekLoc)
				nQuant:=nQtd
				nQuant2:=nQtd2UM
				Do While !Eof() .And. &cComparaLoc == cSeekLoc .And. nQuant > 0

					// Tratamento para nao liberar saldo do registro errado
					If SDC->DC_ORIGEM == "SDD"
						If !Empty(cIdSDD) .And. !Empty(SDC->DC_IDSDD)
							If AllTrim(cIdSDD) <> AllTrim(SDC->DC_IDSDD)
								dbSkip()
								Loop
							EndIf
						ElseIf Len(AllTrim(SDD->DD_DOC)) == Len(AllTrim(SDC->DC_PEDIDO))
							If AllTrim(SDD->DD_DOC) <> AllTrim(SDC->DC_PEDIDO)
								dbSkip()
								Loop
							EndIf
						EndIf
					EndIf

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Limpa Registros com qtd zerada para comp. versoes ant.³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If (QtdComp(SDC->DC_QUANT) <= QtdComp(0)) .And. SDC->DC_ORIGEM $ "SC6/SL2"
						RecLock("SDC",.F.,.T.)
						dbDelete()
						MsUnLock()
						dbSkip()
						Loop
					EndIf
					nBaixa:=Min(nQuant,SDC->DC_QUANT)
					nBaixa2:=Min(nQuant2,SDC->DC_QTSEGUM)
					nQuant-=nBaixa
					nQuant2-=nBaixa2
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Retira empenho do SBF                                  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !(lWmsNew .And. lIntWMS)
						dbSelectArea("SBF")
						dbSetOrder(1)
						If dbSeek(xFilial()+SDC->DC_LOCAL+SDC->DC_LOCALIZ+SDC->DC_PRODUTO+SDC->DC_NUMSERI+SDC->DC_LOTECTL+SDC->DC_NUMLOTE)
							GravaBFEmp("-",nBaixa,cTpOp,!Empty(cPedido).And.cOrigem!="SDD",nBaixa2)
						EndIf
					EndIf

					dbSelectArea("SDC")
					If If(lEncerrOp,(nBaixa <= SDC->DC_QUANT),(nBaixa < SDC->DC_QUANT))
						RecLock("SDC",.F.)
						Replace DC_QUANT With SDC->DC_QUANT - nBaixa
						Replace DC_QTSEGUM With ConvUM(SDC->DC_PRODUTO, SDC->DC_QUANT - nBaixa, 0, 2)
					ElseIf !lEncerrOp
						RecLock("SDC",.F.,.T.)
						dbDelete()
					EndIf
					MsUnLock()
					dbSkip()
				EndDo
			EndIf
		EndIf
		If lEmpSB2
			GravaB2Emp("-",nQtd,cTpOp,!Empty(cPedido).And.cOrigem!="SDD",nQtd2UM)
		EndIf
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o B2_SALPED ou B2_SALPRE, somente se o produto ³
		//³ for negativo na estrutura. Caso nao tenha estrutura ou  ³
		//³ nao seja uma producao, nao executara a funcao GravaB2Pre³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If IsCompENeg(NIL,cProduto,cOp,.F.)
			GravaB2Pre("-",ABS(nQtd),cTpOp)
		EndIf
	EndIf
EndIf

If lMvgrvemp
	ExecBlock("MTGRVEMP",.F.,.F.,{cProduto,cLocal,nQtd,nQtd2UM,cLoteCtl,cNumLote,cLocaliza,cNumSerie,cOp,cTrt,cPedido,cItem,cOrigem,lEstorno,aSalvCols,nSG1})
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Remove travas dos registros utilizados                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
MaDesTrava(aTravas)
RestArea(aArea)
Return aSldLote

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³BuscaQTDOR  ³ Autor ³Michele Girardi       ³ Data ³ 26/12/16³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Buscar a quantidade oridem da SDC                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGACUSB - mata380 - mata381                               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
 Function BuscaQTDOR(cFilDC, cOrigDC, cProdDC, cLocalDC, cEndDC, cSerieDC, cLotCtlDC, CLoteDC, nQuantDC,;
 					cOpDC, cTrtDC, cPedidoDC, cItemDC, nQOrigDC, cSeqDC, nQtdSUMDC, cIdDCFDC, aSDC)

 Local nFor    := 0
 Local lAchou  := .F.
 Local nRetQtd := 0
 Local nQtdNew := 0
 Local nDifQtd := 0

  For nFor:=1 to Len(aSDC)
  	If aSDC[nFor,1] == cFilDC     .And. ;
  		aSDC[nFor,2] == cOrigDC   .And. ;
  		aSDC[nFor,3] == cProdDC   .And. ;
  		aSDC[nFor,4] == cLocalDC  .And. ;
  		aSDC[nFor,5] == cEndDC    .And. ;
  		aSDC[nFor,6] == cSerieDC  .And. ;
  		aSDC[nFor,7] == cLotCtlDC .And. ;
  		aSDC[nFor,8] == CLoteDC   .And. ;
  		aSDC[nFor,10] == cOpDC    .And. ;
  		aSDC[nFor,11] == cTrtDC   .And. ;
  		aSDC[nFor,13] == cItemDC

		//diminuiu a quantidade
		If aSDC[nFor,9] > nQuantDC
			nDifQtd := aSDC[nFor,9] - nQuantDC //qtd anterior - qtd atual
			nQtdNew := aSDC[nFor,14] - nDifQtd //qtd origem anterior - diferenca
		Else
			//aumentou a quantidade
			If aSDC[nFor,9] < nQuantDC
				nDifQtd := nQuantDC - aSDC[nFor,9] //qtd atual - qtd anterior
				nQtdNew := aSDC[nFor,14] + nDifQtd //qtd origem anterior + diferenca
			Else
				nQtdNew := aSDC[nFor,14]
			EndIf
		EndIf

  	 	lAchou := .T.
  	 	Exit
  	 EndIf
  Next nFor

  If lAchou
  	nRetQtd := nQtdNew
  Else
  	nRetQtd := nQOrigDC
  EndIf

 Return nRetQtd

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ A650ReplD4   ³Autor ³Rodrigo de A. Sartorio³Data³ 08/03/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava registros de empenho (SD4)                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do Produto                                  ³±±
±±³          ³ ExpC2 = Local do Empenho                                   ³±±
±±³          ³ ExpD1 = Data do Empenho                                    ³±±
±±³          ³ ExpN1 = Quantidade do Empenho                              ³±±
±±³          ³ ExpC3 = Ordem de Producao                                  ³±±
±±³          ³ ExpC4 = Sequencia da OP                                    ³±±
±±³          ³ ExpC5 = Sub-Lote do empenho                                ³±±
±±³          ³ ExpC6 = Lote do empenho                                    ³±±
±±³          ³ ExpD2 = Data de validade do Lote                           ³±±
±±³          ³ ExpC7 = OP origem do produto                               ³±±
±±³          ³ ExpN2 = Quantidade do Empenho 2a UM                        ³±±
±±³          ³ ExpN3 = Potencia do Lote utilizado                         ³±±
±±³          ³ ExpL1 = Flag que indica se a OP esta Encerrada             ³±±
±±³          ³ ExpC8 = Código CAT 83		                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function A650ReplD4(cProduto,cLocal,dEntrega,nQuantItem,cOp,cTrt,cNumLote,cLoteCtl,dDtValid,cOpOrig,nQuant2UM,nPotencia,lOpEncer,cCAT83,aSalvCols,nSG1,nQtNeces)

Local cAliasSD4	:= ""
Local cQuery	:= ""
Local lFoundSD4	:= .T.
Local lGravaSD4 := ExistBlock("MTAGRSD4")
Local cPai      := ''
Local cRoteiro  := ''
Local cOperac   := ''
local lmta650ac := ExistBlock('MTA650AC')
Local aField 	:= {}
Local nPosCampo := 0

DEFAULT aSalvCols := {}
DEFAULT nSG1      := 0
DEFAULT nQtNeces  := 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Preenche parametros nao recebidos pela funcao         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cLoteCtl :=IF(cLoteCtl==NIL,CriaVar("D4_LOTECTL"),cLoteCtl)
cNumLote :=IF(cNumLote==NIL,CriaVar("D4_NUMLOTE", If(SuperGetMV('MV_LOTEUNI', .F., .F.), .F., Nil)),cNumLote)
dDtValid :=IF(dDtValid==NIL,CriaVar("D4_DTVALID"),dDtValid)
nQuant2UM:=IF(nQuant2UM==NIL,0,nQuant2UM)
nPotencia:=IF(nPotencia==NIL,0,nPotencia)
lOpEncer :=IF(lOpEncer==NIL,.F.,lOpEncer)

dbSelectArea("SD4")
dbSetOrder(1)
lFoundSD4 := (dbSeek(xFilial()+cProduto+cOp+cTrt+cLoteCtl+cNumLote))
If lFoundSD4
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona o empenho correto, considerando OP origem   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cAliasSD4 := GetNextAlias()

		cQuery := "SELECT SD4.R_E_C_N_O_ SD4RECNO "
		cQuery += "FROM "+RetSqlName("SD4")+" SD4 "
		cQuery += "WHERE SD4.D4_FILIAL='"+xFilial("SD4")+"' AND "
		cQuery += "SD4.D4_COD = '"+cProduto+"' AND "
		cQuery += "SD4.D4_OP = '"+cOp+"' AND "
		cQuery += "SD4.D4_TRT = '"+cTrt+"' AND "
		cQuery += "SD4.D4_LOTECTL = '"+cLoteCtl+"' AND "
		cQuery += "SD4.D4_NUMLOTE = '"+cNumLote+"' AND "
		cQuery += "SD4.D4_OPORIG = '"+cOpOrig+"' AND "
		cQuery += "SD4.D4_LOCAL = '"+cLocal+"' AND "
		cQuery += "SD4.D_E_L_E_T_=' ' "

		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSD4,.T.,.T.)

		lFoundSD4 := !(cAliasSD4)->(Eof())

		dbSelectArea("SD4")
		If lFoundSD4
			MsGoTo((cAliasSD4)->SD4RECNO)
    	EndIf
		(cAliasSD4)->( dbCloseArea() )
EndIf

if SD4->(FieldPos('D4_ROTEIRO')) > 0
   cPai     := POSICIONE('SC2',1,xFilial('SC2')+cOp,'C2_PRODUTO')
   cRoteiro := POSICIONE('SC2',1,xFilial('SC2')+cOp,'C2_ROTEIRO')

   If Empty(cRoteiro)
      cRoteiro := POSICIONE('SB1',1,xFilial('SB1')+cPai,'B1_OPERPAD')

      if Empty(cRoteiro)
         cRoteiro := '01'
      Endif
   Endif
   If Len(aSalvCols) > 0 .And. nSG1 > 0 .And. Type("nPosOper") == "N" .And. nPosOper > 0
      cOperac := aSalvCols[nSG1,nPosOper]
   Else
      dbSelectArea("SGF")
      SGF->(dbSetOrder(2))
      If SGF->(dbSeek(xFilial("SGF") + cPai + cRoteiro + cProduto + cTrt))
         cOperac := SGF->GF_OPERAC
      Endif
   EndIf
Endif

RecLock( "SD4", !lFoundSD4 )

Replace D4_FILIAL  With xFilial()
Replace D4_DATA    With dEntrega
Replace D4_COD     With cProduto
Replace D4_LOCAL   With cLocal
Replace D4_QUANT   With D4_QUANT+nQuantItem
Replace D4_QTDEORI With D4_QTDEORI+IIf(lOpEncer,0,nQuantItem)
Replace D4_OP      With cOp
Replace D4_TRT 	   With cTrt
Replace D4_NUMLOTE With cNumLote
Replace D4_LOTECTL With cLoteCtl
Replace D4_DTVALID With dDtValid
Replace D4_QTSEGUM With D4_QTSEGUM+ConvUm(cProduto,nQuantItem,nQuant2UM,2)
Replace D4_OPORIG  With cOpOrig
Replace D4_POTENCI With nPotencia

if SD4->(FieldPos('D4_ROTEIRO')) > 0
	Replace D4_PRODUTO With cPai
	Replace D4_ROTEIRO With cRoteiro
	If Empty(D4_OPERAC)
		Replace D4_OPERAC  With cOperac
	EndIf
Endif

If Len(aSalvCols) > 0 .And. nSG1 > 0 .And. Type("nPosPrdOrg") == "N" .And. nPosPrdOrg > 0
	Replace D4_PRDORG With aSalvCols[nSG1,nPosPrdOrg]
EndIf
If SD4->(FieldPos('D4_QTNECES')) > 0
	Replace D4_QTNECES With nQtNeces
EndIf

//Ponto de entrada para incluir campo na Ordem de Producao, Apenas 1 campo
IF lmta650ac
	aField := ExecBlock("MTA650AC",.F.,.F.)
	IF ValType(aField) ==  "A" .and.LEN(aField) > 0 .AND. Len(aSalvCols) > 0 .And. nSG1 > 0
		nPosCampo  := aScan(aHeader,{|x| Upper(Alltrim(x[2])) == aField[1][2]})
		If nPosCampo > 0
			If ValType(&("SD4->"+ALLTRIM(aField[1][2]))) == ValType(aSalvCols[nSG1,nPosCampo])
				Replace &("SD4->"+ALLTRIM(aField[1][2])) With aSalvCols[nSG1,nPosCampo]
			EndIf
		EndIf
	EndIF
Endif

If lGravaSD4
	ExecBlock("MTAGRSD4",.F.,.F.)
EndIf
MsUnlock()
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GravaB2Pre³ Autor ³Rodrigo de A. Sartorio ³ Data ³21/01/1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Funcao para atualizacao dos campos B2_SALPEDI / B2_SALPPRE ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ GravaB2Pre(ExpC1,ExpN1,ExpC2)                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Sinal da Opera‡„o  ("+" ou "-")                    ³±±
±±³          ³ ExpN1 = Quantidade da Operacao                             ³±±
±±³          ³ ExpC2 = Tipo da OP/SC                                      ³±±
±±³          ³ Expn2 = Quantidade da Operacao na 2a UM                    ³±±
±±³          ³ Expl1 = Mantem nQtSeg recebido quando <> NIL               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Mata650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GravaB2Pre(cSinal,nQuant,cTpOp,nQtSeg,lMantem2UM)
Local aArea		:= GetArea()
Local nMultiplic:=iIf(cSinal == "-",-1,1)

Default lMantem2UM := .F.

nQuant := iIf(nQuant < 0, 0, nQuant)
nQtSeg := iIf(nQtSeg == Nil, 0, nQtSeg)
cTpOp  := iIf(cTpOp  == NIL, SC2->C2_TPOP, cTpOp)
If lMantem2UM
	nQtSeg := iIf(nQtSeg == NIL, ConvUm(SB2->B2_COD,nQuant,0,2), nQtSeg)
Else
	nQtSeg := ConvUm(SB2->B2_COD,nQuant,nQtSeg,2)
EndIf

Reclock("SB2",.F.)
If cTpOp == "P" // OP PREVISTA

	Replace B2_SALPPRE With B2_SALPPRE+(nQuant*nMultiplic)

ElseIf cTpOp $ " F"	// OP FIRME

	Replace B2_SALPEDI With B2_SALPEDI+(nQuant*nMultiplic)
	Replace B2_SALPED2 With B2_SALPED2+(nQtSeg*nMultiplic)
EndIf

MsUnlock()

RestArea(aArea)

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GravaB2Emp³ Autor ³Rodrigo de A. Sartorio ³ Data ³21/01/1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Funcao para atualizacao dos campos B2_QEMP / B2_QEMPPRE    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ GravaB2Emp(ExpC1,ExpN1,ExpC2,ExpL1)                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Sinal da Opera‡„o  ("+" ou "-")                    ³±±
±±³          ³ ExpN1 = Quantidade da Operacao                             ³±±
±±³          ³ ExpC2 = Tipo da OP/SC                                      ³±±
±±³          ³ ExpL1 = Caso grave pedido de venda                         ³±±
±±³          ³ ExpN2 = Quantidade da Operacao 2a UM                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Mata650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GravaB2Emp(cSinal,nQuant,cTpOp,lPedido,nQuant2)
Local nMultiplic:=If(cSinal == "-",-1,1)

Static lB2_DMOV
Static lB2_HMOV

lB2_DMOV := If(lB2_DMOV== NIL, SB2->(ColumnPos("B2_DMOV")) > 0, lB2_DMOV)
lB2_HMOV := If(lB2_HMOV== NIL, SB2->(ColumnPos("B2_HMOV")) > 0, lB2_HMOV)

cTpOp  :=IF(cTpOp==NIL,SC2->C2_TPOP,cTpOp)
lPedido:=IF(lPedido==NIL,.F.,lPedido)
nQuant2:=IF(nQuant2==NIL, ConvUm(SB2->B2_COD, nQuant, 0, 2), nQuant2)
Reclock("SB2",.F.)
If lPedido
	Replace B2_RESERVA With Max(0,B2_RESERVA+(nQuant *nMultiplic))
	Replace B2_RESERV2 With Max(0,B2_RESERV2+(nQuant2*nMultiplic))
Else
	If cTpOp == "P"	// OP PREVISTA
		Replace B2_QEMPPRE With B2_QEMPPRE+(nQuant *nMultiplic)
		Replace B2_QEPRE2  With B2_QEPRE2 +(nQuant2*nMultiplic)
	ElseIf cTpOp $ " F"	// OP FIRME
		Replace B2_QEMP  With B2_QEMP +(nQuant *nMultiplic)
		Replace B2_QEMP2 With B2_QEMP2+(nQuant2*nMultiplic)
	EndIf
EndIf

If lB2_DMOV
	REPLACE	B2_DMOV WITH dDataBase
EndIf

If lB2_HMOV
	REPLACE	B2_HMOV WITH Time()
EndIf

MsUnlock()
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GravaB8Emp³ Autor ³Rodrigo de A. Sartorio ³ Data ³21/01/1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Funcao para atualizacao dos campos B8_EMPENHO / B8_QEMPPRE ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ GravaB8Emp(ExpC1,ExpN1,ExpC2)                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Sinal da Opera‡„o  ("+" ou "-")                    ³±±
±±³          ³ ExpN1 = Quantidade da Operacao                             ³±±
±±³          ³ ExpC2 = Tipo da OP/SC                                      ³±±
±±³          ³ ExpL1 = Caso grave pedido de venda                         ³±±
±±³          ³ ExpN2 = Quantidade da Operacao 2a UM                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Mata650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GravaB8Emp(cSinal,nQuant,cTpOp,lPedido,nQuant2)
Local nMultiplic:=If(cSinal == "-",-1,1)
cTpOp  :=IF(cTpOp==NIL,SC2->C2_TPOP,cTpOp)
lPedido:=IF(lPedido==NIL,.F.,lPedido)
nQuant2:=IF(nQuant2==NIL, ConvUm(SB8->B8_PRODUTO, nQuant, 0, 2), nQuant2)
Reclock("SB8",.F.)
If cTpOp $ " F" .Or. lPedido	// OP FIRME OU PEDIDO DE VENDAS
	Replace B8_EMPENHO With Max(0,B8_EMPENHO+(nQuant *nMultiplic))
	Replace B8_EMPENH2 With Max(0,B8_EMPENH2+(nQuant2*nMultiplic))
ElseIf cTpOp == "P"	// OP PREVISTA
	Replace B8_QEMPPRE With B8_QEMPPRE+(nQuant *nMultiplic)
	Replace B8_QEPRE2  With B8_QEPRE2 +(nQuant2*nMultiplic)
EndIf
If ExistBlock("MTGRVLOT")
	ExecBlock("MTGRVLOT",.F.,.F.,{cSinal,nQuant,cTpOp,lPedido,nQuant2})
EndIf
MsUnlock()
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GravaBFEmp³ Autor ³Rodrigo de A. Sartorio ³ Data ³27/01/1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Funcao para atualizacao dos campos BF_EMPENHO / BF_QEMPPRE ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ GravaBFEmp(ExpC1,ExpN1,ExpC2)                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Sinal da Opera‡„o  ("+" ou "-")                    ³±±
±±³          ³ ExpN1 = Quantidade da Operacao                             ³±±
±±³          ³ ExpC2 = Tipo da OP/SC                                      ³±±
±±³          ³ ExpL1 = Caso grave pedido de venda                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Mata650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GravaBFEmp(cSinal,nQuant,cTpOp,lPedido,nQuant2)
Local nMultiplic:=If(cSinal == "-",-1,1)
cTpOp:=IF(cTpOp==NIL,SC2->C2_TPOP,cTpOp)
lPedido:=IF(lPedido==NIL,.F.,lPedido)
nQuant2:=IF(nQuant2==NIL, ConvUm(SBF->BF_PRODUTO, nQuant, 0, 2), nQuant2)
Reclock("SBF",.F.)
If cTpOp $ " F" .Or. lPedido	// OP FIRME OU PEDIDO DE VENDAS
	Replace BF_EMPENHO With Max(0,BF_EMPENHO+(nQuant *nMultiplic))
	Replace BF_EMPEN2  With Max(0,BF_EMPEN2 +(nQuant2*nMultiplic))
ElseIf cTpOp == "P"	// OP PREVISTA
	Replace BF_QEMPPRE With BF_QEMPPRE+(nQuant *nMultiplic)
	Replace BF_QEPRE2  With BF_QEPRE2 +(nQuant2*nMultiplic)
EndIf
MsUnlock()
SBF->(dbCommit())
Return

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ ProcSDD  ³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 27/11/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Processa gravacao p/ bloquear lote                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ProcSDD(ExpL1)                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpL1 = Flag que indica se libera (.T.) ou bloqueia (.F.)  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Bloqueio Lotes/Sub-Lotes                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function ProcSDD(lLibera)
Local aTravas    := {}
Local aAreaSB8   := SB8->(GetArea())
Local aAreaSBF   := SBF->(GetArea())
Local aAreaAnt   := GetArea()
Local aAreaSDD   := SDD->(GetArea())
Local nQuantLib  := SDD->DD_QUANT
Local nQuantLib2 := SDD->DD_QTSEGUM
Local nSaldoAtu  := (SDD->DD_SALDO-SDD->DD_QUANT)
Local nSaldoAtu2 := (SDD->DD_SALDO2-SDD->DD_QTSEGUM)
Local lEmpPrev	 := .F.
Local nTipoData  := 0
Local dDataRef   := Nil

Static lMtProcSdd
If lMtProcSdd == Nil
	lMtProcSdd := Existblock("MPROCSDD")
Endif

//-- Atualiza o Saldo com base na Quantidade Liberada
If lLibera
	RecLock('SDD', .F.)
	Replace DD_SALDO   With nSaldoAtu
	Replace DD_QUANT   With nSaldoAtu
	Replace DD_QTSEGUM With ConvUm(DD_PRODUTO,nSaldoAtu,nSaldoAtu2,2)   // Qtde. da 2a. UM
	Replace DD_SALDO2  With ConvUm(DD_PRODUTO,nSaldoAtu,nSaldoAtu2,2)    // Saldo da 2a. UM
	MsUnlock()
Else
	dbSelectArea('SDD')
	//Deve empenhar somente o saldo do endereço/numero de serie
	If FwIsInCallStack('MATA265') 
		lEmpPrev := SuperGetMV("MV_QTDPREV",.F.,'N') == "S"
		If !Empty(SDD->DD_LOCALIZ) .Or. !Empty(SDD->DD_NUMSERI)
			nTipoData  := SuperGetMV("MV_TDATALO",.F.,1)
			dDataRef   := If(nTipoData==1,dDataBase,Date())
			nQuantLib  := SB8SBFSld(SDD->DD_PRODUTO, SDD->DD_LOCAL, SDD->DD_LOTECTL, SDD->DD_NUMLOTE, SDD->DD_LOCALIZ, SDD->DD_NUMSERI, .F., lEmpPrev, dDataRef)
			nQuantLib2 := SB8SBFSld(SDD->DD_PRODUTO, SDD->DD_LOCAL, SDD->DD_LOTECTL, SDD->DD_NUMLOTE, SDD->DD_LOCALIZ, SDD->DD_NUMSERI, .T., lEmpPrev, dDataRef)
		Else
			SB8->(DbSetOrder(1)) //B8_FILIAL+B8_PRODUTO+B8_LOCAL+DTOS(B8_DTVALID)+B8_LOTECTL+B8_NUMLOTE
			SB8->(DbSeek(FWXFilial('SB8')+SDD->(DD_PRODUTO+DD_LOCAL+DTOS(DD_DTVALID)+DD_LOTECTL+DD_NUMLOTE)))
			nQuantLib  := SB8Saldo(.F.,.T.,NIL,,,lEmpPrev)
			nQuantLib2 := SB8Saldo(.F.,.T.,NIL,.T.,,lEmpPrev)
		EndIf
	EndIf
EndIf
If lMtProcSdd
	ExecBlock("MPROCSDD",.F.,.F.,{lLibera})
Endif
//-- Atualiza os arquivos de Saldos por Lote, Localizacao e Saldos em Estoque
GravaEmp(DD_PRODUTO,;  //-- 01.C¢digo do Produto
	DD_LOCAL,;    //-- 02.Local
	nQuantLib,;   //-- 03.Quantidade
	nQuantLib2,;  //-- 04.Quantidade
	DD_LOTECTL,;  //-- 05.Lote
	DD_NUMLOTE,;  //-- 06.SubLote
	DD_LOCALIZ,;  //-- 07.Localiza‡Æo
	DD_NUMSERI,; //-- 08.Numero de S‚rie
	Nil,;         //-- 09.OP
	Nil,;         //-- 10.Seq. do Empenho/Libera‡Æo do PV (Pedido de Venda)
	DD_DOC,;      //-- 11.PV
	NIL,;         //-- 12.Item do PV
	'SDD',;       //-- 13.Origem do Empenho
	Nil,;         //-- 14.OP Original
	Nil,;         //-- 15.Data da Entrega do Empenho
	@aTravas,;    //-- 16.Array para Travamento de arquivos
	lLibera,;     //-- 17.Estorna Empenho?
	Nil,;         //-- 18.chamada da Projecao de Estoques?
	.T.,;         //-- 19.Empenha no SB2?
	.F.,;         //-- 20.Grava SD4?
	.T.,;         //-- 21.Considera Lotes Vencidos?
	.T.,;         //-- 22.Empenha no SB8/SBF?
	Nil,;         //-- 23.Cria SDC?
	Nil,;         //-- 24.Encerra empenho de OP?
	Nil,;         //-- 25.Identificador do DCF
	Nil,;         //-- 26.Array campos ajuste empenho SD4
	Nil,;         //-- 27.Pos.atual no array de campos
	Nil,;         //-- 28.OP Encerrada?
	Nil,;         //-- 29.Tipo OP
	Nil,;         //-- 30.Cod.CAT83
	Nil,;         //-- 31.Dt.Emissao
	Nil,;         //-- 32.Grava lote?
	Nil,;         //-- 33.Array com dados SDC
	Nil,;         //-- 34.Atualiza SBF?
	Nil,;         //-- 35.Qtd.Necessidade
	DD_IDSDD)     //-- 36.Num.Sequencial SDD

//-- Destrava os Registros Utilizados
MaDestrava(aTravas)
RestArea(aAreaSDD)
SB8->(RestArea(aAreaSB8))
SBF->(RestArea(aAreaSBF))
RestArea(aAreaAnt)
Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GravaSc7  ³ Autor ³ Wagner Xavier         ³ Data ³ 15.03.99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Grava Pedido de Compras - Integracao SIGAEIC                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programar ³ Data   ³ BOPS ³  Motivo da Alteracao                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GravaSc7(nOpcao,cCodProd,nQuant,nPreco,cNumPed,cLocal,cCusto,cFornece,cLoja,dEmissao,cNumSc,dDataPr,cItem,cSequen,cObserv,cOrigem,cItemSc,nQtSegum,cSegum,nMoeda,cFluxo,nTaxa,cNumPo,cAprov, cConapro, nDespesa , nDesconto)

Return GravaSC7A(nOpcao,cCodProd,nQuant,nPreco,cNumPed,cLocal,cCusto,cFornece,cLoja,dEmissao,cNumSc,dDataPr,cItem,cSequen,cObserv,cOrigem,cItemSc,nQtSegum,cSegum,nMoeda,cFluxo,nTaxa,cNumPo,cAprov, cConapro, nDespesa , nDesconto)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³FA430Process³ Autor ³ Eduardo Riera         ³ Data ³28/11/95³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Depura as reservas                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA430                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Guilherme   ³10/07/07³128865³Inclusao do Parametro lBatch, para execu- ³±±
±±³Santos      ³        ³      ³cao via Job.                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function FA430Process(lEnd, cAlias, lBatch)
Local cNumSL2	:= ""			// Numero do Orcamento do Loja
Local cFilRes   := ""           // Filial de Solic da Reserva

DEFAULT lBatch := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variaveis utilizadas para desenhar cursor                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If !lBatch
	ProcRegua(RecCount(),18,4)
EndIf

GetMv("MV_ULRESER")
dbSelectArea("SX6")
If ( Found() )
	PutMv("MV_ULRESER",Dtoc(dDataBase))
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Utiliza arquivo de liberados para geracao na nota      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea(cAlias)
dbSetOrder(1)
dbSeek(xFilial())
While !Eof() .And. xFilial() == C0_FILIAL

	If !lBatch
		IncProc(18,4)
	EndIf

	If ( (dDataBase > SC0->C0_VALIDA ) .And. ( SC0->C0_QUANT == SC0->C0_QTDORIG .OR. SC0->C0_TIPO == "LJ" ) )
		Begin Transaction

	  		cFilRes := SC0->C0_FILRES
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica se a reserva foi feita pelo SigaLoja³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SC0->C0_TIPO == "LJ"
				Reclock( "SC0", .F. )
				SC0->C0_QUANT := SC0->C0_QTDORIG
				SC0->( MsUnlock() )

				SL2->( DbSetOrder( 5 ) )
				If SL2->( MsSeek ( cFilRes + SC0->C0_NUM ) )
					cNumSL2 := SL2->L2_NUM

					While SL2->( !Eof() ) .AND. SL2->L2_RESERVA == SC0->C0_NUM
						Reclock( "SL2", .F.)
						SL2->L2_RESERVA	:= ""
						SL2->L2_LOJARES	:= ""
						SL2->( MsUnlock() )
						SL2->( DbSkip() )
					End

					SL1->( DbSetOrder( 1 ) )
					If SL1->( MsSeek ( cFilRes + cNumSL2 ) )
						Reclock( "SL1", .F.)
						SL1->L1_RESERVA := ""
						SL1->( MsUnlock() )
					Endif
				Endif
			Endif

			a430Reserv({3,SC0->C0_TIPO,SC0->C0_DOCRES,SC0->C0_SOLICIT,SC0->C0_FILRES},;
				SC0->C0_NUM,;
				SC0->C0_PRODUTO,;
				SC0->C0_LOCAL,;
				SC0->C0_QUANT,;
				{	SC0->C0_NUMLOTE,;
				SC0->C0_LOTECTL,;
				SC0->C0_LOCALIZ,;
				SC0->C0_NUMSERI})

		End Transaction
	Endif

	dbSelectArea("SC0")
	dbSkip()
EndDo
Return .T.


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ A430Auto ³ Autor ³ Eduardo Riera         ³ Data ³ 10/03/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Depura automaticamente o arquivo de reservas p/faturamento ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A430Auto( Void )                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
/*/
Function a430Auto()
Local aArea      	:= SGetArea()
Local cAlias     	:= "SC0"
Local lEnd       	:= .F.
Local lContinua 	:= GetMv("MV_RESERVA")
Local lLockSX6		:= .F.

lContinua := IIf(__cInterNet == "AUTOMATICO",.F.,lContinua)
If ( lContinua )
	If ( GetMv("MV_ULRESER") >= dDataBase )
		lContinua := .F.
	EndIf
	If lContinua
		GetMv("MV_RESERVA")
		dbSelectArea("SX6")
		lLockSX6 := MsRLock()
	EndIf
Endif
If ( lContinua .And. lLockSX6 )
	Processa({|lEnd| FA430Process(@lEnd,cAlias)},STR0036,OemToAnsi(STR0037),.F.)		//"Depura‡„o de Reservas"###"Depurando reservas ..."
	dbSelectArea("SX6")
	GetMv("MV_RESERVA")
	MsRUnLock()
EndIf
SRestArea(aArea)
Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ CalcEstL ³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 15/05/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o Saldo inicial por Produto/Local do arquivo SD5   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpA1 := CalcEstL(ExpC1,ExpC2,ExpD1,ExpC3,ExpC4,ExpC5,ExpC6)³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do Produto                                  ³±±
±±³          ³ ExpC2 = Local (Almoxarifado)                               ³±±
±±³          ³ ExpD1 = Data para obter o Saldo Inicial.                   ³±±
±±³          ³ ExpC3 = Lote                                               ³±±
±±³          ³ ExpC4 = Sub-Lote                                           ³±±
±±³          ³ ExpC5 = Localizacao                                        ³±±
±±³          ³ ExpC6 = Numero de Serie                                    ³±±
±±³          ³ ExpL1 = Verifica se obtem o saldo por Sub-Lote com rastro L³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGACUS                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CalcEstL(cCod,cLocal,dData,cLoteCtl,cNumLote,cLocaliz,cNumSeri,lConsSub)

Local lMATA103       := IsInCallStack("MATA103")
Local cProcNam       := IIF(FindFunction("GetSPName"), GetSPName("MAT029","17"), "MAT029")
Local lRastro    		:= Rastro(cCod)
Local lLocaliza  		:= Localiza(cCod)
Local l300SalNeg 		:= SuperGetMv("MV_MT300NG",.F.,.F.)
Local dMes				:= GetMV("MV_ULMES")
Local aSaldoL
Local lWmsnew 		:= SuperGetMv("MV_WMSNEW",.F.,.F.)
Local cProOri 		:= ""

Default dData        := dDataBase

dData	 := If(Empty(dData),Ctod( "01/01/80","ddmmyy" ),dData)
If ExistProc( cProcNam, VerIDProc())  .and. ( TcSrvType() <> "AS/400" ) .And. !lMATA103

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Preenche os parametros n„o inicializados                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dData    := If(dData==Nil, dDataBase, dData)
	cLoteCtl := If(cLoteCtl==Nil.Or.!lRastro, CriaVar('D5_LOTECTL'), cLoteCtl)
	cNumLote := If(cNumLote==Nil.Or.!lRastro, CriaVar('D5_NUMLOTE', If(SuperGetMV('MV_LOTEUNI', .F., .F.), .F., Nil)), cNumLote)
	cLocaliz := If(cLocaliz==Nil.Or.!lLocaliza, CriaVar('DB_LOCALIZ'), cLocaliz)
	cNumSeri := If(cNumSeri==Nil.Or.!lLocaliza, CriaVar('DB_NUMSERI'), cNumSeri)
	lConsSub := If(Valtype(lConsSub) # "L", .F. ,lConsSub)

	aSaldoL := {}
	//Tratamento com procedure exceto para Plataforma  "AS/400"
	aSaldoL := TCSPExec( xProcedures(cProcNam),	cFilAnt,;
														cCod,;											// 01. Codigo do Produto
														cLocal,;										// 02. Codigo do Armazem
														DTOS(dData),;									// 03. Data de Processamento
														cLoteCtl,;										// 04. Lote
														cNumLote,;										// 05. Sub-Lote
														cLocaliz,;										// 06.	Endereco
														cNumSeri,;										// 07.	Num de Serie do Produto
														If(lConsSub,'1','0'),;						// 08. Verifica se obtem o saldo por Sub-Lote
														DTOS(dMes),;									// 09. Data do ultimo fechamento de estoque
														If(l300SalNeg,'1','0'),;						// 10. Indica se permite saldo negativo(MV_MT300NG)
														If(lWmsNew,'1','0'),;						// 11. Utiliza ou não WMS
														cProOri)										// 12. Produto Origem
	If aSaldoL == Nil
		Final(STR0091) //"RE-INSTALAR AS STORED PROCEDURES"
	EndIf
	Return (aSaldoL)
Else
	Return xCEstL(@cCod,@cLocal,@dData,@cLoteCtl,@cNumLote,@cLocaliz,@cNumSeri,lConsSub)
EndIf
	/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ xCEstL ³ Autor ³ Wilson Junior         ³ Data ³ 28.03.94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o Saldo inicial por Produto/Local do arquivo SD5 - ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpA1 := CalcEstL(ExpC1,ExpC2,ExpD1)                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do Produto                                  ³±±
±±³          ³ ExpC2 = Local (Almoxarifado)                               ³±±
±±³          ³ ExpD1 = Data para obter o Saldo Inicial.                   ³±±
±±³          ³ ExpC3 = Lote                                               ³±±
±±³          ³ ExpC4 = Sub-Lote                                           ³±±
±±³          ³ ExpC5 = Localizacao                                        ³±±
±±³          ³ ExpC6 = Numero de Serie                                    ³±±
±±³          ³ ExpL1 = Verifica se obtem o saldo por Sub-Lote com rastro L³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGACUSB                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function xCEstL(cCod,cLocal,dData,cLoteCtl,cNumLote,cLocaliz,cNumSeri,lConsSub)
Local aSaldo     := {0, 0, 0, 0, 0, 0, 0}
Local aAreaAnt   := GetArea()
Local aAreaSBJ   := SBJ->(GetArea())
Local aAreaSBK   := SBK->(GetArea())
Local aAreaSD5   := SD5->(GetArea())
Local aAreaSDB   := SDB->(GetArea())
Local lRastro    := Rastro(cCod)
Local lSRastro   := Rastro(cCod, 'S')
Local lLocaliza  := Localiza(cCod)
Local lHasRec    := .F.
Local cCompSBJ   := ''
Local cCompSBK   := ''
Local cCompSD5   := ''
Local cCompSDB   := ''
Local cCompSDB1  := ''
Local cSeekSBJ   := ''
Local cSeekSBK   := ''
Local cSeekSD5   := ''
Local cSeekSDB   := ''
Local cSeekSDB1  := ''
Local dUltFec    := CtoD('  /  /  ')
Local cFiltroSD5 := ''
Local l300SalNeg := SuperGetMv("MV_MT300NG",.F.,.F.)

	dbSelectArea("SD5")
	cFiltroSD5 := dbFilter()
	If !Empty(cFiltroSD5)
		cFiltroSD5 += ".And. OrderBy("+StrTran(ClearKey(IndexKey()),"+",",")+")"
		dbClearFilter()
	EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Preenche os parametros n„o inicializados                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dData    := If(dData==Nil, dDataBase, dData)
cLoteCtl := If(cLoteCtl==Nil.Or.!lRastro, CriaVar('D5_LOTECTL'), cLoteCtl)
cNumLote := If(cNumLote==Nil.Or.!lRastro, CriaVar('D5_NUMLOTE', If(SuperGetMV('MV_LOTEUNI', .F., .F.), .F., Nil)), cNumLote)
cLocaliz := If(cLocaliz==Nil.Or.!lLocaliza, CriaVar('DB_LOCALIZ'), cLocaliz)
cNumSeri := If(cNumSeri==Nil.Or.!lLocaliza, CriaVar('DB_NUMSERI'), cNumSeri)
lConsSub := If(Valtype(lConsSub) # "L", .F. ,lConsSub)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se obtem o saldo por Sub-Lote mesmo com rastro L   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lConsSub .And. lRastro .And. !Empty(cNumLote)
	lSRastro:=.T.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorna o Saldo Inicial da Rastreabilidade (SBJ ou SD5)     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Empty(cLocaliz+cNumSeri) .And. !Empty(cLoteCtl)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Procura no SBJ por Saldos Iniciais ref. ao Ultimo Fechamento ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea('SBJ')
	dbSetOrder(2)
	cSeekSBJ := xFilial('SBJ') + cCod + cLocal + cLoteCtl
	cCompSBJ := 'BJ_FILIAL+BJ_COD+BJ_LOCAL+BJ_LOTECTL'
	If !Empty(cNumLote) .And. lSRastro
		dbSetOrder(1)
		cSeekSBJ += cNumLote
		cCompSBJ += '+BJ_NUMLOTE'
	EndIf

	dbSeek(cSeekSBJ+dtos(dData),.T.);dbSkip(-1)
	If cSeekSBJ == &(cCompSBJ) .And. SBJ->BJ_DATA < dData
		lHasRec := .T.
		dUltFec := BJ_DATA
	Else
		dUltFec := Ctod( "01/01/80","ddmmyy" )
	EndIf

	If lHasRec
		cSeekSBJ+=DTOS(dUltFec)
		cCompSBJ+="+DTOS(BJ_DATA)"
		dbSeek(cSeekSBJ)
		Do While !Eof() .And. &(cCompSBJ) == cSeekSBJ
			aSaldo[1] += BJ_QINI
			aSaldo[7] += BJ_QISEGUM
			dUltFec   := BJ_DATA
			dbSkip()
		EndDo
	EndIf
	RestArea(aAreaSBJ)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Procura no SD5 por Movimentacoes posteriores ao Ultimo SBJ  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( l300SalNeg .Or. QtdComp(aSaldo[1]+aSaldo[7])==QtdComp(0) ) .Or. ( ( l300SalNeg .Or. QtdComp(aSaldo[1]+aSaldo[7])>QtdComp(0) ) .And. !Empty(dUltFec) )
		dbSelectArea('SD5')
		dbSetOrder(2)
		cCompSD5 := 'D5_FILIAL+D5_PRODUTO+D5_LOCAL+D5_LOTECTL'
		cSeekSD5 := xFilial('SD5')+cCod+cLocal+cLoteCtl

		If !Empty(cNumLote) .And. lSRastro
			cCompSD5 += '+D5_NUMLOTE'
			cSeekSD5 += cNumLote
		EndIf

		If dbSeek(cSeekSD5, .F.)
			Do While !Eof() .And. &(cCompSD5) == cSeekSD5
				If !Empty(dUltFec) .And. D5_DATA <= dUltFec
					dbSkip()
					Loop
				EndIf
				If D5_DATA < dData .And. D5_ESTORNO # 'S'
					If D5_ORIGLAN<='500' .Or. Substr(D5_ORIGLAN,1,2) $ 'DE·PR·MA'
						aSaldo[1] += D5_QUANT
						aSaldo[7] += D5_QTSEGUM
					Else
						aSaldo[1] -= D5_QUANT
						aSaldo[7] -= D5_QTSEGUM
					EndIf
				EndIf
				dbSkip()
			EndDo
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Retorna o Saldo Inicial da Localiza‡Æo (SBK ou SDB)         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ElseIf !Empty(cLocaliz+cNumSeri)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Procura no SBK por Saldos Iniciais ref. ao Ultimo Fechamento ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea('SBK')
	dbSetOrder(2)
	cSeekSBK := xFilial('SBK') + cCod + cLocal
	cCompSBK := 'BK_FILIAL+BK_COD+BK_LOCAL+BK_LOTECTL'
	If lRastro
		cSeekSBK+= cLoteCtl
		If lSRastro .And. !Empty(cNumLote)
			dbSetOrder(1)
			cCompSBK += '+BK_NUMLOTE'
			cSeekSBK += cNumLote
		EndIf
		cSeekSBK+= cLocaliz+cNumSeri
		cCompSBK+= "+BK_LOCALIZ+BK_NUMSERI"
	Else
		cSeekSBK+= Criavar("BK_LOTECTL",.F.)+cLocaliz+cNumSeri
		cCompSBK+= "+BK_LOCALIZ+BK_NUMSERI"
	EndIf

	dbSeek(cSeekSBK+dtos(dData),.T.);dbSkip(-1)
	If cSeekSBK == &(cCompSBK) .And. SBK->BK_DATA < dData
		lHasRec := .T.
		dUltFec := BK_DATA
	Else
		dUltFec := Ctod( "01/01/80","ddmmyy" )
	EndIf

	If lHasRec
		cSeekSBK+=DTOS(dUltFec)
		cCompSBK+="+DTOS(BK_DATA)"
		dbSeek(cSeekSBK)
		Do While !Eof() .And. &(cCompSBK) == cSeekSBK
			aSaldo[1] += BK_QINI
			aSaldo[7] += BK_QISEGUM
			dbSkip()
		EndDo
	EndIf
	RestArea(aAreaSBK)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Procura no SDB por Movimentacoes posteriores ao Ultimo SBJ  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( l300SalNeg .Or. QtdComp(aSaldo[1]+aSaldo[7])==QtdComp(0) ) .Or. ( (l300SalNeg .Or. QtdComp(aSaldo[1]+aSaldo[7])>QtdComp(0) ) .And. !Empty(dUltFec) )

		dbSelectArea('SDB')
		dbSetOrder(10)

		cSeekSDB := xFilial('SDB') + cCod + cLocal
		cCompSDB := 'DB_FILIAL+DB_PRODUTO+DB_LOCAL'

		cSeekSDB1 := cLocaliz + cNumSeri
		cCompSDB1 := 'DB_LOCALIZ+DB_NUMSERI'
		If lRastro
			cSeekSDB1 += cLoteCtl
			cCompSDB1 += '+DB_LOTECTL'
			If !Empty(cNumLote) .And. lSRastro
				cSeekSDB1 += cNumLote
				cCompSDB1 += '+DB_NUMLOTE'
			EndIf
		EndIf

		dbSeek(cSeekSDB +If(Empty(dUltFec),"",DTOS(dUltFec)),.T.)
		Do While !Eof() .And. &(cCompSDB) == cSeekSDB .And. DB_DATA < dData
			If !Empty(dUltFec) .And. DB_DATA <= dUltFec
				dbSkip()
				Loop
			EndIf
			If &(cCompSDB1) == cSeekSDB1 .And. DB_ESTORNO # 'S' .And. DB_ATUEST # "N"
				If DB_TM<='500' .Or. Substr(DB_TM,1,2) $ 'DE·PR·MA'
					aSaldo[1] += SDB->DB_QUANT
					aSaldo[7] += SDB->DB_QTSEGUM
				Else
					aSaldo[1] -= SDB->DB_QUANT
					aSaldo[7] -= SDB->DB_QTSEGUM
				EndIf
			EndIf
			dbSkip()
		EndDo
		RestArea(aAreaSDB)
	EndIf
EndIf

	If !Empty(cFiltroSD5)
		dbSelectArea('SD5')
		dbSetFilter({||&cFiltroSD5},cFiltroSD5)
		dbGoTop()
	EndIf
RestArea(aAreaSD5)
RestArea(aAreaAnt)
Return(aSaldo)

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ INCD3DOC   ³ Autor ³Fernando Joly Siquini³ Data ³ 04/08/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Verifica qual ‚ o ultimo numero do D3_DOC no arquivo SD3 e ³±±
±±³          ³ incrementa 1.                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³ Void                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Caracter no Tamanho do D3_DOC com o Numero do Documento    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Gen‚rico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function IncD3Doc()

Local cRet       := Space(Len(SD3->D3_DOC))
Local aAreaAnt   := GetArea()
Local aAreaSD3   := {}

dbSelectArea('SD3')
aAreaSD3 := GetArea()
cRet     := NextNumero('SD3',2,'D3_DOC',.T.)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Corrige numeracao do documento qdo utilizar documento do inventario.  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Upper(Substr(cRet,1,5)) == 'INVEN'
	dbSetOrder(2)
	dbSeek(xFilial('SD3') + 'z', .T.)
	Do While !Bof()
		If D3_FILIAL == xFilial('SD3') .And. !Empty(D3_DOC) .And. ;
				Upper(Substr(D3_DOC,1,5)) # 'INVEN'
			cRet := Soma1(D3_DOC)
			Exit
		EndIf
		dbSkip(-1)
	EndDo

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Caso nao consiga achar numeracao, inicializa o documento ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Upper(Substr(cRet,1,5)) == 'INVEN'
		cRet := Replicate('0',Len(D3_DOC)-1) + '1'
	EndIf
EndIf

RestArea(aAreaSD3)
RestArea(aAreaAnt)

Return cRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Capacidade³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 08/05/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se a localizacao tem capacidade para o movimento  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpL1:= Capacidade(ExpC1,ExpC2,ExpN1,ExpC3)                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpL1 = Retorno logico se tem capacidade (.T.) ou nao (.F.)³±±
±±³          ³ ExpC1 = Almoxarifado a ter a capacidade pesquisada         ³±±
±±³          ³ ExpC2 = Localizacao a ter a capacidade pesquisada          ³±±
±±³          ³ ExpN1 = Quantidade do movimento                            ³±±
±±³          ³ ExpC3 = Produto do movimento                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function Capacidade(cAlmox,cLocaliza,nQuant,cProduto)
LOCAL lRet     :=.T.
LOCAL nSaldo   :=0,nAltura:=0
LOCAL aAreaSBE :=SBE->(GetArea())
LOCAL lAvalCapa:=GetMV("MV_CAPLOCA")
LOCAL aInfProd:={}
LOCAL aDimensoes:={}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se avalia a capacidade da localizacao  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lAvalCapa
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Recupera dados ref. as dimensoes do produto     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aInfProd:=InfProd(cProduto)
	SBE->(dbSetOrder(1))
	If SBE->(dbSeek(xFilial("SBE")+cAlmox+cLocaliza))
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se utiliza controle de Cubagem         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If aInfProd[1]
			If (SBE->BE_ALTURLC*SBE->BE_LARGLC*SBE->BE_COMPRLC > 0)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Recupera dados ref. as dimensoes da localizacao ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica se todas dimensoes estao compativeis   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aDimensoes:=Dimensoes(aInfProd,{SBE->BE_ALTURLC,SBE->BE_LARGLC,SBE->BE_COMPRLC})
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Aviso ao usuario indicando p/ rotacionar dimensoes ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If aDimensoes[1] .And. aDimensoes[2]
					Help(" ",1,"MA265ROTAC")
					lRet:=.F.
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Aviso ao usuario indicando que produto nao cabe    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lRet .And. !aDimensoes[1]
					Help(" ",1,"MA265DIMEN")
					lRet:=.F.
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica se ha espaco disponivel p/ armazenagem ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lRet
					nAltura:=AlturaLc(SBE->BE_LOCAL,SBE->BE_LOCALIZ,cProduto)
					nSaldo :=AreaDisp(aInfProd,{nAltura,SBE->BE_LARGLC,SBE->BE_COMPRLC,SBE->BE_PERDA})
					If QtdComp(nSaldo) < QtdComp(ConvFatArm(aInfProd[6],SBE->BE_LOCAL,SBE->BE_LOCALIZ,nQuant))
						Help(" ",1,"MA265CAPAC")
						lRet:=.F.
					EndIf
				EndIf
			ElseIf !IntWMS(cProduto)
				Help(" ",1,"MA265LOCDF")
				lRet:=.F.
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se utiliza controle por quantidade     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Else
			If SBE->BE_CAPACID > 0
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Calcula saldo por quantidade                    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nSaldo:=QuantSBF(cAlmox,cLocaliza,cProduto)
				If SBE->BE_CAPACID < nSaldo+nQuant
					Help(" ",1,"MA265CAPAC")
					lRet:=.F.
				EndIf
			EndIf
		EndIf
	EndIf
EndIf
RestArea(aAreaSBE)
Return lRet


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MADistrAut³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 30/12/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Monta em array a distribuicao automatica do movimento      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe  ³ ExpA1:=MADistrAut(ExpC1,ExpC2,ExpN1)                       ³±±
±±³          ³ ExpA1 -> Array com a distribuicao feita                    ³±±
±±³          ³ ExpC1 -> Almoxarifado                                      ³±±
±±³          ³ ExpC2 -> Produto                                           ³±±
±±³          ³ ExpN1 -> Quantidade a ser distribuida                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function MADistrAut(cLocal,cProduto,nSaldo)
LOCAL aInfProd	:=InfProd(cProduto)
LOCAL nAltura	:=0,nRet:=0,aRet:={}
LOCAL cAlias 	:= DistrAutQy(cLocal)

Do While nSaldo > 0 .And. (cAlias)->(!Eof())
	If ProdLocali(cProduto,cLocal,(cAlias)->(BE_LOCALIZ),.F.)
		nBaixa:=0
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se utiliza controle de Cubagem         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If aInfProd[1]
			If (QtdComp((cAlias)->(BE_ALTURLC)*(cAlias)->(BE_LARGLC)*(cAlias)->(BE_COMPRLC)) > QtdComp(0))
				nAltura:=AlturaLc((cAlias)->(BE_LOCAL),(cAlias)->(BE_LOCALIZ),cProduto)
				nRet:=AreaDisp(aInfProd,{nAltura,(cAlias)->(BE_LARGLC),(cAlias)->(BE_COMPRLC),(cAlias)->(BE_PERDA)}) * aInfProd[6]
				nRet-=QuantSBF(cLocal,(cAlias)->(BE_LOCALIZ),cProduto)
				nBaixa:=Min(QtdComp(nSaldo),nRet)
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se utiliza controle por quantidade     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Else
			If (cAlias)->(BE_CAPACID) > 0
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Calcula saldo por quantidade                    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nOcupado:=QuantSBF(cLocal,(cAlias)->(BE_LOCALIZ))
				nRet:=(cAlias)->(BE_CAPACID)-nOcupado
				nBaixa:=Min(QtdComp(nSaldo),QtdComp(nRet))
			Else
				nBaixa:=nSaldo
			EndIf
		EndIf

		If QtdComp(nBaixa) > QtdComp(0)
			AADD(aRet,{(cAlias)->(BE_LOCALIZ),nBaixa,ConvUm(cProduto,nBaixa,aCols[Len(aCols),nPosQtSegum],2)})
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Retira a baixa do saldo                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nSaldo -= nBaixa
	EndIf
	(cAlias)->(dbSkip())
EndDo

If Select(cAlias) > 0
	(cAlias)->(DbCloseArea())
EndIf

Return aRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ AreaDisp ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 26/01/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica qual a quantidade que pode ser armazenada         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe  ³ nRet:=AreaDisp(ExpA1,ExpA2)                                ³±±
±±³          ³ nRet  -> Var. numerica com qtdade que pode ser armazenada  ³±±
±±³          ³ ExpA1 -> Array com os dados do produto                     ³±±
±±³          ³                            [1] Logico se Utiliza Cubagem   ³±±
±±³          ³                            [2] Altura p/ Armazenagem       ³±±
±±³          ³                            [3] Largura p/ Armazenagem      ³±±
±±³          ³                            [4] Comprimento p/ Armazenagem  ³±±
±±³          ³                            [5] Logico se Permite Rotacao   ³±±
±±³          ³                            [6] Fator de Armazenamento      ³±±
±±³          ³                            [7] Seq. de Armazenamento       ³±±
±±³          ³ ExpA2 -> Array com os dados da localizacao                 ³±±
±±³          ³                            [1] Altura p/ Armazenagem       ³±±
±±³          ³                            [2] Largura p/ Armazenagem      ³±±
±±³          ³                            [3] Comprimento p/ Armazenagem  ³±±
±±³          ³                            [4] Indice de perda de espaco   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function AreaDisp(aInfProd,aLocaliz)
Local nFatAltura:=0,nLarguraAr:=0,nCompriArm:=0,nMultiplicador:=1-(aLocaliz[4]/100)
// Calcula os fatores de armazenagem por dimensao (Altura X Largura X Comprimento)
nFatAltura:=Int(aLocaliz[1]/aInfProd[2])
nLarguraAr:=Int(aLocaliz[2]/aInfProd[3])
nCompriArm:=Int(aLocaliz[3]/aInfProd[4])
Return Int(nFatAltura*nLarguraAr*nCompriArm*nMultiplicador)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ InfProd  ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 29/12/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna array com informacoes do produto referentes ao     ³±±
±±³          ³ controle de armazenagem com cubagem.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ aRet     := InfProd(cProduto)                              ³±±
±±³          ³ aRet     := Array contendo [1] Logico se Utiliza InfProd   ³±±
±±³          ³                            [2] Altura p/ Armazenagem       ³±±
±±³          ³                            [3] Largura p/ Armazenagem      ³±±
±±³          ³                            [4] Comprimento p/ Armazenagem  ³±±
±±³          ³                            [5] Logico se Permite Rotacao   ³±±
±±³          ³                            [6] Fator de Armazenamento      ³±±
±±³          ³ cProduto := Produto utilizado                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ EST/PCP/FAT/COM                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function InfProd(cProduto)
Local aRet      :={.F.,0,0,0,.F.,0}
Local aArea     :=GetArea()
Local aAreaSB5  :=SB5->(GetArea())
If SB5->(MsSeek(xFilial("SB5")+cProduto)) .And. ;
		(QtdComp(SB5->B5_ALTURLC*SB5->B5_LARGLC*SB5->B5_COMPRLC) > QtdComp(0))
	aRet:={.T.,SB5->B5_ALTURLC,SB5->B5_LARGLC,SB5->B5_COMPRLC,SB5->B5_ROTACAO=="1",SB5->B5_FATARMA}
EndIf
SB5->(RestArea(aAreaSB5))
RestArea(aArea)
Return aRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ AlturaLc ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 27/12/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna a altura considerada p/ armazenamento (Cubagem)    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ nRet:=AlturaLc(cLocal,cLocalizacao,cProduto)               ³±±
±±³          ³ nRet         := Altura a ser considerada                   ³±±
±±³          ³ cLocal       := Almoxarifado Utilizado                     ³±±
±±³          ³ cLocalizacao := Localizacao utilizada                      ³±±
±±³          ³ cProduto     := Produto Utilizado                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ EST/PCP/FAT/COM                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function AlturaLc(cLocal,cLocalizacao,cProduto)
Local nRet      :=0
Local aArea     :=GetArea()
Local aAreaSB5  :=SB5->(GetArea())
Local aAreaSBE  :=SBE->(GetArea())
SBE->(dbSetOrder(1))
SB5->(dbSetOrder(1))
SBE->(MsSeek(xFilial("SBE")+cLocal+cLocalizacao))
If SB5->(MsSeek(xFilial("SB5")+cProduto)) .And. SB5->B5_EMPMAX > 0
	nRet:=SB5->B5_ALTURLC*SB5->B5_EMPMAX
	If nRet > SBE->BE_ALTURLC
		nRet := Int(SBE->BE_ALTURLC / SB5->B5_ALTURLC) * SB5->B5_ALTURLC
	Endif
Else
	If ! SBE->(EOF())
		nRet:=SBE->BE_ALTURLC
	EndIf
EndIf
SB5->(RestArea(aAreaSB5))
SBE->(RestArea(aAreaSBE))
RestArea(aArea)
Return nRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ Dimensoes³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 20/01/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se o produto cabe na localizacao escolhida        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe  ³ ExpA1:=Dimensoes(ExpA2,ExpA3)                              ³±±
±±³          ³ ExpA1 -> Array com as seguintes informacoes:               ³±±
±±³          ³          [1] Variavel logica indicando se o produto cabe   ³±±
±±³          ³          [2] Variavel logica indicando se precisa rotacao  ³±±
±±³          ³ ExpA2 -> Array com as dimensoes do produto e se permite    ³±±
±±³          ³          rotacao {ExpL1,ExpN1,ExpN2,ExpN3,ExpL2}           ³±±
±±³          ³ ExpA3 -> Array com as dimensoes da Localizacao Fisica      ³±±
±±³          ³          {ExpN1,ExpN2,ExpN3}                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function Dimensoes(aBackProd,aBackLoc)
LOCAL z:=0,y:=0
LOCAL cPossivel:=""
LOCAL lRet:=.T.,lRotacao:=.F.
LOCAL aProduto:={},aLocalizacao:={},aPossiveis:={}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta array com as dimensoes do produto         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For z:=2 to 4
	AADD(aProduto,aBackProd[z])
Next z

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta array com as dimensoes das localizacoes   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For z:=1 to Len(aBackLoc)
	AADD(aLocalizacao,aBackLoc[z])
Next z

For z:=1 to Len(aProduto)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica dimensoes sem rotacionar o produto                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (aProduto[z] > aLocalizacao[z])
		lRet:=.F.
	EndIf
Next z

If aBackProd[5] .And. !lRet
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica todas possibilidades caso o produto possa ser rotacionado ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	AADD(aPossiveis,{"1",aProduto[1],aLocalizacao[1]})
	AADD(aPossiveis,{"1",aProduto[2],aLocalizacao[2]})
	AADD(aPossiveis,{"1",aProduto[3],aLocalizacao[3]})

	AADD(aPossiveis,{"2",aProduto[1],aLocalizacao[1]})
	AADD(aPossiveis,{"2",aProduto[3],aLocalizacao[2]})
	AADD(aPossiveis,{"2",aProduto[2],aLocalizacao[3]})

	AADD(aPossiveis,{"3",aProduto[2],aLocalizacao[1]})
	AADD(aPossiveis,{"3",aProduto[1],aLocalizacao[2]})
	AADD(aPossiveis,{"3",aProduto[3],aLocalizacao[3]})

	AADD(aPossiveis,{"4",aProduto[2],aLocalizacao[1]})
	AADD(aPossiveis,{"4",aProduto[3],aLocalizacao[2]})
	AADD(aPossiveis,{"4",aProduto[1],aLocalizacao[3]})

	AADD(aPossiveis,{"5",aProduto[3],aLocalizacao[1]})
	AADD(aPossiveis,{"5",aProduto[1],aLocalizacao[2]})
	AADD(aPossiveis,{"5",aProduto[2],aLocalizacao[3]})

	AADD(aPossiveis,{"6",aProduto[3],aLocalizacao[1]})
	AADD(aPossiveis,{"6",aProduto[2],aLocalizacao[2]})
	AADD(aPossiveis,{"6",aProduto[1],aLocalizacao[3]})

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Analisa todas possibilidades e indica se ha possibilidade de rotacao³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	y:=1
	While y <= Len(aPossiveis)
		cPossivel:=aPossiveis[y,1];lRet:=.T.
		While y <= Len(aPossiveis)	.And. cPossivel == aPossiveis[y,1]
			If aPossiveis[y,2]  > aPossiveis[y,3]
				y++
				lRet:=.F.
				Exit
			EndIf
			y++
		End
		If lRet
			Exit
		EndIf
	End
	lRotacao:=lRet
EndIf
Return {lRet,lRotacao}

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ConvFatArm³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 26/01/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Converte a quantidade com fator de armazenamento           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe  ³ ExpN1:=ConvFatArm(ExpN2,ExpC1,ExpC2,ExpN3)                 ³±±
±±³          ³ ExpN2 -> Fator de Armazenamento                            ³±±
±±³          ³ ExpC1 -> Almoxarifado                                      ³±±
±±³          ³ ExpC2 -> Localizacao                                       ³±±
±±³          ³ ExpN3 -> Quantidade a ser convertida                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function ConvFatArm(nFator,cAlmox,cLocaliza,nQuant)
LOCAL aArea   :=GetArea()
LOCAL aAreaSBF:=SBF->(GetArea())
LOCAL nResto  :=0
// Converte a quantidade de acordo com o Fator de Armazenamento
SBF->(dbSetOrder(1))
SBF->(dbSeek(xFilial("SBF")+cAlmox+cLocaliza))
nFator:=If(nFator>0,nFator,1)
nQuant:=(nQuant+SBF->BF_QUANT)/nFator
// Soma a diferenca para evitar diferenca pelo resto
nResto:=ABS(Int(nQuant)-nQuant)
nQuant+=If(nResto>0,1-nResto,0)
RestArea(aAreaSBF)
RestArea(aArea)
Return nQuant

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ProdLocali³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 27/01/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna se o produto e' o unico na localizacao             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe  ³ ExpL1:=ProdLocali(ExpC1,ExpC2,ExpC3,ExpL2)                 ³±±
±±³          ³ ExpL1 -> Retorno Logico                                    ³±±
±±³          ³ ExpC1 -> Produto                                           ³±±
±±³          ³ ExpC2 -> Almoxarifado                                      ³±±
±±³          ³ ExpC3 -> Localizacao                                       ³±±
±±³          ³ ExpL2 -> Indica se mostra o help ou nao                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function ProdLocali(cProduto,cLocal,cLocaliz,lMostraHelp)
Local lRet       := .T.
Local aArea      := GetArea()
Local aAreaSBF   := SBF->(GetArea())
	Local cAliasQry  := ""
	Local cQuery     := ""


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Controla se apresenta help ou nao               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lMostraHelp:=IF(lMostraHelp==NIL,.T.,lMostraHelp)

If !IntWMS(cProduto)
		cAliasQry := GetNextAlias()
		cQuery := "SELECT SBF.BF_PRODUTO, SBF.R_E_C_N_O_ SBFRECNO FROM "+RetSqlName("SBF")+" SBF "
		cQuery += "JOIN "+RetSqlName("SB1")+" SB1 ON SB1.B1_COD = SBF.BF_PRODUTO AND "
		cQuery += "SB1.B1_LOCALIZ = 'S' AND SB1.B1_FILIAL = '"+xFilial("SB1")+"' AND SB1.D_E_L_E_T_ = '' "
		cQuery += "JOIN "+RetSqlName("SB5")+" SB5 ON SB5.B5_COD = SBF.BF_PRODUTO AND "
		cQuery += "SB5.B5_ALTURLC > 0 AND SB5.B5_LARGLC > 0 AND SB5.B5_COMPRLC > 0 AND "
		cQuery += "SB5.B5_FILIAL = '"+xFilial("SB5")+"' AND SB5.D_E_L_E_T_ = '' "
		cQuery += "AND SB1.B1_FILIAL = '"+xFilial("SB1")+"' AND SB1.D_E_L_E_T_ = '' "
		cQuery += "AND ( SB1.B1_LOCALIZ = 'S' "
		If SBZ->(FieldPos("BZ_LOCALIZ")) > 0
			cQuery += " OR EXISTS(SELECT 1 From " + RetSqlName("SBZ") +  " WHERE BZ_COD = SB1.B1_COD AND BZ_LOCALIZ = 'S')"
		EndIf
		cQuery += " ) "
		cQuery += "JOIN "+RetSqlName("SBE")+" BE ON BE.BE_FILIAL='"+xFilial("SBE")+"' AND SBF.BF_FILIAL ='"+xFilial("SBF")+"' AND BE.BE_LOCAL=SBF.BF_LOCAL AND BE.BE_LOCALIZ=SBF.BF_LOCALIZ AND BE_CODPRO<>' ' "
		cQuery += "WHERE SBF.BF_PRODUTO <> '"+cProduto+"' AND SBF.BF_LOCAL = '"+cLocal+"' AND "
		cQuery += "SBF.BF_LOCALIZ = '"+cLocaliz+"' AND SBF.BF_FILIAL = '"+xFilial("SBF")+"' AND SBF.D_E_L_E_T_ = ''"
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)

		If (cAliasQry)->(!Eof())
			If lMostraHelp
				Help(" ",1,"A265PRDDIF")
			EndIf
			lRet:=.F.
		EndIf
		dbSelectArea(cAliasQry)
		dbCloseArea()
EndIf
RestArea(aAreaSBF)
RestArea(aArea)
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ fGravaCQ ³ Autor ³ Fernando Joly Siquini ³ Data ³ 28.01.99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Atualiza as informa‡”es nos arquivos SD7 e CQ999999.TXT    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fGravaCQ(ExpC1, ExpC2, ExpL1, ExpA1, ExpA2, ExpA3, ExpN1)  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = 01.Codigo do Produto.                              ³±±
±±³          ³ ExpC2 = 02.Numero da Movimentacao no CQ.                   ³±±
±±³          ³ ExpL1 = 03.Estorno (.T.) ou N„o (.F.).                     ³±±
±±³          ³ ExpA1 = 04.Array com as Movmentacoes Ocorridas com o Prod  ³±±
±±³          ³ ExpA2 = 05.Array com os Custos Medios do Produto.          ³±±
±±³          ³ ExpA3 = 06.Array que contem os campos X3_CAMPO/X3_PROPRI.  ³±±
±±³          ³ ExpN1 = 07.Potencia do Lote a ser gravado                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fGravaCq(cProduto, cNumero, lEstorno, aMov, aCM, aHeaderPro, nPotencia, cNumSeqTRF)

Local aAreaAnt   := GetArea()
Local aAreaSB1   := SB1->(GetArea())
Local aAreaSB2   := SB2->(GetArea())
Local aAreaSB8   := SB8->(GetArea())
Local aAreaSD1   := SD1->(GetArea())
Local aAreaSD3   := SD3->(GetArea())
Local aAreaSD7   := SD7->(GetArea())
Local aCusto     := {}
Local aValDesp   := {}
Local aDespAgreg := {}
Local aAnterior  := {}
Local aEstorna   := {}
Local aSD7       := {}
Local aNewMov    := {}
Local bCampo     := {|nCPO| Field(nCPO) }
Local cLocCQ     := GetMvNNR('MV_CQ','98')
Local cDirCQ     := GetMv('MV_DIRCQ')
Local cArqCQ     := ''
Local cLocDest   := ''
Local cSeekSD1   := ''
Local cSeekSD3   := ''
Local cSeekSD7   := ''
Local cTipo      := ''
Local cTexto     := ''
Local cLoteCtl   := ''
Local cNumLote   := ''
Local cNLoteOrig := ''
Local cTipoMov   := ''
Local cTipoCQ    := ''
Local cDoc       := ''
Local cSerie     := ''
Local cFornece   := ''
Local cLoja      := ''
Local cNumSeq    := ''
Local cNSeqOrig  := ''
Local cOrigLan   := ''
Local cLocaliza  := ''
Local cLoteFor	 := ''
Local cNumDesp   := ''
Local dDtValid   := CtoD('  /  /  ')
Local dDtUlFec   := MVUlmes()
Local lArqCQ     := .T.
Local lRet       := .T.
Local lAchouD1   := .F.
Local lAchouC2	 := .T.
Local lUtil175   := IsInCallStack("MATA175") .Or. IsInCallStack('QIEA215')
Local nX         := 0
Local nY         := 0
Local nZ         := 0
Local nSerie     := 0
Local nSeq       := 0
Local nQuant     := 0
Local nSaldo     := 0
Local nSaldo2    := 0
Local nSaldoDisp := 0
Local nRecTPZero := 0
Local nHandle    := 0
Local nItens     := 0
Local nEstorno   := 0
Local nSD3OrdAnt := 0
Local nQuantSD3  := 0
Local nTargRec   := 0
Local aTotCompra := {0,0,0,0,0}
Local aDecCusD3  := {2,2,2,2,2}
Local aCusDASD3  := {0,0,0,0,0}
Local xVar       := ''
Local nQtde      := 0
Local cCF        := ''
Local aSerie     := {}
Local cDocEIC    := ''
Local cItemEIC   := ''
Local cServWMS   := ''
Local cEndeWMS   := ''
Local lEIC       := .F.
Local nQtdaLib   := 0
Local cOpCompl   := ""
Local lConsVenc  := (SuperGetMV('MV_LOTVENC')=='S')
Local aSD7PMS	 :=	{}
Local aRecsAFO	 :=	{}
Local aRecsAFN	 :=	{}
Local aUsrMemo   := {}
Local nPos 		 := 0
Local lPrdIntWms := IntWMS(cProduto)
Local uRet
Local lQIMPSKD7	:= Existblock("QIMPSKD7")
Local cLOTVENC	:= SuperGetMV('MV_LOTVENC')
Local cLocOrig  := ""
Local nPrdImp   := 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ MV_PROCQE6 - Parametro utilizado para gerar "RE6/DE6"         |
//|              nas Liberacoes do CQ quando D7_ORIGLAN = 'PR'    |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local lProCQE6 := SuperGetMV('MV_PROCQE6',.F.,.F.)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ MV_A175VLD - Parametro utilizado para verificar se o usuario  |
//|              podera realizar a alteração da data de validade  |
//|              do lote atraves da rotina de Baixas do CQ.       |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local lA175Vld  := SuperGetMv("MV_A175VLD",.F.,.F.)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ lTranCQ   - Indica se o ambiente esta preparado para o        |
//|             proceso de transferencia de filiais para CQ.      |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local lTranCQ  := IsTranCQ()
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ cRecTrfCQ - Somente utilizado no processo de transferencia de |
//|             CQ atraves do MATA310 (obrigatorio registro da    |
//|             tabela SD7 posicionado).                          |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local nRecTrfCQ := IIf(lTranCQ .And. lEstorno .and. IsIncallStack("MATA310"),SD7->(Recno()),0)

DEFAULT nPotencia := 0
DEFAULT cNumSeqTRF:= ''

//-- Formato do Array aMov:
//-- (Sua Montagem deve seguir a Ordem 1 :
//--  Filial+Numero+Produto+Local+Sequencia+Data)
//-- Em caso de Estorno, enviar todos os Registros (Menos o tipo 0-Zero)
//-- Em caso de Libera‡Æo/Rejei‡Æo, enviar somente as Movimenta‡äes Novas
//-- [n,01] = Tipo da Movimentacao (1 = Liberar / 2 = Rejeirar)
//-- [n,02] = Quantidade a ser Movimentada
//-- [n,03] = Local de Destino para a Movimenta‡„o
//-- [n,04] = Data da Movimenta‡„o
//-- [n,05] = Estornado (X = Estornado)
//-- [n,06] = Motivo da Rejei‡„o
//-- [n,07] = Observacao
//-- [n,08] = Quantidade na 2a Unidade de Medida
//-- [n,09] = Endereco Origem
//-- [n,10] = Numero de Serie Origem

//-- Formato do Array aHeaderPro
//-- [n,1] = Nome do Campo do SD7 (X3_CAMPO).
//-- [n,2] = Verifica se o campo do SD7, e' criado ou nao pelo usuario (X3_PROPRI).


cLocCQ := PADR(cLocCQ,TAMSX3("D7_LOCAL")[1])  //adequo o conteudo padrão "98" para "98 "

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³PE para obter os campos virtuais do tipo MEMO ³
//³criados pelo usuario.                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock('MTMEMOCQ')
	uRet := ExecBlock('MTMEMOCQ')
	If ValType(uRet) == "A" .And. Len(uRet) > 0
		aUsrMemo := uRet
	EndIf
EndIf

lEstorno := If(lEstorno==Nil,.F.,lEstorno)

If cProduto == Nil .Or. cNumero == Nil .Or. aMov == Nil .Or. Len(aMov) == 0
	lRet := .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Abre ou Cria arquivo MV_DIRCQ + CQ99999.TXT          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !(nModulo == 21)      // SIGAQIE
	If lRet .And. !File(cDirCQ+(cArqCQ:='CQ'+cNumero+'.TXT'))
		If (nHandle:=MsfCreate(cDirCQ+cArqCQ,0)) <= -1
			If !MontaDir(cDirCQ)
				Help (' ',1,'RELDIRERR')
				lArqCQ := .F.
			ElseIf (nHandle:=MsfCreate(cDirCQ+cArqCQ,0)) <= -1
				Help(' ',1,'ERRORCQ',,cDirCQ+cArqCQ,4,15)
				lArqCQ := .F.
			Endif
		EndIf
	ElseIf lRet .And. (nHandle:=fOpen(cDirCQ+cArqCQ,0+64)) <= -1
		Help(' ',1,'ERRORCQ',,cDirCQ+cArqCQ,4,15)
		lArqCQ := .F.
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Carrega o conte£do do arquivo TXT na variavel cTexto ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !(nModulo == 21) //SIGAQIE
		If lRet .And. lArqCQ
			If !fClose(nHandle)
				Help(' ',1,'MEMOERRO')
				lArqCQ := .F.
			Else
				cTexto := MemoRead(cDirCQ+cArqCQ)
			EndIf
		EndIf
	EndIf
EndIf

If lRet
	aDecCusD3 := {TamSX3('D3_CUSTO1')[2], TamSX3('D3_CUSTO2')[2], TamSX3('D3_CUSTO3')[2], TamSX3('D3_CUSTO4')[2], TamSX3('D3_CUSTO5')[2]}
EndIf

Begin Transaction

	//-- Consiste os Registros ja existentes no SD7
	dbSelectArea('SD7')
	dbSetOrder(1)
	If dbSeek(cSeekSD7:=xFilial('SD7')+cNumero+cProduto+cLocCQ, .F.)
		Do While !Eof() .And. cSeekSD7==D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL
			cTipo := StrZero(D7_TIPO,1)
			If !lEstorno .Or. (lEstorno.And.cTipo=='0')
				If Len(aMov[1]) > 8
					aAdd(aSD7, {D7_TIPO, D7_QTDE, D7_LOCDEST, D7_DATA, D7_ESTORNO, D7_MOTREJE,'', D7_QTSEGUM,D7_LOCALIZ,D7_NUMSERI})
				Else
					aAdd(aSD7, {D7_TIPO, D7_QTDE, D7_LOCDEST, D7_DATA, D7_ESTORNO, D7_MOTREJE,'', D7_QTSEGUM})
				EndIf
				If IntegraEIC(D7_DOC,D7_SERIE,D7_FORNECE,D7_LOJA)
					cDocEIC  := SD7->D7_DOCSWN
					cItemEIC := SD7->D7_ITEMSWN
				EndIf
			EndIf
			If cTipo == '0' //-- Movimenta‡„o Original
				nRecTPZero := Recno()
				nQuant     := D7_SALDO
				nSaldo     := D7_SALDO
				nSaldo2    := D7_SALDO2
				cDoc       := D7_DOC
				cSerie     := D7_SERIE
				cFornece   := D7_FORNECE
				cLoja      := D7_LOJA
				cTipoCQ    := D7_TIPOCQ
				cOrigLan   := D7_ORIGLAN
				cLoteCtl   := D7_LOTECTL
				cNLoteOrig := D7_NUMLOTE
				cNSeqOrig  := D7_NUMSEQ
				cLocOrig   := D7_LOCALIZ
				If Empty(cTipoCQ) //-- Compatibilizacao com versoes anteriores
					cTipoCQ := 'M'
					RecLock('SD7', .F.)
					Replace D7_TIPOCQ With cTipoCQ
					MsUnlock()
				EndIf
				If nPotencia # 0
					RecLock('SD7', .F.)
					Replace D7_POTENCI With nPotencia
					MsUnlock()
				Else
					nPotencia  := D7_POTENCI
				EndIf
			ElseIf cTipo $'1ú2ú3' //-- Liberada / Rejeitada / Transferido
				nSaldo     -= D7_QTDE
				nSaldo2    -= D7_QTSEGUM
			ElseIf cTipo $'5' 	//-- Alterar Data de Validade Lote
				//-- Data de Validade
			ElseIf cTipo $'6ú7ú4' //-- Est.Lib. / Est.Rej. / Est. Transf.
				nSaldo     += D7_QTDE
				nSaldo2    += D7_QTSEGUM
			ElseIf cTipo == '8' //-- Despesas Agregadas
				If !lEstorno .And. !(D7_ESTORNO=='S')
					aAdd(aDespAgreg, {D7_PRODUTO,D7_DOC,D7_SERIE,D7_FORNECE,D7_LOJA,D7_NUMSEQ})
				EndIf
			EndIf
			aAdd(aAnterior, Recno())
			dbSkip()
		EndDo
		nSeq := Len(aAnterior)
	Else
		lRet := .F.
	EndIf

	//-- Nao realiza movimentacoes de CQ quando nao existir o registro Tipo ZERO
	If lRet .And. nRecTPZero == 0
		Help(' ', 1, 'SEMSEQ001')
		lRet := .F.
	EndIf

	//-- Adiciona os Registros j  existentes no SD7 ao array aMov
	If lRet
		aNewMov := aClone(aMov)
		aMov    := aClone(aSD7)
		For nX  := 1 to Len(aNewMov)
			aAdd(aMov, aNewMov[nX])
		Next nX
	EndIf

	If lRet .And. !lEstorno
		//-- Libera‡”es / Rejei‡”es
		For nX := 1 to Len(aMov)
			//-- Grava Somente Novos Registros
			If nX <= Len(aAnterior)
				Loop
			EndIf

			//-- Somente Registros com Tipo 1 ou 2 ou 5
			If !(aMov[nX,1]==1) .And. !(aMov[nX,1]==2) .And. IIf(lA175Vld,!aMov[nX,1]==5,.T.) .And. IIf(lTranCQ,!aMov[nX,1]==3,.T.)
				Loop
			EndIf

			//-- Nao processa Tipos 1 e 2 com Quantidade 0 (ZERO)
			If QtdComp(aMov[nX, 2]) == QtdComp(0) .And. ( aMov[nX,1]==1 .Or. aMov[nX,1]==2 .Or. aMov[nX,1]==3)
				Loop
			EndIf

			//-- Impede Movimentacoes com Data Anterior a do Ultimo Fechamento
			If (aMov[nX, 4]<dDtUlFec) .Or. (dDataBase<dDtUlFec)
				Help(' ', 1, 'FECHTO')
				Loop
			EndIf

			//-- Posiciona o Arquivo SB1
			dbSelectArea('SB1')
			dbSetorder(1)
			If !dbSeek(xFilial('SB1')+cProduto,.F.)
				Help(' ',1,'NOFOUNDSB1')
				Loop
			EndIf

			//-- Posiciona o Arquivo SB8
			cLocaliza:= ""
			cLoteFor := ""
			dDtValid := CtoD('  /  /  ')
			If Rastro(cProduto)
				dbSelectArea('SB8')
				dbSetorder(3)
				If !dbSeek(xFilial('SB8')+cProduto+cLocCQ+cLoteCtl+If(Rastro(cProduto,"S"),cNLoteOrig,""), .F.)
					Help(' ',1,'NOFOUNDSB8')
					Loop
				Else
					dDtValid := B8_DTVALID
					cLoteFor := B8_LOTEFOR
					cNumDesp := B8_NUMDESP
					If Rastro(cProduto,'S')
						cNumLote := NextLote(cProduto,'S')
					Else
						cNumLote := ""
					EndIf
				EndIf
			EndIf

			//-- Grava movimento de CQ tipo 3
			If aMov[nX,1]==3 .And. lTranCQ

				//-- Subtrai a Liberacao/Rejeicao do Saldo em CQ a ser gravado
				nSaldo  -= aMov[nX,2]
				nSaldo2 -= aMov[nX,8]

				//-- Cria registro com Dados da Movimenta‡„o do CQ (SD7)
				nSeq ++
				RecLock('SD7', .T.)
				Replace D7_FILIAL  With xFilial('SD7')
				Replace D7_SEQ     With StrZero(nSeq,Len(D7_SEQ))
				Replace D7_PRODUTO With cProduto
				Replace D7_TIPO    With aMov[nX,1]
				Replace D7_QTDE    With aMov[nX,2]
				Replace D7_SALDO   With nSaldo
				Replace D7_USUARIO With CUSERNAME
				Replace D7_QTSEGUM With aMov[nX,8]
				Replace D7_SALDO2  With nSaldo2
				Replace D7_NUMSEQ  With cNumSeqTRF
				Replace D7_LOCAL   With cLocCQ
				Replace D7_LOCDEST With cLocCQ
				Replace D7_NUMERO  With cNumero
				Replace D7_DATA    With aMov[nX,4]
				Replace D7_LIBERA  With Space(Len(D7_LIBERA))
				Replace D7_LOTECTL With cLoteCtl
				Replace D7_POTENCI With nPotencia
				Replace D7_NUMLOTE With cNumLote
				Replace D7_ESTORNO With Space(Len(D7_ESTORNO))
				Replace D7_DOC     With cDoc
				Replace D7_SERIE   With cSerie
				Replace D7_FORNECE With cFornece
				Replace D7_LOJA    With cLoja
				Replace D7_ORIGLAN With cOrigLan
				Replace D7_TIPOCQ  With cTipoCQ
				//Replace D7_MOTREJE With If(aMov[nX,1]==4,aMov[nX,6],Space(Len(D7_MOTREJE)))
				//Replace D7_DTVALID With aMov[nX,Len(aNewMov[1])]
				If Len(aMov[1]) > 8
					Replace D7_LOCALIZ With aMov[nX,09]
					Replace D7_NUMSERI With aMov[nX,10]
				EndIf

				If lPrdIntWms .And. !Empty(cServWMS)
					Replace D7_SERVIC With cServWMS
				EndIf

				MsUnLock()

				// Ponto de Entrada para possibilitar recuperar informacoes da tabela SD7 no Skip-Lote da Importacao do SIGAQIE
				If lQIMPSKD7
					Execblock("QIMPSKD7",.F.,.F.)
				Endif

				//-- Incorporar a Observa‡„o a variavel cTexto
				cTexto += fGrvCQObs(aMov[nX,7],aMov[nX,1],nSeq)

			ElseIf aMov[nX,1]==5 .And. lA175Vld
				//-- Cria registro com Dados da Movimenta‡„o do CQ (SD7)
				nSeq ++
				RecLock('SD7', .T.)
				Replace D7_FILIAL  With xFilial('SD7')
				Replace D7_SEQ     With StrZero(nSeq,Len(D7_SEQ))
				Replace D7_PRODUTO With cProduto
				Replace D7_TIPO    With aMov[nX,1]
				Replace D7_QTDE    With aMov[nX,2]
				Replace D7_SALDO   With nSaldo
				Replace D7_USUARIO With CUSERNAME
				Replace D7_QTSEGUM With aMov[nX,8]
				Replace D7_SALDO2  With nSaldo2
				Replace D7_NUMSEQ  With ''
				Replace D7_LOCAL   With cLocCQ
				Replace D7_LOCDEST With IIf(!Empty(aMov[nX,3]),aMov[nX,3],cLocCQ)
				Replace D7_NUMERO  With cNumero
				Replace D7_DATA    With aMov[nX,4]
				Replace D7_LIBERA  With Space(Len(D7_LIBERA))
				Replace D7_LOTECTL With cLoteCtl
				Replace D7_POTENCI With nPotencia
				Replace D7_NUMLOTE With cNumLote
				Replace D7_ESTORNO With Space(Len(D7_ESTORNO))
				Replace D7_DOC     With cDoc
				Replace D7_SERIE   With cSerie
				Replace D7_FORNECE With cFornece
				Replace D7_LOJA    With cLoja
				Replace D7_ORIGLAN With cOrigLan
				Replace D7_TIPOCQ  With cTipoCQ
				Replace D7_MOTREJE With If(aMov[nX,1]==2,aMov[nX,6],Space(Len(D7_MOTREJE)))
				Replace D7_DTVALID With aMov[nX,Len(aNewMov[1])]
				If Len(aMov[1]) > 8
					Replace D7_LOCALIZ With aMov[nX,09]
					Replace D7_NUMSERI With aMov[nX,10]
				EndIf

				If !(aHeaderPro==Nil) .And. Len(aHeaderPro)>0
					For nY := 1 to Len(aHeader)
						If !(aHeader[nY, 10]=='V') .And. aHeaderPro[nY, 2] == 'U'
							xVar := AllTrim(aHeader[nY,2])
							Replace &xVar. With aCols[nX,nY]
						ElseIf Len(aUsrMemo) > 0
							If !(AllTrim(aHeader[nY,2]) $ 'D7_ALI_WT|D7_REC_WT') .And. (aHeader[nY, 10]=='V') .And. ;
								(aHeaderPro[nY, 2] == 'U') .And. (aHeader[nY, 8] == 'M')
								xVar := AllTrim(aHeader[nY,2])
								If (nPos := Ascan(aUsrMemo, {|x| x[2] == xVar }) ) > 0
									MSMM(xVar,,, aCols[nX, nY], 1,,, aHeader[nY, 9], aUsrMemo[nPos, 1] )
								EndIf
							EndIf
						Endif
					Next nY
				EndIf
				MsUnLock()

				// Ponto de Entrada para possibilitar recuperar informacoes da tabela SD7 no Skip-Lote da Importacao do SIGAQIE
				If lQIMPSKD7
					Execblock("QIMPSKD7",.F.,.F.)
				Endif

				//-- Posiciona o Arquivo SB8
				If Rastro(SD7->D7_PRODUTO)
					dbSelectArea('SD5')
					dbSetorder(2)
					If !dbSeek(xFilial('SD5')+SD7->D7_PRODUTO+SD7->D7_LOCDEST+SD7->D7_LOTECTL+If(Rastro(SD7->D7_PRODUTO,"S"),SD7->D7_NUMLOTE,""), .F.)
						Help(' ',1,'NOFOUNDSB8')
						Loop
					EndIf
				EndIf

				//-- Acerta a data de validade do Lote
				dbSelectArea("SD5")
				A390Valid("SD5",Recno(),4,SD7->D7_DTVALID,.T.)

				//-- Incorporar a Observa‡„o a variavel cTexto
				cTexto += fGrvCQObs(aMov[nX,7],aMov[nX,1],nSeq)


			//-- Grava movimento de CQ tipo 1 e 2
			Else

				//-- Nao considera bloqueios por Data para lotes nas Rejeicoes de CQ
				lConsVenc := If(aMov[nX,1]==2, .T., (cLOTVENC=='S'))
				//-- Nao Movimenta Quantidades Superiores ao Saldo Disponivel do Produto
				nSaldoDisp := 0
				aSerie	   := {}
				If cPaisLoc == "BRA"
					nPrdImp    := IIf(cOrigLan == "PR", SD3->D3_PERIMP, 0)
				EndIf
				If Rastro(cProduto) .Or. Localiza(cProduto)
					If Len(aMov[1]) > 8
						cLocOrig := aMov[nX,9]
						aArray := SldPorLote(cProduto, cLocCQ, aMov[nX, 2],aMov[nX, 8], cLoteCtl,cNLoteOrig,cLocOrig,aMov[nx,10],,.F.,,lConsVenc)
					Else
						aArray := SldPorLote(cProduto, cLocCQ, aMov[nX, 2],aMov[nX, 8], cLoteCtl,cNLoteOrig,,,,.F.,,lConsVenc)
					EndIf
					For nY := 1 to Len(aArray)
						nSaldoDisp += aArray[nY, 5]
						nz:=aScan(aSerie,{ |x| x[1] == aArray[nY, 4]})
						If nz <= 0
							AADD(aSerie,{aArray[nY, 4],aArray[nY, 3],aArray[nY, 5],aArray[nY, 6]})
						EndIf
					Next nY
				Else
					dbSelectArea('SB2')
					dbSetOrder(1)
					If dbSeek(xFilial('SB2')+cProduto+cLocCQ, .F.)
						nSaldoDisp += SaldoSB2()
					EndIf
					aSerie:={{"","",aMov[nX, 2],aMov[nX, 8]}}

				EndIf
				If QtdComp(aMov[nX, 2]) > QtdComp(nSaldoDisp)
					Help(' ', 1, 'SEMSALDO')
					Loop
				EndIf

				If lPrdIntWms
					If Len(aMov[nX])>=11// .And. !Empty(aMov[nx,11])
						//-- Obtem o Servico digitado pelo usuario na liberacao do CQ
						cServWMS := aMov[nx,11]
					EndIf
					If Len(aMov[nX])>=9// .And. !Empty(aMov[nx,09])
						//-- Obtem o Endereco digitado pelo usuario na liberacao do CQ
						cEndeWMS := aMov[nx,09]
					EndIf
				EndIf

				For nSerie:=1 to Len(aSerie)

					aMov[nx,2]:=aSerie[nSerie,3]
					aMov[nx,8]:=aSerie[nSerie,4]

					//-- Define o Numero Sequencial do Movimento
					cNumSeq := ProxNum()

					//-- Define o Almoxarifado de Destino
					cLocDest := If(!Empty(aMov[nX,3]),aMov[nX,3],If(aMov[nX,1]==1,RetFldProd(SB1->B1_COD,"B1_LOCPAD"),cLocCQ))

					//-- Subtrai a Liberacao/Rejeicao do Saldo em CQ a ser gravado
					nSaldo  -= aMov[nX,2]
					nSaldo2 -= aMov[nX,8]

					//-- Cria registro com Dados da Movimenta‡„o do CQ (SD7)
					nSeq ++
					RecLock('SD7', .T.)
					Replace D7_FILIAL  With xFilial('SD7')
					Replace D7_SEQ     With StrZero(nSeq,Len(D7_SEQ))
					Replace D7_PRODUTO With cProduto
					Replace D7_TIPO    With aMov[nX,1]
					Replace D7_QTDE    With aMov[nX,2]
					Replace D7_SALDO   With nSaldo
					Replace D7_USUARIO With CUSERNAME
					Replace D7_QTSEGUM With aMov[nX,8]
					Replace D7_SALDO2  With nSaldo2
					Replace D7_NUMSEQ  With cNumSeq
					Replace D7_LOCAL   With cLocCQ
					Replace D7_LOCDEST With cLocDest
					Replace D7_NUMERO  With cNumero
					Replace D7_DATA    With aMov[nX,4]
					Replace D7_LIBERA  With Space(Len(D7_LIBERA))
					Replace D7_LOTECTL With cLoteCtl
					Replace D7_POTENCI With nPotencia
					Replace D7_NUMLOTE With cNumLote
					Replace D7_ESTORNO With Space(Len(D7_ESTORNO))
					Replace D7_DOC     With cDoc
					Replace D7_SERIE   With cSerie
					Replace D7_FORNECE With cFornece
					Replace D7_LOJA    With cLoja
					Replace D7_ORIGLAN With cOrigLan
					Replace D7_TIPOCQ  With cTipoCQ
					Replace D7_MOTREJE With If(aMov[nX,1]==2,aMov[nX,6],Space(Len(D7_MOTREJE)))
					Replace D7_DTVALID With CTOD("  /  /  ")
					If Len(aMov[1]) > 8
						Replace D7_LOCALIZ With aMov[nX,09]
						Replace D7_NUMSERI With aMov[nX,10]
					EndIf
					If lPrdIntWms .And. !Empty(cServWMS)
						Replace D7_SERVIC With cServWMS
					EndIf

					If !(aHeaderPro==Nil) .And. Len(aHeaderPro)>0
						For nY := 1 to Len(aHeader)
							If !(aHeader[nY, 10]=='V') .And. aHeaderPro[nY, 2] == 'U'
								xVar := AllTrim(aHeader[nY,2])
								Replace &xVar. With aCols[nX,nY]
							ElseIf Len(aUsrMemo) > 0
								If !(AllTrim(aHeader[nY,2]) $ 'D7_ALI_WT|D7_REC_WT') .And. (aHeader[nY, 10]=='V') .And. ;
									(aHeaderPro[nY, 2] == 'U') .And. (aHeader[nY, 8] == 'M')
									xVar := AllTrim(aHeader[nY,2])
									If (nPos := Ascan(aUsrMemo, {|x| x[2] == xVar }) ) > 0
										MSMM(xVar,,, aCols[nX, nY], 1,,, aHeader[nY, 9], aUsrMemo[nPos, 1] )
									EndIf
								EndIf
							Endif
						Next nY
					EndIf

					If IntegraEIC(cDoc,cSerie,cFornece,cLoja)
						Replace D7_DOCSWN  With cDocEIC
						Replace D7_ITEMSWN With cItemEIC
					EndIf

					MsUnLock()
					nSD7Rec := Recno()

					AAdd(aSD7PMS,nSD7Rec)

					// Ponto de Entrada para possibilitar recuperar informacoes da tabela SD7 no Skip-Lote da Importacao do SIGAQIE
					If lQIMPSKD7
						Execblock("QIMPSKD7",.F.,.F.)
					Endif

					//-- Incorporar a Observa‡„o a variavel cTexto
					cTexto += fGrvCQObs(aMov[nX,7],aMov[nX,1],nSeq)

					//-- Cria as Movimentacoes de Entrada / Saida (SD3)
					For nY := 1 to 2
						//-- 'D' = Entrada / 'R' = Saida
						cTipoMov := If(nY==1,'R','D')

						//-- Posiciona (ou Cria) o Arquivo de Saldos (SB2)
						dbSelectArea('SB2')
						dbSetOrder(1)
						If !dbSeek(xFilial('SB2')+cProduto+If(cTipoMov=='D',cLocDest,cLocCQ),.F.)
							CriaSB2(cProduto,If(cTipoMov=='D',cLocDest,cLocCQ))
						EndIf

						//-- Na Saida atualiza o Campo referente a Localização Fisica
						If !lPrdIntWms
							cLocaliza := aSerie[nSerie,2]
						Else
							cLocaliza := aMov[nX,9]
						EndIf

						//-- Cria Movimentacao (E/S) (SD3)
						RecLock('SD3',.T.)
						Replace D3_FILIAL  With xFilial('SD3')
						Replace D3_COD     With cProduto
						Replace D3_QUANT   With aMov[nX,2]
						If lProCQE6
							Replace D3_CF      With If(cTipoMov=='D','DE','RE')+If(cOrigLan=='PR','6','6')
						Else
							Replace D3_CF      With If(cTipoMov=='D','DE','RE')+If(cOrigLan=='PR','4','6')
						EndIf
						Replace D3_CHAVE   With If(cTipoMov=='D','E9','E0')
						Replace D3_LOCAL   With If(cTipoMov=='D',cLocDest,cLocCQ)
						Replace D3_DOC     With SD7->D7_NUMERO
						Replace D3_EMISSAO With SD7->D7_DATA
						Replace D3_UM      With SB1->B1_UM
						Replace D3_GRUPO   With SB1->B1_GRUPO
						Replace D3_NUMSEQ  With cNumSeq
						Replace D3_QTSEGUM With SD7->D7_QTSEGUM
						Replace D3_SEGUM   With SB1->B1_SEGUM
						Replace D3_TM      With If(cTipoMov=='D','499','999')
						Replace D3_TIPO    With SB1->B1_TIPO
						Replace D3_CONTA   With SB1->B1_CONTA
						Replace D3_USUARIO With CUSERNAME
						Replace D3_NUMLOTE With If(Rastro(cProduto,'S'),If(cTipoMov=='D',cNumLote,cNLoteOrig),'')
						Replace D3_LOTECTL With If(Rastro(cProduto),cLoteCtl,'')
						Replace D3_POTENCI With nPotencia
						Replace D3_LOCALIZ With If(cTipoMov=='D',"",cLocaliza)
						Replace D3_NUMSERI With If(cTipoMov=='D',"",aSerie[nSerie,1])
						Replace D3_IDENT   With cNSeqOrig
						Replace D3_DTVALID With dDtValid
						If cPaisLoc == "BRA"
							Replace D3_PERIMP  With nPrdImp
						EndIf 	
						If IntegraEIC(cDoc,cSerie,cFornece,cLoja)
							Replace D3_DOCSWN  With cDocEIC
							Replace D3_ITEMSWN With cItemEIC
						EndIf
						//-- Gera o Servico de WMS com o Servico/Endereco/Estrutura digitados na NF de entrada ou na Movimentacao do CQ
						If lPrdIntWms .And. !Empty(cServWMS)
							Replace D3_SERVIC With cServWMS
							Replace D3_STSERV With "1"
						EndIf
						MsUnLock()
						nSD3Rec := Recno()

						//-- Grava o custo da movimentacao
						aCusto := GravaCusD3(aCM)

						//-- Atualiza o saldo atual no Local Origem (VATU) com os dados do SD3
						B2AtuComD3(aCusto,,,,,lConsVenc,,,,,,,,,,,,,,,,,,,,,,,cLoteFor,cNumDesp,cOriglan,,(len(aDespAgreg) > 0))

						//--Atualiza saldo de terceiros /em terceiros
						If  lUtil175 .And. !Empty(cNSeqOrig)
							SD1->(dbSetOrder(4))
							SD1->(MsSeek(xFilial("SD1")+cNSeqOrig))
							If !Empty(SD1->D1_TES)
								dbSelectArea('SF4')
								dbSetOrder(1)
								MsSeek(xFilial("SF4")+SD1->D1_TES)
								//-- 'D' = Entrada / "R" = Saida
								If SF4->F4_PODER3 == "R"
									If SF4->F4_ESTOQUE == "S"
										RecLock('SB2',.F.)
										Replace B2_QTNP  With B2_QTNP + (If(cTipoMov=="R",-1,1) * aMov[nX,2])
										MsUnLock()
									Else
										RecLock('SB2',.F.)
										Replace B2_QTER  With B2_QTER + (If(cTipoMov=="R",-1,1) * aMov[nX,2])
										MsUnLock()
									EndIf
								EndIf
							EndIf
						EndIf

						If ny == 2 .And. cOriglan == "PR" .And. !Localiza(SD3->D3_COD) .And. (SD3->D3_LOCAL != cLocCQ)
							SD3->(dbsetorder(3))
							SD3->(dbSeek(xFilial("SD3")+cProduto+cLocCQ+cNSeqOrig))
							SF5->(dbsetorder(1))
							If SF5->(dbSeek(xFilial("SF5")+SD3->D3_TM)) .And. SF5->F5_LIBPVPR == "S"
								SC2->(dbSetOrder(1))
								If SC2->(dbSeek(xFilial("SC2")+SD3->D3_OP)) .And. !Empty(SC2->C2_PEDIDO)
									If SC6->(dbSeek(xFilial("SC6")+SC2->C2_PEDIDO+SC2->C2_ITEMPV)) .And. Empty(SC6->C6_QTDRESE)
										nQtdaLib:=(SC6->C6_QTDVEN - SC6->C6_QTDEMP - SC6->C6_QTDENT)
										MALibDoFat(SC6->(Recno()),Min(aMov[nx,2],nQtdAlib),.F.,.F.,.T.,.T.)
										MaLiberOk({SC2->C2_PEDIDO})
									EndIf
								EndIf
							EndIf
						EndIf
					Next nY

					If lPrdIntWms
						If !(lRet := WmsIntCQ(nSD7Rec))
							If InTransact()
    					    	DisarmTransaction()
    						EndIf
							Exit
						EndIf
					EndIf
					If lRet
						//-- Caso item da NF seja para OP, grava o numero da OP na requisicao.
						dbSelectArea('SD1')
						dbSetOrder(2)
						If cOrigLan == 'CP' .And. aMov[nX,1]==1 .And. dbSeek(cSeekSD1:=xFilial('SD1')+SD7->D7_PRODUTO+SD7->D7_DOC+SD7->D7_SERIE+SD7->D7_FORNECE+SD7->D7_LOJA, .F.) .And. !Empty(D1_OP)
							//-- Garante o posicionamento correto do registro no SD1
							lAchouD1  := .F.
							cLocaliza := '' //-- A RE5 nao sabe de qual Localizacao Retirar
							Do While !Eof() .And. cSeekSD1 == D1_FILIAL+D1_COD+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA
								If SD7->D7_NUMERO == D1_NUMCQ .And. !Empty(D1_OP)
									lAchouD1 := .T.
									Exit
								EndIf
								dbSkip()
							EndDo
							//-- Posiciona tabela SC2
							If lAchouD1
								If !SC2->(MsSeek(xFilial("SC2")+SD1->D1_OP))
									lAchouC2 := .F.
								EndIf
							EndIf

							If lAchouD1 .And. lAchouC2 .And. !Localiza(cProduto,.T.)
								//-- Gera Movimentação (S) RE5 Ref. a OP no SD1 (SD3)
								RecLock('SD3', .T.)
								Replace D3_FILIAL  With xFilial('SD3')
								Replace D3_COD     With cProduto
								Replace D3_QUANT   With aMov[nX,2]
								Replace D3_CF      With 'RE5'
								Replace D3_CHAVE   With 'E0'
								Replace D3_LOCAL   With cLocDest
								Replace D3_DOC     With SD7->D7_NUMERO
								Replace D3_EMISSAO With SD7->D7_DATA
								Replace D3_UM      With SB1->B1_UM
								Replace D3_GRUPO   With SB1->B1_GRUPO
								Replace D3_NUMSEQ  With SD7->D7_NUMSEQ
								Replace D3_QTSEGUM With SD7->D7_QTSEGUM
								Replace D3_SEGUM   With SB1->B1_SEGUM
								Replace D3_TM      With '999'
								Replace D3_TIPO    With SB1->B1_TIPO
								Replace D3_CONTA   With SB1->B1_CONTA
								Replace D3_USUARIO With CUSERNAME
								Replace D3_OP      With SD1->D1_OP
								Replace D3_NUMLOTE With If(Rastro(cProduto,'S'),cNumLote,'')
								Replace D3_LOTECTL With If(Rastro(cProduto),cLoteCtl,'')
								Replace D3_POTENCI With nPotencia
								Replace D3_LOCALIZ With If(cTipoMov=='D',"",cLocaliza)
								Replace D3_NUMSERI With If(cTipoMov=='D',"",aSerie[nSerie,1])
								Replace D3_IDENT   With cNSeqOrig
								Replace D3_DTVALID With dDtValid
								If IntegraEIC(SD7->D7_DOC,SD7->D7_SERIE,SD7->D7_FORNECE,SD7->D7_LOJA)
									Replace D3_DOCSWN  With cDocEIC
									Replace D3_ITEMSWN With cItemEIC
								EndIf
								MsUnlock()
								nSD3Rec := Recno()

								//-- Grava o custo da movimentacao
								aCusto := GravaCusD3(aCM)

								dbSelectArea("SD4")
								dbSetOrder(1)
								If MsSeek(xFilial()+SD1->D1_COD+SD1->D1_OP)
									nQtde := IIf(SD4->D4_QUANT < SD3->D3_QUANT,SD4->D4_QUANT,SD3->D3_QUANT)
									RecLock("SD4",.F.)
									SD4->D4_QUANT	:= SD4->D4_QUANT - nQtde
									SD4->D4_QTSEGUM	:= SD4->D4_QTSEGUM - ConvUM(SD4->D4_COD, nQtde, 0, 2)
									dbSelectArea("SB2")
									dbSetOrder(1)
									If MsSeek(xFilial()+SD4->D4_COD+SD4->D4_LOCAL)
										RecLock("SB2",.F.)
										nQtde := IIf(nQtde==NIL,SD1->D1_QUANT,nQtde)
										Replace B2_QEMP  With B2_QEMP - nQtde
										Replace B2_QEMP2 With B2_QEMP2 - ConvUM(SB2->B2_COD, nQtde, 0, 2)
									EndIf
								EndIf

								//-- Atualiza o saldo atual (VATU) com os dados do SD3
								B2AtuComD3(aCusto,,,,,lConsVenc)

								//-- Acerta custo da OP relacionada na NF de Entrada
								If !Empty(SD3->D3_OP)
									C2AtuComD3(aCusto)
								EndIf
							EndIf
						EndIf

						//-- Processa Despesas Agregadas
						If !(aMov[nX,5]=='S')
							For nY := 1 To Len(aDespAgreg)
								nItens     := 0
								aTotCompra := {0,0,0,0,0}
								aCusto     := {0,0,0,0,0}
								aValDesp   := {0,0,0,0,0}

								//-- Obtem na NF de Entrada o custo a ser Agregado no CQ
								If cOrigLan == 'CP'
									dbSelectArea('SD1')
									dbSetorder(2)
									If dbSeek(cSeekSD1:=xFilial('SD1')+aDespAgreg[nY,1]+aDespAgreg[nY,2]+aDespAgreg[nY,3]+aDespAgreg[nY,4]+aDespAgreg[nY,5], .F.)
										Do While !Eof() .And. cSeekSD1 == D1_FILIAL+D1_COD+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA
											If D1_NUMCQ == SD7->D7_NUMERO
												aValDesp[1] += D1_CUSTO
												aValDesp[2] += D1_CUSTO2
												aValDesp[3] += D1_CUSTO3
												aValDesp[4] += D1_CUSTO4
												aValDesp[5] += D1_CUSTO5
											EndIf
											dbSkip()
										EndDo
									Else
										Loop
									EndIf
								ElseIf cOrigLan == 'IM'
									nSD3OrdAnt := SD3->(IndexOrd())
									SD3->(dbSetOrder(3))
									If SD3->(dbSeek(cSeek:=xFilial('SD3')+aDespAgreg[nY, 1]+cLocCQ+aDespAgreg[nY, 6], .F.))
										nQuantSD3 := 0
										Do While !SD3->(Eof()) .And. AllTrim(cSeek)==AllTrim(SD3->D3_FILIAL+SD3->D3_COD+SD3->D3_LOCAL+SD3->D3_NUMSEQ)
											lEIC := IntegraEIC(SD7->D7_DOC,SD7->D7_SERIE,SD7->D7_FORNECE,SD7->D7_LOJA)
											If If(lEIC,SD3->D3_ITEMSWN==cItemEIC,If(Rastro(SD3->D3_COD),SD7->D7_LOTECTL == SD3->D3_LOTECTL,.T.))
												aValDesp[1] += SD3->D3_CUSTO1
												aValDesp[2] += SD3->D3_CUSTO2
												aValDesp[3] += SD3->D3_CUSTO3
												aValDesp[4] += SD3->D3_CUSTO4
												aValDesp[5] += SD3->D3_CUSTO5
											EndIf
											SD3->(dbSkip())
										EndDo
									Else
										SD3->(dbSetOrder(nSD3OrdAnt))
										Loop
									EndIf
									SD3->(dbSetOrder(nSD3OrdAnt))
								EndIf

								aCusto[1] := aValDesp[1]
								aCusto[2] := aValDesp[2]
								aCusto[3] := aValDesp[3]
								aCusto[4] := aValDesp[4]
								aCusto[5] := aValDesp[5]

								//-- Verifica se existe mais de 1 item deste produto na NF de Entrada
								If cOrigLan == 'CP' .And. dbSeek(cSeek := xFilial('SD1') +aDespAgreg[nY,1]+aDespAgreg[nY,2]+aDespAgreg[nY,3]+aDespAgreg[nY,4]+aDespAgreg[nY,5], .F.)
									nTargRec := Recno()
									cOpCompl := SD1->D1_OP
									Do While !Eof() .And. cSeek == D1_FILIAL+D1_COD+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA
										If D1_NUMCQ == SD7->D7_NUMERO
											nItens++
											aTotCompra[1] += D1_CUSTO
											aTotCompra[2] += D1_CUSTO2
											aTotCompra[3] += D1_CUSTO3
											aTotCompra[4] += D1_CUSTO4
											aTotCompra[5] += D1_CUSTO5
										EndIf
										dbSkip()
									EndDo

									//-- Rateia o custo pela NF de Compra
									If nItens > 1
										MsGoto(nTargRec)
										Do While !Eof() .And. cSeek == D1_FILIAL+D1_COD+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA
											If SD7->D7_NUMERO == D1_NUMCQ
												aCusto[1] := Round(aValDesp[1] * D1_CUSTO/aTotCompra[1], aDecCusD3[1])
												aCusto[2] := Round(aValDesp[2] * D1_CUSTO/aTotCompra[2], aDecCusD3[2])
												aCusto[3] := Round(aValDesp[3] * D1_CUSTO/aTotCompra[3], aDecCusD3[3])
												aCusto[4] := Round(aValDesp[4] * D1_CUSTO/aTotCompra[4], aDecCusD3[4])
												aCusto[5] := Round(aValDesp[5] * D1_CUSTO/aTotCompra[5], aDecCusD3[5])
												Exit
											EndIf
											dbSkip()
										EndDo
									EndIf
								ElseIf cOrigLan == 'IM' .And. QtdComp(nQuantSD3)>QtdComp(nQuant)
									aCusto[01] := (aCusto[01]/nQuantSD3)*nQuant
									aCusto[02] := (aCusto[02]/nQuantSD3)*nQuant
									aCusto[03] := (aCusto[03]/nQuantSD3)*nQuant
									aCusto[04] := (aCusto[04]/nQuantSD3)*nQuant
									aCusto[05] := (aCusto[05]/nQuantSD3)*nQuant
								EndIf

								//-- Atribui ao Custo o Percentual da Quantidade Total
								aCusto[01] := Round(aCusto[01] * (SD7->D7_QTDE/nQuant), aDecCusD3[1])
								aCusto[02] := Round(aCusto[02] * (SD7->D7_QTDE/nQuant), aDecCusD3[2])
								aCusto[03] := Round(aCusto[03] * (SD7->D7_QTDE/nQuant), aDecCusD3[3])
								aCusto[04] := Round(aCusto[04] * (SD7->D7_QTDE/nQuant), aDecCusD3[4])
								aCusto[05] := Round(aCusto[05] * (SD7->D7_QTDE/nQuant), aDecCusD3[5])

								//-- Recalcula o Custo p/Acerto de Arredondamento na Ultima Movimentacao
								If QtdComp(nSaldo) == QtdComp(0)
									aCusDASD3 := aClone(TotD3QC(cProduto, cLocDest, SD7->D7_NUMERO, aDespAgreg[nY, 6], .T.)[2])
									aCusto[01] := Round(QtdComp(aValDesp[1]-aCusDASD3[1]), aDecCusD3[1])
									aCusto[02] := Round(QtdComp(aValDesp[2]-aCusDASD3[2]), aDecCusD3[2])
									aCusto[03] := Round(QtdComp(aValDesp[3]-aCusDASD3[3]), aDecCusD3[3])
									aCusto[04] := Round(QtdComp(aValDesp[4]-aCusDASD3[4]), aDecCusD3[4])
									aCusto[05] := Round(QtdComp(aValDesp[5]-aCusDASD3[5]), aDecCusD3[5])
								EndIf

								For nZ := 1 to 2
									cTipoMov := If(nZ==1,'R','D')

									//-- Cria Movimenta‡„o (E/S) Ref. a Despesa Agregada (SD3)
									RecLock('SD3',.T.)
									Replace D3_FILIAL  With xFilial('SD3')
									Replace D3_COD     With cProduto
									Replace D3_QUANT   With 0
									Replace D3_CF      With If(cTipoMov=='D','DE','RE')+If(cOrigLan=='PR','4','6')
									Replace D3_CHAVE   With If(cTipoMov=='D','E9','E0')
									Replace D3_LOCAL   With If(cTipoMov=='D',cLocDest,cLocCQ)
									Replace D3_DOC     With SD7->D7_NUMERO
									Replace D3_EMISSAO With SD7->D7_DATA
									Replace D3_UM      With SB1->B1_UM
									Replace D3_GRUPO   With SB1->B1_GRUPO
									Replace D3_NUMSEQ  With SD7->D7_NUMSEQ
									Replace D3_QTSEGUM With 0
									Replace D3_SEGUM   With SB1->B1_SEGUM
									Replace D3_TM      With If(cTipoMov=='D','499','999')
									Replace D3_TIPO    With SB1->B1_TIPO
									Replace D3_CONTA   With SB1->B1_CONTA
									Replace D3_LOCALIZ With If(cTipoMov=='D',"",cLocaliza)
									Replace D3_NUMSERI With If(cTipoMov=='D',"",aSerie[nSerie,1])
									Replace D3_IDENT   With aDespAgreg[nY, 6]
									Replace D3_USUARIO With CUSERNAME
									Replace D3_NUMLOTE With If(Rastro(cProduto,'S'),If(cTipoMov=='D',cNumLote,cNLoteOrig),'')
									Replace D3_LOTECTL With If(Rastro(cProduto),cLoteCtl,'')
									Replace D3_POTENCI With nPotencia
									If IntegraEIC(SD7->D7_DOC,SD7->D7_SERIE,SD7->D7_FORNECE,SD7->D7_LOJA)
										Replace D3_DOCSWN  With cDocEIC
										Replace D3_ITEMSWN With cItemEIC
									EndIf
									MsUnlock()
									nSD3Rec := Recno()

									//-- Grava o Custo da Movimenta‡„o
									GravaCusD3(aCusto, .T.)

									//-- Atualiza o saldo atual (VATU) com os dados do SD3
									B2AtuComD3(aCusto,,,,,lConsVenc)


									If nz == 2 .And. !Empty(cOpCompl)
										//-- Gera Movimenta‡„o (S) RE5 Ref. a OP no SD1 (SD3)
										RecLock('SD3', .T.)
										Replace D3_FILIAL  With xFilial('SD3')
										Replace D3_COD     With cProduto
										Replace D3_QUANT   With 0
										Replace D3_CF      With 'RE5'
										Replace D3_CHAVE   With 'E0'
										Replace D3_LOCAL   With cLocDest
										Replace D3_DOC     With SD7->D7_NUMERO
										Replace D3_EMISSAO With SD7->D7_DATA
										Replace D3_UM      With SB1->B1_UM
										Replace D3_GRUPO   With SB1->B1_GRUPO
										Replace D3_NUMSEQ  With SD7->D7_NUMSEQ
										Replace D3_QTSEGUM With SD7->D7_QTSEGUM
										Replace D3_SEGUM   With SB1->B1_SEGUM
										Replace D3_TM      With '999'
										Replace D3_TIPO    With SB1->B1_TIPO
										Replace D3_CONTA   With SB1->B1_CONTA
										Replace D3_USUARIO With CUSERNAME
										Replace D3_OP      With cOpCompl
										Replace D3_NUMLOTE With If(Rastro(cProduto,'S'),cNumLote,'')
										Replace D3_LOTECTL With If(Rastro(cProduto),cLoteCtl,'')
										Replace D3_POTENCI With nPotencia
										Replace D3_LOCALIZ With If(cTipoMov=='D',"",cLocaliza)
										Replace D3_NUMSERI With If(cTipoMov=='D',"",aSerie[nSerie,1])
										Replace D3_IDENT   With aDespAgreg[nY, 6]
										Replace D3_DTVALID With dDtValid
										If IntegraEIC(SD7->D7_DOC,SD7->D7_SERIE,SD7->D7_FORNECE,SD7->D7_LOJA)
											Replace D3_DOCSWN  With cDocEIC
											Replace D3_ITEMSWN With cItemEIC
										EndIf
										MsUnlock()
										nSD3Rec := Recno()
										//-- Grava o custo da movimentacao
										aCusto := GravaCusD3(aCusto,.T.)
										//-- Atualiza o saldo atual (VATU) com os dados do SD3
										B2AtuComD3(aCusto,,,,,lConsVenc)
										//-- Acerta custo da OP relacionada na NF de Entrada
										If !Empty(SD3->D3_OP)
											C2AtuComD3(aCusto)
										EndIf
									EndIf
								Next nZ
							Next nY
						Endif
					EndIf
				Next nSerie
			EndIf
			If !lRet
				Exit
			EndIf
		Next nX

	ElseIf lRet

		//-- Estornos
		For nX := 1 to Len(aMov)

			//-- Processa somente Estornados
			If !(aMov[nX,5]=='X')
				Loop
			EndIf

			//-- Processa Somente Registros Tipo 1, 2 ou 3
			If !(aMov[nX,1]==1) .And. !(aMov[nX,1]==2) .And. IIf(lTranCQ,!(aMov[nX,1]==3),.T.)
				Loop
			EndIf

			//-- Posiciona o Arquivo SB1
			dbSelectArea('SB1')
			dbSetOrder(1)
			If !dbSeek(xFilial('SB1')+cProduto,.F.)
				Help(' ',1,'NOFOUNDSB1')
				Loop
			EndIf

			//-- Posiciona o Arquivo SB8
			dDtValid := CtoD('  /  /  ')
			cNumLote := ''
			If Rastro(cProduto)
				dbSelectArea('SB8')
				dbSetOrder(3)
				If !dbSeek(xFilial('SB8') + cProduto + cLocCQ + cLoteCtl, .F.)
					Help(' ',1,'NOFOUNDSB8')
					Loop
				Else
					dDtValid := B8_DTVALID
					If Rastro(cProduto,'S')
						cNumLote := B8_NUMLOTE
					EndIf
				EndIf
			EndIf

			//-- Posiciona o Arquivo SD7
			dbSelectArea('SD7')
			dbSetOrder(1)
			If nRecTrfCQ > 0
				MsGoto(nRecTrfCQ)
			Else
				MsGoto(aAnterior[nX])
			EndIf

			//-- Impede Estornos de Movimentacoes Feitas Antes do Ultimo Fechamento
			If D7_DATA < dDtUlFec
				Help(' ', 1, 'FECHTO')
				Loop
			EndIf

			//-- Define o Numero Sequencial do Movimento
			cNumSeq := D7_NUMSEQ

			//-- Define o Almoxarifado de Destino
			cLocDest := D7_LOCAL

			//-- Atualiza os Saldos a serem gravados
			nSaldo  += aMov[nX,2]
			nSaldo2 += aMov[nX,8]

			//-- Marca a Movimentação Atual como Estornada
			RecLock('SD7', .F.)
			Replace D7_ESTORNO With 'S'
			MsUnlock()

			// Processa o estorno do Tipo 3
			If aMov[nX,1]==3 .And. lTranCQ

				//-- Cria registro com Dados do Estorno (SD7)
				nSeq ++
				RecLock('SD7', .T.)
				Replace D7_FILIAL  With xFilial('SD7')
				Replace D7_SEQ     With StrZero(nSeq,3)
				Replace D7_PRODUTO With cProduto
				Replace D7_TIPO    With 4
				Replace D7_QTDE    With aMov[nX,2]
				Replace D7_SALDO   With nSaldo
				Replace D7_USUARIO With CUSERNAME
				Replace D7_QTSEGUM With aMov[nX,8]
				Replace D7_SALDO2  With nSaldo2
				Replace D7_NUMSEQ  With cNumSeq
				Replace D7_LOCAL   With cLocCQ
				Replace D7_LOCDEST With cLocCQ
				Replace D7_NUMERO  With cNumero
				Replace D7_DATA    With dDataBase
				Replace D7_LIBERA  With Space(Len(D7_LIBERA))
				Replace D7_LOTECTL With cLoteCtl
				Replace D7_POTENCI With nPotencia
				Replace D7_NUMLOTE With cNumLote
				Replace D7_ESTORNO With 'S'
				Replace D7_DOC     With cDoc
				Replace D7_SERIE   With cSerie
				Replace D7_FORNECE With cFornece
				Replace D7_LOJA    With cLoja
				Replace D7_ORIGLAN With cOrigLan
				Replace D7_TIPOCQ  With cTipoCQ
				MsUnLock()
				nSD7Rec := Recno()

				// Ponto de Entrada para possibilitar recuperar informacoes da tabela SD7 no Skip-Lote da Importacao do SIGAQIE
				If lQIMPSKD7
					Execblock("QIMPSKD7",.F.,.F.)
				Endif

				//-- Incorporar a Observa‡„o a variavel cTexto
				cTexto += fGrvCQObs(aMov[nX,7],iIf(aMov[nX,1]==1,6,7),nSeq)

			// Processa o estorno do Tipo 1 e 2
			Else

				AAdd(aSD7PMS,RECNO())

				//-- Cria registro com Dados do Estorno (SD7)
				nSeq ++
				RecLock('SD7', .T.)
				Replace D7_FILIAL  With xFilial('SD7')
				Replace D7_SEQ     With StrZero(nSeq,3)
				Replace D7_PRODUTO With cProduto
				Replace D7_TIPO    With If(aMov[nX,1]==1,6,7)
				Replace D7_QTDE    With aMov[nX,2]
				Replace D7_SALDO   With nSaldo
				Replace D7_USUARIO With CUSERNAME
				Replace D7_QTSEGUM With aMov[nX,8]
				Replace D7_SALDO2  With nSaldo2
				Replace D7_NUMSEQ  With cNumSeq
				Replace D7_LOCAL   With cLocCQ
				Replace D7_LOCDEST With cLocDest
				Replace D7_NUMERO  With cNumero
				Replace D7_DATA    With dDataBase
				Replace D7_LIBERA  With Space(Len(D7_LIBERA))
				Replace D7_LOTECTL With cLoteCtl
				Replace D7_POTENCI With nPotencia
				Replace D7_NUMLOTE With cNumLote
				Replace D7_ESTORNO With 'S'
				Replace D7_DOC     With cDoc
				Replace D7_SERIE   With cSerie
				Replace D7_FORNECE With cFornece
				Replace D7_LOJA    With cLoja
				Replace D7_ORIGLAN With cOrigLan
				Replace D7_TIPOCQ  With cTipoCQ
				Replace D7_MOTREJE With Space(Len(D7_MOTREJE))
				If !(aHeaderPro==Nil) .And. Len(aHeaderPro) > 0
					For nY := 1 to Len(aHeader)
						If !(aHeader[nY, 10]=='V') .And. aHeaderPro[nY, 2]=='U'
							xVar := AllTrim(aHeader[nY, 2])
							If xVar # "D7_DOCSWN" .And. xVar # "D7_ITEMSWN"
								Replace &xVar. With aCols[nX, nY]
							EndIf
						ElseIf Len(aUsrMemo) > 0
							If !(AllTrim(aHeader[nY,2]) $ 'D7_ALI_WT|D7_REC_WT') .And. (aHeader[nY, 10]=='V') .And. ;
								(aHeaderPro[nY, 2] == 'U') .And. (aHeader[nY, 8] == 'M')
								xVar := AllTrim(aHeader[nY,2])
								If (nPos := Ascan(aUsrMemo, {|x| x[2] == xVar }) ) > 0
									MSMM(xVar,,, aCols[nX, nY], 1,,, aHeader[nY, 9], aUsrMemo[nPos, 1] )
								EndIf
							Endif
						Endif
					Next nY
				EndIf

				If IntegraEIC(cDoc,cSerie,cFornece,cLoja)
					Replace D7_DOCSWN  With cDocEIC
					Replace D7_ITEMSWN With cItemEIC
				EndIf

				MsUnLock()
				nSD7Rec := Recno()

				// Ponto de Entrada para possibilitar recuperar informacoes da tabela SD7 no Skip-Lote da Importacao do SIGAQIE
				If lQIMPSKD7
					Execblock("QIMPSKD7",.F.,.F.)
				EndIf

				//-- Incorporar a Observação a variavel cTexto
				cTexto += fGrvCQObs(aMov[nX,7],iIf(aMov[nX,1]==1,6,7),nSeq)

				//-- Estorna Movimentações (SD3)
				SD3->(dbSetOrder(4))
				SD3->(dbSeek(cSeekSD3:=xFilial('SD3')+cNumSeq, .F.))
				aEstorna := {}
				cCF := 'RE4úDE4úRE6úDE6' + If(!Localiza(cProduto),'úRE5úDE5',"")
				Do While SD3->(!Eof()) .And. cSeekSD3 == SD3->D3_FILIAL+SD3->D3_NUMSEQ
					If SD3->D3_CF $ cCF .And. Empty(SD3->D3_ESTORNO)
						aAdd(aEstorna, {SD3->(Recno()), SD3->D3_CHAVE})
					EndIf
					SD3->(dbSkip())
				EndDo

				//-- Ordena as movimentacoes para processar o estorno corretamente
				//-- Como o saldo ja foi validado, estorna primeiro saidas para evitar
				//-- alertas de saldo indevidos.
				aSort(aEstorna,,, {|x, y| x[2] < y[2]})

				//-- Estorna lancamentos no SD3
				For nY := 1 To Len(aEstorna)
					dbSelectArea('SD3')
					MsGoto(aEstorna[nY, 1])

					//-- Impede Estornos de Movimentacoes Feitas Antes do Ultimo Fechamento
					If D3_EMISSAO < dDtUlFec
						Help(' ', 1, 'FECHTO')
						Loop
					EndIf

					RecLock('SD3', .F.)
					Replace D3_ESTORNO With 'S'
					MsUnLock()

					//-- Cria o registro de estorno com mesmos dados do original
					For nZ := 1 To SD3->(fCount())
						M->&(EVal(bCampo,nZ)) := SD3->(FieldGet(nZ))
					Next nZ
					RecLock('SD3', .T.)
					For nZ := 1 To FCount()
						FieldPut(nZ, M->&(EVAL(bCampo,nZ)))
					Next nZ
					cTipoMov := If(Left(D3_CF,1)=='D','R','D') //-- 'D' = Entrada / 'R' = Saida
					Replace D3_CF       With cTipoMov + Subs(D3_CF,2,2)
					Replace D3_TM       With If(cTipoMov=='D','499','999')
					Replace D3_CHAVE    With If(cTipoMov=='D','E9','E0')
					Replace D3_USUARIO  With CUSERNAME
					MsUnLock()
					nSD3Rec := Recno()

					//-- Pega o custo da movimentacao
					aCusto := PegaCusD3()

					//-- Atualiza o saldo atual (VATU) com os dados do SD3
					B2AtuComD3(aCusto)

					//--Atualiza saldo de terceiros /em terceiros
					If  lUtil175 .And. !Empty(cNSeqOrig)
						SD1->(dbSetOrder(4))
						SD1->(MsSeek(xFilial("SD1")+cNSeqOrig))
						If !Empty(SD1->D1_TES)
							dbSelectArea('SF4')
							dbSetOrder(1)
							MsSeek(xFilial("SF4")+SD1->D1_TES)
							//-- 'D' = Entrada / 'R' = Saida
							If SF4->F4_PODER3 == "R"
								If SF4->F4_ESTOQUE == "S"
									RecLock('SB2',.F.)
									Replace B2_QTNP  With B2_QTNP + (If(cTipoMov=="R",-1,1) * aMov[nX,2])
									MsUnLock()
								Else
									RecLock('SB2',.F.)
									Replace B2_QTER  With B2_QTER + (If(cTipoMov=="R",-1,1) * aMov[nX,2])
									MsUnLock()
								EndIf
							EndIf
						EndIf
					EndIf

				//-- Acerta custo da OP relacionada na NF de Entrada
					If !Empty(D3_OP)
						C2AtuComD3(aCusto)
					EndIf
				Next nY

				If lPrdIntWms
					If !(lRet := WmsEstCQ(aAnterior[nX],nSD3Rec))
						Exit
					EndIf
				EndIf
			EndIf

		Next nX

	EndIf

	//-- Somente se houve Movimentação
	If lRet .And. (lEstorno .Or. nSeq>Len(aAnterior))
		//-- Posiciona sobre o Registro Tipo 0
		dbSelectArea('SD7')
		dbSetOrder(1)
		dbSeek(cSeekSD7)
		nEstorno := 0
		Do While !Eof() .And. cSeekSD7 == D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL
			//-- Verifica se existem Estornos
			nEstorno += If(D7_TIPO>=1.And.D7_ESTORNO=='S',1,0)

			//-- Libera os produtos sem Saldo ou Retira Liberacao de Produtos com Saldo
			If QtdComp(nSaldo)==QtdComp(0) .And. !(D7_LIBERA=='S')
				RecLock('SD7',.F.)
				Replace D7_LIBERA With 'S'
				MsUnlock()
			ElseIf !(QtdComp(nSaldo)==QtdComp(0)) .And. !Empty(D7_LIBERA)
				RecLock('SD7',.F.)
				Replace D7_LIBERA With ''
				MsUnlock()
			EndIf

			dbSkip()
		EndDo

		dbSeek(xFilial('SD7')+cNumero+cProduto+cLocCQ+'001', .F.)

		//-- Se existir algum Estorno marca o D7_ESTORNO do Tipo ZERO com "S"
		If nEstorno>0 .And. !(D7_ESTORNO=='S')
			RecLock('SD7',.F.)
			Replace D7_ESTORNO With 'S'
			MsUnlock()
		ElseIf nEstorno == 0 .And. !Empty(D7_ESTORNO)
			RecLock('SD7',.F.)
			Replace D7_ESTORNO With ''
			MsUnlock()
		EndIf

		//-- Atualiza o campo D1_SKIPLOT no arquivo de Movimentos SD1
		If D7_ORIGLAN == 'CP'
			dbSelectArea('SD1')
			dbSetOrder(2)
			If dbSeek(xFilial('SD1')+SD7->D7_PRODUTO+SD7->D7_DOC+SD7->D7_SERIE+SD7->D7_FORNECE+SD7->D7_LOJA	,.F.)
				If SD7->D7_LIBERA == 'S' .And. !Empty(D1_SKIPLOT)
					RecLock('SD1',.F.)
					Replace D1_SKIPLOT With ''
					MsUnLock()
				ElseIf Empty(SD7->D7_LIBERA) .And. !(D1_SKIPLOT=='S')
					RecLock('SD1',.F.)
					Replace D1_SKIPLOT With 'S'
					MsUnLock()
				EndIf
			Else
				If cPaisLoc == "BRA"
					Help(' ',1,'NOPRD1',,SD7->D7_PRODUTO)
				EndIf
			EndIf
		EndIf
	ElseIf lRet .And. !lEstorno .And. nSeq<=Len(aAnterior)
		//-- Caso nao tenha havido nenhuma movimentacao
		lRet := .F.
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Integracao com PMS                                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRet .And. IntePMS() .And. ExisteSx2('AFO') .And. Type('aRatAFO')=='A'
		DbSelectArea("AFO")
		SD1->(DBSETORDER(4))
		SD1->(MsSeek(xFilial()+SD7->D7_NUMSEQ))
		For nX:=	1	To Len(aSD7PMS)
			SD7->(MsGoTo(aSD7PMS[nX]))
			cChaveAFN	:=	xFilial('AFN')+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_ITEM
			dbSelectArea("AFN")
			dbSetOrder(2)
			If SD7->D7_TIPO == 1
				If  SD7->D7_ESTORNO <> "S"
					If Len(aRatAFO) > 0 .And. aScan(aRatAFO,{|x| x[1]==SD7->D7_SEQ}) > 0
						PMSWriteAFO(SD7->D7_TIPO,aRatAFO[aScan(aRatAFO,{|x| x[1]==SD7->D7_SEQ})][2])
						While !AFN->(EOF()) .And.;
							 AFN->AFN_FILIAL+AFN->AFN_DOC+AFN->AFN_SERIE+AFN->AFN_FORNEC+AFN->AFN_LOJA+AFN->AFN_ITEM ==cChaveAFN
							PmsAvalAFN("AFN",1)
							AFN->(DbSkip())
						Enddo
					EndIf
				Else
					PMSWriteAFO(2,,,,@aRecsAFO,@aRecsAFN)
					For nY := 1 To Len(aRecsAFN)
						AFN->(MsGoTo(aRecsAFN[nY]))
						PmsAvalAFN("AFN",2)
					Next nY
					PMSWriteAFO(3,,,,@aRecsAFO)
				Endif
			Endif
		Next
	EndIf

End Transaction

//-- Grava as Observa‡”es no Arquivo Texto (Se nÆo houver, deleta o arquivo)
If !(nModulo == 21)      // SIGAQIE
	If lArqCQ
		If Len(cTexto)>0
			If !MemoWrit(cDirCQ+cArqCQ, cTexto)
				Help(' ',1,'MEMOERRO')
			EndIf
		ElseIf fErase(cDirCQ+cArqCQ) == -1
			Help(' ',1,'MEMOERRO')
		EndIf
	EndIf
EndIf
//-- Retorna a Integridade do Sistema
RestArea(aAreaSD7)
RestArea(aAreaSD3)
RestArea(aAreaSD1)
RestArea(aAreaSB8)
RestArea(aAreaSB2)
RestArea(aAreaSB1)
RestArea(aAreaAnt)

Return lRet

/*/{Protheus.doc} fGrvCQobs
	(long_description)
	@type  Function
	@author reynaldo
	@since 04/12/2020
	@version version
	@param cObs, caracter, Informações preenchidas na celula de observacao
	@param cTipo, caracter, d7_tipo informado
	@return cTexto, caracter, Texto formatado ser gravado no campo memo
	/*/
Static Function fGrvCQobs(cObs ,nTipo ,nSeq )
Local nTamMaxObs
Local cTexto := ""

If !Empty(cObs)
	nTamMaxObs := 0
	Do While nTamMaxObs <= 4096
		nTamMaxObs ++
		cObs := RTRim(cObs)
		If Right(cObs,1) $ CHR(13)+CHR(10)+CHR(13)+CHR(141)
			cObs := Left(cObs, Len(cObs)-1)
		Else
			Exit
		EndIf
	EndDo
	cTexto := '[TIPO:' + StrZero(nTipo,1) + '/SEQ:' + StrZero(nSeq,3) + '/A]' + CHR(13) + CHR(10)
	cTexto += cObs + CHR(13) + CHR(10)
	cTexto += '[TIPO:' + StrZero(nTipo,1) + '/SEQ:' + StrZero(nSeq,3) + '/Z]' + CHR(13) + CHR(10)
EndIf

Return cTexto



/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fGeraCQ8  ³ Autor ³ Fernando Joly Siquini ³ Data ³ 02/03/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Gera Reg. Tipo 8 no CQ e Movimentos no SD3 se necessario   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fGeraCQ8(EC1, EC2, EC3, EC4, EC5, EC6, EC7, EC8, EA1)      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³ .T. Se a Gera‡„o Tiver ocorrido, .F. em caso contrario.    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = 01.Numero da NF                                    ³±±
±±³          ³ ExpC2 = 02.Serie da NF                                     ³±±
±±³          ³ ExpC3 = 03.Fornecedor                                      ³±±
±±³          ³ ExpC4 = 04.Loja                                            ³±±
±±³          ³ ExpC5 = 05.Codigo do Produto                               ³±±
±±³          ³ ExpC6 = 06.Item da NF                                      ³±±
±±³          ³ ExpC7 = 07.Origem do Lancamento                            ³±±
±±³          ³ ExpC8 = 08.Local                                           ³±±
±±³          ³ ExpA1 = 09.Array com os Recnos do SF1 ref. as NF Utilizadas³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Ger‚rico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fGeraCQ8(cDoc, cSerie, cFornece, cLoja, cCod, cItem, cOrigLan, cLocCQ, aRecSF1Ori,cNumCQ,lEIC,cItEIC,cDocEIC,cNFOri)

Local aAreaAnt   := GetArea()
Local aAreaSD1   := SD1->(GetArea())
Local aAreaSF1   := SF1->(GetArea())
Local aAreaSD3   := SD3->(GetArea())
Local aAreaSD7   := SD7->(GetArea())
Local aRecCQ     := {}
Local aCusEnt    := {0,0,0,0,0}
Local aCusAgreg  := {0,0,0,0,0}
Local aCustoD3   := {0,0,0,0,0}
Local aRateio    := {0,0,0,0,0}
Local aCQ		 := {}
Local cOP        := ''
Local cMVCQ      := GetMvNNR('MV_CQ','98')
Local cProdImp   := PadR(GetMV('MV_PRODIMP'),Len(SD1->D1_COD))
Local cDocOri    := ''
Local cSerOri    := ''
Local cItemOri   := ''
Local cDocCH     := ''
Local cSerCH     := ''
Local cForCH     := ''
Local cLojCH     := ''
Local cNumSeq    := ''
Local cSeqAtu    := ''
Local cLibera    := ''
Local cTipoCQ    := ''
Local cLoteCtl   := ''
Local cNumLote   := ''
Local cNumSeq8   := ''
Local cNumSeqOri := ''
Local cSeek      := ''
Local cSeekSD1   := ''
Local cSeekSD3   := ''
Local cSeekSD7   := ''
Local cTipoMov   := ''
Local cIdentTP0  := ''
Local cImpSWN    := ''
Local cIndSWN    := ''
Local cTpDocD1	 := ''
Local cTpD1		 := ''
Local nQuant     := 0
Local nX         := 0
Local nY         := 0
Local nZ         := 0
Local nRecSD1    := 0
Local nRecSD7    := 0
Local nSaldoIni  := 0
Local nSaldoAtu  := 0
Local nSaldoAtu2 := 0
Local lRet       := .T.
Local lContinua  := .T.
Local lSeekSD1	 := .F.
Local aCusOp     :={0,0,0,0,0}
Local dDataCQ    := dDataBase
Local aCQColab	 := {}

Default cLocCQ     := cMVCQ
Default cOrigLan   := 'CP'
Default cNumCQ     := CriaVar('D7_NUMERO')
Default lEIC       := .F.
Default cItEIC     := ''
Default cDocEIC    := ''
Default aRecSF1Ori := {}
Default cNFOri := ""

//-- S¢ verifica produtos com Local Destino igual a MV_CQ
If !(cLocCQ == cMVCQ)
	lContinua := .F.
	lRet      := .T.
EndIf

//-- Posiciona sobre a NF Complementar de Entrada no SD1
If lContinua
	dbSelectArea('SD1')
	dbSetOrder(1)
	//-- Obtem o Custo para a Movimentacao de Despesa Agregada p/o Item
	If cOrigLan == 'CP'
		If dbSeek(xFilial('SD1')+cDoc+cSerie+cFornece+cLoja+cCod+cItem, .F.)
			cNumCQ    := D1_NUMCQ
			cOP       := D1_OP
			cDocCH    := D1_DOC
			cSerCH    := D1_SERIE
			cForCH    := D1_FORNECE
			cLojCH    := D1_LOJA
			cNumSeq   := D1_NUMSEQ
			cLoteCtl  := D1_LOTECTL
			cNumLote  := D1_NUMLOTE
			cDocOri   := D1_NFORI
			cSerOri   := D1_SERIORI
			cItemOri  := D1_ITEMORI
			If FunName() == "MATA143" .and.  Type("c143CUSB")=="C"  .and. !Empty(c143CUSB) .and. c143CUSB <> D1_FORNECE  // c143CUSB - variavel alimentada no MATA143
				cFornOri := c143CUSB
			Else
				cFornOri  := D1_FORNECE
			Endif
			nRecSD1   := Recno()
			aCusAgreg := PegaCMD1()
			dDataCQ:= IIf(GetMv("MV_DATAHOM",NIL,"1") == "1" .Or.Empty(SF1->F1_RECBMTO),dDataBase,SF1->F1_RECBMTO)

			If FindFunction("COLXCQ")
				aCQColab  := COLXCQ(cDoc,cSerie,cFornece,cLoja,cCod,cItem,cDocOri,cSerOri,cItemOri)
			Endif

			//NF originida via totvs colaboração
			If Len(aCQColab) > 0 .And. aCQColab[1]
				cNumCQ 		:= aCQColab[2] //Numero CQ (NF de Origem)
				cDocOri 	:= aCQColab[3] //Numero NF de origem
				cSerOri		:= aCQColab[4] //Serie NF de origem
				cItemOri	:= aCQColab[5] //Item NF de origem
				aAdd(aRecSF1Ori,aCQColab[6]) //Recno SF1 da NF de origem
			Endif
		Else
			Help(' ',1,'NAOEXISTE')
			lContinua := .F.
			lRet      := .F.
		EndIf
	ElseIf cOrigLan == 'IM'
		dbSelectArea('SD3')
		dbSetOrder(3)
		cOP       := D3_OP
		cDocCH    := ''
		cSerCH    := ''
		cForCH    := ''
		cLojCH    := ''
		cNumSeq   := D3_NUMSEQ
		cLoteCtl  := ''
		cNumLote  := ''
		cDocOri   := ''
		cSerOri   := ''
		cItemOri  := ''
		nRecSD1   := SD1->(Recno())
		aCusAgreg := PegaCMD3()
		dbSelectArea('SWN')
		dbSetOrder(1)
		//-- Procura pela NF Original no SIGAEIC
		If dbSeek(xFilial('SWN')+cDoc+cSerie+SD1->D1_TEC,.F.)
			cImpSWN    := WN_HAWB
			cIndSWN    := CriaTrab('',.F.)
			IndRegua('SWN',cIndSWN,"WN_FILIAL+WN_DOC+WN_SERIE+WN_TEC+WN_EX_NCM+WN_EX_NBM+WN_HAWB",,'WN_FILIAL=="'+WN_FILIAL+'".And.WN_HAWB=="'+cImpSWN+'"',STR0002) //"Selecionando Registros..."
			dbGoTop()
			cNumSeqOri := ''
			Do While !Eof()
				If (cCod==WN_PRODUTO) .And. QtdComp(WN_QUANT)>QtdComp(0) .And. SD1->(dbSeek(cSeekSD1:=xFilial('SD1')+SWN->WN_DOC+SWN->WN_SERIE+SWN->WN_FORNECE+SWN->WN_LOJA+cProdImp, .F.))
					Do While !SD1->(Eof()) .And. cSeekSD1==SD1->D1_FILIAL+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD
						If WN_TEC+WN_EX_NCM+WN_EX_NBM==SD1->D1_TEC
							cNumSeqOri := SD1->D1_NUMSEQ
							Exit
						EndIf
						SD1->(dbSkip())
					EndDo
				EndIf
				If !Empty(cNumSeqOri)
					Exit
				EndIf
				dbSkip()
			EndDo
			DbSelectArea("SWN")
			If __TTSInUse
				dbSetOrder(1)
			Else
				RetIndex("SWN")
				fErase(cIndSWN+OrdBagExt())
			EndIf
			If !Empty(cNumSeqOri)
				dbSelectArea('SD7')
				dbSetOrder(3)
				If dbSeek(xFilial('SD7')+cCod+cNumSeqOri, .F.)
					While !Eof() .And. xFilial('SD7')+cCod+cNumSeqOri == D7_FILIAL+D7_PRODUTO+D7_NUMSEQ
						If If(lEIC,D7_DOCSWN+D7_ITEMSWN==cDocEic+cItEIC,.T.)
							cNumCQ := SD7->D7_NUMERO
							Exit
						EndIf
						dbSkip()
					EndDo
				EndIf
			EndIf
			dbSelectArea('SD1')
		Else
			Help(' ',1,'NAOEXISTE')
			lContinua := .F.
			lRet      := .F.
		EndIf
	Else
		lContinua := .F.
		lRet      := .F.
	EndIf
EndIf

If lContinua .And. !lEIC
	aCusEnt := {0,0,0,0,0}
	If (cOrigLan=='CP'.And.!Empty(cDocOri+cSerOri+cItemOri)) .Or. (cOrigLan=='IM'.And.!Empty(cNumSeqOri))
		//-- Calcula o Custo da Movimentacao Original para o Item
		If cOrigLan == 'CP'
			If Len(aRecSF1Ori) = 0
				cTpDocD1 := SD1->D1_TIPODOC
				cTpD1	 := SD1->D1_TIPO
				lSeekSD1 := dbSeek(xFilial('SD1')+cDocOri+cSerOri+cFornOri+cLoja+cCod+cItemOri, .F.)
				If lSeekSD1 .And. !Empty(D1_NUMCQ)
					cNumCQ     := D1_NUMCQ
					aCusEnt[1] := D1_CUSTO
					aCusEnt[2] := D1_CUSTO2
					aCusEnt[3] := D1_CUSTO3
					aCusEnt[4] := D1_CUSTO4
					aCusEnt[5] := D1_CUSTO5
				Else
					Help(' ',1,'NAOEXISTE')
					lContinua := .F.
					lRet      := .F.
				EndIf
			Else
				For nX := 1 to Len(aRecSF1Ori)
					SF1->(DbGoTo(aRecSF1Ori[nX]))
					If cPaisLoc =="BOL" .AND. !Empty(cNFOri) .AND. FwIsInCallStack("MATA143") 
						If cNFOri != SF1->F1_DOC
							Loop
						EndIf
					EndIf 
					lSeekSD1	:= dbSeek(xFilial('SD1')+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA+cCod+Strzero(VAL(cItemOri),tamsx3('D1_ITEM')[1]))
					cTpDocD1 := SD1->D1_TIPODOC
					cTpD1	 := SD1->D1_TIPO

					// Nota de Gastos: verifica se ha' remito vinculado na factura origem
					If cPaisLoc <> "BRA" .And. lSeekSD1 .And. Empty(D1_NUMCQ) .And. !Empty(SD1->D1_REMITO);
						.And. cTpD1 == "C" .And. cTpDocD1 == "13"
						dbSelectArea('SD1')
						dbSetOrder(1)
						lSeekSD1 := MSSeek(xFilial("SD1")+SD1->D1_REMITO+SD1->D1_SERIREM+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD+SD1->D1_ITEMREM)
					EndIf

					If lSeekSD1 .And. !Empty(D1_NUMCQ)
						aCusEnt[1] += D1_CUSTO
						aCusEnt[2] += D1_CUSTO2
						aCusEnt[3] += D1_CUSTO3
						aCusEnt[4] += D1_CUSTO4
						aCusEnt[5] += D1_CUSTO5
					Else
					Help(' ',1,'NAOEXISTE')
						lContinua := .F.
						lRet      := .F.
					EndIf

				Next nX
			EndIf
		ElseIf cOrigLan == 'IM'
			nQuant := 0
			dbSelectArea('SD3')
			dbSetOrder(3)
			If dbSeek(cSeek:=xFilial('SD3')+cCod+cLocCQ+cNumSeqOri, .F.)
				Do While !Eof() .And. cSeek==D3_FILIAL+D3_COD+D3_LOCAL+D3_NUMSEQ
					nQuant     += D3_QUANT
					aCusEnt[1] += D3_CUSTO1
					aCusEnt[2] += D3_CUSTO2
					aCusEnt[3] += D3_CUSTO3
					aCusEnt[4] += D3_CUSTO4
					aCusEnt[5] += D3_CUSTO5
					dbSkip()
				EndDo
				dbSelectArea('SD1')
			Else
				Help(' ',1,'NAOEXISTE')
				lContinua := .F.
				lRet      := .F.
			EndIf
		Else
			lContinua := .F.
			lRet      := .F.
		EndIf
		//-- Calcula o Custo Total do Produto nas NF's de Entrada Originais (Frete/Importa‡Æo)
	ElseIf Len(aRecSF1Ori) > 0
		dbSetOrder(2)
		For nX := 1 to Len(aRecSF1Ori)
			SF1->(MsGoto(aRecSF1Ori[nX]))
			If dbSeek(cSeekSD1:=xFilial('SD1')+cCod+SF1->F1_DOC+SF1->F1_SERIE, .F.)
				Do While !Eof() .And. cSeekSD1 == D1_FILIAL+D1_COD+D1_DOC+D1_SERIE
					If D1_NUMCQ == cNumCQ
						aCusEnt[1] := D1_CUSTO
						aCusEnt[2] := D1_CUSTO2
						aCusEnt[3] := D1_CUSTO3
						aCusEnt[4] := D1_CUSTO4
						aCusEnt[5] := D1_CUSTO5
						Exit
					EndIf
					dbSkip()
				EndDo
			EndIf
			If QtdComp(aCusEnt[1]+aCusEnt[2]+aCusEnt[3]+aCusEnt[4]+aCusEnt[5]) > QtdComp(0)
				Exit
			EndIf
		Next nX
	Else
		lContinua := .F.
		lRet      := .F.
	EndIf
EndIf

If lContinua
	//-- Posiciona o SB1
	If !SB1->(dbSeek(xFilial('SB1')+cCod, .F.))
		Help(' ',1,'NOFOUNDSB1')
		lContinua := .F.
		lRet      := .F.
	Else
		//-- Reposiciona o SD1 no Registro original
		dbSelectArea('SD1')
		dbSetOrder(1)
		MsGoto(nRecSD1)
	EndIf
EndIf

If lContinua .And. !Empty(cNumCQ)
	dbSelectArea('SD7')
	dbSetOrder(1)
	If dbSeek((cSeekSD7:=xFilial('SD7')+cNumCQ+cCod+cLocCQ)+'001', .F.)

		//-- Verifica a Movimenta‡Æo no CQ
		Do While !Eof() .And. cSeekSD7 == D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL
			If D7_TIPO == 0 .And. If(lEIC,D7_DOCSWN+D7_ITEMSWN == cDocEIC+cItEIC,.T.)
				nRecSD7   := Recno()
				cTipoCQ   := D7_TIPOCQ
				cLibera   := D7_LIBERA
				nSaldoIni := D7_SALDO
				cIdentTP0 := D7_NUMSEQ
				If cOrigLan == 'IM'
					cLoteCtl := D7_LOTECTL
					cNumLote := D7_NUMLOTE
				EndIf
			ElseIf (D7_TIPO==1.Or.D7_TIPO==2) .And. Empty(D7_ESTORNO) .And. If(lEIC,D7_DOCSWN+D7_ITEMSWN == cDocEIC+cItEIC,.T.)
				aAdd(aRecCQ, Recno())
			EndIf
			cSeqAtu    := D7_SEQ
			nSaldoAtu  := D7_SALDO
			nSaldoAtu2 := D7_SALDO2
			dbSkip()
		EndDo

		//-- Gera o Registro Tipo 8 de Despesas Agregadas no SD7
		If nRecSD7 > 0
			RecLock('SD7', .T.)
			Replace D7_FILIAL  With xFilial('SD7')
			Replace D7_NUMERO  With cNumCQ
			Replace D7_PRODUTO With cCod
			Replace D7_ORIGLAN With cOrigLan
			Replace D7_USUARIO With CUSERNAME
			Replace D7_LOCAL   With cLocCQ
			Replace D7_LOCDEST With RetFldProd(SB1->B1_COD,"B1_LOCPAD")
			Replace D7_TIPO    With 8
			Replace D7_DOC     With cDocCH
			Replace D7_SERIE   With cSerCH
			Replace D7_FORNECE With cForCH
			Replace D7_LOJA    With cLojCH
			Replace D7_QTDE    With 0
			Replace D7_DATA    With dDataCQ
			Replace D7_NUMSEQ  With (cNumSeq8:=cNumSeq)
			Replace D7_SEQ     With StrZero((Val(cSeqAtu)+1),3)
			Replace D7_SALDO   With nSaldoAtu
			Replace D7_SALDO2  With nSaldoAtu2
			Replace D7_TIPOCQ  With cTipoCQ
			Replace D7_LIBERA  With cLibera
			Replace D7_LOTECTL With cLoteCtl
			Replace D7_NUMLOTE With cNumLote
			If lEIC
				Replace D7_DOCSWN  With cDocEIC
				Replace D7_ITEMSWN With cItEIC
			EndIf
			MsUnlock()
			aAreaSD7[3] := Recno()

			//-- Gera RE6/DE6 para as movimenta‡äes de CQ j  existentes
			SD3->(dbSetOrder(3))
			For nY := 1 to Len(aRecCQ)
				aCustoD3 := {0,0,0,0,0}
				SD7->(MsGoto(aRecCQ[nY]))
				If SD3->(dbSeek((cSeekSD3:=xFilial('SD3')+SD7->D7_PRODUTO+SD7->D7_LOCDEST)+SD7->D7_NUMSEQ, .F.))
					//-- Pega o Custo no SD3 gerado pela movimenta‡Æo no CQ
					Do While !Eof() .And. cSeekSD3==SD3->D3_FILIAL+SD3->D3_COD+SD3->D3_LOCAL
						If If(lEIC,cDocEIC+cItEIC == SD3->D3_DOCSWN+SD3->D3_ITEMSWN,;
								(Empty(SD3->D3_IDENT) .Or. AllTrim(SD3->D3_IDENT)==AllTrim(cIdentTP0)).And. SD3->D3_NUMSEQ == SD7->D7_NUMSEQ .And. SD3->D3_CF == "DE6");
								.And. Empty(SD3->D3_ESTORNO)
							aCustoD3[1] += SD3->D3_CUSTO1
							aCustoD3[2] += SD3->D3_CUSTO2
							aCustoD3[3] += SD3->D3_CUSTO3
							aCustoD3[4] += SD3->D3_CUSTO4
							aCustoD3[5] += SD3->D3_CUSTO5
						EndIf
						SD3->(dbSkip())
					EndDo

					//-- Verifica se o Campo D3_IDENT ‚ igual ao D7_NUMSEQ do Registro tipo ZERO no CQ
					//-- (For‡a a utiliza‡Æo do Custo correto no SD3)
					If !Empty(SD3->D3_IDENT) .And. !(AllTrim(SD3->D3_IDENT)==AllTrim(cIdentTP0))
						Do While !SD3->(Eof()) .And. cSeekSD3 == SD3->D3_FILIAL+SD3->D3_COD+SD3->D3_LOCAL+SD3->D3_NUMSEQ
							If Empty(SD3->D3_IDENT) .Or. AllTrim(SD3->D3_IDENT)==AllTrim(cIdentTP0)
								aCustoD3[1] := SD3->D3_CUSTO1
								aCustoD3[2] := SD3->D3_CUSTO2
								aCustoD3[3] := SD3->D3_CUSTO3
								aCustoD3[4] := SD3->D3_CUSTO4
								aCustoD3[5] := SD3->D3_CUSTO5
								Exit
							EndIf
							SD3->(dbSkip())
						EndDo
					EndIf

					aRateio := {0,0,0,0,0}
					If lEIC
						aRateio := aClone(aCusAgreg)
						//-- Retorna os Itens Liber. e Rejeit. do CQ - Somente para NF de Importacao
						aCQ := FLibRejCQ8(cCod,cDoc,cSerie,cFornece,cLoja,cLoteCtl,cNumLote,cNumCQ,cItEIC,cDocEIC, aRecCQ[nY])
						//-- Calcula o Custo Agregado Proporcional Pela Quantidade Liberada no CQ
						If Len(aCQ) > 0
							For nZ := 1 To Len(aRateio)
								aRateio[nZ] := aRateio[nZ] * (aCQ[2,2] / aCQ[1,2])
							Next nZ
						EndIf
					Else
						For nZ := 1 to Len(aCusEnt)
							aRateio[nZ] := (aCusAgreg[nZ]/aCusEnt[nZ])*aCustoD3[nZ]
						Next nZ
					EndIf
					For nZ := 1 to 2
						cTipoMov := If(nZ==1,'R','D') //-- "D"=Entrada/"R"=Saida
						RecLock('SD3',.T.)
						Replace D3_FILIAL  With xFilial('SD3')
						Replace D3_DOC     With cNumCQ
						Replace D3_COD     With SD7->D7_PRODUTO
						Replace D3_UM      With SB1->B1_UM
						Replace D3_EMISSAO With dDataCQ
						Replace D3_GRUPO   With SB1->B1_GRUPO
						Replace D3_TIPO    With SB1->B1_TIPO
						Replace D3_IDENT   With cNumSeq8
						Replace D3_CF      With If(cTipoMov=='D','DE','RE')+If(cOrigLan=='PR','4','6')
						Replace D3_LOCAL   With If(cTipoMov=='R',SD7->D7_LOCAL,SD7->D7_LOCDEST)
						Replace D3_TM      With If(cTipoMov=='R','999','499')
						Replace D3_CHAVE   With If(cTipoMov=='R','E0','E9')
						Replace D3_USUARIO With CUSERNAME
						Replace D3_NUMSEQ  With SD7->D7_NUMSEQ
						Replace D3_QUANT   With 0
						Replace D3_CUSTO1  With aRateio[1]
						Replace D3_CUSTO2  With aRateio[2]
						Replace D3_CUSTO3  With aRateio[3]
						Replace D3_CUSTO4  With aRateio[4]
						Replace D3_CUSTO5  With aRateio[5]
						Replace D3_CONTA   With SB1->B1_CONTA
						If lEIC
							Replace D3_DOCSWN  With cDocEIC
							Replace D3_ITEMSWN With cItEIC
						EndIf
						MsUnlock()
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Atualiza o saldo atual (VATU) com os dados do SD3     ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						aCusOp:={D3_CUSTO1,D3_CUSTO2,D3_CUSTO3,D3_CUSTO4,D3_CUSTO5}
						B2AtuComD3({D3_CUSTO1,D3_CUSTO2,D3_CUSTO3,D3_CUSTO4,D3_CUSTO5})
					Next nZ
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o valor da OP com os dados do SD3            ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !Empty(cOp)
						RecLock('SD3',.T.)
						Replace D3_FILIAL  With xFilial('SD3')
						Replace D3_DOC     With cNumCQ
						Replace D3_COD     With SD7->D7_PRODUTO
						Replace D3_UM      With SB1->B1_UM
						Replace D3_EMISSAO With dDataCQ
						Replace D3_GRUPO   With SB1->B1_GRUPO
						Replace D3_TIPO    With SB1->B1_TIPO
						Replace D3_IDENT   With cNumSeq8
						Replace D3_CF      With "RE5"
						Replace D3_LOCAL   With SD7->D7_LOCDEST
						Replace D3_TM      With '999'
						Replace D3_CHAVE   With 'E0'
						Replace D3_OP      With cOP
						Replace D3_USUARIO With CUSERNAME
						Replace D3_NUMSEQ  With SD7->D7_NUMSEQ
						Replace D3_QUANT   With 0
						Replace D3_CUSTO1  With aCusOP[1]
						Replace D3_CUSTO2  With aCusOp[2]
						Replace D3_CUSTO3  With aCusOp[3]
						Replace D3_CUSTO4  With aCusOp[4]
						Replace D3_CUSTO5  With aCusOp[5]
						Replace D3_CONTA   With SB1->B1_CONTA
						If lEIC
							Replace D3_DOCSWN  With cDocEIC
							Replace D3_ITEMSWN With cItEIC
						EndIf
						MsUnlock()
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Atualiza o saldo atual (VATU) com os dados do SD3     ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						B2AtuComD3({D3_CUSTO1,D3_CUSTO2,D3_CUSTO3,D3_CUSTO4,D3_CUSTO5})
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Atualiza os saldos atuais (VATU) das OP's ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						C2AtuComD3({SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5})
					EndIf
				EndIf
			Next nY
		Else
			Help(' ', 1, 'SEMSEQ001')
			lContinua := .F.
			lRet      := .F.
		EndIf
	Else
		Help('', 1, 'SEMSEQ001')
		lContinua := .F.
		lRet      := .F.
	EndIf
EndIf

RestArea(aAreaSD7)
RestArea(aAreaSD3)
RestArea(aAreaSF1)
RestArea(aAreaSD1)
RestArea(aAreaAnt)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fEstoCQ8  ³ Autor ³ Fernando Joly Siquini ³ Data ³ 02/03/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Estorna Reg. Tipo 8 no CQ e Movimentos no SD3 se necessario³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fEstoCQ8(ExpC1, ExpC2, ExpC3)                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³ .T. Se o Estorno Tiver ocorrido, .F. em caso contrario.    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Numero do CQ                                       ³±±
±±³          ³ ExpC2 = Codigo do Produto                                  ³±±
±±³          ³ ExpC2 = Local do CQ                                        ³±±
±±³          ³ ExpC2 = Chave para Localiza‡Æo do Registro Origem          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Ger‚rico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fEstoCQ8(cNumCQ, cCod, cLocal, aOrigem)

Local aAreaAnt   := GetArea()
Local aAreaSD3   := SD3->(GetArea())
Local aAreaSD7   := SD7->(GetArea())
Local aRecCQ     := {}
Local aRecD3     := {}
Local aRecTP8    := {}
Local aCustoD3   := {}
Local cSeekSD7   := ''
Local nX         := 0
Local nY         := 0
Local nZ         := 0
Local bCampo := {|nCPO| Field(nCPO)}
Local cSeqAtu    := ''
Local cNumSeq8   := ''
Local nSaldoAtu  := 0
Local nSaldoAtu2 := 0
Local lRet       := .T.
Local lTemOrig     := (aOrigem#Nil.And.!Empty(aOrigem))
Local cDcEIC	 := ''
Local cItEIC	 := ''
Local lEIC		 := If(GetMV("MV_EASY")=="S",.T.,.F.)
Local nV         := 0

//-- Formato do Array aOrigem
//-- [1] = D1_DOC
//-- [2] = D1_SERIE
//-- [3] = D1_FORNECE
//-- [4] = D1_LOJA

dbSelectArea('SD7')
dbSetOrder(1)
If dbSeek((cSeekSD7:=xFilial('SD7')+cNumCQ+cCod+cLocal)+'001', .F.)
	Do While !Eof() .And. cSeekSD7 == D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL
		If (D7_TIPO==1.Or.D7_TIPO==2) .And. Empty(D7_ESTORNO)
			aAdd(aRecCQ, Recno())
		ElseIf D7_TIPO == 8 .And. Empty(D7_ESTORNO) .And. If(lTemOrig, D7_PRODUTO+D7_DOC+D7_SERIE+D7_FORNECE+D7_LOJA==cCod+aOrigem[1]+aOrigem[2]+aOrigem[3]+aOrigem[4], .T.)
			aAdd(aRecTP8, Recno())
		EndIf
		cSeqAtu    := SD7->D7_SEQ
		nSaldoAtu  := SD7->D7_SALDO
		nSaldoAtu2 := SD7->D7_SALDO2
		dbSkip()
	EndDo

	//-- Estorna Despesas Agregadas no SD7 (Tipo 8) e gera Registro Tipo 9
	If Len(aRecTP8) > 0
		For nV := 1 to Len(aRecTP8)

			SD7->(MsGoto(aRecTP8[nV]))
			cNumSeq8 := SD7->D7_NUMSEQ
			RecLock('SD7',.F.)
			Replace D7_ESTORNO With 'S'
			MsUnlock()
			If lEIC
				cDcEIC := SD7->D7_DOCSWN
				cItEIC := SD7->D7_ITEMSWN
			EndIf

			//-- Salva a integridade dos campos de Bancos de Dados
			For nX := 1 To FCount()
				M->&(Eval(bCampo,nX)) := FieldGet(nX)
			Next nX

			//-- Cria o registro de estorno com mesmos dados do original
			RecLock('SD7', .T.)
			For nX := 1 To FCount()
				FieldPut(nX,M->&(Eval(bCampo,nX)))
			Next nX
			Replace D7_SEQ    With (cSeqAtu:=StrZero((Val(cSeqAtu)+1),3))
			Replace D7_SALDO  With nSaldoAtu
			Replace D7_SALDO2 With nSaldoAtu2
			Replace D7_TIPO   With 9
			MsUnlock()

			//-- Procura Movimenta‡äes no SD3 referentes a esta despesa agregada
			For nX := 1 to Len(aRecCQ)
				aRecD3 := {}
				SD7->(MsGoto(aRecCQ[nX]))
				dbSelectArea('SD3')
				dbSetOrder(4)
				If dbSeek(cSeekSD3:=xFilial('SD3')+SD7->D7_NUMSEQ,.F.)
					Do While !Eof() .And. cSeekSD3 == D3_FILIAL+D3_NUMSEQ
						If QtdComp(D3_QUANT) == QtdComp(0) .And. Empty(D3_ESTORNO)
							//-- Verifica se o campo D3_IDENT ‚ o mesmo do D7_NUMSEQ da Despesa Agregada
							//-- Se for integracao no SIGAEIC, D3_IDENT deve ser o mesmo que o D7_ITEMSWN
							If If(lEIC .And. !Empty(D3_DOCSWN+D3_ITEMSWN) ,D3_DOCSWN+D3_ITEMSWN==cDcEIC+cItEIC,If(!Empty(D3_IDENT),AllTrim(D3_IDENT)==AllTrim(cNumSeq8),.T.))
								aAdd(aRecD3, Recno())
							EndIf
						EndIf
						dbSkip()
					EndDo
				Endif

				//-- Estorna as Movimenta‡äes no SD3
				For nY := 1 to Len(aRecD3)

					SD3->(MsGoto(aRecD3[nY]))
					RecLock('SD3',.F.)
					Replace D3_ESTORNO With 'S'
					MsUnlock()

					//-- Salva a integridade dos campos de Bancos de Dados
					For nZ := 1 to FCount()
						M->&(Eval(bCampo,nZ)) := FieldGet(nZ)
					Next nZ

					//-- Cria o registro de estorno com mesmos dados do original
					RecLock('SD3', .T.)
					For nZ := 1 To FCount()
						FieldPut(nZ, M->&(Eval(bCampo,nZ)))
					Next nZ

					//-- Inverte a movimenta‡Æo ("D"=Entrada/"R"=Saida)
					cTipoMov := If(D3_TM>'500','R','D')

					Replace D3_TM      With If(cTipoMov=='R','499','999')
					Replace D3_CF      With If(cTipoMov=='R','DE6','RE6')
					Replace D3_CHAVE   With If(cTipoMov=='R','E0','E9')
					Replace D3_USUARIO With CUSERNAME

					//-- Pega o custo da movimentacao
					aCustoD3 := PegaCusD3()

					//-- Atualiza o saldo atual (VATU) com os dados do SD3
					B2AtuComD3(aCustoD3)

					//-- Acerta custo da OP relacionada na NF de Entrada
					If !Empty(SD3->D3_OP)
						C2AtuComD3(aCustoD3)
					EndIf

				Next nY
			Next nX
		Next nV
	Elseif lTemOrig
		Help(' ', 1, 'SEMSEQ001')
		lRet := .F.
	EndIf

Else
	Help(' ', 1, 'SEMSEQ001')
	lRet := .F.
EndIf

RestArea(aAreaSD7)
RestArea(aAreaSD3)
RestArea(aAreaAnt)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A100Distri³ Autor ³ Fernando Joly Siquini ³ Data ³ 05/04/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Realiza a Distribui‡Æo Autom tica  de um  produto para uma ³±±
±±³          ³ Localiza‡Æo/Numero de S‚rie Especifica.Se os parametros de ³±±
±±³          ³ Localiza‡Æo e Numero de S‚rie nÆo forem passados  a fun‡Æo ³±±
±±³          ³ ir  utilizar os dados constantes no  parametro MV_DISTAUT. ³±±
±±³          ³ No conte£do  deste  parametro  deve  existir uma  ou  mais ³±±
±±³          ³ sequencias do tipo:                                        ³±±
±±³          ³ AALLLLLLLLLLLLLLLNNNNNNNNNNNNNNNNNNNN                      ³±±
±±³          ³ Onde:                                                      ³±±
±±³          ³ A = ALMOXARIFAFO;                                          ³±±
±±³          ³ L = LOCALIZA€ÇO FISICA;                                    ³±±
±±³          ³ N = NéMERO DE SERIE.                                       ³±±
±±³          ³ Pode-se cadastrar  tantas  sequencias  quanto  suportar  o ³±±
±±³          ³ tamanho  do campo  X6_CONTEUD, mas  nÆo ‚ permitido que se ³±±
±±³          ³ cadastre mais de 1 sequencia com o mesmo ALMOXARIFADO,pois ³±±
±±³          ³ a fun‡Æo ir  utilizar apenas a 1a  ocorr. de uma sequencia ³±±
±±³          ³ que possua o ALMOXARIFADO igual ao passado como parametro. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A100Distri(EC1,EC2,EC3,EC4,EC5,EC6,EC7,EC8,EC9,EN1)        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³ .T. Se a Distribui‡Æo tiver sido Feita, .T. caso contr rio.³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = 01.C¢digo                                          ³±±
±±³          ³ ExpC2 = 02.Local/Almoxarifado                              ³±±
±±³          ³ ExpC3 = 03.NumSeq                                          ³±±
±±³          ³ ExpC4 = 04.Documento                                       ³±±
±±³          ³ ExpC5 = 05.S‚rie                                           ³±±
±±³          ³ ExpC6 = 06.Cliente/Fornecedor                              ³±±
±±³          ³ ExpC7 = 07.Loja                                            ³±±
±±³          ³ ExpC8 = 08.Localiza‡Æo (se NIL utiliza o MV_DISTAUT)       ³±±
±±³          ³ ExpC9 = 09.Numero de S‚rie (se NIL utiliza o MV_DISTAUT)   ³±±
±±³          ³ ExpN1 = 10.Quantidade (Se maior que 1 nÆo pode ter N.S‚rie)³±±
±±³          ³ ExpC11= 11.Lote do Produto                                 ³±±
±±³          ³ ExpC12= 12.Sub-Lote do Produto                             ³±±
±±³          ³ ExpN2 = 13.Quantidade na segunda UM                        ³±±
±±³          ³ ExpC13= 14.Doc SWN                                         ³±±
±±³          ³ ExpC14= 15.Item SWN                                        ³±±
±±³          ³ ExpN3 = 16.Quantidade no SD3                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Ger‚rico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function A100Distri(cCod, cLocal, cNumSeq, cDoc, cSerie, cCliFor, cLoja, cLocaliz, cNumSerie, nQuant, cLoteCtl, cNumLote, nQuant2UM, cDocSWN, cItemSWN, nQuantSD3)

Local aAreaAnt   := GetArea()
Local aAreaSB2   := SB2->(GetArea())
Local aAreaSB8   := SB8->(GetArea())
Local aAreaSBE   := SBE->(GetArea())
Local aAreaSBF   := SBF->(GetArea())
Local aAreaSDA   := SDA->(GetArea())
Local aAreaSDB   := SDB->(GetArea())
Local aDistAut   := {}
Local cDistAut   := GetMV('MV_DISTAUT')
Local dUlMes     := GetMV('MV_ULMES')
Local cSeekSDA   := ""
Local lRet       := .T.
Local nX         := 0
Local nPos       := 0
Local nBaixa     := 0
Local nBaixa2    := 0
Local nTamCPOs   := 0
Local nEmpenho   := 0
Local nEmpenh2   := 0
Local nForTimes  := 0
Local nTamLocal  := 0
Local nTamLocFis := 0
Local nTamNumSer := 0
Local nTamContX6 := 0
Local cItem	:=	""
Local lRetPE := .T.
Local lAutoma := .F.
DEFAULT nQuant2UM:=0
cCod       := If(cCod==Nil,CriaVar('DB_PRODUTO'),cCod)
cLocal     := If(cLocal==Nil,CriaVar('DB_LOCAL'),cLocal)
cNumSeq    := If(cNumSeq==Nil,CriaVar('DA_NUMSEQ'),cNumSeq)
cDoc       := If(cDoc==Nil,CriaVar('DA_DOC'),cDoc)
cSerie     := If(cSerie==Nil,CriaVar('DA_SERIE'),cSerie)
cCliFor    := If(cCliFor==Nil,CriaVar('DA_CLIFOR'),cCliFor)
cLoja      := If(cLoja==Nil,CriaVar('DA_LOJA'),cLoja)
cLocaliz   := If(cLocaliz==Nil,CriaVar('DB_LOCALIZ'),cLocaliz)
cNumSerie  := If(cNumSerie==Nil,CriaVar('DB_NUMSERI'),cNumSerie)
nQuant     := If(nQuant==Nil,0,nQuant)
nQuant2UM  := ConvUm(cCod,nQuant,nQuant2UM,2)
cDocSWN    := If(cDocSWN==Nil, '', cDocSWN)
cItemSWN   := If(cItemSWN==Nil, '', cItemSWN)
nQuantSD3  := If(nQuantSD3==Nil,0,nQuantSD3)

//-- S¢ distribui produtos com Controle de Localiza‡Æo
If !Localiza(cCod)
	lRet := .F.
EndIf

If lRet .And. ExistBlock('A100DIST')
	lRetPE := ExecBlock('A100DIST', .F., .F., {cCod, cLocal})
	If Valtype(lRetPE) == 'L'
		lRet := lRetPE
	EndIf
EndIf

//-- Utiliza o MV_DISTAUT caso a Localiza‡Æo/Num.S‚rie sejam nÆo sejam passadas
If lRet .And. (Empty(cLocaliz) .And. Empty(cNumSerie))
	lAutoma := .T.
	If Empty(cDistAut) .and. !SuperGetMV("MV_DISTMOV",.F.,.F.)
		lRet := .F.
	Else
		//-- Calcula o Tamanho dos Segmentos contendo Local/Localiza‡Æo/N.S‚rie,
		//-- e o numero de ocorrˆncias destes segmentos cadastrados no SX6.
		nTamLocal  := TamSX3('DB_LOCAL')[1]
		nTamLocFis := TamSX3('DB_LOCALIZ')[1]
		nTamNumSer := TamSX3('DB_NUMSERI')[1]
		nTamCPOs   := (nTamLocal+nTamLocFis+nTamNumSer)
		nTamContX6 := Len(SX6->X6_CONTEUD)
		nForTimes  := Max(Int(nTamContX6/nTamCPOs)*nTamCPOs,1)

		//-- Formato do Array aDistAut:
		//-- [n, 1] = Local
		//-- [n, 2] = Localiza‡Æo Fisica
		//-- [n, 3] = Numero de S‚rie
		For nX := 1 to nForTimes Step nTamCPOs
			aAdd(aDistAut, {})
			aAdd(aDistAut[Len(aDistAut)], SubStr(cDistAut, nX, nTamLocal))
			aAdd(aDistAut[Len(aDistAut)], SubStr(cDistAut, nX+nTamLocal, nTamLocFis))
			aAdd(aDistAut[Len(aDistAut)], SubStr(cDistAut, nX+nTamLocal+nTamLocFis, nTamNumSer ))
		Next nX

		//-- Encontra a LOCALIZA€ÇO e N.SERIE de acordo com o LOCAL parƒmetrizado
		If (nPos:=aScan(aDistAut, {|x| x[1] == cLocal}))>0
			cLocaliz  := If(Empty(cLocaliz),aDistAut[nPos, 2],cLocaliz)
			cNumSerie := If(Empty(cNumSerie),aDistAut[nPos, 3],cNumSerie)
		Else
			lRet := .F.
		EndIf
	EndIf
EndIf

//-- Verifica se a Localiza‡Æo Fisica est  Cadastrada
dbSelectArea('SBE')
dbSetorder(1)
If lRet .And. !dbSeek(xFilial('SBE')+cLocal+cLocaliz, .F.) .And. Empty(cNumSerie)
	lRet := .F.
EndIf

//-- Impede Distribui‡äes com Numero de S‚rie p/ Quantidades superiores a 1
If lRet .And. !Empty(cNumSerie) .And. QtdComp(nQuant) > QtdComp(1)
	lRet := .F.
EndIf

//-- Posiciona o SDA
dbSelectArea('SDA')
dbSetOrder(1)
If lRet
	cSeekSDA:=xFilial('SDA')+cCod+cLocal+cNumSeq+cDoc+cSerie+cCliFor+cLoja
	If dbSeek(cSeekSDA, .F.)
		lRet := .F.
		While !Eof() .And. cSeekSDA == DA_FILIAL+DA_PRODUTO+DA_LOCAL+DA_NUMSEQ+DA_DOC+DA_SERIE+DA_CLIFOR+DA_LOJA
			If cLoteCtl+cNumLote == DA_LOTECTL+DA_NUMLOTE
				If If(nQuantSD3>0, nQuantSD3==DA_QTDORI .And. nQuantSD3==DA_SALDO, .T.) //-- Compara a Quantidade para Distribuicoes via EIC com mais de 1 item no SWM e 1 item no SD3
					lRet := .T.
					Exit
				EndIf
			ElseIf nQuantSD3 == 0 .And. Empty(cLoteCtl) .And. Empty(cNumLote)
				lRet := .T.
				Exit
			EndIf
			dbSkip()
		EndDo
	EndIf
EndIf

//-- Verifica se o Produto possui Quantidade a ser distribuida
If lRet .And. (QtdComp(nQuant)<=QtdComp(0).Or.QtdComp(DA_SALDO)<QtdComp(nQuant))
	lRet := .F.
EndIf

If lRet
	//-- Gera arquivo de Movimento no SDB
	cItem	:=	A265UltIt('C')
	CriaSDB(DA_PRODUTO, DA_LOCAL, nQuant, cLocaliz, cNumSerie, DA_DOC, DA_SERIE, DA_CLIFOR, DA_LOJA, DA_TIPONF, DA_ORIGEM, IIf(DA_DATA>=dUlMes,DA_DATA,dDataBase) , DA_LOTECTL, DA_NUMLOTE, DA_NUMSEQ, '499', 'D', StrZero(Val(cItem)+1, Len(cItem)), .F., If(QtdComp(DA_EMPENHO)>QtdComp(0),nQuant,0),nQuant2UM)
	//-- Atualiza o Saldo no SDA
	RecLock('SDA', .F.)
	Replace DA_SALDO   With (DA_SALDO-SDB->DB_QUANT)
	Replace DA_EMPENHO With (DA_EMPENHO-SDB->DB_EMPENHO)
	Replace DA_QTSEGUM With (DA_QTSEGUM - SDB->DB_QTSEGUM)
	Replace DA_EMP2    With (DA_EMP2 - SDB->DB_EMP2)
	MsUnlock()

	//-- Baixa Saldo a Classificar no SB2
	SB2->(dbSetOrder(1))
	SB2->(MsSeek(xFilial("SB2")+SDA->DA_PRODUTO+SDA->DA_LOCAL))
	RecLock('SB2', .F.)
	Replace B2_QACLASS With (B2_QACLASS-SDB->DB_QUANT)
	MsUnlock()

	//-- Baixa Saldo Empenhado (Ref. ao Saldo a Classificar) no SB8
	If Rastro(SDA->DA_PRODUTO)
		dbSelectArea('SB8')
		dbSetOrder(3)
		If Rastro(SDA->DA_PRODUTO, 'S')
			If dbSeek(cSeek:=xFilial('SB8')+SDA->DA_PRODUTO+SDA->DA_LOCAL+SDA->DA_LOTECTL+SDA->DA_NUMLOTE, .F.)
				RecLock('SB8', .F.)
				Replace B8_QACLASS With (B8_QACLASS-SDB->DB_QUANT)
				Replace B8_QACLAS2 With (B8_QACLAS2-SDB->DB_QTSEGUM)
				MsUnlock()
			EndIf
		Else
			nEmpenho := SDB->DB_QUANT
			nEmpenh2 := SDB->DB_QTSEGUM
			dbSeek(cSeek:=xFilial('SB8')+SDA->DA_PRODUTO+SDA->DA_LOCAL+SDA->DA_LOTECTL, .T.)
			Do While !Eof() .And. QtdComp(nEmpenho) > QtdComp(0) .And. cSeek == B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL
				If QtdComp(nBaixa:=If(QtdComp(B8_QACLASS)<QtdComp(nEmpenho),B8_QACLASS,nEmpenho)) > QtdComp(0)
					nBaixa2:=If(QtdComp(B8_QACLAS2)<QtdComp(nEmpenh2),B8_QACLAS2,nEmpenh2)
					Reclock('SB8', .F.)
					Replace B8_QACLASS With (B8_QACLASS-nBaixa)
					Replace B8_QACLAS2 With (B8_QACLAS2-nBaixa2)
					MsUnlock()
					nEmpenho -= nBaixa
				EndIf
				dbSkip()
			EndDo
		EndIf
	EndIf

	//-- Cria Saldo no SBF baseado no movimento do SDB
	GravaSBF('SDB')
EndIf

//SIGAACD - Atualiza endereco/n. serie na etiqueta
If lRet .And. lAutoma .And. !Empty(cCliFor) .And. UsaCB0("01")
	CBNFEDistAut(cCod,cDoc,cSerie,cCliFor,cLoja)
EndIf

//-- Restaura as Areas de Trabalho
RestArea(aAreaSDB)
RestArea(aAreaSDA)
RestArea(aAreaSBF)
RestArea(aAreaSBE)
RestArea(aAreaSB8)
RestArea(aAreaSB2)
RestArea(aAreaAnt)
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MatVldEst ³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 17.02.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Avalia se pode estornar movimento ou nao                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Logico (.T. ou .F.) se estorno pode ser efetuado            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do Produto         - Obrigatorio              ³±±
±±³          ³ExpC2: Local                     - Obrigatorio              ³±±
±±³          ³ExpC3: Lote de Controle          - Obrig. se Inf. Sub-Lote  ³±±
±±³          ³ExpC4: Sub-Lote                                             ³±±
±±³          ³ExpC5: Localizacao                                          ³±±
±±³          ³ExpC6: Numero de Serie                                      ³±±
±±³          ³ExpC7: Numero Sequencial                                    ³±±
±±³          ³ExpC8: Documento                                            ³±±
±±³          ³ExpN1: Quantidade                - Obrigatorio              ³±±
±±³          ³ExpL1: Deve mostrar Help                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MatVldEst(cProduto,cLocal,cLoteCtl,cNumLote,cLocaliz,cNumSerie,cNumSeq,cDoc,nQuant,lShow)
Static lNotEstNeg:=NIL
Local oSaldoADis	:= Nil
Local aAreaAnt   := GetArea()
Local z        :=0
Local nQuantArr:=0
Local lRet     :=.T.
Local aArray   :={}
Local lRastro  := Rastro(cProduto)
Local lLocaliz := Localiza(cProduto,.T.)
Local lWmsNew  := SuperGetMV("MV_WMSNEW",.F.,.F.)
Local cHelp		:=	""
lShow	:=	If(lShow == Nil,.T.,lShow)
lNotEstNeg := If(lNotEstNeg==NIL,GetMV("MV_ESTNEG") == "N",lNotEstNeg)

cLocal := Padr(cLocal, TamSx3("B2_LOCAL")[1])
// Verifica saldo adequado
If lLocaliz .Or. lRastro
	// Caso tenha gerado movimento de distribuicao (Sem Localizacao/Num Serie)
	If (lLocaliz .And. !(lWmsNew .And. IntWMS(cProduto))) .And. Empty(cLocaliz+cNumSerie)
		SDA->(dbSetOrder(1))
		If SDA->(dbSeek(xFilial("SDA")+cProduto+cLocal+cNumSeq+cDoc+CriaVar("DA_SERIE")+CriaVar("DA_CLIFOR")+CriaVar("DA_LOJA")))
			nQuantArr:=SDA->DA_SALDO
		EndIf
	ElseIf IntWMS(cProduto) .And. lWmsNew .And. Empty(cLocaliz+cNumSerie)
		oSaldoADis:= WMSDTCSaldoADistribuir():New()
		nQuantArr := oSaldoADis:WmsVldEst(cLocal,cProduto,cDoc,cNumSerie,Nil,Nil,cNumSeq)
	Else
		aArray:=SldPorLote(cProduto,cLocal,nQuant,,cLoteCtl,cNumLote,cLocaliz,cNumSerie)
		For z:=1 to Len(aArray)
			nQuantArr+=aArray[z,5]
		Next z
	EndIf
ElseIf lNotEstNeg
	SB2->(dbSeek(xFilial("SB2")+cProduto+cLocal))
	nQuantArr+=SaldoMov()
EndIf
If ((lLocaliz .And. !(lWmsNew .And. IntWMS(cProduto)))  .Or. lRastro .Or. lNotEstNeg ) .And. QtdComp(nQuantArr) < QtdComp(nQuant)
	If (lLocaliz .And. !(lWmsNew .And. IntWMS(cProduto)))
		If Empty(cLocaliz+cNumSerie)
			If IntWMS(cProduto) .And. lWmsNew
				cHelp   :=  "D0GJADIS"
			Else
				cHelp	:=	"SDAJADISTR"
			EndIf
		Else
			cHelp	:=	"MA265QTEST"
		EndIf
	ElseIf lRastro
		cHelp	:=	"MA240NEGLT"
	Else
		cHelp	:=	"MA240NEGAT"
	EndIf
	lRet:=.F.
EndIf
If lShow .And. !Empty(cHelp)
	Help(" ",1,cHelp)
Endif
RestArea(aAreaAnt)
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ TotD3QC  ³ Autor ³Fernando Joly Siquini  ³ Data ³ 28.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna a Soma das Quantidades e Custos(QC) do Produto no D3³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Array no Formato{X,{Y1,Y2,Y3,Y4,Y5}},Onde X=Qtd Tot e Y=Cust³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1= Codigo do Produto         - Obrigatorio              ³±±
±±³          ³ExpC2= Local                     - Obrigatorio              ³±±
±±³          ³ExpC3= Documento                 - Obrigatorio              ³±±
±±³          ³ExpC4= Identificador                                        ³±±
±±³          ³ExpL1= Considera Somente Despesas Agregadas? (Default=.F.)  ³±±
±±³          ³ExpN1= A ser Inicializado com a Quantidade Total na 1aUM    ³±±
±±³          ³ExpA1= A ser Inicializado com o Custo Total nas 5 Moedas    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function TotD3QC(cCod, cLocal, cDoc, cIdent, lDAOnly, nTotQtd, aTotCus)

//-- Variaveis Locais
Local aAreaAnt   := GetArea()
Local aAreaSD3   := SD3->(GetArea())
Local aReturn    := {0,{0,0,0,0,0}}
Local cSeek      := ''
Local cLocCQ     := GetMvNNR('MV_CQ','98')
Local nTamDoc    := TamSX3("D3_DOC")[1]

//-- Variaveis passadas como Parametro
cCod    := If(cCod==Nil,CriaVar('D3_COD'),cCod)
cLocal  := If(cLocal==Nil,CriaVar('D3_LOCAL'),cLocal)
cDoc    := If(cDoc==Nil,Criavar('D3_DOC'),cDoc)
cIdent  := If(cIdent==Nil,Criavar('D3_IDENT'),cIdent)
lDAOnly := If(lDAOnly==Nil,.F.,lDAOnly)
nTotQtd := 0
aTotCus := {0,0,0,0,0}

dbSelectArea('SD3')
dbSetOrder(2)
If dbSeek(cSeek:=xFilial('SD3')+PadR(cDoc,nTamDoc)+cCod, .F.)
	Do While !Eof() .And. cSeek == D3_FILIAL+D3_DOC+D3_COD
		If !Empty(D3_ESTORNO)
			dbSkip()
			Loop
		EndIf
		If !lDAOnly .And. !(alltrim(D3_LOCAL)==alltrim(cLocal))
			dbSkip()
			Loop
		EndIf
		//-- Validacao para considerar somente os movimentos de entrada de despesas
		//-- agregadas, quando o local destino e igual ao armazem de CQ.
		If lDAOnly .And. alltrim(D3_LOCAL)==alltrim(cLocCQ) .And. !(D3_CF=='DE6')
			dbSkip()
			Loop
		EndIf
		If lDAOnly .And. !(QtdComp(D3_QUANT)==QtdComp(0))
			dbSkip()
			Loop
		EndIf
		If !Empty(cIdent) .And. !(cIdent==D3_IDENT)
			dbSkip()
			Loop
		EndIf
		nTotQtd += D3_QUANT
		aTotCus[1] += D3_CUSTO1
		aTotCus[2] += D3_CUSTO2
		aTotCus[3] += D3_CUSTO3
		aTotCus[4] += D3_CUSTO4
		aTotCus[5] += D3_CUSTO5
		dbSkip()
	EndDo
	aReturn := {nTotQtd, aTotCus}
EndIf

RestArea(aAreaSD3)
RestArea(aAreaAnt)

Return aReturn

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡„o    ³ AlmoxCQ                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Autor     ³ Rodrigo de Almeida Sartorio              ³ Data ³ 22/09/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Busca Almoxarifado do Controle de Qualidade                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe    ³ ExpC1:=AlmoxCq()                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³           ³ ExpC1 = Almoxarifado padrao do Controle de Qualidade       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Uso      ³ Generico MATERIAIS                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function AlmoxCq()
Static cLocalCQ:=NIL
cLocalCQ:=IF(Valtype(cLocalCQ)#"C",GetMvNNR('MV_CQ','98'),cLocalCQ)
RETURN cLocalCQ

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡„o    ³ MtAvlNSer                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Autor     ³ Rodrigo de Almeida Sartorio              ³ Data ³ 15/02/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Avalia qtd utilizada em movimentos com Numero de Serie     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe    ³ ExpL1:=MtAvlNSer                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³           ³ ExpL1 = Indica se movimento pode prosseguir ou nao         ³±±
±±³           ³ ExpC1 = Codigo do produto a ser movimentado                ³±±
±±³           ³ ExpC2 = Numero de Serie do produto a ser movimentado       ³±±
±±³           ³ ExpN1 = Quantidade a ser movimentada na 1a UM              ³±±
±±³           ³ ExpN2 = Quantidade a ser movimentada na 2a UM              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Uso      ³ Generico MATERIAIS                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MtAvlNSer(cCod,cNumSerie,nQuant,nQuant2UM,lShowHelp)
Local aAreaSB1:=SB1->(GetArea())
Local lOK:=.T.
Local xRet	:= 0
Local xRet1	:= 1

lShowHelp:=If(valtype(lShowHelp)=="L",lSHowHelp,.T.)
If !Empty(cNumSerie)
	SB1->(dbSetOrder(1))
	If SB1->(MsSeek(xFilial("SB1")+cCod))
			If(ValType(SB1->B1_QTDSER)) == "C"
				xRet1:= AllTrim(Str(xRet1))
				xRet:= AllTrim(Str(xRet))
			EndIf
			If SB1->B1_QTDSER == xRet1 .Or. SB1->B1_QTDSER == xRet
				If nQuant # QtdComp(1)
					lOk:=.F.
				EndIf
			Else
				If nQuant2UM # QtdComp(1)
					lOk:=.F.
				EndIf
			EndIf
		EndIf
	If !lOk .And. lShowHelp
		Help(" ",1,"QUANTSERIE")
	EndIf
	SB1->(RestArea(aAreaSB1))
EndIf
RETURN lOk

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³IntDL     ³ Autor ³ Fernando Joly Siquini ³ Data ³ 24/01/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Pesquisa no SX6 e no SB1 se o Produto ‚ Integrado ao APDL.  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ IntDL(EXPC1)                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = C¢digo do produto a ser pesquisado no SB1.         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ EST/PCP/FAT/COM/?MS                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function IntDL(cProd,lLocaliz)
Local lIntDL     := (SuperGetMV("MV_INTDL",,"N") == "S")
Local cAlias     := ''
Local cFilSB1    := ''
Local lRet       := .F.
Local nRecno     := 0
Local nOrder     := 0
Local lWmsNew   	:= SuperGetMV("MV_WMSNEW",.F.,.F.) .And. lIntDL
Local aArea		:= GetArea()

Default cProd      := ''
Default lLocaliz 	:= .F.

If lIntDL
	If !Empty(cProd)
		cFilSB1 := xFilial('SB1')
		If (SB1->B1_FILIAL+SB1->B1_COD==cFilSB1+cProd)
			If !lLocaliz
				lRet := Localiza(cProd,.T.)
		Else
				lRet := lLocaliz
			Endif
		Else
			cAlias := Alias()
			nOrder := IndexOrd()
			nRecno := Recno()
			If !(cAlias=='SB1')
				dbSelectArea('SB1')
			EndIf
			If !(nOrder==1)
				dbSetOrder(1)
			EndIf
			If dbSeek(cFilSB1+cProd, .F.)
				If !lLocaliz
					lRet := Localiza(cProd,.T.)
				Else
					lRet := lLocaliz
				Endif
			EndIf
			If	!Empty(cAlias)
				If !(cAlias=='SB1')
					dbSelectArea(cAlias)
				EndIf
				If !(nOrder==IndexOrd())
					dbSetOrder(nOrder)
				EndIf
				If !(nRecno==Recno())
					dbGoto(nRecno)
				EndIf
			EndIf
		EndIf
		If lRet .And. lWmsNew
			If SB5->(FieldPos("B5_CTRWMS")) > 0
				If (SB5->(B5_FILIAL+B5_COD) == xFilial("SB5")+cProd)
					If RetFldProd(cProd,"B5_CTRWMS") <> "1"
						lReT  := .F.
					EndIf
				Else
					SB5->(DbSetOrder(1))
					If SB5->(DbSeek(xFilial("SB5")+cProd))
						If RetFldProd(cProd,"B5_CTRWMS") <> "1"
							lRet := .F.
						EndIf
					Else
						lRet := .F.
					EndIf
				EndIf
			Else
				lRet := .F.
			EndIf
		EndIf
	Else
		lRet := lIntDL
	EndIf
EndIf

RestArea(aArea)
Return(lRet)

//-------------------------------------------------------------------
/*/{Protheus.doc} CriaDCF()
Gravar dados no arquivo DCF (Ordens de Servico)
@author  Fernando Joly Siquini
@since   30/05/2001
@version P11
@obs     Mantida por compatibilizacao
/*/
//-------------------------------------------------------------------
Function CriaDCF(cAliasOrig, nTpApanhe, cServPad, lGrvServD2, aParm, nPosDCF )
Return WmsCriaDCF(cAliasOrig, nTpApanhe, cServPad, aParm, @nPosDCF)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³OLCheck   ³ Autor ³ Fernando Joly Siquini ³ Data ³03.12.2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Verifica o uso do "Template" de Operador Logistico         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ OLCheck(ExpC1)                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Caracter com 2 posicoes para Filial corrente.      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ *Se ExpC1 NAO for passado a funcao ira retornar "True" se  ³±±
±±³          ³  o parametro de Operadr Logistico estiver ativado.         ³±±
±±³          ³ *Se ExpC1 for passado a funcao ira retornar "True" se o    ³±±
±±³          ³  parametro estiver ativado e se a filial passada no        ³±±
±±³          ³  parametro e a mesma definida no parametro MV_APDLFOP.     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function OLCheck(cFilAtual)

Static lOperador  := Nil
Static cFilOpera  := Nil
Local lRet       := .F.

Default cFilAtual  := ''

If (lOperador==Nil)
	lOperador := (GetMV('MV_APDLOPE', .F., .F.).And.IntDL())
EndIf
If (lRet:=lOperador) .And. !Empty(cFilAtual)
	If (cFilOpera==Nil)
		cFilOpera := GetMV('MV_APDLFOP', .F., '')
	EndIf
	lRet := !Empty(cFilOpera) .And. (cFilAtual==cFilOpera)
EndIf

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³OLFiltra  ³ Autor ³ Fernando Joly Siquini ³ Data ³03.12.2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Filtra um arquivo de acordo com o Operador Logistico       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ OLFiltra(ExpC1,ExpC2)                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array multidimencional no seguinte formato:        ³±±
±±³          ³         ExpA1[nn,01] = Alias a ser filtrado (Obrigatorio)  ³±±
±±³          ³         ExpA1[nn,02] = Filtragem ja utilizada (Opcional)   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Array multidimencional no seguinte formato:                ³±±
±±³          ³ ExpA1[nn,01] = Array no seguinte formato:                  ³±±
±±³          ³                ExpA1[nn,01,01] = Alias do Arquivo          ³±±
±±³          ³                ExpA1[nn,01,02] = Indice anterior a filtrag.³±±
±±³          ³                ExpA1[nn,01,03] = Registro anterior a filt. ³±±
±±³          ³ ExpA1[nn,02] = Filtro usado antes da filtragem             ³±±
±±³          ³ ExpA1[nn,03] = Nome do Arquivo criado na filtragem.        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function OLFiltra(aFiltra)

Local aAreaAnt   := GetArea()
Local aAreaAlias := GetArea()
Local aRet       := {}
Local cAlias     := ''
Local cFile      := ''
Local cFilter    := ''
Local cFilterOL  := ''
Local cIndex     := ''
Local cMSFil     := ''
Local nIndex     := 0
Local nX         := 0

Default aFiltra    := {{Alias(), ''}}

For nX := 1 to Len(aFiltra)
	cAlias  := If(Len(aFiltra[nX])>=1,aFiltra[nX,1],'')
	cFilter := If(Len(aFiltra[nX])>=2,aFiltra[nX,2],'')
	If Select(cAlias)>0 .And. OLCheck() .And. !OLCheck(cFilAnt)
		cMSFil := If(Upper(Left(cAlias,1))=='S',Upper(SubStr(cAlias,2,2)),Upper(Left(cAlias,3)))+'_MSFIL'
		dbSelectArea(cAlias)
		aAreaAlias := GetArea()
		If FieldPos(cMSFil)>0
			cFile     := CriaTrab('',.F.)
			cIndex    := IndexKey()
			cFilterOL := cFilter + If(!Empty(cFilter),'.And.','') + cMSFil+'=="'+cFilAnt+'"'
			IndRegua(cAlias,cFile,cIndex,,cFilterOL,STR0002) //"Selecionando Registros..."
			nIndex := RetIndex(cAlias)
			dbSetOrder(nIndex+1)
			dbGoTop()
		EndIf
		aAdd(aRet, {aAreaAlias, cFilter, cFile+OrdBagExt()})
	Else
		aAdd(aRet, {})
	EndIf
Next nX

dbSelectArea(aAreaAnt[1])
If !(aAreaAnt[1]==aAreaAlias[1])
	dbSetOrder(aAreaAnt[2])
EndIf
MsGoto(aAreaAnt[3])

Return aRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³OLLimpa   ³ Autor ³ Fernando Joly Siquini ³ Data ³04.12.2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Limpa o Filtro do arquivo feito para Operador Logistico    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ OLLimpa(ExpC1)                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array multidimencional criado na OLFiltra():       ³±±
±±³          ³         ExpA1[nn,01] = Array no seguinte formato:          ³±±
±±³          ³                        ExpA1[nn,01,01] = Alias             ³±±
±±³          ³                        ExpA1[nn,01,02] = Indice            ³±±
±±³          ³                        ExpA1[nn,01,03] = Registro          ³±±
±±³          ³         ExpA1[nn,02] = Filtro a ser adicionado ao arquivo  ³±±
±±³          ³                        apos se retirar a filtragem do MSFIL³±±
±±³          ³         ExpA1[nn,03] = Arquivo previamente criado na funcao³±±
±±³          ³                        OLFiiltra() a ser excluido.         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nil                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function OLLimpa(aLimpa)

Local aAreaAnt   := GetArea()
Local aAreaAlias := GetArea()
Local cFilter    := dbFilter()
Local cFile      := ''
Local nX         := 0

Default aLimpa     := {{GetArea(), '', ''}}

For nX := 1 to Len(aLimpa)
	If Len(aLimpa[nX])>=3
		aAreaAlias := aClone(aLimpa[nX,1])
		cFilter    := aLimpa[nX,2]
		cFile      := aLimpa[nX,3]
		If Select(aAreaAlias[1])>0
			RestArea(aAreaAlias)
			RetIndex()
			If !Empty(cFilter)
				Set Filter to &(cFilter)
			EndIf
		EndIf
		If !Empty(cFile) .And. File(cFile)
			fErase(cFile)
		EndIf
	EndIf
Next nX

dbSelectArea(aAreaAnt[1])
If !(aAreaAnt[1]==aAreaAlias[1])
	dbSetOrder(aAreaAnt[2])
EndIf
MsGoto(aAreaAnt[3])

Return Nil

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fLibRejCQ8³ Autor ³ Larson Zordan         ³ Data ³ 17/04/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retorna os Itens Liber. e Rejeit. do CQ - NF Importacao    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fLibRejCQ8(ExpC1,ExpC2,ExpC3,ExpC4,ExpC5,ExpC6,ExpC7,ExpC8)³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³ Um Array no seguinte formato:                              ³±±
±±³       	 ³ Array[n,1] = Tipo de Movimenta‡„o (0=Qtd.Orig./1=Lib/2=Rej)³±±
±±³       	 ³ Array[n,2] = Quantidade Movimentada                        ³±±
±±³       	 ³ Array[n,3] = Local Destino da Movimenta‡„o                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do Produto;                                 ³±±
±±³          ³ ExpC2 = Numero da NF;                                      ³±±
±±³          ³ ExpC3 = S‚rie da NF;                                       ³±±
±±³          ³ ExpC4 = Codigo do Fornecedor;                              ³±±
±±³          ³ ExpC5 = Loja do Fornecedor;                                ³±±
±±³          ³ ExpC6 = Lote+SubLote do Produto;                           ³±±
±±³          ³ ExpC7 = Numero do CQ                                       ³±±
±±³          ³ ExpC8 = Item do Produto no SWN                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Ger‚rico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fLibRejCQ8(cProduto, cDocOri, cSerieOri, cCliente, cLoja, cLoteCtl, cNumLote, cNumCQ, cItEIC, cDocEIC, nRecno)
//-- Inicializa Variaveis Locais
Local aAreaAnt   := GetArea()
Local nSD7Rec    := SD7->(Recno())
Local nSD7Ord    := SD7->(IndexOrd())
Local nPos       := 0
Local aRet       := {}

//-- Inicializa Ordens dos Arquivos utilizados na Fun‡„o
SD7->(dbSetOrder(1))

//-- Procura a Movimenta‡„o no CQ referente a Nota Original
If SD7->(dbSeek(xFilial('SD7')+cNumCQ+cProduto, .F.))
	Do While !SD7->(Eof()) .And. xFilial('SD7')+cNumCQ+cProduto == SD7->D7_FILIAL+SD7->D7_NUMERO+SD7->D7_PRODUTO
		If If(Rastro(cProduto),SD7->D7_LOTECTL==cLoteCtl,.T.) .And. cDocEIC+cItEIC == SD7->D7_DOCSWN+SD7->D7_ITEMSWN
			If SD7->D7_TIPO >= 1.And.SD7->D7_TIPO <= 2.And.SD7->D7_ESTORNO # 'S'
				If SD7->(Recno())==nRecno
					If (nPos:=aScan(aRet,{|x|x[1]==SD7->D7_TIPO.And.x[3]==SD7->D7_LOCDEST}))==0
						aAdd(aRet, {0,0,''})
						nPos := Len(aRet)
						aRet[nPos, 1] := SD7->D7_TIPO
						aRet[nPos, 3] := SD7->D7_LOCDEST
					EndIf
				EndIf
				aRet[nPos, 2] += SD7->D7_QTDE
			ElseIf SD7->D7_TIPO == 0
				aAdd(aRet, {0, SD7->D7_SALDO, SD7->D7_LOCAL})
			EndIf
		EndIf
		SD7->(dbSkip())
	EndDo
EndIf

SD7->(dbSetOrder(nSD7Ord))
SD7->(MsGoto(nSD7Rec))
RestArea(aAreaAnt)

Return aRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³IntegraEIC³ Autor ³ Larson Zordan         ³ Data ³ 26/04/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Valida a integracao com SIGAEIC com criacao de campos D3/D7³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ IntegraEIC()                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³ ExpL1 = retorno da confirmacao da integracao com SIGAEIC e ³±±
±±³       	 ³ a validacao da existencia de campos no SD3 e SD7.          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nenhum.                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Ger‚rico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function IntegraEIC(cDoc,cSerie,cFornece,cLoja)
Local aAreaAnt := GetArea()
Local lEIC     := If(GetMv("MV_EASY")=="S",.T.,.F.)

SF1->(dbSetOrder(1))
SF1->(dbSeek(xFilial("SF1")+cDOC+cSERIE+cFORNECE+cLOJA))
lEIC := If(SF1->F1_IMPORT # "S",.F.,lEIC)

RestArea(aAreaAnt)
Return(lEIC)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³DLAtiUsaRFºAutor  ³Fernando Joly S.    º Data ³ 13.09.2002  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Verifica se a Tarefa/Atividade utiliza RF                  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAWMS                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function DLAtiUsaRF(lRadioF, cTarefa, cAtiv)
Local aAreaDC6   := DC6->(GetArea())
Local lRet       := .F.
Default lRadioF    := (SuperGetMV('MV_RADIOF')=='S')
Default cTarefa    := Replicate('Z', TamSX3('DC6_TAREFA')[1])
Default cAtiv      := Replicate('Z', TamSX3('DC6_ATIVID')[1])
If (lRet:=lRadioF)
	DC6->(dbSetOrder(2))
	If ! Empty(cTarefa) .and.  DC6->(DBSeek(xFilial('DC6')+cTarefa+If(cAtiv=='ZZZ','',cAtiv), .F.))
		lRet := (DC6->DC6_RADIOF=='1')
		If !(cAtiv==DC6->DC6_ATIVID)
			Do While !DC6->(Eof()) .And. xFilial('DC6')+cTarefa== DC6->(DC6_FILIAL+DC6_TAREFA)
				lRet := (DC6->DC6_RADIOF=='1')
				DC6->(dbSkip())
			EndDo
		EndIf
	Else
	   lRet:= .F.
	EndIf
EndIf

DC6->(dbSetOrder(aAreaDC6[02]))
DC6->(MSGoto(aAreaDC6[03]))
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³SDACQOrig ºAutor  ³Fernando J Siquini  º Data ³  03/03/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Prepara o SDA para estorno de movimentacoes de CQ que serao º±±
±±º          ³Redistribuidas (opcao "Redistribuir" da PergDevLoc())       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Especifico da funcao CriaSDA                               º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function SDACQOrig(nQuant)

Local aAreaAnt   := GetArea()
Local aAreaSDA   := SDA->(GetArea())
Local aAreaSD7   := SD7->(GetArea())
Local aAreaSDB   := SDB->(GetArea())
Local aRecSDB    := {}
Local bCampo     := {|nCPO| Field(nCPO) }
Local cSeekSDB   := ''
Local lFoundSDA  := .F.
Local nRecSDA    := 0
Local nQuantSDB  := 0
Local nX         := 0
Local nY         := 0

Default nQuant     := 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Posiciona no 1o registro (Tipo 0) do SD7 referente a movimentacao     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea('SD7')
dbSetorder(2) //-- D7_FILIAL+D7_NUMERO+D7_PRODUTO+D7_LOCAL+D7_NUMSEQ+STR(D7_TIPO)
If MsSeek(xFilial('SD7')+SD3->D3_DOC, .F.)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona no SDA referente ao Doc que originou a movimentacao de CQ   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea('SDA')
	dbSetOrder(1)
	lFoundSDA := MsSeek(xFilial('SDA')+SD3->D3_COD+SD7->D7_LOCAL+SD7->D7_NUMSEQ+SD7->D7_DOC, .F.)

	If lFoundSDA
		nRecSDA := Recno()

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Prepara o SDA Original para ser reutilizado                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		RecLock('SDA', .F.)
		Replace DA_DATA    With dDataBase
		Replace DA_QTDORI  With Max((DA_QTDORI-nQuant),0) //-- Subtrai a qtd movimentada da quantidade Original (isto evita com que a Qtd Original fique maior do que deveria, pois a funcao CRIASDA ira somar novamente esta quantidade em seguida)
		MsUnlock()

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Estorna as Devolucoes para CQ referentes a quantidade estornada       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea('SDB')
		dbSetOrder(1) //-- DB_FILIAL+DB_PRODUTO+DB_LOCAL+DB_NUMSEQ+DB_DOC+DB_SERIE+DB_CLIFOR+DB_LOJA+DB_ITEM
		If MsSeek(cSeekSDB:=xFilial('SDB')+SD3->D3_COD+SD7->D7_LOCAL+SD7->D7_NUMSEQ+SD7->D7_DOC+SD7->D7_SERIE+SD7->D7_FORNECE+SD7->D7_LOJA, .F.)
			Do While !Eof() .And. cSeekSDB == DB_FILIAL+DB_PRODUTO+DB_LOCAL+DB_NUMSEQ+DB_DOC+DB_SERIE+DB_CLIFOR+DB_LOJA
				If Empty(DB_ESTORNO) .And. DB_TM <= '500' //-- Procura por Devolucoes ao CQ
					aAdd(aRecSDB, {Recno(), DB_QUANT})
					nQuantSDB += DB_QUANT
				EndIf
				If nQuantSDB >= nQuant
					Exit
				EndIf
				dbSkip()
			EndDo

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Estorna/Deleta movimentacoes no SDB ref. a qtd estornada no CQ        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nQuantSDB := nQuant
			If (nPos:=aScan(aRecSDB, {|x| QtdComp(x[2])==QtdComp(nQuant)})) > 0 //-- 1o Tenta encontrar alguma movimentacao com a quantidade exata p/Estornar/Deletar
				MsGoto(aRecSDB[nPos, 1])
				RecLock('SDB', .F.)
				Replace DB_ESTORNO With 'S'
				dbDelete()
				MsUnlock()
			Else
				For nX := 1 to Len(aRecSDB) //-- Estorna/Deleta somente a quantidade necessaria e cria registros "Ativos" com a diferenca
					MsGoto(aRecSDB[nX, 1])
					RecLock('SDB', .F.)
					Replace DB_ESTORNO With 'S'
					dbDelete()
					MsUnlock()
					If QtdComp(nDif:=(SDB->DB_QUANT-nQuantSDB)) > QtdComp(0)
						nQuantSDB -= nQuant
						For nY := 1 To SD3->(fCount())
							M->&(EVal(bCampo,nY)) := SDB->(FieldGet(nY))
						Next nY
						RecLock('SDB', .T.)
						For nY := 1 To FCount()
							FieldPut(nY, M->&(EVAL(bCampo,nY)))
						Next nY
						Replace DB_ESTORNO With ' '
						Replace DB_QUANT   With nDif
						Replace DB_QTSEGUM With ConvUm(DB_PRODUTO, nDif, Nil, 2)
						MsUnlock()
					Else
						nQuantSDB -= DB_QUANT
					EndIf
					If QtdComp(nQuantSDB) <= QtdComp(0)
						Exit
					EndIf
				Next nX
			EndIf
		EndIf
	EndIf
EndIf

RestArea(aAreaSDB)
RestArea(aAreaSD7)
RestArea(aAreaSDA)
RestArea(aAreaAnt)

If lFoundSDA
	SDA->(MsGoto(nRecSDA))
EndIf

Return lFoundSDA

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³RetFldProd ³ Autor ³Rodrigo A. Sartorio    ³ Data ³05/05/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna as informacoes do arquivo SB1 ou da tabela de dados ³±±
±±³          ³acessorios do produto.                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cCodPro   - Codigo do Produto                              ³±±
±±³          ³ cCampo    - Nome do campo da tabela SB1                    ³±±
±±³          ³ cAliasTop - Nome do alias top                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Retorno  ³ Conteudo do campo da tabela SB1 ou SBZ                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Materiais                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function RetFldProd(cCodPro,cCampo,cAliasTop)
Local cDadosProd:= SuperGetMV("MV_ARQPROD",.F.,"SB1")
Local lArqProp  := SuperGetMV("MV_ARQPROP",.F.,.F.)
Local aArea     := GetArea()
Local cRet      := ""
Local lDadosSBZ := .F.

Default cAliasTop := ""

If Empty(cAliasTop)
	If Substr(cCampo,1,2) == 'B5'
	      cAliasTop := "SB5"
	Else
	      cAliasTop := "SB1"
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Checa a existencia dos dados na tabela SBZ             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cDadosProd == "SBZ"
	dbSelectArea("SBZ")
	lDadosSBZ:=!RetArqProd(cCodPro)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorna o conteudo dos campos da tabela SBZ            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lDadosSBZ
	// Lista de campos fixos - NAO USAR MACRO PARA GARANTIR PERFORMANCE IDEAL
	If cCampo == "B1_LOCPAD"
		cRet:=SBZ->BZ_LOCPAD
	ElseIf cCampo == "B1_QE"
		cRet:=SBZ->BZ_QE
	ElseIf cCampo == "B1_EMIN"
		cRet:=SBZ->BZ_EMIN
	ElseIf cCampo == "B1_CUSTD"
		cRet:=SBZ->BZ_CUSTD
	ElseIf cCampo == "B1_UCALSTD"
		cRet:=SBZ->BZ_UCALSTD
	ElseIf cCampo == "B1_UPRC"
			cRet:=SBZ->BZ_UPRC
	ElseIf cCampo == "B1_MCUSTD"
		cRet:=SBZ->BZ_MCUSTD
	ElseIf cCampo == "B1_UCOM"
		cRet:=SBZ->BZ_UCOM
	ElseIf cCampo == "B1_ESTSEG"
		cRet:=SBZ->BZ_ESTSEG
	ElseIf cCampo == "B1_ESTFOR"
		cRet:=SBZ->BZ_ESTFOR
	ElseIf cCampo == "B1_FORPRZ"
		cRet:=SBZ->BZ_FORPRZ
	ElseIf cCampo == "B1_PE"
		cRet:=SBZ->BZ_PE
	ElseIf cCampo == "B1_TIPE"
		cRet:=SBZ->BZ_TIPE
	ElseIf cCampo == "B1_LE"
		cRet:=SBZ->BZ_LE
	ElseIf cCampo == "B1_LM"
		cRet:=SBZ->BZ_LM
	ElseIf cCampo == "B1_TOLER"
		cRet:=SBZ->BZ_TOLER
	ElseIf cCampo == "B1_TE"
		cRet:=SBZ->BZ_TE
	ElseIf cCampo == "B1_TS"
		cRet:=SBZ->BZ_TS
	ElseIf cCampo == "B1_PICMENT"
	If cPaisLoc == "BRA"
		cRet:=SBZ->BZ_PICMENT
	EndIf
	ElseIf cCampo == "B1_ALIQISS"
	If cPaisLoc == "BRA"
		cRet:=SBZ->BZ_ALIQISS
	EndIf
	ElseIf cCampo == "B1_DATREF"
		cRet:=SBZ->BZ_DATREF
	ElseIf cCampo == "B1_CONINI"
		cRet:=SBZ->BZ_CONINI
	ElseIf cCampo == "B1_EMAX"
		cRet:=SBZ->BZ_EMAX
	ElseIf cCampo == "B1_TIPOCQ"
		cRet:=SBZ->BZ_TIPOCQ
	ElseIf cCampo == "B1_QB"
		cRet:=SBZ->BZ_QB
	ElseIf cCampo == "B1_QBP"
		cRet:=SBZ->BZ_QBP
	ElseIf cCampo == "B1_OPC"
		cRet:=SBZ->BZ_OPC
	ElseIf cCampo == "B1_MARKUP"
		cRet:=SBZ->BZ_MARKUP
	ElseIf cCampo == "B1_CODISS"
		If !lArqProp .Or. ( lArqProp .And. !Empty(SBZ->BZ_CODISS) )
			cRet:=SBZ->BZ_CODISS
		Else
			cRet:=(cAliasTop)->B1_CODISS
		EndIf
	ElseIf cCampo == "B1_MRP" // Projeto Implementeacao de campos MRP e FANTASM no SBZ
		cRet:=SBZ->BZ_MRP
	ElseIf cCampo == "B1_FANTASM" // Projeto Implementeacao de campos MRP e FANTASM no SBZ
		cRet:=SBZ->BZ_FANTASM
	//Campos para NFS-e (BZ_TRIBMUN E BZ_CNAE)
	ElseIf cCampo == "B1_TRIBMUN"
		If cPaisLoc == "BRA"
		cRet:=SBZ->BZ_TRIBMUN
		EndIf
	ElseIf cCampo == "B1_CNAE"
		If cPaisLoc == "BRA"
		cRet:=SBZ->BZ_CNAE
		EndIf
	ElseIf cCampo == "B1_IMPNCM"
		cRet:=SBZ->BZ_IMPNCM
    ElseIf cCampo == "B1_LOCALIZ"
    	cRet:=SBZ->BZ_LOCALIZ
    ElseIf cCampo == "B5_CTRWMS"
    	cRet:=SBZ->BZ_CTRWMS
    ElseIf cCampo == "B1_GRTRIB"
    	cRet:=SBZ->BZ_GRTRIB
    ElseIf cCampo == "B1_PICM"
    	If cPaisLoc == "BRA"
    	cRet:=SBZ->BZ_PICM
    	EndIf
	ElseIf cCampo == "B1_ORIGEM"
		cRet := SBZ->BZ_ORIGEM
	ElseIf cCampo == "B1_MOPC"
		cRet := SBZ->BZ_MOPC
	ElseIf cCampo == "B1_CONTA"
		If SBZ->(ColumnPos("BZ_CONTA")) > 0
			cRet := SBZ->BZ_CONTA
		Else
			cRet := (cAliasTop)->B1_CONTA
		EndIf
	ElseIf cCampo == "B1_TIPO"
		If SBZ->(ColumnPos("BZ_TIPO")) > 0
			cRet := SBZ->BZ_TIPO
		Else
			cRet := (cAliasTop)->B1_TIPO
		EndIf
	Else
		cRet := Criavar(cCampo,.F.)
	EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorna o conteudo dos campos da tabela SB1            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ElseIf ((cAliasTop) == "SB5" .AND. (cAliasTop)->B5_COD == cCodPro) 
        cCampo:=UPPER(ALLTRIM(cCampo))
		If cCampo == "B5_CTRWMS"
            cRet:=(cAliasTop)->B5_CTRWMS
      	Else
            cRet:=Criavar(cCampo,.F.)
      	EndIf
ElseIf ((cAliasTop) != "SB5" .AND. (cAliasTop)->B1_COD == cCodPro)
	cCampo:=UPPER(ALLTRIM(cCampo))
	// Lista de campos fixos - NAO USAR MACRO PARA GARANTIR PERFORMANCE IDEAL
	If cCampo == "B1_LOCPAD"
		cRet:=(cAliasTop)->B1_LOCPAD
	ElseIf cCampo == "B1_QE"
		cRet:=(cAliasTop)->B1_QE
	ElseIf cCampo == "B1_EMIN"
		cRet:=(cAliasTop)->B1_EMIN
	ElseIf cCampo == "B1_CUSTD"
		cRet:=(cAliasTop)->B1_CUSTD
	ElseIf cCampo == "B1_UCALSTD"
		cRet:=(cAliasTop)->B1_UCALSTD
	ElseIf cCampo == "B1_UPRC"
		cRet:=(cAliasTop)->B1_UPRC
	ElseIf cCampo == "B1_MCUSTD"
		cRet:=(cAliasTop)->B1_MCUSTD
	ElseIf cCampo == "B1_UCOM"
		cRet:=(cAliasTop)->B1_UCOM
	ElseIf cCampo == "B1_ESTSEG"
		cRet:=(cAliasTop)->B1_ESTSEG
	ElseIf cCampo == "B1_ESTFOR"
		cRet:=(cAliasTop)->B1_ESTFOR
	ElseIf cCampo == "B1_FORPRZ"
		cRet:=(cAliasTop)->B1_FORPRZ
	ElseIf cCampo == "B1_PE"
		cRet:=(cAliasTop)->B1_PE
	ElseIf cCampo == "B1_TIPE"
		cRet:=(cAliasTop)->B1_TIPE
	ElseIf cCampo == "B1_LE"
		cRet:=(cAliasTop)->B1_LE
	ElseIf cCampo == "B1_LM"
		cRet:=(cAliasTop)->B1_LM
	ElseIf cCampo == "B1_TOLER"
		cRet:=(cAliasTop)->B1_TOLER
	ElseIf cCampo == "B1_TE"
		cRet:=(cAliasTop)->B1_TE
	ElseIf cCampo == "B1_TS"
		cRet:=(cAliasTop)->B1_TS
	ElseIf cCampo == "B1_DATREF"
		cRet:=(cAliasTop)->B1_DATREF
	ElseIf cCampo == "B1_CONINI"
		cRet:=(cAliasTop)->B1_CONINI
	ElseIf cCampo == "B1_EMAX"
		cRet:=(cAliasTop)->B1_EMAX
	ElseIf cCampo == "B1_TIPOCQ"
		cRet:=(cAliasTop)->B1_TIPOCQ
	ElseIf cCampo == "B1_QB"
		cRet:=(cAliasTop)->B1_QB
	ElseIf cCampo == "B1_QBP"
		cRet:=(cAliasTop)->B1_QBP
	ElseIf cCampo == "B1_OPC"
		cRet:=(cAliasTop)->B1_OPC
	ElseIf cCampo == "B1_MARKUP"
		cRet:=(cAliasTop)->B1_MARKUP
	ElseIf cCampo == "B1_CODISS"
		cRet:=(cAliasTop)->B1_CODISS
	ElseIf cCampo == "B1_MRP" // Projeto Implementeacao de campos MRP e FANTASM no SBZ
		cRet:=(cAliasTop)->B1_MRP
	ElseIf cCampo == "B1_FANTASM" // Projeto Implementeacao de campos MRP e FANTASM no SBZ
		cRet:=(cAliasTop)->B1_FANTASM
	ElseIf cCampo == "B1_TRIBMUN"
		cRet:=(cAliasTop)->B1_TRIBMUN
	ElseIf cCampo == "B1_CNAE"
		cRet:=(cAliasTop)->B1_CNAE
	ElseIf cCampo == "B1_PICMRET"
		cRet:=(cAliasTop)->B1_PICMRET
	ElseIf cCampo == "B1_PICMENT"
		cRet:=(cAliasTop)->B1_PICMENT
	ElseIf cCampo == "B1_ALIQISS"
		cRet:=(cAliasTop)->B1_ALIQISS
	ElseIf cCampo == "B1_GRTRIB"
		cRet:=(cAliasTop)->B1_GRTRIB
	ElseIf cCampo == "B1_PICM"
		cRet:=(cAliasTop)->B1_PICM
      ElseIf cCampo == "B1_LOCALIZ"
            cRet:=(cAliasTop)->B1_LOCALIZ
	ElseIf cCampo == "B1_ORIGEM"
		cRet:=(cAliasTop)->B1_ORIGEM
	ElseIf cCampo == "B1_MOPC"
		cRet:=(cAliasTop)->B1_MOPC
	ElseIf cCampo == "B1_TIPO"
		cRet:=(cAliasTop)->B1_TIPO
	Else
		cRet:=Criavar(cCampo,.F.)
	EndIf
EndIf

Restarea(aArea)

Return cRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³RetArqProd ³ Autor ³Rodrigo A. Sartorio    ³ Data ³06/05/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna se grava no SB1 ou no SBZ as informacoes            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cCodPro - Codigo do Produto                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Retorno  ³ Logico : .T. - Grava SB1 / .F. - Grava SBZ                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Materiais                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function RetArqProd(cCodPro)
Local cDadosProd :=SuperGetMV("MV_ARQPROD",.F.,"SB1")
Local cAliasOri  := Alias()
Local aArea      := GetArea()
Local lRet       := .T.
Local lPeArqProd := ExistBlock("ARQPROD")
Local uRet
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Valida se existe registro no SBZ para o produto do parametro³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cDadosProd == "SBZ"
	dbSelectArea("SBZ")
	SBZ->(dbSetOrder(1)) 	//BZ_FILIAL+BZ_PRODUTO
	If SBZ->(dbSeek(xFilial("SBZ")+cCodPro))
		lRet:=.F.
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de entrada ARQPROD utilizado para validar a utilizacao³
//³ da tabela SBZ.                                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lPeArqProd
	uRet := ExecBlock("ARQPROD",.F.,.F.,{cCodPro,lRet})
	If Valtype(uRet)=="L"
		lRet := uRet
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Restaura toda a area a nao ser que esteja posicionado no SBZ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cAliasOri <> "SBZ"
	Restarea(aArea)
EndIf
Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³IsCompENeg ³ Autor ³ Erike Yuri da Silva  ³ Data ³ 05/07/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se um componente que faz parte da estrutura de um ³±±
±±³			 ³ produto, possui ou nao estrutura negativa.                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do Produto PA/PI da Estrutura               ³±±
±±³          ³ ExpC2 = Codigo do Componente                               ³±±
±±³          ³ ExpC3 = Codigo da OP                                       ³±±
±±³          ³ ExpL1 = Valida existencia no cadastro de estrutura         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³ Caso nao seja informado o codigo do produto "cCodProd", o  ³±±
±±³          ³ Codigo da Op devera ser informado.                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function IsCompENeg(cCodProd,cComponente,cOp,lVerEstr)
Local lRet := .T.
Local aSC2 := SC2->(GetArea())
Local aSG1 := SG1->(GetArea())
Default cComponente := Space(TamSX3("G1_COMP")[1])
Default lVerEstr := .T.

If !SuperGetMV("MV_NEGESTR",.F.,.F.)
	lRet := .F.
EndIf

If lRet .And. cCodProd == NIL
	DbSelectArea("SC2")
	DbSetOrder(1)
	If cOp == NIL .or. !SC2->(DbSeek(xFilial("SC2")+cOp))
		SC2->(RestArea(aSC2))
		lRet := .F.
	Else
		cCodProd := SC2->C2_PRODUTO
	EndIf
EndIf

If lRet .And. lVerEstr
	DbSelectArea("SG1")
	DbSetOrder(1)
	If SG1->(dbSeek(xFilial("SG1")+cCodProd+cComponente) .And. G1_QUANT < 0)
		lRet := .T.
	EndIf
EndIf

SC2->(RestArea(aSC2))
SG1->(RestArea(aSG1))

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³IsCrossDocºAutor  ³Sandro              º Data ³  19/08/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Verifica se o endereço eh de CrossDoc                       º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ WMS                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function IsCrossDoc(cCodEst)
Local lRet := .F.
Local aAreaDC8   := DC8->(GetArea())
If DC8->DC8_CODEST == cCodEst
	Return DC8->DC8_TPESTR=="3"
EndIf
DC8->(DbSetOrder(1))
DC8->(DbSeek(xFilial('DC8')+cCodEst))
lRet := DC8->DC8_TPESTR=="3"
RestArea(aAreaDC8)
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³IsFifoOnLine ³ Autor ³Microsiga S/A        ³ Data ³06/12/07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao utilizada para verificar se utiliza o conceito de    ³±±
±±³          ³de FIFO On-Line.                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Retorno  ³lRet - Logico                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function IsFifoOnLine()
Local lRet        := .F.
Local lOnLine     := SuperGetMv("MV_FFONLIN",.F.,.F.)
Local lCusFifo    := SuperGetMv("MV_CUSFIFO",.F.,.F.)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se utiliza Fifo On-Line                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lCusFifo .And. lOnLine
	//-- Utilizar custo fifo on-line
	lRet := .T.
EndIf

Return lRet
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³B2AtuFIFO    ³ Autor ³Microsiga S/A        ³ Data ³06/12/07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao utilizada para atualizar as tabelas de movimentacoes ³±±
±±³          ³FIFO. Somente para FIFO On-Line                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cArquivo   - Tabela de movimento SD1/SD2/SD3               ³±±
±±³          ³ nMultiplic - Verifica se soma ou subtrai o saldo           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function B2AtuFIFO(cArquivo,nMultiplic,aCustoFF)
Local aAreaAnt	:= GetArea()
Local aAreaArq	:= (cArquivo)->(GetArea())
Local aAreaSB2	:= SB2->(GetArea())
Local lOnLine	:= IsFifoOnLine()
Local aAreaSF1	:= {}
Local aAreaSD2	:= {}
Local aAreaSF2	:= {}
Local lTrfil	:= .F.
Local aCusAux	:= {}

Default cArquivo	:= ''
Default aCustoFF	:= {0,0,0,0,0}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza Custo FIFO OnLine                                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lOnLine
	Do Case
		//-- Documento de Entrada
		Case cArquivo == "SD1"
			If nMultiplic > 0
				If cPaisLoc <> "BRA" .And. AllTrim(SD1->D1_ESPECIE) == "RTE"
					aAreaSF1 := SF1->(GetArea())
					aAreaSD2 := SD2->(GetArea())
					dbSelectArea("SF1")
					dbSetOrder(1)
					If dbSeek(xFilial("SF1")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_TIPO)
						dbSelectArea("SD2")
						dbSetOrder(3)
						If dbSeek(GetFilOri("SD2",SF1->F1_FILORIG)+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD+SUBSTR(SD1->D1_ITEM,3,2) )
							dbSelectArea("SD1")
							//-- Gravacao do Lote FIFO On-Line
							GravaSBD(cArquivo,{SD2->D2_CUSFF1,SD2->D2_CUSFF2,SD2->D2_CUSFF3,SD2->D2_CUSFF4,SD2->D2_CUSFF5},SD1->D1_TIPO,Nil,Nil,lOnLine)
						EndIf
					EndIf
					RestArea(aAreaSF1)
					RestArea(aAreaSD2)
					dbSelectArea("SD1")
				Else
					A103TrFil(GdFieldGet('D1_TES',n),SD1->D1_TIPO,SD1->D1_FORNECE,SD1->D1_LOJA,SD1->D1_DOC,SD1->D1_SERIE,GdFieldGet('D1_COD',n),GdFieldGet('D1_QUANT',n),,GdFieldGet('D1_LOTECTL',n),GdFieldGet('D1_NUMLOTE',n),@lTrfil,GdFieldGet('D1_ITEM',n))
					If lTrfil
						aAreaSF1 := SF1->(GetArea())
						aAreaSD2 := SD2->(GetArea())
						aareaSF2 := SF2->(GetArea())
						dbSelectArea("SF1")
						dbSetOrder(1)
						If dbSeek(xFilial("SF1")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_TIPO)
							SF2->(Dbsetorder(1))
							SF2->(Dbseek(GetFilOri("SF1",SF1->F1_FILORIG)+SF1->F1_DOC+SF1->F1_SERIE))
							dbSelectArea("SD2")
							dbSetOrder(3)
							If dbSeek(GetFilOri("SD2",SF1->F1_FILORIG)+SD1->D1_DOC+SD1->D1_SERIE+SF2->F2_CLIENTE+SF2->F2_LOJA+SD1->D1_COD+SUBSTR(SD1->D1_ITEM,3,2) )
								dbSelectArea("SD1")
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Calcula o percentual para credito do PIS / COFINS   ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								aAdd(aCusAux,{SD2->D2_CUSFF1 	;
												,SD1->D1_VALIPI ;
												,SD1->D1_VALICM ;
												,SF4->F4_CREDIPI;
												,SF4->F4_CREDICM;
												," "			;
												," "			;
												," "			;
												," "			;
												,0				;
												,0				;
												,SF4->F4_CREDST ;
												,SD1->D1_ICMSRET;
												,{}				;
												,SF4->F4_PISCOF ;
												,SF4->F4_PISCRED;
												,0				;
												,0				;
												,0				;
												,})

								aRet := RetCusEnt(,aCusAux,SD1->D1_TIPO)

								//-- Gravacao do Lote FIFO On-Line
								GravaSBD(cArquivo,aRet[1],SD1->D1_TIPO,Nil,Nil,lOnLine)
							EndIf
						EndIf
						RestArea(aAreaSF1)
						RestArea(aAreaSD2)
						RestArea(aAreaSF2)
						dbSelectArea("SD1")
					Else
						//-- Gravacao do Lote FIFO On-Line
						GravaSBD(cArquivo,{SD1->D1_CUSTO,SD1->D1_CUSTO2,SD1->D1_CUSTO3,SD1->D1_CUSTO4,SD1->D1_CUSTO5},SD1->D1_TIPO,Nil,Nil,lOnLine)
					EndIf
				EndIf
			Else
				//-- Apaga movimentacao FIFO On-Line
				DeletaSBD("SD1",lOnLine)
			EndIf
		//-- Documento de Saida
		Case cArquivo == "SD2"
			If nMultiplic > 0
				//-- Apaga movimentacao FIFO On-Line
				DeletaSBD("SD2",lOnLine)
			Else
				//-- Baixa do Lote Fifo On-Line
				BaixaSBD("SD2",Nil,Nil,Nil,lOnLine)
			EndIf
		//-- Movimento Interno
		Case cArquivo == "SD3"
			If nMultiplic > 0
				//-- Gravacao do Lote Fifo On-Line
				If SubStr(SD3->D3_CF,1,2) $ "PR|ER"
					GravaSBD(cArquivo,{aCustoFF[01],aCustoFF[02],aCustoFF[03],aCustoFF[04],aCustoFF[05]},Nil,Nil,Nil,lOnLine)
				Else
					GravaSBD(cArquivo,{SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5},Nil,Nil,Nil,lOnLine)
				EndIF
			Else
				//-- Baixa do Lote Fifo On-Line
				BaixaSBD(cArquivo,Nil,SD3->D3_CF=='RE5',SD3->D3_CF=='RE6',lOnLine,@aCustoFF)
			EndIf
	EndCase
EndIf

RestArea(aAreaArq)
RestArea(aAreaSB2)
RestArea(aAreaAnt)
Return aCustoFF

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³DeletaSBD    ³ Autor ³Microsiga S/A        ³ Data ³06/12/07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao utilizada para excluir movimentacao FIFO             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cArquivo - Tabela de movimento SD1/SD2/SD3                 ³±±
±±³          ³ lOnLine  - Verifica se utiliza custo fifo on-line          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function DeletaSBD(cArquivo,lOnLine)
Local lRet       := .F.
Local cSeek      := ''
Local aAreaAnt   := GetArea()
Local aAreaSB2   := SB2->(GetArea())
Local aAreaArq   := (cArquivo)->(GetArea())
Local cMoedaCM   := SuperGetMv('MV_MOEDACM',.F.,"2345")

Default cArquivo := ''
Default lOnLine  := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Apaga movimentacao do Custo FIFO OnLine                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lOnLine
	Begin Transaction
		Do Case
			Case cArquivo == "SD1"
				dbSelectArea("SD8")
				dbSetOrder(5)
				dbSeek(cSeek:=xFilial("SD8")+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_NUMSEQ)
				Do While !Eof() .And. cSeek == SD8->D8_FILIAL+SD8->D8_PRODUTO+SD8->D8_LOCAL+SD8->D8_NUMSEQ

					If SD8->D8_TM <= '500'
						dbSelectArea("SBD")
						dbSetOrder(2)
						If dbSeek(xFilial("SBD")+SD8->D8_SEQ) .And. SBD->BD_QFIM >= SD8->D8_QUANT
							//-- Atualiza Lote FIFO
							RecLock("SBD",.F.)
							Replace  BD_QFIM    With BD_QFIM    - SD8->D8_QUANT
							Replace  BD_QFIM2UM With BD_QFIM2UM - SD8->D8_QT2UM
							Replace  BD_CUSFIM1 With BD_CUSFIM1 - SD8->D8_CUSTO1
							If("2" $ cMoedaCM)
								Replace  BD_CUSFIM2 With BD_CUSFIM2 - SD8->D8_CUSTO2
							EndIf
							If("3" $ cMoedaCM)
								Replace  BD_CUSFIM3 With BD_CUSFIM3 - SD8->D8_CUSTO3
							EndIf
							If("4" $ cMoedaCM)
								Replace  BD_CUSFIM4 With BD_CUSFIM4 - SD8->D8_CUSTO4
							EndIf
							If("5" $ cMoedaCM)
								Replace  BD_CUSFIM5 With BD_CUSFIM5 - SD8->D8_CUSTO5
							EndIf
			                MsUnLock()
							//-- Apaga Lote FIFO
							If SBD->BD_QFIM == 0
								RecLock("SBD",.F.)
								dbDelete()
								MsUnLock()
							EndIf
							//-- Atualiza Saldo SB2
							dbSelectArea("SB2")
							dbSetOrder(1)
							If MsSeek(xFilial("SB2")+SBD->BD_PRODUTO+SBD->BD_LOCAL)
								RecLock("SB2")
								Replace B2_QFIMFF  With B2_QFIMFF  - SD8->D8_QUANT
								Replace B2_VFIMFF1 With B2_VFIMFF1 - SD8->D8_CUSTO1
								If("2" $ cMoedaCM)
									Replace B2_VFIMFF2 With B2_VFIMFF2 - SD8->D8_CUSTO2
								EndIf
								If("3" $ cMoedaCM)
									Replace B2_VFIMFF3 With B2_VFIMFF3 - SD8->D8_CUSTO3
								EndIf
								If("4" $ cMoedaCM)
									Replace B2_VFIMFF4 With B2_VFIMFF4 - SD8->D8_CUSTO4
								EndIf
								If("5" $ cMoedaCM)
									Replace B2_VFIMFF5 With B2_VFIMFF5 - SD8->D8_CUSTO5
								EndIf
								Replace B2_CMFF1   With B2_VFIMFF1 / B2_QFIMFF
								If("2" $ cMoedaCM)
									Replace B2_CMFF2   With B2_VFIMFF2 / B2_QFIMFF
								EndIf
								If("3" $ cMoedaCM)
									Replace B2_CMFF3   With B2_VFIMFF3 / B2_QFIMFF
								EndIf
								If("4" $ cMoedaCM)
									Replace B2_CMFF4   With B2_VFIMFF4 / B2_QFIMFF
								EndIf
								If("5" $ cMoedaCM)
									Replace B2_CMFF5   With B2_VFIMFF5 / B2_QFIMFF
								EndIf
								MsUnLock()
							EndIf
							//-- Apaga movimento SD8
							RecLock("SD8",.F.)
							dbDelete()
							MsUnLock()
							lRet := .T.
						EndIf
					EndIf
					dbSelectArea("SD8")
					dbSkip()
				EndDo
			Case cArquivo == "SD3"
				//-- Tabela SD3 nao eh excluida  eh somente estornada
			Case cArquivo == "SD2"
				dbSelectArea("SD8")
				dbSetOrder(5)
				dbSeek(cSeek:=xFilial("SD8")+SD2->D2_COD+SD2->D2_LOCAL+SD2->D2_NUMSEQ)
				Do While !Eof() .And. cSeek == SD8->D8_FILIAL+SD8->D8_PRODUTO+SD8->D8_LOCAL+SD8->D8_NUMSEQ
					If SD8->D8_TM > '500'
						dbSelectArea("SBD")
						dbSetOrder(2)
						If dbSeek(xFilial("SBD")+SD8->D8_SEQ)
							//-- Atualiza Lote FIFO
							RecLock("SBD",.F.)
							Replace  BD_QFIM    With BD_QFIM    + SD8->D8_QUANT
							Replace  BD_QFIM2UM With BD_QFIM2UM + SD8->D8_QT2UM
							Replace  BD_CUSFIM1 With BD_CUSFIM1 + SD8->D8_CUSTO1
							If("2" $ cMoedaCM)
								Replace  BD_CUSFIM2 With BD_CUSFIM2 + SD8->D8_CUSTO2
							EndIf
							If("3" $ cMoedaCM)
								Replace  BD_CUSFIM3 With BD_CUSFIM3 + SD8->D8_CUSTO3
							EndIf
							If("4" $ cMoedaCM)
								Replace  BD_CUSFIM4 With BD_CUSFIM4 + SD8->D8_CUSTO4
							EndIf
							If("5" $ cMoedaCM)
								Replace  BD_CUSFIM5 With BD_CUSFIM5 + SD8->D8_CUSTO5
							EndIf
							//-- Ajusta o Status do Lote
							If SBD->BD_QFIM > 0
								Replace BD_STATUS With " "
							EndIf
			                MsUnLock()

							//-- Atualiza Saldo SB2
							dbSelectArea("SB2")
							dbSetOrder(1)
							If MsSeek(xFilial("SB2")+SBD->BD_PRODUTO+SBD->BD_LOCAL)
								RecLock("SB2")
								Replace B2_QFIMFF  With B2_QFIMFF  + SD8->D8_QUANT
								Replace B2_VFIMFF1 With B2_VFIMFF1 + SD8->D8_CUSTO1
								If("2" $ cMoedaCM)
									Replace B2_VFIMFF2 With B2_VFIMFF2 + SD8->D8_CUSTO2
								EndIf
								If("3" $ cMoedaCM)
									Replace B2_VFIMFF3 With B2_VFIMFF3 + SD8->D8_CUSTO3
								EndIf
								If("4" $ cMoedaCM)
									Replace B2_VFIMFF4 With B2_VFIMFF4 + SD8->D8_CUSTO4
								EndIf
								If("5" $ cMoedaCM)
									Replace B2_VFIMFF5 With B2_VFIMFF5 + SD8->D8_CUSTO5
								EndIf
								Replace B2_CMFF1   With B2_VFIMFF1 / B2_QFIMFF
								If("2" $ cMoedaCM)
									Replace B2_CMFF2   With B2_VFIMFF2 / B2_QFIMFF
								EndIf
								If("3" $ cMoedaCM)
									Replace B2_CMFF3   With B2_VFIMFF3 / B2_QFIMFF
								EndIf
								If("4" $ cMoedaCM)
									Replace B2_CMFF4   With B2_VFIMFF4 / B2_QFIMFF
								EndIf
								If("5" $ cMoedaCM)
									Replace B2_CMFF5   With B2_VFIMFF5 / B2_QFIMFF
								EndIf
								MsUnLock()
							EndIf
							//-- Apaga movimento SD8
							RecLock("SD8",.F.)
							dbDelete()
							MsUnLock()
							lRet := .T.
						EndIf
					EndIf
					dbSelectArea("SD8")
					dbSkip()
				EndDo
		EndCase
	End Transaction
EndIf

RestArea(aAreaArq)
RestArea(aAreaSB2)
RestArea(aAreaAnt)
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³SaldoSBD     ³ Autor ³Microsiga S/A        ³ Data ³06/12/07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao utilizada para recuperar o saldo FIFO                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cArquivo - Alias do Arquivo SD1/SD2/SD3                     ³±±
±±³          ³cProduto - Codigo do Produto                                ³±±
±±³          ³cLocal   - Codigo do Armazem                                ³±±
±±³          ³dData    - Data de composicao do saldo                      ³±±
±±³          ³lLote    - Saldo por Lote Fifo                              ³±±
±±³          ³cAliastop- Alias aberto por query                           ³±±
±±³          ³cNumSeq  - Numero Sequencia                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function SaldoSBD(cArquivo,cProduto,cLocal,dData,lLote,cAliasTop,cNumSeq)
Local aRet    := {0,0,0,0,0,0}
Local lOnLine := IsFifoOnLine()
Local aAreaAnt:= GetArea()
Local aAreaArq:= (cArquivo)->(GetArea())
Local aAreaSD8:= SD8->(GetArea())

Default cAliasTop:= ''
Default cProduto := ''
Default cLocal   := ''
Default cNumSeq  := ''
Default dData    := dDataBase+1
Default lLote    := .F.

If lOnLine
	If lLote
		If Empty(cNumSeq)
			If Empty(cAliasTop)
				cNumSeq := IIf(cArquivo=="SD1",SD1->D1_NUMSEQ,IIf(cArquivo=="SD2",SD2->D2_NUMSEQ,SD3->D3_NUMSEQ))
			Else
				cNumSeq := IIf(cArquivo=="SD1",(cAliasTop)->D1_NUMSEQ,IIf(cArquivo=="SD2",(cAliasTop)->D2_NUMSEQ,(cAliasTop)->D3_NUMSEQ))
			EndIf
		EndIf
		//-- Caso exista o movimento fifo calcular o saldo do lote
		dbSelectArea("SD8")
		dbSetOrder(5)
		If dbSeek(xFilial("SD8")+cProduto+cLocal+cNumSeq)
			aRet := CalcEstFF( cProduto,cLocal,dData+1,Nil,Nil,SD8->D8_SEQ)
		EndIf

	Else

		//-- Caso seja saldo por produto
		aRet := CalcEstFF( cProduto,cLocal,dData+1,Nil,Nil,Nil)

	EndIf
EndIf

RestArea(aAreaSD8)
RestArea(aAreaArq)
RestArea(aAreaAnt)
Return aRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GetFilOri  ³ Autor ³ Marcos V. Ferreira   ³ Data ³ 04.03.08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Pega xFilial de um arquivo, para uma outra filial.         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ SIGACUSB                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function GetFilOri(cAlias,cNumFil)
Local cRet      := ''

Default cAlias  := Alias()
Default cNumFil := cFilAnt

If ( At( cAlias + 'E', cArqTab ) > 0 )
	cRet := ( cNumFil )
Else
	cRet := ( '  ' )
EndIf

Return cRet


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³TrfSldPoder3 | Autor ³Marcos V. Ferreira  ³ Data ³20/03/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Transferencia de Saldos para Armazem de Poder de Terceiros  ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³TrfSldPoder3()                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cTes     - Codigo da TES	                                  ³±±
±±³          ³ cAlias   - Alias da tabela SD1/SD2                         ³±±
±±³          ³ cProduto - Codigo do Produto                               ³±±
±±³          ³ lEstorno - Indica se e um movimento de estorno             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function TrfSldPoder3(cTes,cAlias,cProduto,lEstorno)
Local aAreaAnt   := GetArea()
Local aAreaSF4   := {}
Local aAreaSB2   := {}
Local aAreaSB1   := {}
Local aAreaSD1   := {}
Local aAreaSD2   := {}
Local aAreaSBE   := {}
Local aAreaDev   := {}
Local cLocTerc   := GetMvNNR('MV_ALMTERC','80')
Local lConTerc   := SuperGetMv("MV_CONTERC",.F.,.F.)
Local lCusFil    := AllTrim(SuperGetMV('MV_CUSFIL',.F.,"A")) == "F"
Local lCusEmp    := AllTrim(SuperGetMv('MV_CUSFIL',.F.,"A")) == "E"
Local aArray     := {}
Local aSldLote   := {}
Local aItens     := {}
Local aRetPE     := {}
Local lProcessa  := .F.
Local cDocumento := ""
Local cTrbSD3    := ""
Local nIndice    := 0
Local nX         := 0
Local nRetPE     := 0
Local nSoma		 := 0
Local lP3NFE     := ExistBlock("MTP3NFE")
Local lP3NFS     := ExistBlock("MTP3NFS")
Local cLocalTerc := ''
Local cLoteCtl   := ""
Local cNumLote   := ""
Local cLocaliz   := ""
Local nTamLoc	 := 0
Local cNumSeri	 := ""

Local lEndManual := SuperGetMv("MV_ENDMANU",.F.,.F.)
Local cEndDest   := ''
Local lEncontrou := .F.
Local nPEndDes   := 0
Local nI         := 0

Default cTes        := ""
Default cAlias      := ""
Default cProduto    := ""
Default lEstorno    := .F.

nTamLoc := TamSx3( 'NNR_CODIGO' )[ 1 ]
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Posiciona no TES utilizado no Documento Fiscal              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SF4")
dbSetOrder(1)
MsSeek(xFilial("SF4")+cTes)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ So segue se o TES Controla Armazem de Terceiros             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If SF4->(ColumnPos("F4_CONTERC")) <> 0 .And. SF4->F4_CONTERC == "2"
	lConTerc := .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Processamento da transferencia de saldos                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lConTerc .And. !Empty(cLocTerc) .And. ( lCusFil .Or. lCusEmp )

	Private lMsErroAuto := .F.
	Private cNumSeqP3   := ""

	aAreaSF4   := SF4->(GetArea())
	aAreaSB2   := SB2->(GetArea())
	aAreaSB1   := SB1->(GetArea())
	aAreaSD1   := SD1->(GetArea())
	aAreaSD2   := SD2->(GetArea())
	aAreaSBE   := SBE->(GetArea())

	Do Case
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Devolucao de Poder de Terceiros                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Case ( cAlias == "SD1" .And. SD1->D1_TIPO == "N" .And. SF4->F4_ESTOQUE == "N" .And. SF4->F4_PODER3 == "D" ) .Or.;
			 ( cAlias == "SD1" .And. SD1->D1_TIPO == "B" .And. SF4->F4_ESTOQUE == "N" .And. SF4->F4_PODER3 == "D" )

			lProcessa  := .T.
			cNumSeqP3  := SD1->D1_NUMSEQ

			//-- Verifica se o produto controla enderecos ou rastreabilidade
			If Rastro(cProduto) .Or. Localiza(cProduto)

				// Tratamento para devolver o mesmo lote/sublote que foi informado no pedido de venda
				aAreaDev := GetArea()
				If !Empty(SD1->D1_NFORI) .And. !Empty(SD1->D1_SERIORI) .And. !Empty(SD1->D1_ITEMORI)
					DbSelectArea("SD2")
					DbSetOrder(3)	// D2_FILIAL+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA+D2_COD+D2_ITEM
					If MsSeek(xFilial("SD2") + SD1->(D1_NFORI+D1_SERIORI+D1_FORNECE+D1_LOJA+D1_COD+D1_ITEMORI))
						cLoteCtl := SD2->D2_LOTECTL
						cNumLote := SD2->D2_NUMLOTE
						cLocaliz := SD2->D2_LOCALIZ
						cNumSeri := SD2->D2_NUMSERI
					EndIf
				EndIf
				RestArea(aAreaDev)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Parametros do array aSldLote[]:              |
				//| aSldLote[nX,1] - Lote de Controle            |
				//| aSldLote[nX,2] - Sub-Lote                    |
				//| aSldLote[nX,3] - Localizacao                 |
				//| aSldLote[nX,4] - Numero de Serie             |
				//| aSldLote[nX,5] - Quantidade                  |
				//| aSldLote[nX,6] - Quantidade 2aUM             |
				//| aSldLote[nX,7] - Data de Validade            |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aSldLote := SldPorLote(SD1->D1_COD ,If(lEstorno,SD1->D1_LOCAL,SubStr(cLocTerc,1,nTamLoc)) ,SD1->D1_QUANT ,SD1->D1_QTSEGUM, cLoteCtl, cNumLote, cLocaliz,cNumSeri,,.F.)

				nSoma := 0
				For nX:= 1 To Len(aSldLote)
					nSoma += aSldLote[nX,5]
				Next nX

				If !Len(aSldLote) > 0 .Or. nSoma < SD1->D1_QUANT
					lProcessa := .F.
					Help(" ",1,"MA240NEGLT")
					DisarmTransaction()
					Break
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ MTP3NFE - Ponto de Entrada para manipular o  |
				//| Lote/Localizacao.                            |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lP3NFE
					aRetPE := ExecBlock("MTP3NFE",.F.,.F.,{aSldLote})
					If Valtype(aRetPE) == "A"
						For nX := 1 to Len(aRetPE)
							nRetPE += aRetPE[nX,5]
						Next
						If QtdComp(nRetPE) == QtdComp(SD1->D1_QUANT)
							aSldLote := aRetPE
						EndIf
					EndIf
				EndIf

				For nX:= 1 To Len(aSldLote)
	                aAdd(aItens,{SD1->D1_COD				,; //01. Produto Origem
	                			 SubStr(cLocTerc,1,nTamLoc)	,; //02. Local Origem
	                			 SD1->D1_COD				,; //03. Produto Destino
	                			 SD1->D1_LOCAL				,; //04. Local Destino
	                			 aSldLote[nX,5]				,; //05. Quantidade
	                			 aSldLote[nX,6]				,; //06. Quantidade na 2UM
	                			 aSldLote[nX,1]	 			,; //07. Lote de Controle
	                			 aSldLote[nX,2]				,; //08. Sub-Lote
	                			 aSldLote[nX,7]				,; //09. Data de Validade
	                			 aSldLote[nX,3]				,; //10. Endereco
	                			 aSldLote[nX,4]			 	; //11. Numero de Serie
	                			} )
				Next nX

			Else
                aAdd(aItens,{SD1->D1_COD				,; //01. Produto Origem
                			 SubStr(cLocTerc,1,nTamLoc)	,; //02. Local Origem
                			 SD1->D1_COD				,; //03. Produto Destino
                			 SD1->D1_LOCAL				,; //04. Local Destino
                			 SD1->D1_QUANT				,; //05. Quantidade
                			 SD1->D1_QTSEGUM			,; //06. Quantidade na 2UM
                			 SD1->D1_LOTECTL 			,; //07. Lote de Controle
                			 SD1->D1_NUMLOTE			,; //08. Sub-Lote
                			 SD1->D1_DTVALID			,; //09. Data de Validade
                			 ""							,; //10. Endereco
                			 ""		 				 	; //11. Numero de Serie
                			} )
			EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Remessa de Poder de Terceiros                        |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Case ( cAlias == "SD2" .And. SD2->D2_TIPO == "B" .And. SF4->F4_ESTOQUE == "N" .And. SF4->F4_PODER3 == "R" ) .Or.;
  		     ( cAlias == "SD2" .And. SD2->D2_TIPO == "N" .And. SF4->F4_ESTOQUE == "N" .And. SF4->F4_PODER3 == "R" )
			lProcessa  := .T.
			cNumSeqP3  := SD2->D2_NUMSEQ

			//-- Verifica se o produto controla enderecos ou rastreabilidade
			If Rastro(cProduto) .Or. Localiza(cProduto)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Parametros do array aSldLote[]:              |
				//| aSldLote[nX,1] - Lote de Controle            |
				//| aSldLote[nX,2] - Sub-Lote                    |
				//| aSldLote[nX,3] - Localizacao                 |
				//| aSldLote[nX,4] - Numero de Serie             |
				//| aSldLote[nX,5] - Quantidade                  |
				//| aSldLote[nX,6] - Quantidade 2aUM             |
				//| aSldLote[nX,7] - Data de Validade            |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aSldLote := SldPorLote(SD2->D2_COD, If(lEstorno,SubStr(cLocTerc,1,nTamLoc),SD2->D2_LOCAL), SD2->D2_QUANT, SD2->D2_QTSEGUM, SD2->D2_LOTECTL, SD2->D2_NUMLOTE, SD2->D2_LOCALIZ, SD2->D2_NUMSERI,,.F.)

				nSoma := 0
				For nX:= 1 To Len(aSldLote)
					nSoma += aSldLote[nX,5]
				Next nX

				If !Len(aSldLote) > 0 .Or. nSoma < SD2->D2_QUANT
					lProcessa := .F.
					Help(" ",1,"MA240NEGLT")
					DisarmTransaction()
					Break
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ MTP3NFS - Ponto de Entrada para manipular o  |
				//| Lote/Localizacao.                            |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lP3NFS
					aRetPE := ExecBlock("MTP3NFS",.F.,.F.,{aSldLote})
					If Valtype(aRetPE) == "A"
						For nX := 1 to Len(aRetPE)
							nRetPE += aRetPE[nX,5]
						Next
						If QtdComp(nRetPE) == QtdComp(SD2->D2_QUANT)
							aSldLote := aRetPE
						EndIf
					EndIf
				EndIf

				For nX:= 1 To Len(aSldLote)
	                aAdd(aItens,{SD2->D2_COD				,; //01. Produto Origem
	                			 SD2->D2_LOCAL 				,; //02. Local Origem
	                			 SD2->D2_COD				,; //03. Produto Destino
	                			 SubStr(cLocTerc,1,nTamLoc)	,; //04. Local Destino
	                			 aSldLote[nX,5]				,; //05. Quantidade
	                			 aSldLote[nX,6]				,; //06. Quantidade na 2UM
	                			 aSldLote[nX,1]	 			,; //07. Lote de Controle
	                			 aSldLote[nX,2]				,; //08. Sub-Lote
	                			 aSldLote[nX,7]				,; //09. Data de Validade
	                			 aSldLote[nX,3]				,; //10. Endereco
	                			 aSldLote[nX,4]			 	; //11. Numero de Serie
	                			} )
				Next nX

			Else
                aAdd(aItens,{SD2->D2_COD				,; //01. Produto Origem
                			 SD2->D2_LOCAL				,; //02. Local Origem
                			 SD2->D2_COD				,; //03. Produto Destino
                			 SubStr(cLocTerc,1,nTamLoc)	,; //04. Local Destino
                			 SD2->D2_QUANT				,; //05. Quantidade
                			 SD2->D2_QTSEGUM			,; //06. Quantidade na 2UM
                			 SD2->D2_LOTECTL 			,; //07. Lote de Controle
                			 SD2->D2_NUMLOTE			,; //08. Sub-Lote
                			 SD2->D2_DTVALID			,; //09. Data de Validade
                			 SD2->D2_LOCALIZ			,; //10. Endereco
                			 SD2->D2_NUMSERI		 	; //11. Numero de Serie
                			} )
			EndIf

	EndCase

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Executa rotina automatica para transferencia de saldo para  |
	//| o armazem de terceiros.                                     |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lProcessa
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se o armazem/endereco de terceiro existe na SBE |
		//³ Caso nao exista sera criado.                             |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SBE")
		dbSetOrder(1)
		For nX := 1 to Len(aItens)
    		cEndDest   := ''
			If !Empty(aItens[nX,10])
				lEncontrou := SBE->(DbSeek(xFilial("SBE")+aItens[nX,04]+aItens[nX,10]))
				cLocalTerc := SubStr( cLocTerc, 1, nTamLoc )
				If !lEndManual 
					If !lEncontrou 
						SBE->(RecLock("SBE", .T.))
						For nI := 1 To SBE->(FCount())
							SBE->(FieldPut(nI, CriaVar(FieldName(nI), .T.) ))
						Next Ni
						SBE->BE_FILIAL  := FWxFilial('SBE')
						SBE->BE_LOCAL   := aItens[nX,04]
						SBE->BE_LOCALIZ := aItens[nX,10]
						SBE->(MsUnlock())
						cEndDest := aItens[nX,10]
					Else 
						cEndDest := aItens[nX,10]
					EndIf
				Else 
					If !lEncontrou 
						If aItens[nX,04] == cLocalTerc 
							SBE->(RecLock("SBE", .T.))
							For nI := 1 To SBE->(FCount())
								SBE->(FieldPut(nI, CriaVar(FieldName(nI), .T.) ))
							Next Ni
							SBE->BE_FILIAL  := FWxFilial('SBE')
							SBE->BE_LOCAL   := aItens[nX,04]
							SBE->BE_LOCALIZ := aItens[nX,10]
							SBE->(MsUnlock())
							cEndDest := aItens[nX,10]
						Else 
							cEndDest := CriaVar('BE_LOCALIZ')
						EndIf
					Else 
						If aItens[nX,04] == cLocalTerc 
							cEndDest := aItens[nX,10]
						Else 
							cEndDest := CriaVar('BE_LOCALIZ')
						EndIf
					EndIf
				EndIf
			EndIf
    
			AAdd(aItens[nX], cEndDest)
			nPEndDes := Len(aItens[nX])
		Next nX
		
		//-- Criacao do armazem de terceiros
		cLocalTerc := SubStr( cLocTerc, 1, nTamLoc )

		dbSelectArea("NNR")
		dbSetOrder(1)
		If !MsSeek(xFilial("NNR") + cLocalTerc )
			lProcessa := .F.
	    	Help(NIL, NIL, STR0251, NIL, ;        //"Armazem de Terceiros"
					I18N(STR0252 ,{cTes}), ;        //"A TES '#1[501]#' necessita o armazem de terceiros cadastrado, a qual não foi encontrado."
					1, 0, NIL, NIL, NIL, NIL, NIL,;
					{I18N(STR0253 ,{cLocalTerc})} ) //"Incluir o armazem de terceiro '#1[80]#' no cadastro local de estoque(NNR)."
			DisarmTransaction()
			Break
		EndIf

		dbSelectArea("SB2")
		dbSetOrder(1)
		If !MsSeek(xFilial("SB2") + cProduto + cLocalTerc )
			CriaSB2( cProduto, cLocalTerc )
		EndIf

		//-- Desbloqueia o armazem de terceiro para realizar a transferencia de saldos
		dbSelectArea("SB2")
		dbSetOrder(1)
		If MsSeek(xFilial("SB2") + cProduto + cLocalTerc )
			RecLock("SB2",.F.)
			Replace B2_STATUS With "1"
			MsUnLock()
		EndIf
		//-- Verifica numero do documento para transferencia
		If !lEstorno
			cDocumento  := Criavar("D3_DOC")
			cDocumento	:= IIf(Empty(cDocumento),NextNumero("SD3",2,"D3_DOC",.T.),cDocumento)
			cDocumento	:= A261RetINV(cDocumento)
		EndIf
		//-- Posiciona produto
		dbSelectArea("SB1")
		dbSetorder(1)
		MsSeek(xFilial("SB1")+cProduto)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Estorno da transferencia para o armazem de terceiros        |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lEstorno

			cTrbSD3 := CriaTrab(,.F.)

			dbSelectArea('SD3')
			IndRegua('SD3',cTrbSD3,'D3_FILIAL+D3_IDENT+D3_COD',,,STR0002)	//"Selecionando Registros"
			nIndice := RetIndex('SD3')
			dbSetOrder(nIndice+1)
			If dbSeek(xFilial('SD3')+cNumSeqP3+cProduto,.F.)
				//-- Cabecalho
				aArray := { {	SD3->D3_DOC,;					// 01.Numero do Documento
								SD3->D3_EMISSAO } }				// 02.Data da Transferencia

				MATA261(aArray,4) //Estorno da transferencia interna
			EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Inclusao da transferencia para o armazem de terceiros       |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Else

			//-- Cabecalho
			aArray    := Array(Len(aItens)+1)
			aArray[1] := {cDocumento,;							// 01.Numero do Documento
						  dDataBase}							// 02.Data da Transferencia
			For nX := 1 to Len(aItens)
				//-- Detalhe
				aArray[nX+1] :=  {{"D3_COD" 	, SB1->B1_COD			,NIL}}// 01.Produto Origem
				aAdd(aArray[nX+1],{"D3_DESCRI" 	, SB1->B1_DESC			,NIL})// 02.Descricao
				aAdd(aArray[nX+1],{"D3_UM"     	, SB1->B1_UM			,NIL})// 03.Unidade de Medida
				aAdd(aArray[nX+1],{"D3_LOCAL"  	, aItens[nX,02]			,NIL})// 04.Local Origem
				aAdd(aArray[nX+1],{"D3_LOCALIZ"	, aItens[nX,10]			,NIL})// 05.Endereco Origem
				aAdd(aArray[nX+1],{"D3_COD"    	, SB1->B1_COD			,NIL})// 06.Produto Destino
				aAdd(aArray[nX+1],{"D3_DESCRI" 	, SB1->B1_DESC			,NIL})// 07.Descricao
				aAdd(aArray[nX+1],{"D3_UM"     	, SB1->B1_UM			,NIL})// 08.Unidade de Medida
				aAdd(aArray[nX+1],{"D3_LOCAL"  	, aItens[nX,04]			,NIL})// 09.Armazem Destino
				aAdd(aArray[nX+1],{"D3_LOCALIZ"	, aItens[nX, nPEndDes]	,NIL})// 10.Endereco Destino 
				aAdd(aArray[nX+1],{"D3_NUMSERI"	, aItens[nX,11]			,NIL})// 11.Numero de Serie
				aAdd(aArray[nX+1],{"D3_LOTECTL"	, aItens[nX,07]			,NIL})// 12.Lote Origem
				aAdd(aArray[nX+1],{"D3_NUMLOTE"	, aItens[nX,08]			,NIL})// 13.Sub-Lote
				aAdd(aArray[nX+1],{"D3_DTVALID"	, aItens[nX,09]			,NIL})// 14.Data de Validade
				aAdd(aArray[nX+1],{"D3_POTENCI"	, CriaVar("D3_POTENCI")	,NIL})// 15.Potencia do Lote
				aAdd(aArray[nX+1],{"D3_QUANT"  	, aItens[nX,05]			,NIL})// 16.Quantidade
				aAdd(aArray[nX+1],{"D3_QTSEGUM"	, aItens[nX,06]			,NIL})// 17.Quantidade na 2 UM
				aAdd(aArray[nX+1],{"D3_ESTORNO"	, CriaVar("D3_ESTORNO")	,NIL})// 18.Estorno
				aAdd(aArray[nX+1],{"D3_NUMSEQ" 	, cNumSeqP3				,NIL})// 19.NumSeq
				aAdd(aArray[nX+1],{"D3_LOTECTL"	, aItens[nX,07]			,NIL})// 20.Lote Destino
				aAdd(aArray[nX+1],{"D3_DTVALID"	, aItens[nX,09]			,NIL})// 21.Data de Validade Destino
			Next nX

			MATA261(aArray,3) //Inclusao da transferencia interna

		EndIf

		//-- Tratamento de erro para rotina automatica
		If lMsErroAuto
			// Notificacao do erro na rotina automatica
			If !IsBlind() .And. (IsInCallStack("MATA460A") .Or. IsInCallStack("MATA103") .or. IsInCallStack("MATA410"))
				MostraErro()
			EndIf
			DisarmTransaction()
			Break
		EndIf

		//-- Realiza o bloqueio do Armazem de Terceiros
		dbSelectArea("SB2")
		dbSetOrder(1)
		If MsSeek(xFilial("SB2")+cProduto+SubStr(cLocTerc,1,nTamLoc))
			RecLock("SB2",.F.)
			Replace B2_STATUS With "2"
			MsUnLock()
		EndIf

	EndIf
	RestArea(aAreaSD1)
	RestArea(aAreaSD2)
	RestArea(aAreaSB1)
	RestArea(aAreaSB2)
	RestArea(aAreaSF4)
	RestArea(aAreaSBE)
	RestArea(aAreaAnt)
EndIf

//-- Apaga Indice Temporario
If !Empty(cTrbSD3)
	RetIndex('SD3')
	Ferase(cTrbSD3+OrdBagExt())
EndIf

Return

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ CalcEstCP   ³ Autor ³ Microsiga S/A      ³ Data ³ 17.04.08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Rotina utilizada para retornar o saldo do custo em partes  ³±±
±±³			 ³ na parte selecionada                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpA1 := CalcEst(ExpC1,ExpC2,ExpD1) 						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array com o Saldo Inicial para o Produto/Local.	  ³±±
±±³			 ³ ExpC1 = Codigo do Produto								  ³±±
±±³			 ³ ExpC2 = Local (AlmoxarIfado)								  ³±±
±±³			 ³ ExpD1 = Data para obter o Saldo Inicial.					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ SIGACUS													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CalcEstCP(cCod,cLocal,dData,cFilAux,lConsTesTerc,nParte)
#define F_SB9  1
#define F_SD1  2
#define F_SD2  3
#define F_SD3  4
#define F_SF4  5
#define F_SF5  6

Local nReg,nReg1,nOrd,nOrd1,dDtVai

	Local lHasRec := .F.

Local aSaldo     := { 0,0,0,0,0,0,0,0,0,0,0,0 }
Local cLocProc   := GetMvNNR('MV_LOCPROC','99')
Local cArq       := Alias()
Local nCnt01     := 0

Local aFilial  := { xFilial( "SB9" ),;
                    xFilial( "SD1" ),;
                    xFilial( "SD2" ),;
                    xFilial( "SD3" ),;
                    xFilial( "SF4" ),;
                    xFilial( "SF5" ) }

Local lRemInt  := SuperGetMv("MV_REMINT",.F.,.F.)

Local cMV_MOEDACM:= SuperGetMv('MV_MOEDACM',.F.,"2345")

Default lConsTesTerc := .F.
Default dData        := dDataBase
Default nParte       := 1

dData	 := If(Empty(dData),Ctod( "01/01/80","ddmmyy" ),dData)

If !(cFilAux == NIL)
	For nCnt01 := 1 To Len( aFilial )
		If !(aFilial[ nCnt01 ] == "  ")
			aFilial[ nCnt01 ] := cFilAux
		EndIf
	Next
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de partida para compor o saldo inicial.        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea( "SB9" )
		DbSeek(aFilial[ F_SB9 ]+cCod+cLocal)
		lHasRec := .f.
		While !Eof() .and. (aFilial[ F_SB9 ]+cCod+cLocal == B9_FILIAL + B9_COD+B9_Local)
			If B9_DATA >= dData .and. lHasRec
				Exit
			Else
				lHasRec := .t.
			EndIf
			DbSkip()
		End
		If lHasRec
			DbSkip(-1)
		EndIf

If ((aFilial[ F_SB9 ]+cCod+cLocal == SB9->B9_FILIAL+SB9->B9_COD+SB9->B9_Local) .And. ;
	(SB9->B9_DATA < dData))

	aSaldo[01] := SB9->B9_QINI
	aSaldo[02] := &("SB9->B9_CP"+StrZero(nParte,2)+"01")
	If '2' $ cMV_MOEDACM   
		aSaldo[03] := &("SB9->B9_CP"+StrZero(nParte,2)+"02")
	EndIf 
	If '3' $ cMV_MOEDACM
		aSaldo[04] := &("SB9->B9_CP"+StrZero(nParte,2)+"03")
	EndIf 
	If '4' $ cMV_MOEDACM
		aSaldo[05] := &("SB9->B9_CP"+StrZero(nParte,2)+"04")
	EndIf 
	If '5' $ cMV_MOEDACM
		aSaldo[06] := &("SB9->B9_CP"+StrZero(nParte,2)+"05")
	EndIf 
	aSaldo[07] := SB9->B9_QISEGUM
		aSaldo[08] := SB9->B9_CM1
		aSaldo[09] := SB9->B9_CM2
		aSaldo[10] := SB9->B9_CM3
		aSaldo[11] := SB9->B9_CM4
		aSaldo[12] := SB9->B9_CM5
	dDtVai    := SB9->B9_DATA+1
Else
	dDtVai    := Ctod( "01/01/80","ddmmyy" )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Correr SD1, SD2 e SD3 para  obter o saldo na Data desejada. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea( "SF4" )
nReg1 := Recno()
nOrd1 := Indexord()

DbSelectArea( "SD1" )
nReg := Recno()
nOrd := IndexOrd()
DbSetOrder( 7 )

DbSeek( aFilial[ F_SD1 ]+cCod+cLocal+Dtos(dDtVai),.T. )

While (!Eof() .And. ;
	(aFilial[ F_SD1 ]+cCod+cLocal) == (SD1->D1_FILIAL+SD1->D1_COD+SD1->D1_Local) .And.;
	(SD1->D1_DTDIGIT < dData))

	If cPaisLoc != "BRA"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Desconsiderar notas de remito e notas geradas pelo EIC       ³
		//| com excecao da nota de FOB.									 |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !Empty(SD1->D1_REMITO) .Or. SD1->D1_TIPO_NF $ '6789AB'
			SD1->(DbSkip())
			Loop
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Desconsiderar notas de entrada tipo 10 quando o cliente uti_ |
		//| lizar o conceito de remito interno com importacao (SIGAEIC)  |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lRemInt
		  	If !Empty(SD1->D1_CONHEC) .And. SD1->D1_TIPO_NF $ '5' .And. SD1->D1_TIPODOC $ '10'
				SD1->(DbSkip())
				Loop
			EndIf
		EndIf

	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Somente Notas Fiscais Nao Lancadas No Modulo do Livro Fiscal ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !(SD1->D1_ORIGLAN == "LF")
		DbSelectArea( "SF4" )
		If ((SF4->F4_FILIAL+SF4->F4_CODIGO == aFilial[ F_SF4 ]+SD1->D1_TES ) .Or. ;
			DbSeek( aFilial[ F_SF4 ]+SD1->D1_TES,.F. ))
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Somente TES Que Movimenta Estoque Deve Ser Considerada ³
			//³ ou TES de poder de terceiros com parametro ligado      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (SF4->F4_ESTOQUE == "S") .Or. (lConsTesTerc .And. SF4->F4_PODER3 $ "RD")
				aSaldo[1] += SD1->D1_QUANT
				aSaldo[2] += &("SD1->D1_CP"+StrZero(nParte,2)+"01")
				If '2' $ cMV_MOEDACM	
					aSaldo[3] += &("SD1->D1_CP"+StrZero(nParte,2)+"02")
				EndIf
				If '3' $ cMV_MOEDACM 
					aSaldo[4] += &("SD1->D1_CP"+StrZero(nParte,2)+"03")
				EndIf 
				If '4' $ cMV_MOEDACM
					aSaldo[5] += &("SD1->D1_CP"+StrZero(nParte,2)+"04")
				EndIf 
				If '5' $ cMV_MOEDACM	
					aSaldo[6] += &("SD1->D1_CP"+StrZero(nParte,2)+"05")
				EndIf 	
				aSaldo[7] += SD1->D1_QTSEGUM
			EndIf
		EndIf
		DbSelectArea( "SD1" )
	EndIf
	DbSkip(1)
End

DbSetOrder( nOrd ) ; MsGoTo( nReg )

DbSelectArea( "SD2" )
nReg := Recno()
nOrd := IndexOrd()
DbSetOrder( 6 )

DbSeek( aFilial[ F_SD2 ]+cCod+cLocal+DtoS( dDtVai ),.T. )

While (!Eof() .And. ;
	(aFilial[ F_SD2 ]+cCod+cLocal == SD2->D2_FILIAL+SD2->D2_COD+SD2->D2_Local) .And. ;
	(SD2->D2_EMISSAO < dData))

	If !Empty(SD2->D2_REMITO) .And. !(SD2->D2_TPDCENV $ "A1")
		SD2->(DbSkip())
		Loop
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Despreza Notas Fiscais Lancadas Pelo Modulo do Livro Fiscal  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !(SD2->D2_ORIGLAN == "LF")
		DbSelectArea("SF4")
		If ((SF4->F4_FILIAL+SF4->F4_CODIGO == aFilial[ F_SF4 ]+SD2->D2_TES ) .Or. ;
			DbSeek( aFilial[ F_SF4 ]+SD2->D2_TES,.F. ))
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Somente TES Que Movimenta Estoque Deve Ser Considerada ³
			//³ ou TES de poder de terceiros com parametro ligado      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (SF4->F4_ESTOQUE == "S") .Or. (lConsTesTerc .And. SF4->F4_PODER3 $ "RD")
				aSaldo[1] -= SD2->D2_QUANT
				aSaldo[2] -= &("SD2->D2_CP"+StrZero(nParte,2)+"01")
				If '2' $ cMV_MOEDACM
					aSaldo[3] -= &("SD2->D2_CP"+StrZero(nParte,2)+"02")
				EndIf 
				If '3' $ cMV_MOEDACM
					aSaldo[4] -= &("SD2->D2_CP"+StrZero(nParte,2)+"03")
				EndIf
				If '4' $ cMV_MOEDACM
					aSaldo[5] -= &("SD2->D2_CP"+StrZero(nParte,2)+"04")
				EndIf 
				If '5' $ cMV_MOEDACM
					aSaldo[6] -= &("SD2->D2_CP"+StrZero(nParte,2)+"05")
				EndIf 
				aSaldo[7] -= SD2->D2_QTSEGUM
			EndIf
		EndIf
		DbSelectArea( "SD2" )
	EndIf
	DbSkip(1)
End

DbSetOrder( nOrd ) ; MsGoTo( nReg )


DbSetOrder( nOrd ) ; MsGoTo( nReg )

DbSelectArea( "SF4" )
DbSetOrder( nOrd1 ) ; MsGoTo( nReg1 )

DbSelectArea( "SF5" )
nReg1 := Recno()
nOrd1 := IndexOrd()

DbSelectArea( "SD3" )
nReg := Recno()
nOrd := IndexOrd()
DbSetOrder( 7 )

DbSeek( aFilial[ F_SD3 ]+cCod+cLocal+DtoS( dDtVai ),.T. )

While (!Eof() .And. ;
	(aFilial[ F_SD3 ]+cCod+cLocal == SD3->D3_FILIAL+SD3->D3_COD+SD3->D3_Local) .And. ;
	(SD3->D3_EMISSAO < dData))
	If !D3Valido()
		DbSkip()
		Loop
	EndIf
	DbSelectArea( "SF5" )
	If ((SF5->F5_FILIAL+SF5->F5_CODIGO == aFilial[ F_SF5 ]+SD3->D3_TM) .Or. ;
		(SD3->D3_TM == "499") .Or. ;
		(SD3->D3_TM == "999") .Or. ;
		DbSeek( aFilial[ F_SF5 ]+SD3->D3_TM,.F. ))
		If SD3->D3_TM >"500"
			aSaldo[1] -= SD3->D3_QUANT
			aSaldo[2] -= &("SD3->D3_CP"+StrZero(nParte,2)+"01")
			If '2' $ cMV_MOEDACM
				aSaldo[3] -= &("SD3->D3_CP"+StrZero(nParte,2)+"02")
			EndIf 
			If '3' $ cMV_MOEDACM
				aSaldo[4] -= &("SD3->D3_CP"+StrZero(nParte,2)+"03")
			EndIf 
			If '4' $ cMV_MOEDACM
				aSaldo[5] -= &("SD3->D3_CP"+StrZero(nParte,2)+"04")
			EndIf 
			If '5' $ cMV_MOEDACM
				aSaldo[6] -= &("SD3->D3_CP"+StrZero(nParte,2)+"05")
			EndIf 
			aSaldo[7] -= SD3->D3_QTSEGUM
		Else
			aSaldo[1] += SD3->D3_QUANT
			aSaldo[2] += &("SD3->D3_CP"+StrZero(nParte,2)+"01")
			If '2' $ cMV_MOEDACM
				aSaldo[3] += &("SD3->D3_CP"+StrZero(nParte,2)+"02")
			EndIf 
			If '3' $ cMV_MOEDACM
				aSaldo[4] += &("SD3->D3_CP"+StrZero(nParte,2)+"03")
			EndIf 
			If '4' $ cMV_MOEDACM
				aSaldo[5] += &("SD3->D3_CP"+StrZero(nParte,2)+"04")
			EndIf
			If '5' $ cMV_MOEDACM 
				aSaldo[6] += &("SD3->D3_CP"+StrZero(nParte,2)+"05")
			EndIf 
			aSaldo[7] += SD3->D3_QTSEGUM
		EndIf
	EndIf
	DbSelectArea( "SD3" ) ; DbSkip(1)
End

If cLocal == cLocProc

	DbSetOrder( 7 )

	DbSeek( aFilial[ F_SD3 ]+cCod,.T. )

	While (!Eof() .And. ;
		(aFilial[ F_SD3 ]+cCod == SD3->D3_FILIAL+SD3->D3_COD) .And. ;
		(SD3->D3_EMISSAO < dData))

		If ((SD3->D3_EMISSAO <  dData)      .And. ;
			(SD3->D3_EMISSAO >= dDtVai)     .And. ;
			(SubS( SD3->D3_CF,2 ) == "E3")  .And. ;
			!(SD3->D3_Local == cLocProc))

			If !D3Valido()
				DbSkip()
				Loop
			EndIf

			DbSelectArea( "SF5" )

			If ((SF5->F5_FILIAL+SF5->F5_CODIGO == aFilial[ F_SF5 ]+SD3->D3_TM) .Or. ;
				(SD3->D3_TM == "499") .Or. ;
				(SD3->D3_TM == "999") .Or. ;
				DbSeek( aFilial[ F_SF5 ]+SD3->D3_TM,.F. ))

				If SD3->D3_CF = "RE3"

					aSaldo[1] += SD3->D3_QUANT
					aSaldo[2] += &("SD3->D3_CP"+StrZero(nParte,2)+"01")
					If '2' $ cMV_MOEDACM
						aSaldo[3] += &("SD3->D3_CP"+StrZero(nParte,2)+"02")
					EndIf 
					If '3' $ cMV_MOEDACM
						aSaldo[4] += &("SD3->D3_CP"+StrZero(nParte,2)+"03")
					EndIf 
					If '4' $ cMV_MOEDACM
						aSaldo[5] += &("SD3->D3_CP"+StrZero(nParte,2)+"04")
					EndIf 
					If '5' $ cMV_MOEDACM
						aSaldo[6] += &("SD3->D3_CP"+StrZero(nParte,2)+"05")
					EndIf 
					aSaldo[7] += SD3->D3_QTSEGUM
				ElseIf SD3->D3_CF = "DE3"

					aSaldo[1] -= SD3->D3_QUANT
					aSaldo[2] -= &("SD3->D3_CP"+StrZero(nParte,2)+"01")
					If '2' $ cMV_MOEDACM
						aSaldo[3] -= &("SD3->D3_CP"+StrZero(nParte,2)+"02")
					EndIf 
					If '3' $ cMV_MOEDACM
						aSaldo[4] -= &("SD3->D3_CP"+StrZero(nParte,2)+"03")
					EndIf 
					If '4' $ cMV_MOEDACM
						aSaldo[5] -= &("SD3->D3_CP"+StrZero(nParte,2)+"04")
					EndIf 
					If '5' $ cMV_MOEDACM
						aSaldo[6] -= &("SD3->D3_CP"+StrZero(nParte,2)+"05")
					EndIf 
					aSaldo[7] -= SD3->D3_QTSEGUM
				EndIf
			EndIf
		EndIf

		DbSelectArea("SD3")
		DbSkip()
	End
EndIf

DbSetOrder( nOrd ) ; MsGoTo( nReg )


DbSelectArea("SF5")
DbSetOrder( nOrd1 ) ; MsGoTo( nReg1 )

DbSelectArea( cArq )

Return( aSaldo )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o    ³ SldEmpOP                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Autor     ³ Microsiga Software S/A                   ³ Data ³ 10/10/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Retorna o Saldo Empenhado de uma determinado Ordem de      ³±±
±±³           ³ Producao.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³ ExpC1 = Codigo do Produto                                  ³±±
±±³           ³ ExpC2 = Codigo do Armazem                                  ³±±
±±³           ³ ExpC3 = Numeracao do Lote                                  ³±±
±±³           ³ ExpC4 = Numeracao do SubLote                               ³±±
±±³           ³ ExpC5 = Codigo da Ordem de Producao                        ³±±
±±³           ³ ExpC6 = Localizacao ou rastro (SDC ou SD4)                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno    ³ Array[1] - Saldo Empenhado na 1a.UM                        ³±±
±±³           ³ Array[2] - Saldo Empenhado na 2a.UM                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function SldEmpOP(cProd,cLocal,cLoteCtl,cNumLote,cOP,cLocaliz,cNumSeri,cLocRas)

Static aSetEmpOp  := {}
Static aPrepEmpOp := {}

Local aAreaAnt  := GetArea()
Local aAreaSD4  := SD4->(GetArea())
Local aSaldo	:= {0,0}
Local aInsert   := {}
Local cAliasSD4	:= "SD4"
Local cQuery	:= ""
Local cMD5      := ""
Local nPosPrep  := 0
Local nX        := 0

Default cLoteCtl := CriaVar('D4_LOTECTL', .F.)
Default cNumlote := CriaVar('D4_NUMLOTE', .F.)
Default cLocaliz := CriaVar('DC_LOCALIZ', .F.)
Default cNumSeri := CriaVar('DC_NUMSERI', .F.)
Default cLocRas	 := "R"
Default cOP      := CriaVar('D4_OP'     , .F.)

__lCusaVLib := Iif(__lCusaVLib == NIL,FWLibVersion() >= "20211116",__lCusaVLib)

If Len(aSetEmpOp) == 0
	aAdd(aSetEmpOp, {"QTD1SD4", "N", TamSx3("D4_QUANT")[1],   TamSx3("D4_QUANT")[2]})
	aAdd(aSetEmpOp, {"QTD2SD4", "N", TamSx3("D4_QTSEGUM")[1], TamSx3("D4_QTSEGUM")[2]})
EndIf

	cAliasSD4	:= "SALDOSD4"
	If cLocRas == "R"
		cQuery := "SELECT SUM(SD4.D4_QUANT) AS QTD1SD4, SUM(SD4.D4_QTSEGUM) AS QTD2SD4 FROM " +RetSqlName("SD4") +" SD4 "
		cQuery += "WHERE SD4.D4_FILIAL = ? AND "
		cQuery += "SD4.D4_OP = ? AND "
		cQuery += "SD4.D4_COD = ? AND "
		cQuery += "SD4.D4_LOCAL = ? AND "
		cQuery += "SD4.D4_QUANT > 0 AND "
		aAdd(aInsert, xFilial("SD4"))
		aAdd(aInsert, cOP)
		aAdd(aInsert, cProd)
		aAdd(aInsert, cLocal)
		//-- Considera Lote no filtro
		If !Empty(cLoteCtl)
			cQuery += "SD4.D4_LOTECTL = ? AND "
			aAdd(aInsert, cLoteCtl)
		EndIf
		//-- Considera SubLote no filtro
		If !Empty(cNumLote) .And. Rastro(cProd,"S")
			cQuery += "SD4.D4_NUMLOTE = ? AND "
			aAdd(aInsert, cNumLote)
		EndIf
		cQuery += "SD4.D_E_L_E_T_=' ' "
	ElseIf cLocRas == "L"
		cQuery := "SELECT SUM(SDC.DC_QUANT) AS QTD1SD4, SUM(SDC.DC_QTSEGUM) AS QTD2SD4 FROM " +RetSqlName("SDC") +" SDC "
		cQuery += "WHERE SDC.DC_FILIAL = ? AND "
		cQuery += "SDC.DC_OP = ? AND "
		cQuery += "SDC.DC_PRODUTO = ? AND "
		cQuery += "SDC.DC_LOCAL = ? AND "
		cQuery += "SDC.DC_QUANT > 0 AND "
		aAdd(aInsert, xFilial("SDC"))
		aAdd(aInsert, cOP)
		aAdd(aInsert, cProd)
		aAdd(aInsert, cLocal)
		//-- Considera Lote no filtro
		If !Empty(cLoteCtl)
			cQuery += "SDC.DC_LOTECTL = ? AND "
			aAdd(aInsert, cLoteCtl)
		EndIf
		//-- Considera SubLote no filtro
		If !Empty(cNumLote) .And. Rastro(cProd,"S")
			cQuery += "SDC.DC_NUMLOTE = ? AND "
			aAdd(aInsert, cNumLote)
		EndIf
		//-- Considera localizacao fisica no filtro
		If !Empty(cLocaliz)
			cQuery += "SDC.DC_LOCALIZ = ? AND "
			aAdd(aInsert, cLocaliz)
		EndIf
		//-- Considera numero de serie no filtro
		If !Empty(cNumSeri)
			cQuery += "SDC.DC_NUMSERI = ? AND "
			aAdd(aInsert, cNumSeri)
		EndIf
		cQuery += "SDC.D_E_L_E_T_=' ' "
	EndIf

	// Define um identificador para a query
	cMD5 := MD5(cQuery)
	
	If (nPosPrep := aScan(aPrepEmpOp,{|x| x[2] == cMD5})) == 0
		If __lCusaVLib
			// FwExecStatement - realiza o bind de queries diretamente no banco de dados obtendo ganho de performance
			Aadd(aPrepEmpOp,{FwExecStatement():New(),cMD5})
		Else
			// Monta FWPreparedStatement e ChangeQuery apenas 1x para cada variacao da query	
			aAdd(aPrepEmpOp,{FWPreparedStatement():New(), cMD5})
		EndIf
		nPosPrep := Len(aPrepEmpOp)
		aPrepEmpOp[nPosPrep][1]:SetQuery(ChangeQuery(cQuery))
	EndIf
	// Seta as variaveis na query
	For nX := 1 To Len(aInsert)
		aPrepEmpOp[nPosPrep][1]:SetString(nX, aInsert[nX])
	Next nX
	
	If __lCusaVLib
		cAliasSD4 := aPrepEmpOp[nPosPrep][1]:OpenAlias(cAliasSD4)
		DbSelectArea(cAliasSD4)

		TCSetField(cAliasSD4, "QTD1SD4", "N", TamSx3("D4_QUANT")[1]  , TamSx3("D4_QUANT")[2])
		TCSetField(cAliasSD4, "QTD2SD4", "N", TamSx3("D4_QTSEGUM")[1], TamSx3("D4_QTSEGUM")[2])

		aSaldo[1] := aPrepEmpOp[nPosPrep][1]:ExecScalar('QTD1SD4')
		aSaldo[2] := aPrepEmpOp[nPosPrep][1]:ExecScalar('QTD2SD4')
	Else
		// Recupera a query transformada
		cQuery := aPrepEmpOp[nPosPrep][1]:getFixQuery()

		// Abre um alias com a query e ja executa o TCSetField nos campos
		cAliasSD4 := MPSysOpenQuery(cQuery, cAliasSD4, aSetEmpOp)

		//-- Saldo empenhado para Ordem de Producao
		aSaldo[1] := (cAliasSD4)->QTD1SD4
		aSaldo[2] := (cAliasSD4)->QTD2SD4
	EndIf
	(cAliasSD4)->( dbCloseArea() )

	aInsert := aSize(aInsert,0)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Restaura Ambiente³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RestArea(aAreaSD4)
RestArea(aAreaAnt)
Return aSaldo

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡ao    ³ AvalBlqLoc                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Autor     ³ Microsiga Software S/A                   ³ Data ³ 10/12/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Funcao utilizada para verificar se existe bloqueio para    ³±±
±±³           ³ o tipo de armazem a ser movimentado.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³ ExpC01 = Codigo do Produto Origem                          ³±±
±±³           ³ ExpC02 = Codigo do Armazem Origem                          ³±±
±±³           ³ ExpC03 = Codigo da TES Origem                              ³±±
±±³           ³ ExpL04 = Mostra Help na Tela                               ³±±
±±³           ³ ExpC05 = Codigo do Produto Destino                         ³±±
±±³           ³ ExpC06 = Codigo do Armazem Destino                         ³±±
±±³           ³ ExpC07 = Codigo da TES Destino                             ³±±
±±³           ³ ExpC08 = Codigo da Filial Origem                           ³±±
±±³           ³ ExpC09 = Codigo da Filial Destino                          ³±±
±±³           ³ ExpC10 = Codigo da Ordem de Producao                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno    ³ Logico                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function AvalBlqLoc(cCodOrig,cLocOrig,cTesOrig,lHelp,cCodDest,cLocDest,cTesDest,cFilOrig,cFilDest,cOp)
Local lBloqueio := .F.
Local lContinua := .T.
Local cFilBkp   := cFilAnt
Local aAreaAnt  := GetArea()
Local aAreaSB2  := SB2->(GetArea())
Local aAreaSF4  := SF4->(GetArea())
Local cTpBlqPro := '2'
Local cTpBlqTer := '3|4|5'
Local cTipoOrig := CriaVar("B2_TIPO")
Local cTipoDest := CriaVar("B2_TIPO")


Local uRet
Default cFilOrig  := ''
Default cCodOrig  := ''
Default cLocOrig  := ''
Default cTesOrig  := ''
Default cFilDest  := ''
Default cCodDest  := ''
Default cLocDest  := ''
Default cTesDest  := ''
Default lHelp     := .T.

//- verifica a existÊncia de ponto de entrada 
Static __lAvlBloq 
Static __lAvlRegr 

If __lAvlBloq == nil 
	__lAvlBloq := ExistBlock('AVALBLOQ')
 	__lAvlRegr := ExistBlock('AVALREGR')
EndIf 

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³AVALREGR - Ponto de entrada utilizado para definir regras especificas  ³
//³           para bloqueio de produtos/armazens.                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If __lAvlRegr
	uRet := ExecBlock('AVALREGR',.F.,.F.,{cCodOrig,cLocOrig,cTesOrig,lHelp,cCodDest,cLocDest,cTesDest,cFilOrig,cFilDest,cOp})
	If Valtype(uRet) == "L"
		lBloqueio := uRet
		lContinua := .F.
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Validacao padrao de bloqueio de produtos/armazens                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lContinua
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³AVALBLOQ - Ponto de entrada para manipular os bloqueios entre armazens ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If __lAvlBloq
		aRet := ExecBlock('AVALBLOQ',.F.,.F.,{cTpBlqPro,cTpBlqTer})
		If Len(aRet) >= 2
			If ValType(aRet[1]) == "C" .And. ValType(aRet[2]) == "C"
				cTpBlqPro := aRet[1]
				cTpBlqTer := aRet[2]
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Regra Padrao para Bloqueio de Armazens                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Do Case
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Analise de bloqueio para MOVIMENTOS INTERNOS	                      |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Case !Empty(cCodOrig) .And. Empty(cCodDest) .And. Empty(cTesOrig) .And. Empty(cTesDest)
			dbSelectArea("SB2")
			dbSetOrder(1)
			If MsSeek(xFilial("SB2")+cCodOrig+cLocOrig)
				If Empty(cOp) .And. SB2->B2_BLOQUEI $ '2|4'  		//Bloqueia Consumo
					If lHelp
						Help(" ",1,"BLOQLOC1",,STR0144+cLocOrig,5,10)
					EndIf
					lBloqueio := .T.
				ElseIf !Empty(cOp) .And. SB2->B2_BLOQUEI $ '3|4'	//Bloqueia Producao
					If lHelp
						Help(" ",1,"BLOQLOC2",,STR0144+cLocOrig,5,10)
					EndIf
					lBloqueio := .T.
				EndIf
			EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Analise de bloqueio para MOVIMENTOS INTERNOS	(TRANSFERENCIAS)      |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Case !Empty(cCodOrig) .And. !Empty(cCodDest) .And. Empty(cTesOrig) .And. Empty(cTesDest)
			// Analisa Movimento de ORIGEM
			dbSelectArea("SB2")
			dbSetOrder(1)
			If MsSeek(xFilial("SB2")+cCodOrig+cLocOrig)
				If Empty(cOp) .And. SB2->B2_BLOQUEI $ '2|4'  		//Bloqueia Consumo
					If lHelp
						Help(" ",1,"BLOQLOC1",,STR0144+cLocOrig,5,10)
					EndIf
					lBloqueio := .T.
				ElseIf !Empty(cOp) .And. SB2->B2_BLOQUEI $ '3|4'	//Bloqueia Producao
					If lHelp
						Help(" ",1,"BLOQLOC2",,STR0144+cLocOrig,5,10)
					EndIf
					lBloqueio := .T.
				EndIf
				cTipoOrig := If(Empty(SB2->B2_TIPO),"1",SB2->B2_TIPO)
			EndIf
			// Analisa Movimento de DESTINO
			dbSelectArea("SB2")
			dbSetOrder(1)
			//Cria saldo na SB2 caso não exista no armazém destino
			If !(MsSeek(xFilial("SB2")+cCodDest+cLocDest))
				CriaSB2(cCodDest,cLocDest)
			EndIf
			If !lBloqueio
				If Empty(cOp) .And. SB2->B2_BLOQUEI $ '2|4'  		//Bloqueia Consumo
					If lHelp
						Help(" ",1,"BLOQLOC1",,STR0144+cLocDest,5,10)
					EndIf
					lBloqueio := .T.
				ElseIf !Empty(cOp) .And. SB2->B2_BLOQUEI $ '3|4'	//Bloqueia Producao
					If lHelp
						Help(" ",1,"BLOQLOC2",,STR0144+cLocDest,5,10)
					EndIf
					lBloqueio := .T.
				EndIf
				cTipoDest := If(Empty(SB2->B2_TIPO),"1",SB2->B2_TIPO)
			EndIf
			//-- Comparativo entre ORIGEM Versus DESTINO
			If nModulo <> 11 .and. nModulo <> 14 .and. nModulo <> 41 .And. !IsInCallStack('MATA410') // 11=Veiculos, 14=Oficina, 41=Auto Peças
				If !lBloqueio .And. (cTipoDest # cTipoOrig)
					Help(" ",1,"BLOQLOC5")
					lBloqueio := .T.
				EndIf
			EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Analise de bloqueio para DOCUMENTO ENTRADA/SAIDA                   |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Case !Empty(cCodOrig) .And. Empty(cCodDest) .And. !Empty(cTesOrig) .And. Empty(cTesDest)
			dbSelectArea("SB2")
			dbSetOrder(1)
			If MsSeek(xFilial("SB2")+cCodOrig+cLocOrig)
				dbSelectArea('SF4')
				dbSetOrder(1)
				If MsSeek(xFilial("SF4")+cTesOrig) .And. SF4->F4_ESTOQUE == "S"
					// Caso seja movimentacao no armazem proprio NAO permitir PODER3
					If (SB2->B2_TIPO $ cTpBlqPro) .And. (SF4->F4_PODER3 $ "R|D")
						If lHelp
							Help(" ",1,"BLOQLOC3",,STR0144+cLocOrig,5,10)
						EndIf
						lBloqueio := .T.
					// Caso seja movimentacao no armazem terceiros NAO permitir TES sem controle de PODER3
					ElseIf (SB2->B2_TIPO $ cTpBlqTer) .And. !(SF4->F4_PODER3 $ "R|D")
						If lHelp
							Help(" ",1,"BLOQLOC4",,STR0144+cLocOrig,5,10)
						EndIf
						lBloqueio := .T.
					// Bloqueia Producao
					ElseIf !Empty(cOp) .And. SB2->B2_BLOQUEI $ '3|4'
						If lHelp
							Help(" ",1,"BLOQLOC2",,STR0144+cLocDest,5,10)
						EndIf
						lBloqueio := .T.
					EndIf
				EndIf
	    	EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Analise de bloqueio para DOCUMENTO ENTRADA/SAIDA (TRANSFERENCIAS)  |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Case !Empty(cCodOrig) .And. !Empty(cCodDest) .And. !Empty(cTesOrig) .And. !Empty(cTesDest)
			//-- Analise da filial ORIGEM
			cFilAnt := cFilOrig
			dbSelectArea("SB2")
			dbSetOrder(1)
			If MsSeek(xFilial("SB2")+cCodOrig+cLocOrig)
				dbSelectArea('SF4')
				dbSetOrder(1)
				If MsSeek(xFilial("SF4")+cTesOrig) .And. SF4->F4_ESTOQUE == "S"
					// Caso seja movimentacao no armazem proprio NAO permitir PODER3
					If (SB2->B2_TIPO $ cTpBlqPro) .And. (SF4->F4_PODER3 $ "R|D")
						If lHelp
							Help(" ",1,"BLOQLOC3",,STR0144+cLocOrig,5,10)
						EndIf
						lBloqueio := .T.
					// Caso seja movimentacao no armazem terceiros NAO permitir TES sem controle de PODER3
					ElseIf (SB2->B2_TIPO $ cTpBlqTer) .And. !(SF4->F4_PODER3 $ "R|D")
						If lHelp
							Help(" ",1,"BLOQLOC4",,STR0144+cLocOrig,5,10)
						EndIf
						lBloqueio := .T.
					EndIf
					cTipoOrig := If(Empty(SB2->B2_TIPO),"1",SB2->B2_TIPO)
				EndIf
			EndIf
			//-- Analise da filial DESTINO
			cFilAnt := cFilDest
			dbSelectArea("SB2")
			dbSetOrder(1)
			If !lBloqueio .And. MsSeek(xFilial("SB2")+cCodDest+cLocDest)
				dbSelectArea('SF4')
				dbSetOrder(1)
				If MsSeek(xFilial("SF4")+cTesDest)
					// Caso seja movimentacao no armazem proprio NAO permitir PODER3
					If (SB2->B2_TIPO $ cTpBlqPro) .And. (SF4->F4_PODER3 $ "R|D")
						If lHelp
							Help(" ",1,"BLOQLOC3",,STR0144+cLocOrig,5,10)
						EndIf
						lBloqueio := .T.
					// Caso seja movimentacao no armazem terceiros NAO permitir TES sem controle de PODER3
					ElseIf (SB2->B2_TIPO $ cTpBlqTer) .And. !(SF4->F4_PODER3 $ "R|D")
						If lHelp
							Help(" ",1,"BLOQLOC4",,STR0144+cLocOrig,5,10)
						EndIf
						lBloqueio := .T.
					EndIf
					cTipoDest := If(Empty(SB2->B2_TIPO),"1",SB2->B2_TIPO)
				EndIf
			EndIf
			//-- Comparativo entre ORIGEM Versus DESTINO
			If nModulo <> 11 .and. nModulo <> 14 .and. nModulo <> 41 // 11=Veiculos, 14=Oficina, 41=Auto Peças
				If !lBloqueio .And. (cTipoDest # cTipoOrig)
					Help(" ",1,"BLOQLOC5")
					lBloqueio := .T.
				EndIf
			EndIf
			// Restaura Filial Origem
			cFilAnt:=cFilBkp
	EndCase

EndIf
RestArea(aAreaSF4)
RestArea(aAreaSB2)
RestArea(aAreaAnt)
Return lBloqueio
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ IsNegEstrºAutor  ³Andre Anjos         º Data ³  10/02/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Funcao para verificar se um produto e sub-produto em 	  º±±
±±º			 ³ estrutura e qual o estrutura origem.					 	  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cProduto: Codigo do produto analisado.				 	  º±±
±±º			 ³ dDataNec: Data de necessidade do produto.			 	  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno	 ³ aRet[1]: Indica se e sub-produto (.T.=Sim;.F.=Nao).		  º±±
±±º			 ³ aRet[2]: Codigo do produto pai da estrutura origem.		  º±±
±±º			 ³ aRet[3]: Opcional que gera o sub-produto.	  			  º±±
±±º			 ³ aRet[4]: Quantidade necessaria a produzir do PA.			  º±±
±±º			 ³ aRet[5]: Numero de OP's do pai a gerar.					  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATA650, MATA710, MATA170 e MATA760                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function IsNegEstr(cProduto,dDataNec,nQuant,cProdPEst)
Local aAreaBkp := GetArea()
Local aAreaSG1 := SG1->(GetArea())
Local aRet 	   := {.F.,"",""}
Local lNegEstr := SuperGetMV("MV_NEGESTR",.F.,.F.)
Local cProdPai := ""
Local cChave   := "G1_FILIAL+"
Local cSeek	   := xFilial("SG1")
Local cRevAtu  := ""
Local cOpc	   := ""
Local nLaco	   := 1
Local lFantasma := .F.
Local nCalc    := 0
Local nNeces   := 0


Local aEstru   := {}
Local aAreaBkp1
Local aAreaSG11
Local aEstruinv
Local lPCPREVATU	:= FindFunction('PCPREVATU')
Default dDataNec := dDataBase
Default nQuant 	 := 0
Default cProdPEst := ' '

Private nEstru   := 0

SB1->(MsSeek(xFilial("SB1")+cProduto))
cProdPai := SB1->B1_ESTRORI
If !Empty(cProdPai)
	nBloq := SB1->B1_MSBLQL
	If nBloq == '1'
		cProdPai := " "
	EndIf
EndIf
lNegEstr := If(lNegEstr,SB1->B1_PRODSBP == "P",.F.)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Caso exista estrutura origem informada no SB1, verifica se ela	³
//³ existe. Existindo, ja define o retorno senao procura em outra	³
//| estrutura.														³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
While lNegEstr
	dbSelectArea("SG1")
	If !Empty(cProdPai)
		dbSetOrder(1)
		cChave += "G1_COD+G1_COMP"
		cSeek  += cProdPai+cProduto
	Else
		dbSetOrder(2)
		cChave += "G1_COMP"
		cSeek  += cProduto
	EndIf
	dbSeek(cSeek)
	While !EOF() .And. &(cChave) == cSeek
		SB1->(MsSeek(xFilial("SB1")+SG1->G1_COD))
		cRevAtu := IIF(lPCPREVATU , PCPREVATU(SB1->B1_COD), SB1->B1_REVATU )
		cOpc 	:= G1_GROPC+G1_OPC

		nBloq := SB1->B1_MSBLQL
		If nBloq == '1'
			dbSkip()
			Loop
		EndIf

		If ExplEstr(1,dDataNec,cOpc,cRevAtu) < 0
			If !Empty(cProdPEst)
				aAreaBkp1 := GetArea()
				aAreaSG11 := SG1->(GetArea())

				SB1->(MsSeek(xFilial("SB1")+SG1->G1_COD))
				//Se o subproduto é filho de um fantasma, deve procurar o produto pai imediatamente acima do fantasma
				//caso contrário irá criar ordens de produção para o produto fantasma no mata650/mata760/mata712/pcpa107
				if SB1->B1_FANTASM == 'S'
				    lfantasma := .T.
				    nneces:= ExplEstr(1,dDataNec,cOpc,cRevAtu)
					aEstruinv := explinvert(SG1->G1_COD,nneces,dDataNec ) // função irá explodir a estrutura de forma invertida (do componente para o pai)
					AADD(aEstru,{nEstru,aEstruinv[1,1],cProduto,aEstruinv[1,2],,,,})
				else
					nEstru := 0
					aEstru := Estrut(SG1->G1_COD,1,.F.,.F.)
				endif

				RestArea(aAreaSG11)
				RestArea(aAreaBkp1)

				If (aScan(aEstru,{|x| x[3] == cProdPEst }) > 0)
					dbSkip()
					Loop
				Endif
			EndIf

			if lfantasma = .T.
				IF AllTrim(G1_FIXVAR) == "F"
					nLaco := Abs(nQuant/aEstruinv[1,2])
					nLaco := Int(nLaco) + If(((nLaco - Int(nLaco)) > 0),1,0)

	    		//este calculo é baseado na função EstrQtdPai, porém precisa utilizar a quantidade necessária calculada pela explosão invertida da estrutura.
					If !Empty(SB1->B1_LOTESBP)
				        nCalc := SB1->B1_LOTESBP
				    Else
				        nCalc := If(aEstruinv[1,2] <= 0,1,aEstruinv[1,2])
				    EndIf
				else
					nCalc := ((nQuant / aEstruinv[1,2]) * (100 - SG1->G1_PERDA)) / 100
					nCalc := nCalc * If(aEstruinv[1,2] <= 0,1,aEstruinv[1,2])
				EndIf

				nCalc := Abs(nCalc)

				Do Case
				    Case (SB1->B1_TIPODEC == "A")
				        nCalc := Round(nCalc,0)
				    Case (SB1->B1_TIPODEC == "I")
				        nCalc := Int(nCalc) + If(((nCalc - Int(nCalc)) > 0),1,0)
				    Case (SB1->B1_TIPODEC == "T")
				        nCalc := Int(nCalc)
				EndCase

				aRet := {.T.,aEstruinv[1,1],cOpc,nCalc,nLaco}
			else
				IF AllTrim(G1_FIXVAR) == "F"
					nLaco := Abs(nQuant/G1_QUANT)
					nLaco := Int(nLaco) + If(((nLaco - Int(nLaco)) > 0),1,0)
				EndIf
				aRet := {.T.,G1_COD,cOpc,EstrQtdPai(nQuant),nLaco}
			endif
			Exit
		EndIf
		dbSkip()
	End
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ O fim ocorre quando:									³
	//³ A) aRet[2] preenchido - Encontrou estrutura				³
	//| B) cProdPai vazio - Nao encontrou estrutura.			³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(aRet[2]) .Or. Empty(cProdPai)
		Exit
	Else
		cProdPai := ""
	EndIf
End

RestArea(aAreaSG1)
RestArea(aAreaBkp)
Return aRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³EstrQtdPaiºAutor  ³Andre Anjos         º Data ³  10/02/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Calcula, com SG1 posicionados, o quanto de produto	  	  º±±
±±º			 ³ pai e necessario produzir para gerar uma determinada qtde  º±±
±±º			 ³ do sub-produto.											  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ nQuant: Quantidade do sub-produto.						  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno	 ³ nBack: Quantidade do produto pai que deve ser produzida.	  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ IsNegEstr (SIGACUSB)                                       º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function EstrQtdPai(nQuant)
Local nBack    := 0
Local nQtdBase := 0

SB1->(MsSeek(xFilial("SB1")+SG1->G1_COD))
nQtdBase := RetFldProd(SG1->G1_COD,"B1_QB")

If AllTrim(SG1->G1_FIXVAR) $ " V"
	nBack := ((nQuant / SG1->G1_QUANT) * (100 - SG1->G1_PERDA)) / 100
	nBack := nBack * If(nQtdBase <= 0,1,nQtdBase)
Else
	//Quando quantidade fixa nao ha razao para proporcionalizar
	//Neste caso produz o lote de sub-produto ou o minimo (Qtde. Base)
	If !Empty(SB1->B1_LOTESBP)
		nBack := SB1->B1_LOTESBP
	Else
		nBack := If(nQtdBase <= 0,1,nQtdBase)
	EndIf
EndIf

nBack := Abs(nBack)

Do Case
	Case (SB1->B1_TIPODEC == "A")
		nBack := Round(nBack,0)
	Case (SB1->B1_TIPODEC == "I")
		nBack := Int(nBack) + If(((nBack - Int(nBack)) > 0),1,0)
	Case (SB1->B1_TIPODEC == "T")
		nBack := Int(nBack)
EndCase

Return nBack

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡ao    ³ ESTLoad                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Autor     ³ Microsiga Software S/A                   ³ Data ³ 15/10/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Funcao utilizada para executar rotinas na abertura do      ³±±
±±³           ³ do modulo de Estoque e Custos                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Uso      ³ EST                                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function EstLoad()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Realiza Bloqueio automatico de Inventario com base no parametro MV_BLQINVA ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
MATA271(.T.)

//
// Realiza o registro das metricas referente ao modulo de estoque
//
If FindFunction("ESTMetrics") // ESTXFUN.PRW
	ESTMetrics()
EndIf

If FindFunction("fFilDocFis")
	fFilDocFis()
EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ValidaCNI³ Autor ³  Julio Saraiva        ³ Data ³08.06.2012³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Para controle das funcoes do Projeto CNI                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nenhum													 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Projeto CNI                                               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function ValidaCNI()
Local lRet := .F.

lRet := FindFunction("PRJCNI")

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ MtPesqOpcºAutor  ³Andre Anjos         º Data ³  17/12/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Funcao que verifica se para determinado produto ha cadastroº±±
±±º          ³ de opcionais X cliente, retornando o opcional do cadastro. º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ EST/PCP/FAT												  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MtPesqOpc(cProduto,cCliente,aGrupos)
	Local cRet 		:= ""
	//Função migrada para PCPXFUN
	cRet := MtPeOpcPcp(cProduto,cCliente,aGrupos)
Return cRet


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³IsTranCQ | Autor ³  TOTVS S/A            ³ Data ³25/02/2014³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao utilizada para verificar se deve ativar o processo  ³±±
±±³          ³de transferencia de materiais entre filiais para o         ³±±
±±³          ³armazem de CQ.                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ ESTOQUE/FATURAMENTO/COMPRAS (somente TOPCONNECT)          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function IsTranCQ
Local lRet := .F.
#IFDEF TOP
	If Alltrim(cPaisLoc) == "BRA"
		lRet := SuperGetMv("MV_M310TRV",.F.,.F.)
	EndIf
#ENDIF
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} SIGACUSB_V
Verifica a data da última alteração do SIGACUS (DEVERÁ SER RETIRADA APÓS A DIVISÃO DESTE FONTE ENTRE OS MÓDULOS)

@author jose.eulalio
@since 08/05/2014
@version P12
@return nRet
/*/
//-------------------------------------------------------------------
Function SIGACUSB_V
Local nRet := 20141209
Return nRet

//-------------------------------------------------------------------
/*/{Protheus.doc} MtGetProd()
Retorna o produto digitado no grid para ser utilizado no filtro da consulta padrão CX1.

@author taniel.silva
@since 22/01/2015
@version P12
@return cProd
/*/
//--------------------------------------------------------------------

Function MtGetProd()
Local oModel
Local nPosCod
Local cProd := ""

If IsInCallStack("MATA103") .Or. IsInCallStack("MATA140")
	nPosCod	:= GDFieldPos( "D1_COD"  )
	cProd 		:= aCols[n,nPosCod]
ELseIf IsInCallStack("CNTA300")
    oModel	:= FWModelActive()
	cProd	:= oModel:GetModel("CNBDETAIL"):GetValue("CNB_PRODUT")
ELseIf IsInCallStack("MATA120")
	nPosCod	:= GDFieldPos( "C7_PRODUTO"  )
	cProd		:= aCols[n,nPosCod]
ELseIf IsInCallStack("GCPA300")
	oModel	:= FWModelActive()
	cProd	:= oModel:GetModel("CPYDETAIL"):GetValue("CPY_CODPRO")
EndIf


Return cProd


//------------------------------------------------------------------
/*/{Protheus.doc} VerIDProc()
Identifica a sequencia de controle do fonte ADVPL com a
stored procedure, qualquer alteracao que envolva diretamente
a stored procedure a variavel sera incrementada.
Procedure MAT029 - 17
@author André Maximo
@since 08/07/2016
@version P12
/*/
//-------------------------------------------------------------------


Static Function VerIDProc()
Return STATICCALL (MATA280,VERIDPROC)

//-------------------------------------------------------------------

//-------------------------------------------------------------------
/*/{Protheus.doc} MTWmsPai()
Função para setar o produto e trabalhar com o objeto
@author taniel.silva
@since 11/11/2014
@version P118
@return lRet
/*/
//-------------------------------------------------------------------
Function MTWmsPai(cProduto,oProduto)
Local aSavArea   := GetArea()
Local lWmsNew  := SuperGetMV("MV_WMSNEW",.F.,.F.) .And. IntWMS(cProduto)

If lWmsNew
	oProduto := WMSDTCProdutoComponente():New()
	oProduto:SetProduto(cProduto)
	oProduto:SetPrdOri(cProduto)
	oProduto:EstProduto()
EndIf

RestArea(aSavArea)

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} MtWMSGtPai()
Função que retorna o pai Referente ao Filho
@author Flavio Lopes Rasta
@since 11/11/2014
@version P118
@return lRet
/*/
//-------------------------------------------------------------------
Function MtWMSGtPai(cProduto)
Local oProduto	:= Nil
Local cPai			:= cProduto
Local aSavArea   := GetArea()

oProduto := WMSDTCProdutoComponente():New()
oProduto:SetPrdCmp(cProduto)
oProduto:LoadData(2)
If !Empty(oProduto:GetProduto())
	cPai := oProduto:GetProduto()
Endif

RestArea(aSavArea)
Return cPai

//-------------------------------------------------------------------
/*/{Protheus.doc} MTVerPai()
Função para verificar se o produto pai tem partes e bloquear a inclusão no  inventário e mestre inventário.
@author taniel.silva
@since 11/11/2014
@version P118
@return lRet
/*/
//-------------------------------------------------------------------
Function MTVerPai(cProd,lShowHelp)
Local lIntegraWMS	:= SuperGetMv('MV_WMSNEW',.F.,.F.) .And. IntWMS(cProd)
Local lRet := .T.
Local oProduto := Nil
Local aSavArea   := GetArea()
Local lInvent		:= IsInCallStack("ACDV035")
Local lTransIn		:= (IsInCallStack("MATA260") .Or. IsInCallStack("MATA261"))

Default lShowHelp := .T.
Default cProd := &(ReadVar())

If lIntegraWMS
	oProduto := WMSDTCProdutoComponente():New()
 	oProduto:SetProduto(cProd)
	oProduto:SetPrdOri(cProd)
	oProduto:EstProduto()

	If	aScan(oProduto:aProduto,{|x| x[1] == (oProduto:GetProduto())}) = 0
		lRet := .F.
		If lShowHelp
			If lInvent
				Help(" ",1,"A270VERPAI")
			ElseIf !lTransIn
				Help(" ",1,"AVERPAIMOV")
			Else
				Help(" ",1,"AVERPAITRF")
			EndIf
		Endif
	EndIf
EndIf

RestArea(aSavArea)
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³EndUsadWMS | Autor ³  Antenor            ³ Data ³27/11/2014³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Função que indica se um endereço está sendo usado pelo WMS ³±±
±±³          ³(T=Sim;F=Não)                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ ESTOQUE/FATURAMENTO/COMPRAS (somente TOPCONNECT)          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function EndUsadWMS(cLocal,cLocaliz)
Local lRet 		:= .F.
Local aAreaSBE	:= SBE->(GetArea())
Local cAliasSBE := GetNextAlias()

	cLocal   := PadR(cLocal, TamSx3("DB_LOCAL")[1])
	cLocaliz := PadR(cLocaliz, TamSx3("DB_LOCALIZ")[1])
	BeginSql Alias cAliasSBE
		SELECT 1
		FROM %Table:SBE% SBE
		WHERE SBE.BE_FILIAL = %xFilial:SBE%
		AND SBE.BE_LOCAL = %Exp:cLocal%
		AND SBE.BE_LOCALIZ = %Exp:cLocaliz%
		AND SBE.BE_ESTFIS = ' '
		AND SBE.BE_CODZON = ' '
	EndSql
	If (cAliasSBE)->(Eof())
		lRet := .T.
	EndIf
	(cAliasSBE)->(dbCloseArea())
	RestArea(aAreaSBE)
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³BloqEndWMS | Autor ³  Antenor            ³ Data ³27/11/2014³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Função que bloqueia endereçamento em endereços utilizados  ³±±
³±±				pelo WMS                                                   ³±±                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ ESTOQUE/FATURAMENTO/COMPRAS (somente TOPCONNECT)          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function BloqEndWMS(cLocal,cEnd)
Local lRet	   := .T.
Local lWmsNew  := SuperGetMV("MV_WMSNEW",.F.,.F.)
Default cLocal := ""
Default cEnd   := ""
	If lWmsNew
		cLocal := IIf(Empty(cLocal),M->DA_LOCAL,cLocal)
		cEnd   := If(Empty(cEnd),M->DB_LOCALIZ,cEnd)
		If EndUsadWMS(cLocal ,cEnd)
			Help("",1,"BloqEndWMS")
			lRet := .F.
		EndIf
	EndIf
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o   ProdIsWms   ³| Autor ³  Matheus Lando      ³ Data ³20/01/2015³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Função que indica se um produto controla WMS               ³±±
³±±				pelo WMS                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ ESTOQUE/FATURAMENTO/COMPRAS (somente TOPCONNECT)          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ProdIsWms(cProd)
Local lRet		:= .F.
Local lWmsNew := SuperGetMV("MV_WMSNEW",.F.,.F.) .And. (SuperGetMV("MV_INTDL",.F.,"N")=="S")

SB5->(dbSetOrder(1))
If lWmsNew .And. IntDl(cProduto)
	lRet := .T.
Else
	lRet := .F.
EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} EspDH1Wms()
Funcao para gravar a tabela espenho da SD3 para a DH1
@author Bruno.Schmidt
@since 10/08/2015
@version P12.7
/*/
//-------------------------------------------------------------------
Function EspDH1Wms(aItenSD3,cRotina,cA240End,cGravaWms,oOrdServ,aCpoAuxUsr)
Local nx := 0
Local lRet := .T.
Local nY	:= 0
Default cGravaWms := "1"
Default aItenSD3 := {}
Default cA240End := ""
Default aCpoAuxUsr := {}

	For nX := 1 to Len(aItenSD3)
		// Grava na Tabela DH1
		dbSelectArea("DH1")
		RecLock("DH1",.T.)
		DH1->DH1_FILIAL	:=	aItenSD3[nX][1]
		DH1->DH1_TM		:=	aItenSD3[nX][2]
		DH1->DH1_EMISAO	:=	aItenSD3[nX][3]
		DH1->DH1_NUMSEQ	:=	aItenSD3[nX][4]
		DH1->DH1_PRODUT	:=	aItenSD3[nX][5]
		DH1->DH1_LOTECT	:=	aItenSD3[nX][6]
		DH1->DH1_LOCAL	:=	aItenSD3[nX][7]
		DH1->DH1_LOCALI	:=	aItenSD3[nX][8]
		DH1->DH1_QUANT	:=	aItenSD3[nX][9]
		DH1->DH1_QTSEGU	:=	aItenSD3[nX][10]
		DH1->DH1_TRT	:=	aItenSD3[nX][11]
		DH1->DH1_PROJPM	:=	aItenSD3[nX][12]
		DH1->DH1_TASKPM	:=	aItenSD3[nX][13]
		DH1->DH1_CLVL	:=	aItenSD3[nX][14]
		DH1->DH1_SERVIC	:=	aItenSD3[nX][15]
		DH1->DH1_CC		:=	aItenSD3[nX][16]
		DH1->DH1_CONTA	:=	aItenSD3[nX][17]
		DH1->DH1_ITEMCT	:=	aItenSD3[nX][18]
		DH1->DH1_STATUS	:=	aItenSD3[nX][19]
		DH1->DH1_OP		:=	aItenSD3[nX][20]
		DH1->DH1_NUMSA	:=	aItenSD3[nX][21]
		DH1->DH1_ITEMSA	:=	aItenSD3[nX][22]
		DH1->DH1_DOC	:=	aItenSD3[nX][23]
		DH1->DH1_CF		:=	aItenSD3[nX][24]
		DH1->DH1_NUMLOT	:=	aItenSD3[nX][25]
		DH1->DH1_NUMSER	:=	aItenSD3[nX][26]
		DH1->DH1_CUSTO1	:=	aItenSD3[nX][27]
		DH1->DH1_CUSTO2	:=	aItenSD3[nX][28]
		DH1->DH1_CUSTO3	:=	aItenSD3[nX][29]
		DH1->DH1_CUSTO4	:=	aItenSD3[nX][30]
		DH1->DH1_CUSTO5	:=	aItenSD3[nX][31]
		DH1->DH1_DTVALI :=	aItenSD3[nX][32]
		DH1->DH1_POTENC :=	aItenSD3[nX][33]
		DH1->DH1_ROTINA	:=	cRotina
		If !Empty(aCpoAuxUsr)
			For nY := 1 to Len(aCpoAuxUsr[nX])
				DH1->&(aCpoAuxUsr[nX,nY,1]) := aCpoAuxUsr[nX,nY,2]
			Next nY
		EndIf
		DH1->(MsUnlock())

		If cGravaWms == "1"
			lRet := WmsAvalDH1("1","DH1",cRotina,@oOrdServ,cA240End)
		EndIf
	Next nX
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} OpcSelec()
Verifica se o opcional foi selecionado para o componente/nivel atual.

@param cOpcMarc	- String com os opcionais selecionados.
@param cOpc		- Grupo+Opcional da tabela SGA.
@param cProdAnt	- String com os produtos da estrutura.
@param cCompTrt - Componente + sequência da estrutura.

@author Lucas Konrad França
@since 02/09/2016
@version P12
@return lRet
/*/
//--------------------------------------------------------------------
Function OpcSelec(cOpcMarc, cOpc, cProdAnt, cCompTrt)
	Local lRet	:= .F.
	//Função migrada para PCPXFUN
	lRet := OpcSelPcp(cOpcMarc, cOpc, cProdAnt, cCompTrt)
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} GetMvNNR()
Verifica qual valor do parametro e retornar com o tamanho correto
de acordo com a NNR_CODIGO
@param cParametro - Parametro que será processado
@param cConteudo - Grupo+Opcional da tabela SGA.

@author ANDRE MAXIMO
@since 28/03/2018
@version P12.1.17
@return cRet
/*/
//--------------------------------------------------------------------

Function GetMvNNR(cParametro,cConteudo)

Local cRet := ''
Default cParametro := ''
Default cConteudo  := ''

If !Empty(cParametro)
	cRet := PadR(SuperGetMV(cParametro, .F., cConteudo),TamSX3('NNR_CODIGO')[1])
EndIF

Return (cRet)

//-------------------------------------------------------------------
/*/{Protheus.doc} MTSldTrFil()
Calcula saldo em transito proveniente das transferencias entre filiais

@param cProduto	- Codigo do Produto
@param dDataRef	- Data de referência da composição de saldo
@param cFilDest - Filial de destino do saldo a calcular

@author Alessandro dos Santos
@since 29/03/2018
@version P12
@return aRet
/*/
//--------------------------------------------------------------------
Function MTSldTrFil(cProduto,dDataRef,cFilDest)
Local aArea 	:= GetArea()
Local aRet 		:= {0,0}
Local aTamQ		:= TamSX3("B2_QATU")
Local aTamC		:= TamSX3("B2_VATU1")
Local cQuery	:= Nil
Local cIsNull	:= MatIsNull()
Local cLen 		:= IIf( 'MSSQL' $ TcGetDB(), 'LEN', 'LENGTH' )
Local cSubStr	:= MatiSubStr()
Local cQryAlias	:= GetNextAlias()

Default dDataRef := dDataBase
Default cFilDest := cFilAnt

cQuery := " SELECT "+ cIsNull +"( SUM( SD2.D2_QUANT ), 0 ) AS QTDTRAN, "+ cIsNull +"( SUM( SD2.D2_CUSTO1 ), 0 ) AS CUSTRAN "+CRLF

cQuery += " FROM "+ RetSQLName( 'SD2' ) +" SD2 "+CRLF
cQuery += " 	INNER JOIN "+ RetSQLName( 'SF4' ) +" SF4SD2 ON ( SF4SD2.F4_FILIAL = CASE SF4SD2.F4_FILIAL WHEN ' ' THEN ' ' ELSE "+ cSubStr +"( SD2.D2_FILIAL, 1, "+ cLen +"( SF4SD2.F4_FILIAL ) ) END AND SF4SD2.F4_CODIGO = SD2.D2_TES ) "+CRLF
cQuery += " 	INNER JOIN "+ RetSQLName( 'SA1' ) +" SA1 	ON ( SA1.A1_FILIAL = CASE SA1.A1_FILIAL WHEN ' ' THEN ' ' ELSE "+ cSubStr +"( SD2.D2_FILIAL,1, "+ cLen +"( SA1.A1_FILIAL ) ) END AND SA1.A1_COD = SD2.D2_CLIENTE AND SA1.A1_LOJA = SD2.D2_LOJA ) "+CRLF
cQuery += " 	LEFT  OUTER JOIN "+ RetSQLName( 'SD1' ) +" SD1 ON ( SD1.D1_FILIAL = '"+ FWxFilial( 'SD1' ) +"'  "+CRLF
cQuery += " 														AND SD1.D1_DOC = SD2.D2_DOC  "+CRLF
cQuery += " 														AND SD1.D1_SERIE = SD2.D2_SERIE  "+CRLF
cQuery += " 														AND SD1.D1_COD = SD2.D2_COD  "+CRLF
cQuery += " 														AND "+ cSubStr +"( SD1.D1_ITEM, 2, "+ cLen +"( SD1.D1_ITEM ) ) = SD2.D2_ITEM "+CRLF
cQuery += " 														AND SD1.D_E_L_E_T_ = ' ' ) "+CRLF

cQuery += " 	LEFT  OUTER JOIN "+ RetSQLName( 'SA2' ) +" SA2 ON ( SA2.A2_FILIAL = '"+ FWxFilial( 'SA2' ) +"' AND SA2.A2_COD = SD1.D1_FORNECE AND SA2.A2_LOJA = SD2.D2_LOJA AND SA2.D_E_L_E_T_ = ' ' ) "+CRLF

cQuery += " WHERE SD2.D2_COD = '"+ cProduto +"'  "+CRLF
cQuery += " 	AND SD2.D2_EMISSAO <= '"+ Dtos( dDataRef ) +"' "+CRLF
cQuery += " 	AND "+ cIsNull +"(SD1.D1_TES,' ') = ' ' "+CRLF
cQuery += " 	AND "+ cIsNull +"(SA2.A2_FILTRF,'X') <> ' ' "+CRLF
cQuery += " 	AND SF4SD2.F4_ESTOQUE = 'S' AND SF4SD2.F4_TRANFIL = '1'	 "+CRLF
cQuery += " 	AND ( SA1.A1_FILTRF = '"+ cFilDest +"' OR SA1.A1_CGC = '"+ FwArrFilAtu( cEmpAnt, cFilDest )[ 18 ] +"' ) "+CRLF
cQuery += " 	AND SF4SD2.D_E_L_E_T_ = ' ' "+CRLF
cQuery += " 	AND SA1.D_E_L_E_T_ = ' ' "+CRLF
cQuery += " 	AND SD2.D_E_L_E_T_ = ' ' "

cQuery := ChangeQuery( cQuery )
dbUseArea( .T., __cRdd, TcGenQry( ,, cQuery ), cQryAlias, .T., .F. )

dbSelectArea( cQryAlias )
TcSetField( cQryAlias , "QTDTRAN", aTamQ[3], aTamQ[1], aTamQ[2] )
TcSetField( cQryAlias , "CUSTRAN", aTamC[3], aTamC[1], aTamC[2] )

aRet[1] := ( cQryAlias )->QTDTRAN
aRet[2] := ( cQryAlias )->CUSTRAN

IIf( Select( cQryAlias ) > 0, ( cQryAlias )->( dbCloseArea() ), Nil )
RestArea(aArea)
Return aRet


//-------------------------------------------------------------------
/*/{Protheus.doc} explinvert()
Expode a estrutura de forma invertida (do componente para o item pai que não seja o fantasma)
Esta função é recursiva.

@param cComponente- Componente q
@param nquant	- Quantidade necessária do componente
@param dDataNec	- Data da necessidade

@author Michelle Ramos Henriques
@since 05/04/2018
@version P12
@return aRet
/*/
//--------------------------------------------------------------------



Function explinvert(cComponente, nquant, dDataNec)

Local aRet := {}
Local aRet2 := {}
Local cChave   := "G1_FILIAL+"
Local cSeek	   := xFilial("SG1")
Local cProduto := ''
Local lPCPREVATU := FindFunction('PCPREVATU')

	dbSelectArea("SG1")
	dbSetOrder(2)
	cChave += "G1_COMP"
	cSeek  += cComponente
	dbSeek(cSeek)
	While !EOF() .And. &(cChave) == cSeek
		cRevAtu := IIF(lPCPREVATU , PCPREVATU(SB1->B1_COD), SB1->B1_REVATU)
		cOpc 	:= G1_GROPC+G1_OPC
		//Ao subir a estrutura, a quantidade necessaria do componente deve ser multiplicada ao do item pai até chegar em um item pai que não é fantasma.
	    nquant:= nquant * ExplEstr(1,dDataNec,cOpc,cRevAtu)

	    SB1->(MsSeek(xFilial("SB1")+SG1->G1_COD))

        if SB1->B1_FANTASM == 'S'
        	aret2:= explinvert(SG1->G1_COD, nquant, dDataNec) //irá explodir a estrutura até encontrar um produto pai que não seja fantasma
        	SB1->(MsSeek(xFilial("SB1")+aret2[1,1]))
        	if SB1->B1_FANTASM != 'S'
        	   cProduto := aret2[1,1]
        	   nquant := aret2[1,2]
        	   exit
        	endif
        else
        	cproduto := SG1->G1_COD
        	Exit
        endif

		SG1->(DbSkip())
	Enddo
	Aadd(aret,{cProduto,nquant})
return aret

/*/{Protheus.doc} MtVlQtSe
//TODO Descrição auto-gerada.
Efetua a validação referente a quantidade quando produto tem número de série
@author Duque
@since 29/10/2018
@version 1.0
@return lRetorno, Logico	, Valor válido ou não para a quantidade digitada
/*/

Function MtVlQtSe(cProduto,cNumSerie, nQtdVen, nQtdLib)
Local lRetorno	:= .T.

SDB->(DbSetOrder(1))
If SDB->(MsSeek(xFilial("SDB") + cProduto))
	lRetorno := MtAvlNSer(cProduto, cNumSerie, nQtdVen, 0)
	If lRetorno .And. nQtdLib > 0
		lRetorno := MtAvlNSer(cProduto, cNumSerie, nQtdLib, 0)
	EndIF
Else
	lRetorno := MtAvlNSer(cProduto,'1', nQtdVen, 0)
	If lRetorno .And. nQtdLib > 0
		lRetorno := MtAvlNSer(cProduto,'1', nQtdLib, 0)
	EndIF
Endif

Return lRetorno

/*/{Protheus.doc} EstVldStr
	Uso Exclusivo Modulo Estoque/Custos | ACD
	Funcao Responsavel por Validar a Existencia de Caracteres Especiais na String.
	@type  Function
	@author Beraldo
	@since 30/07/2019
	@version 1.00
	@param cString, String, Parametro com Conteudo para ser Validado Sendo 1=Leitura ReaVar | 2=Variavel Recebida via Funcao
	@param nOpcx  , Numeric, Parametro Responsavel por Informar se Iremos Usar o Conteudo Recebido como Parametro ou via ReadVar
	@return lRet, Boolean, Retorna true (.T.) Quando não Existe Caracter Especial e false (.F.) quando Existe
	@example
	(examples)
	@see (links_or_references)
/*/
Function EstVldStr( cString, nOpcx )
Local lRet       	:= .T.
Local nCont			:= 0
Local cConteudo		:= ''
Local cCaracter		:= "|!@#$%¨&*()+{}^~´`][;.>,<=/¢¬§ªº'?*" + '"'

Default cString		:= ''
Default nOpcx		:= 1

cConteudo := Alltrim( IIf( nOpcx == 1, &( ReadVar() ), cString ) )
If !( ValType( cConteudo ) == 'C' )
	lRet := .F.
Else
	For nCont := 1 to Len( cConteudo )
		If SubStr( cConteudo, nCont, 1 ) $ cCaracter
			lRet := .F.
			Exit
		EndIf
	Next nCont
EndIf

If !lRet
	Help( ,, 'Help',, STR0242 , 1, 0 )//'Foi Identificada a Presença de Caracter Especial no Conteudo da String'
EndIf

Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³A241Explod³ Autor ³Marcos V. Ferreira      ³ Data ³07.10.2005³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³ Funcao recursiva para localizar todos os componentes do 	   ³±±
±±³          ³ primeiro nivel da estrutura.                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do Produto Pai                               ³±±
±±³          ³ ExpN1 = Quantidade do produto Pai                           ³±±
±±³          ³ ExpA1 = aArray de retorno                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA241                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function aCusbExpld(cProduto,nQuant,aNewStruct)
Local nX		     := 0
Local aAreaAnt	 := GetArea()
Local aArrayAux  := {}

Default cProduto := ""
Default nQuant	 := 0

//Variavel publica declarada na funcao M241SeleEs()
nEstru := 0

aArrayAux := Estrut(cProduto,nQuant,.T.)

dbSelectArea("SB1")
dbSetOrder(1)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Processa todos os componentes do 1 nivel da estrutura,  |
//| verificando a existencia de produtos fantasmas.         |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nX := 1 to Len(aArrayAux)
	If dbSeek(xFilial("SB1")+aArrayAux[nx,3]) //Filial+Componente
		If RetFldProd(SB1->B1_COD,"B1_FANTASM") $ "S" // Projeto Implementeacao de campos MRP e FANTASM no SBZ
			aCusbExpld(aArrayAux[nx,3],aArrayAux[nx,4],aNewStruct) //Componente+Qtde
		Else
			aAdd(aNewStruct,aArrayAux[nx])
		EndIf
	EndIf
Next nX

RestArea(aAreaAnt)
Return Nil

/*/{Protheus.doc} RetSldEmp
//Função para retornar o saldo empenhado para o mesmo lote em outra OP

@type  Static Function
@author Michele Lais Girardi
@since 18/03/2021
@version P12
@param1 cOpSld      - Ordem de Produção
@param2 cAliasSB8   - Alias da SB8
@return Array (nSldEmp1, nSldEmp2) - Saldo na primeira UM - Saldo na segunda UM
/*/
Static Function RetSldEmp(cOpSld, cAliasSB8)

Local aAreaAnt  := GetArea()
Local aRetSld   := {}
Local cAlias    := GetNextAlias()
Local cQuery	:= ""
Local nSldEmp1  := 0
Local nSldEmp2  := 0

DEFAULT cAliasSB8   := "SB8"

cProdSld   := (cAliasSB8)->B8_PRODUTO
cLocSld    := (cAliasSB8)->B8_LOCAL
cLotCtlSld := (cAliasSB8)->B8_LOTECTL
cNumLtSld  := (cAliasSB8)->B8_NUMLOTE

If (Empty(cLotCtlSld) .And. Empty(cNumLtSld)) .Or. Empty(cOpSld)
	AADD (aRetSld, nSldEmp1)
	AADD (aRetSld, nSldEmp2)
Else
	cQuery := " SELECT SUM(SD4.D4_QUANT) AS QTD1SD4, SUM(SD4.D4_QTSEGUM) AS QTD2SD4 "
	cQuery += "   FROM " +RetSqlName("SD4") + " SD4 "
	cQuery += "  WHERE SD4.D4_FILIAL = '"+xFilial("SD4")+"' "
	cQuery += "    AND SD4.D4_OP <> '"+cOpSld+"' "
	cQuery += "    AND SD4.D4_COD = '"+cProdSld+"' "
	cQuery += "    AND SD4.D4_LOCAL = '"+cLocSld+"' "
	cQuery += "    AND SD4.D4_QUANT > 0 "

	//-- Considera Lote no filtro
	If !Empty(cLotCtlSld)
		cQuery += " AND SD4.D4_LOTECTL = '"+cLotCtlSld+"' "
	EndIf

	//-- Considera SubLote no filtro
	If !Empty(cNumLtSld) .And. Rastro(cProdSld,"S")
		cQuery += " AND SD4.D4_NUMLOTE = '"+cNumLtSld+"' "
	EndIf

	cQuery += " AND SD4.D_E_L_E_T_=' ' "

	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.T.,.T.)

	If (cAlias)->(!EOF())
		nSldEmp1 := (cAlias)->QTD1SD4
		nSldEmp2 := (cAlias)->QTD2SD4

		AADD (aRetSld, nSldEmp1)
		AADD (aRetSld, nSldEmp2)
	EndIf

	(cAlias)->(DbCloseArea())

	RestArea(aAreaAnt)
EndIf

If Empty(aRetSld)
	AADD (aRetSld, nSldEmp1)
	AADD (aRetSld, nSldEmp2)
EndIf

Return aRetSld

/*/{Protheus.doc} DistrAutQy
//Retorna o código dos endereços disponíveis como sugestão de endereçamento
por ordem de priorização.
@type  Static Function
@author SQUAD ENTRADAS
@since 22/07/2021
@param1 cOpSld      - Nome da tabela temporária
@param2 cAliasSB8   - Código do armazém
@return cAlias - Saldo na primeira UM - Saldo na segunda UM
/*/
Static Function DistrAutQy(cLocal)
Local cWhere 	:= ""
Local cAlias    := GetNextAlias()
Local lPosBloq  := SBE->(FieldPos("BE_MSBLQL")) > 0
Local lPosDtBlq := SBE->(FieldPos("BE_MSBLQD")) > 0

cWhere := "% SBE.BE_FILIAL = '" + xFilial ("SBE") + "' AND SBE.BE_LOCAL = '" + cLocal + "' "
If lPosBloq
	cWhere += "AND SBE.BE_MSBLQL <> '1' "
EndIf
If lPosDtBlq
	cWhere += "AND (SBE.BE_MSBLQD = '' OR SBE.BE_MSBLQD >= '" + DtoS(dDataBase) + "') "
EndIf
cWhere+= "%"

BeginSQL Alias cAlias
	SELECT
		BE_LOCAL,BE_PRIOR,BE_LOCALIZ,BE_ALTURLC,BE_LARGLC,BE_COMPRLC,BE_PERDA,BE_CAPACID
	FROM
		%table:SBE% SBE
	WHERE
		%exp:cWhere%
		AND SBE.%notDel%
		ORDER BY SBE.BE_FILIAL,SBE.BE_LOCAL,SBE.BE_PRIOR,SBE.BE_LOCALIZ
EndSQL

Return cAlias

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao  ³ VerEmpSD4 ³ Autor ³ Fabio José Batista³ Data ³ 16/06/2023    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Valida se existe Requisição de emprenho para o produto     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGACUSB
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function VerEmpSD4(cFilSD4,cProduto,cOp,cTrt,cLote,cSubLote,cOrigem)

Local lSemSD4     := .F.
Local aArea      := GetArea()
Local aAreaSD4   := SD4->(GetArea())

SD4->(dbsetorder(1))//D4_FILIAL+D4_COD+D4_OP+D4_TRT+D4_LOTECTL+D4_NUMLOTE                                                                                                             
If cOrigem == 'SC6' .And. !SD4->(DBSeek(xFilial('SD4')+cProduto+cOp+cTrt+cLote+cSubLote))
	lSemSD4 := .T.
EndIf 

RestArea(aAreaSD4)
RestArea(aArea)

Return lSemSD4

/*/{Protheus.doc} CntNumSDD
@Description Retorna proxima numeracao sequencial da tabela.
@Type         function
@Author         fabio josé batista	
@Since         27/11/2023
@return caracter
/*/
Static Function CntNumSDD( cTabela, cCampo )
    Local   aAreaOld  := GetArea()
    Local   aAreaTab  := (cTabela)->(GetArea())
    Local   cRet      := ""
    
    Default cTabela   := ""
    Default cCampo    := ""

    cRet := GetSxeNum(cTabela,cCampo)
    While .T.
        (cTabela)->(dbSetOrder(1))
        If (cTabela)->(dbSeek( xFilial(cTabela) + cRet ))
            ConfirmSX8()
            cRet := GetSxeNum(cTabela,cCampo)
            Loop
        Else
            Exit
        EndIf
    EndDo

    RollBackSxE()

    (cTabela)->(RestArea( aAreaTab ))
    RestArea( aAreaOld )

Return cRet
